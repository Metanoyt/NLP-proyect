Owner s oncall r p Copyright c Facebook Inc its affiliates All rights reserved This source code licensed under BSD-style license found LICENSE file root directory source tree socket threading time datetime timedelta unittest TestCase unittest mock patch torch distributed elastic rendezvous utils _delay _matches_machine_hostname _parse_rendezvous_config _PeriodicTimer _try_parse_port parse_rendezvous_endpoint UtilsTest TestCase test_parse_rendezvous_config_returns_dict - None expected_config = dummy b dummy c dummy =dummy d dummy dummy config = _parse_rendezvous_config b= dummy c=dummy =dummy =dummy d=dummy dummy assertEqual config expected_config test_parse_rendezvous_returns_empty_dict_if_str_is_empty - None config_strs = config_str config_strs subTest config_str=config_str config = _parse_rendezvous_config config_str assertEqual config test_parse_rendezvous_raises_error_if_str_is_invalid - None config_strs = a=dummy a=dummy c=dummy a=dummy c=dummy a=dummy = c=dummy a=dummy = c=dummy a=dummy = c=dummy config_str config_strs subTest config_str=config_str assertRaisesRegex ValueError r ^The rendezvous configuration string must format r key = value keyN = valueN $ _parse_rendezvous_config config_str test_parse_rendezvous_raises_error_if_value_is_empty - None config_strs = b=dummy c=dummy b=dummy c=dummy b=dummy a= c=dummy config_str config_strs subTest config_str=config_str assertRaisesRegex ValueError r ^The rendezvous configuration option must have value specified $ _parse_rendezvous_config config_str test_try_parse_port_returns_port - None port = _try_parse_port assertEqual port test_try_parse_port_returns_none_if_str_is_invalid - None port_strs = abc port_str port_strs subTest port_str=port_str port = _try_parse_port port_str assertIsNone port test_parse_rendezvous_endpoint_returns_tuple - None endpoints = dummy com dummy com dummy com dummy- com dummy- com dummy- com db db db endpoint endpoints subTest endpoint=endpoint host port = parse_rendezvous_endpoint endpoint default_port= expected_host expected_port = endpoint rsplit expected_host == expected_host - == expected_host = expected_host - assertEqual host expected_host assertEqual port int expected_port test_parse_rendezvous_endpoint_returns_tuple_if_endpoint_has_no_port - None endpoints = dummy com dummy- com db endpoint endpoints subTest endpoint=endpoint host port = parse_rendezvous_endpoint endpoint default_port= expected_host = endpoint expected_host == expected_host - == expected_host = expected_host - assertEqual host expected_host assertEqual port test_parse_rendezvous_endpoint_returns_tuple_if_endpoint_is_empty - None endpoints = endpoint endpoints subTest endpoint=endpoint host port = parse_rendezvous_endpoint default_port= assertEqual host localhost assertEqual port test_parse_rendezvous_endpoint_raises_error_if_hostname_is_invalid - None endpoints = ~ dummy com ~ endpoint endpoints subTest endpoint=endpoint assertRaisesRegex ValueError rf ^The hostname rendezvous endpoint endpoint must r dot-separated list labels IPv address IPv address $ parse_rendezvous_endpoint endpoint default_port= test_parse_rendezvous_endpoint_raises_error_if_port_is_invalid - None endpoints = dummy com dummy com abc dummy com - dummy com - endpoint endpoints subTest endpoint=endpoint assertRaisesRegex ValueError rf ^The port number rendezvous endpoint endpoint must integer r between $ parse_rendezvous_endpoint endpoint default_port= test_parse_rendezvous_endpoint_raises_error_if_port_is_too_big - None endpoints = dummy com dummy com endpoint endpoints subTest endpoint=endpoint assertRaisesRegex ValueError rf ^The port number rendezvous endpoint endpoint must integer r between $ parse_rendezvous_endpoint endpoint default_port= test_matches_machine_hostname_returns_true_if_hostname_is_loopback - None hosts = localhost host hosts subTest host=host assertTrue _matches_machine_hostname host test_matches_machine_hostname_returns_true_if_hostname_is_machine_hostname - None host = socket gethostname assertTrue _matches_machine_hostname host test_matches_machine_hostname_returns_true_if_hostname_is_machine_fqdn - None host = socket getfqdn assertTrue _matches_machine_hostname host test_matches_machine_hostname_returns_true_if_hostname_is_machine_address - None addr_list = socket getaddrinfo socket gethostname None proto=socket IPPROTO_TCP addr addr_info addr_info addr_list subTest addr=addr assertTrue _matches_machine_hostname addr test_matches_machine_hostname_returns_false_if_hostname_does_not_match - None hosts = dummy host hosts subTest host=host assertFalse _matches_machine_hostname host test_delay_suspends_thread - None seconds subTest seconds=seconds time = time monotonic _delay seconds type ignore arg-type time = time monotonic assertGreaterEqual time - time patch socket getaddrinfo side_effect= None None a_host None None a_different_host test_matches_machine_hostname_returns_true_if_ip_address_match_between_hosts _ - None assertTrue _matches_machine_hostname a_host patch socket getaddrinfo side_effect= None None a_host None None another_host_with_different_ip test_matches_machine_hostname_returns_false_if_ip_address_not_match_between_hosts _ - None assertFalse _matches_machine_hostname a_host PeriodicTimerTest TestCase test_start_can_be_called_only_once - None timer = _PeriodicTimer timedelta seconds= lambda None timer start assertRaisesRegex RuntimeError r ^The timer has already started $ timer start timer cancel test_cancel_can_be_called_multiple_times - None timer = _PeriodicTimer timedelta seconds= lambda None timer start timer cancel timer cancel test_cancel_stops_background_thread - None name = PeriodicTimer_CancelStopsBackgroundThreadTest timer = _PeriodicTimer timedelta seconds= lambda None timer set_name name timer start assertTrue any t name == name t threading enumerate timer cancel assertTrue all t name = name t threading enumerate test_delete_stops_background_thread - None name = PeriodicTimer_DeleteStopsBackgroundThreadTest timer = _PeriodicTimer timedelta seconds= lambda None timer set_name name timer start assertTrue any t name == name t threading enumerate del timer assertTrue all t name = name t threading enumerate test_set_name_cannot_be_called_after_start - None timer = _PeriodicTimer timedelta seconds= lambda None timer start assertRaisesRegex RuntimeError r ^The timer has already started $ timer set_name dummy_name timer cancel test_timer_calls_background_thread_at_regular_intervals - None timer_begin_time float Call our function every ms call_interval = Keep log intervals between each consecutive call actual_call_intervals list float = Keep number times function called call_count = In order prevent flaky test instead asserting function called exact number times we use lower bound guaranteed true correct implementation min_required_call_count = timer_stop_event = threading Event log_call nonlocal timer_begin_time call_count actual_call_intervals append time monotonic - timer_begin_time call_count += call_count == min_required_call_count timer_stop_event set timer_begin_time = time monotonic timer = _PeriodicTimer timedelta seconds=call_interval log_call timer_begin_time = time monotonic timer start Although theoretically non-deterministic our timer which has ms call interval does get called times seconds there very likely something going timer_stop_event wait timer cancel longMessage = False assertGreaterEqual call_count min_required_call_count f The function has been called call_count time s expected called least f min_required_call_count time s actual_call_interval actual_call_intervals assertGreaterEqual actual_call_interval call_interval f The interval between two function calls actual_call_interval second s f expected least call_interval second s