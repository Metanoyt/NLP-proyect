======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_list py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests __TestCase = CPythonTestCase redirect statements sys importlib abc redirect_imports = test mapping_tests test typinganndata test test_grammar test test_math test test_iter test typinganndata ann_module RedirectImportFinder importlib abc MetaPathFinder find_spec fullname path target=None Check problematic one fullname redirect_imports try Attempt standalone module name = fullname removeprefix test r = importlib import_module name Redirect module sys modules sys modules fullname = r Return module spec found module importlib util find_spec name except ImportError None None Add custom finder sys meta_path sys meta_path insert RedirectImportFinder ======= END DYNAMO PATCH ======= sys textwrap list_tests test support cpython_only test support script_helper assert_python_ok pickle unittest ListTest list_tests CommonTest type test = list test_basic assertEqual list l _ = l _ _bis = list l _ assertEqual l _ l _ _bis assertTrue l _ l _ _bis assertEqual list assertEqual list assertEqual list assertEqual list spam s p m assertEqual list x x range x sys maxsize == x fffffff This test can currently only work -bit machines XXX If when PySequence_Length returns ssize_t should XXX re-enabled Verify clearing bug This assumes max data size sys maxint == max address size also assumes address size least bytes byte addresses bug well tested Note This test expected SEGV under Cygwin earlier due newlib bug See following mailing list thread details assertRaises MemoryError list range sys maxsize This code used segfault Py x = x extend -y y x assertEqual x test_keyword_args assertRaisesRegex TypeError keyword argument list sequence= test_keywords_in_subclass torch _dynamo error_on_graph_break False subclass list pass u = subclass assertIs type u subclass assertEqual list u assertRaises TypeError subclass sequence= torch _dynamo error_on_graph_break False subclass_with_init list __init__ seq newarg=None super __init__ seq newarg = newarg u = subclass_with_init newarg= assertIs type u subclass_with_init assertEqual list u assertEqual u newarg torch _dynamo error_on_graph_break False subclass_with_new list __new__ cls seq newarg=None = super __new__ cls seq newarg = newarg u = subclass_with_new newarg= assertIs type u subclass_with_new assertEqual list u assertEqual u newarg test_truth super test_truth assertTrue assertTrue test_identity assertTrue test_len super test_len assertEqual len assertEqual len assertEqual len test_overflow lst = n = int sys maxsize + len lst mul b b imul b = b assertRaises MemoryError OverflowError mul lst n assertRaises MemoryError OverflowError imul lst n test_empty_slice x = x = x assertEqual x test_list_resize_overflow gh- test new_allocated sizeof PyObject overflow check list_resize lst = del lst assertEqual len lst size = sys maxsize assertRaises MemoryError OverflowError lst size assertRaises MemoryError OverflowError lst = size test_repr_mutate torch _dynamo error_on_graph_break False Obj staticmethod __repr__ try mylist pop except IndexError pass obj mylist = Obj _ range assertEqual repr mylist obj obj obj test_repr_large Check repr large list objects check n l = n s = repr l assertEqual s + join n + check check our checking code check test_iterator_pickle orig = type test data = proto range pickle HIGHEST_PROTOCOL + initial iterator itorig = iter orig d = pickle dumps itorig orig proto = pickle loads d = data assertEqual type type itorig assertEqual list data running iterator next itorig d = pickle dumps itorig orig proto = pickle loads d = data assertEqual type type itorig assertEqual list data empty iterator i range len orig next itorig d = pickle dumps itorig orig proto = pickle loads d = data assertEqual type type itorig assertEqual list data len orig exhausted iterator assertRaises StopIteration next itorig d = pickle dumps itorig orig proto = pickle loads d = data assertEqual list test_reversed_pickle orig = type test data = proto range pickle HIGHEST_PROTOCOL + initial iterator itorig = reversed orig d = pickle dumps itorig orig proto = pickle loads d = data assertEqual type type itorig assertEqual list data len orig - - running iterator next itorig d = pickle dumps itorig orig proto = pickle loads d = data assertEqual type type itorig assertEqual list data len orig - - empty iterator i range len orig next itorig d = pickle dumps itorig orig proto = pickle loads d = data assertEqual type type itorig assertEqual list exhausted iterator assertRaises StopIteration next itorig d = pickle dumps itorig orig proto = pickle loads d = data assertEqual list test_step_overflow = sys maxsize = assertEqual sys maxsize test_no_comdat_folding Issue In PGO build MSVC linker s COMDAT folding optimization causes failures code relies distinct function addresses torch _dynamo error_on_graph_break False L list pass assertRaises TypeError + L test_equal_operator_modifying_operand test fix seg fault reported bpo- part torch _dynamo error_on_graph_break False X __eq__ other list clear NotImplemented Y __eq__ other list clear NotImplemented Z __eq__ other list clear NotImplemented list = X list = Y assertTrue list == list list = Z list = assertFalse list == list test_lt_operator_modifying_operand torch _dynamo error_on_graph_break False See gh- evil __lt__ other other clear NotImplemented = evil assertRaises TypeError test_list_index_modifing_operand torch _dynamo error_on_graph_break False See gh- evil __init__ lst lst = lst __iter__ yield lst lst clear lst = list range operand = evil lst assertRaises ValueError lst - = operand cpython_only test_preallocation iterable = iter_size = sys getsizeof iterable assertEqual iter_size sys getsizeof list assertEqual iter_size sys getsizeof list range test_count_index_remove_crashes bpo- The count index remove methods holding strong references list elements while calling PyObject_RichCompareBool torch _dynamo error_on_graph_break False X __eq__ other lst clear NotImplemented lst = X assertRaises ValueError lst index lst torch _dynamo error_on_graph_break False L list __eq__ other str other NotImplemented lst = L X lst count lst lst = L X assertRaises ValueError lst remove lst bpo- list __contains__ holding strong references list elements while calling PyObject_RichCompareBool lst = X X lst lst = X X X lst test_tier _invalidates_iterator GH- _ range = = iter _ pass append assertEqual list unittest skip Fails python = passes = test_deopt_from_append_list gh- used crash because ` CALL_LIST_APPEND ` specialization failure code = textwrap dedent l = lappend l x y l append x y x range lappend l None None try lappend list None None except TypeError pass raise AssertionError rc _ _ = assert_python_ok -c code assertEqual rc __name__ == __main__ run_tests