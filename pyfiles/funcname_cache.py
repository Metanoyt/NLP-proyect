This module provides functionality caching looking up fully qualified function names Python source files line number It uses Python s tokenize module parse source files tracks function definitions along their nesting build fully qualified names e g method module function The results cached two-level dictionary mapping filename - line_number - fully_qualified_name Example usage name = get_funcname myfile py Returns name function line clearcache Clear cache file contents have changed The parsing done lazily when file first accessed Invalid Python files IO errors handled gracefully returning empty cache entries tokenize typing Optional cache dict str dict int str = clearcache - None cache clear _add_file filename str - None try tokenize open filename f tokens = list tokenize generate_tokens f readline except OSError tokenize TokenError cache filename = NOTE undefined behavior file valid Python source since tokenize will have undefined behavior result dict int str = current full funcname e g xxx yyy zzz cur_name = cur_indent = significant_indents list int = i token enumerate tokens token type == tokenize INDENT cur_indent += token type == tokenize DEDENT cur_indent -= possible end function significant_indents cur_indent == significant_indents - significant_indents pop pop last name cur_name = cur_name rpartition token type == tokenize NAME i + len tokens tokens i + type == tokenize NAME token string == token string == name function always follows token significant_indents append cur_indent cur_name cur_name += cur_name += tokens i + string result token start = cur_name cache filename = result get_funcname filename str lineno int - Optional str filename cache _add_file filename cache filename get lineno None