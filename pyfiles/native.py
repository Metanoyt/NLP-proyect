__future__ annotations typing TYPE_CHECKING typing_extensions assert_never torchgen local torchgen api cpp torchgen api types ArgName BaseCType Binding boolT ConstRefCType CType deviceT layoutT ListCType MutRefCType NamedCType OptionalCType scalarT scalarTypeT tensorT torchgen model Argument FunctionSchema Return SelfArgument TensorOptionsArguments Type TYPE_CHECKING collections abc Sequence This file describes translation JIT schema native functions API This looks lot like C++ API which makes historical sense because idea you wrote native functions implement functions C++ API over time we have evolved C++ API without actually changing our native kernels The intention make native API dispatcher API line up closely possible since results least overhead no translation needed dispatcher API native API NB symint aware you will get non-SymInt variant some dispatch entries SymInt others name func FunctionSchema - str name = str func name name TODO delete func is_out_fn name += _out func name overload_name name += f _ func name overload_name name argumenttype_type t Type mutable bool binds ArgName symint bool - NamedCType str t == Tensor tensor_type OptionalCType = OptionalCType BaseCType tensorT mutable local use_const_ref_for_mutable_tensors NamedCType binds MutRefCType tensor_type NamedCType binds ConstRefCType tensor_type str t == Tensor NamedCType binds ConstRefCType ListCType OptionalCType BaseCType tensorT str t == Scalar NamedCType binds ConstRefCType BaseCType scalarT str t == Scalar NamedCType binds ConstRefCType OptionalCType BaseCType scalarT cpp argumenttype_type t mutable=mutable binds=binds symint=symint returns_type rs Sequence Return symint bool - CType cpp returns_type rs symint=symint argument_type Argument binds ArgName symint bool - NamedCType argumenttype_type type mutable=a is_write binds=binds symint=symint argument Argument &#124; SelfArgument &#124; TensorOptionsArguments is_out bool symint bool - list Binding Ideally we NEVER default native functions However there number functions call native directly rely defaulting existing So BC we generate defaults non-out variants out variants where impossible generate appropriate default should_default = is_out isinstance Argument default str &#124; None = None should_default default None default = cpp default_expr default type symint=symint Binding nctype=argument_type binds=a name symint=symint name=a name default=default argument=a isinstance SelfArgument Erase SelfArgument distinction argument argument is_out=is_out symint=symint isinstance TensorOptionsArguments default = None should_default default = TODO Not sure why arguments assigned here TensorOptionsArguments constituent pieces It seems matter Binding nctype=NamedCType dtype OptionalCType BaseCType scalarTypeT name= dtype default=default argument=a Binding nctype=NamedCType layout OptionalCType BaseCType layoutT name= layout default=default argument=a Binding nctype=NamedCType device OptionalCType BaseCType deviceT name= device default=default argument=a Binding nctype=NamedCType pin_memory OptionalCType BaseCType boolT name= pin_memory default=default argument=a assert_never arguments func FunctionSchema symint bool - list Binding args list Argument &#124; TensorOptionsArguments &#124; SelfArgument = args extend func arguments non_out args extend func arguments out r arg args r argument arg symint=symint is_out=func is_out_fn