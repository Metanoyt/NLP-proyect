mypy allow-untyped-defs contextlib contextmanager torch fx graph_module _format_import_block GraphModule reduce_graph_module reduce_package_graph_module torch package PackageExporter sys_importer _compatibility compatibility _use_lazy_graph_module_flag = False _force_skip_lazy_graph_module_flag = False compatibility is_backward_compatible=False contextmanager _force_skip_lazy_graph_module Skip using lazy graph module disregarding setting _use_lazy_graph_module Use skip _LazyGraphModule when testing inductor torchscript related backend torch jit script _LazyGraphModule results following error https gist github com shunting c aed ecd b try global _force_skip_lazy_graph_module_flag prior = _force_skip_lazy_graph_module_flag _force_skip_lazy_graph_module_flag = True yield finally _force_skip_lazy_graph_module_flag = prior compatibility is_backward_compatible=False contextmanager _use_lazy_graph_module should_use bool try global _use_lazy_graph_module_flag prior = _use_lazy_graph_module_flag _use_lazy_graph_module_flag = should_use _force_skip_lazy_graph_module_flag yield finally _use_lazy_graph_module_flag = prior compatibility is_backward_compatible=False _get_graph_module_cls _LazyGraphModule _use_lazy_graph_module_flag GraphModule _make_graph_module args graph_module_cls=None kwargs graph_module_cls None graph_module_cls = _get_graph_module_cls graph_module_cls args kwargs compatibility is_backward_compatible=False _LazyGraphModule GraphModule The main difference between _LazyGraphModule GraphModule how recompile happens GraphModule will do recompile call generate python code forward method when s constructed Later graph get updated recompile method can called again refresh saved python code forward method However some cases especially inductor recompilation can waste since we never check python code graph module call its forward method A few more concreate examples regarding pattern matching fx passes inductor some passes will update graph compiled then call recompile GraphModule some passes will trace small pattern function search graph being compiled replace match traced graph replacement function The pattern graph replacement graph quite small there large amount them Doing GraphModule recompile them GraphModule __init__ also waste time However simply skip calling GraphModule recompile these scenarios also dangeruous People may want check python code call GraphModule s forward method debugging purposes The way _LazyGraphModule solves we override recompile method just mark need recompilation does do actual recompilation Later people really access compiled python code call GraphModule s forward method we do real recompilation classmethod from_graphmodule cls gm GraphModule isinstance gm _LazyGraphModule gm _LazyGraphModule gm gm graph staticmethod force_recompile gm Sometimes we need force recompile workaround - we want do real recompilation before symbolic_trace avoid error https gist github com shunting c e ae ac c d isinstance gm _LazyGraphModule gm real_recompile real_recompile _needs_recompile _real_recompile classmethod _needs_recompile cls cls forward cls _lazy_forward _lazy_forward args kwargs Call real_recompile rather than _real_recompile here The _lazy_forward method may saved call repeatedly Calling real_recompile can make sure we skip recompilation we have already done so real_recompile assert _needs_recompile call ` __call__ ` rather than forward since recompilation may install wrapper ` __call__ ` provide customized error message args kwargs forward = _lazy_forward __reduce_package__ exporter PackageExporter Follow GraphModule __reduce__ call _real_recompile rather than recompile since _LazyGraphModule recompile just mark need recompilation does PythonCode object python_code = _real_recompile dict_without_graph = __dict__ copy dict_without_graph _graphmodule_cls_name = __class__ __name__ del dict_without_graph _graph generated_module_name = f fx-generated _ exporter get_unique_id import_block = _format_import_block python_code globals exporter importer module_code = import_block + code exporter save_source_string generated_module_name module_code reduce_package_graph_module dict_without_graph generated_module_name __reduce__ Follow GraphModule __reduce__ call _real_recompile rather than recompile since _LazyGraphModule recompile just mark need recompilation does PythonCode object python_code = _real_recompile dict_without_graph = __dict__ copy import_block = _format_import_block python_code globals sys_importer del dict_without_graph _graph reduce_graph_module dict_without_graph import_block _real_recompile super recompile classmethod recompile cls cls forward = cls _lazy_forward property code - str real_recompile super code __str__ - str str GraphModule will access _code attribute Make sure recompile happens so _code attribute available real_recompile super __str__