__future__ annotations contextlib dataclasses functools logging os queue sys warnings abc abstractmethod dataclasses dataclass typing Any Optional TYPE_CHECKING Union typing_extensions final override Self TypeGuard torch _inductor async_compile noqa F required warm up AsyncCompile pools torch fx torch _inductor codecache BypassFxGraphCache FxGraphCache torch _inductor metrics CachedMetricsDeltas CachedMetricsHelper torch _inductor output_code CompiledFxGraph CompiledFxGraphConstants CompiledFxGraphConstantsWithGm OutputCode torch _subclasses FakeTensorMode torch utils _ordered_set OrderedSet config compile_fx _CompileFxKwargs _InProcessFxCompile FxCompile log debug DebugContext graph GraphLowering output_code complex_memory_overlap noqa F virtualized V TYPE_CHECKING types collections abc Generator Mapping Sequence concurrent futures Future torch _inductor utils InputType torch fx GraphModule dataclass _VirtualizedSerializer This handles data serializing Virtualized The values here get serialized We don t grab everything because some fields can t serialized aot_compilation Any = None choices Any = None local_buffer_context Any = None ops Any = None kernel Any = None current_node Any = None classmethod serialize cls - _VirtualizedSerializer Turn current state torch _inductor virtualized V into serializable structure kwargs = f dataclasses fields cls kwargs f name = getattr V f name _VirtualizedSerializer kwargs patch - _VirtualizedSerializerContextManager Returns context manager which patches saved values into current environment While patched any value listed above will poisoned so reads will raise error _VirtualizedSerializerContextManager _VirtualizedSerializerContextManager contextlib ExitStack Helper _VirtualizedSerializer patch __init__ virtualized _VirtualizedSerializer - None super __init__ virtualized = virtualized override __enter__ - Self super __enter__ set_name dir V set_name startswith set_ continue name = set_name name = name removesuffix _handler set_handler = getattr V set_name hasattr virtualized name value = getattr virtualized name poison any values we don t serialize so any unset accesses caught value = torch _inductor virtualized _PoisonedVirtual enter_context set_handler value _is_fallback_handler op object - bool try op _is_fallback_handler type ignore attr-defined except AttributeError False _LoweringSerializer This handles data serializing lowering lowering A full implementation would make sure all lowerings copied over least detected raise bypass when non-standard lowering used For now we just handle tests looking lowerings overridden forced fallback fallbacks OrderedSet str __init__ - None lowering fallbacks = OrderedSet str k k v lowering lowerings items _is_fallback_handler v patch - _LoweringSerializerContextManager _LoweringSerializerContextManager _LoweringSerializerContextManager contextlib ExitStack Helper _LoweringSerializer patch __init__ lowering _LoweringSerializer - None super __init__ lowering = lowering override __enter__ - Self super __enter__ lowering k v lowering lowerings items name = str k name lowering fallbacks _is_fallback_handler v enter_context lowering force_fallback k type ignore arg-type dataclass _FakeTensorModeSerializer allow_non_fake_inputs bool __init__ fake_mode FakeTensorMode - None allow_non_fake_inputs = fake_mode allow_non_fake_inputs shape_env = fake_mode shape_env contextlib contextmanager patch fake_mode FakeTensorMode - Generator None None None saved_allow_non_fake_inputs = fake_mode allow_non_fake_inputs fake_mode allow_non_fake_inputs = allow_non_fake_inputs yield fake_mode allow_non_fake_inputs = saved_allow_non_fake_inputs dataclass _WireProtocolInput For _SerializedFxCompile - encapsulates all data being transferred sent parent child gm torch fx GraphModule example_inputs Sequence InputType inputs_to_check Sequence int graph_kwargs _CompileFxKwargs tracing_context Optional torch _guards TracingContext config dict str object virtualized _VirtualizedSerializer deterministic_guard_for_testing Optional type ignore name-defined mypy bug torch testing _internal common_utils DeterministicGuard logger_state _LoggerState lowering _LoweringSerializer fake_tensor_mode _FakeTensorModeSerializer serialize - _WireProtocolPickledInput Turns object into _WireProtocolPickledInput which can directly transferred across stream torch fx _graph_pickler GraphPickler _WireProtocolPickledInput GraphPickler dumps _current_fake_mode - FakeTensorMode fake_mode = None context = torch _guards TracingContext try_get fake_mode = context fake_mode fake_mode None fake_mode shape_env = torch fx experimental symbolic_shapes ShapeEnv FakeTensorMode shape_env=shape_env dataclass _WireProtocolPickledInput value bytes deserialize - _WireProtocolInput Turn streamable object back into _WireProtocolInput torch fx _graph_pickler GraphPickler fake_mode = _current_fake_mode result = GraphPickler loads value fake_mode assert isinstance result _WireProtocolInput result dataclass _WireProtocolOutput For _SerializedFxCompile - encapsulates all data being transferred returned back child parent graph OutputCode metrics CachedMetricsDeltas logs list logging LogRecord warning_replay Optional list warnings WarningMessage shape_env Optional torch fx experimental symbolic_shapes ShapeEnv serialize - _WireProtocolPickledOutput Turns object into _WireProtocolPickledOutput which can directly transferred across stream torch fx _graph_pickler GraphPickler isinstance graph CompiledFxGraph graph prepare_for_serialization _WireProtocolPickledOutput GraphPickler dumps dataclass _WireProtocolPickledOutput value bytes deserialize constants CompiledFxGraphConstants - _WireProtocolOutput Turn streamable object back into _WireProtocolOutput torch fx _graph_pickler GraphPickler fake_mode = _current_fake_mode result = GraphPickler loads value fake_mode assert isinstance result _WireProtocolOutput isinstance result graph CompiledFxGraph result graph after_deserialization constants result _LoggerState This tracking logging happens during out-of-process compile so we can replay those messages when compile done Used context manager which returns captured logs object loggers dict str int The actual log capturing mechanism - should None when we re actively capturing logs captured_logs Optional _CapturedLogs = None __init__ - None Mapping logger name level loggers = filter logger Union logging Logger logging PlaceHolder - TypeGuard logging Logger isinstance logger logging Logger Assume Placeholders propagate False We only want track torch _inductor logging logger name startswith torch _inductor False If logger propagates then assume we ll track its parent logger propagate False True root = logging getLogger torch _inductor sys version_info logging getChildren doesn t exist until logging _acquireLock type ignore attr-defined try logger root manager loggerDict values filter logger loggers logger name = logger level finally logging _releaseLock type ignore attr-defined q = root while q logger = q pop filter logger loggers logger name = logger level q extend logger getChildren __enter__ - _CapturedLogs assert captured_logs None captured_logs = _CapturedLogs captured_logs apply captured_logs __exit__ exc_type Optional type BaseException exc_value Optional BaseException traceback Optional types TracebackType - None assert captured_logs None captured_logs remove _CapturedLogs Helper _LoggerState - actually attaches logger child process grabs log messages themselves state _LoggerState queue queue Queue logging LogRecord handlers Optional dict str logging Handler __init__ state _LoggerState - None state = state A queue log entries TODO For memory purposes should we log file then respond queue = queue Queue - Mapping name handler only valid when applied handlers = None finish - list logging LogRecord assert handlers None logs = try while True logs append queue get_nowait except queue Empty pass logs remove - None assert handlers None handlers handlers = handlers None name handler handlers items logger = logging getLogger name logger removeHandler handler apply - None logging handlers QueueHandler assert handlers None handlers = name level state loggers items logger = logging getLogger name handler = QueueHandler queue handlers name = handler logger addHandler handler level = logging NOTSET logger setLevel level _SerializedFxCompile FxCompile This used represent FxCompile which occurs across serialized boundary override codegen_and_compile gm GraphModule example_inputs Sequence InputType inputs_to_check Sequence int graph_kwargs _CompileFxKwargs - OutputCode If code changes s likely _AsyncFxCompile codegen_and_compile will also need match serialized = serialize_compile gm example_inputs inputs_to_check graph_kwargs serialized _InProcessFxCompile codegen_and_compile gm example_inputs inputs_to_check graph_kwargs inputs constants = serialized output = _send_to_child inputs deserialize constants _postprocess output _compile_stats type codegen_and_compile += TODO Do we need figure out what changed TracingContext child plumb back up parent output graph serialize_compile gm GraphModule example_inputs Sequence InputType inputs_to_check Sequence int graph_kwargs _CompileFxKwargs - Optional tuple _WireProtocolPickledInput CompiledFxGraphConstantsWithGm Prepare _WireProtocolInput compile If None returned then wasn t possible serialize we should fallback in-process try _check_for_hop raises BypassFxGraphCache when detects something we can t cache serialize FxGraphCache _check_for_hop gm except BypassFxGraphCache e log debug Skipping s compile s type e noqa G None context = torch _guards TracingContext try_get constants = CompiledFxGraphConstantsWithGm gm logger_state = _LoggerState lowering = _LoweringSerializer If we re running tests then grab DeterministicGuard don t want isn t already imported because has side-effects deterministic_guard_for_testing Optional type ignore name-defined mypy bug torch testing _internal common_utils DeterministicGuard = None try deterministic_guard_for_testing = torch testing _internal common_utils DeterministicGuard _current_state type ignore attr-defined mypy bug except AttributeError pass fake_mode = _current_fake_mode fake_tensor_mode = _FakeTensorModeSerializer fake_mode try input = _WireProtocolInput gm example_inputs inputs_to_check graph_kwargs context config save_config_portable _VirtualizedSerializer serialize deterministic_guard_for_testing logger_state lowering fake_tensor_mode serialize input constants except AttributeError BypassFxGraphCache For example AttributeError Can t pickle local object make_opaque_unary_fn locals OpaqueUnaryFn TODO scuba record about being able do log warning Unable pickle input graph example inputs exc_info=True None abstractmethod _send_to_child pickled_input _WireProtocolPickledInput - _WireProtocolPickledOutput The implementation should transfer ` input ` child call ` _run_in_child input ` transfer result back _postprocess output _WireProtocolOutput - None pass classmethod _run_in_child cls pickled_input _WireProtocolPickledInput extra_env Optional Mapping str str = None - _WireProtocolPickledOutput metrics = CachedMetricsHelper contextlib ExitStack stack extra_env None unittest stack enter_context unittest mock patch dict os environ extra_env Save warnings replay parent warning_replay = stack enter_context warnings catch_warnings record=True TODO Should we split input into multiple sections where each section sets up state previous section i e Config section which we decode apply followed FakeTensorMode section which we decode apply etc input = pickled_input deserialize stack enter_context input virtualized patch stack enter_context input lowering patch stack enter_context config patch input config captured_logs = stack enter_context input logger_state input deterministic_guard_for_testing stack enter_context input deterministic_guard_for_testing stack enter_context torch _guards tracing input tracing_context stack enter_context DebugContext fake_mode = _current_fake_mode stack enter_context input fake_tensor_mode patch fake_mode output_graph = _InProcessFxCompile codegen_and_compile input gm input example_inputs input inputs_to_check input graph_kwargs logs = captured_logs finish _WireProtocolOutput output_graph metrics get_deltas logs warning_replay fake_mode shape_env serialize This debugging testing implementation FxCompile which serializes input output still runs FxCompile in-process final _DebugSerdeFxCompile _SerializedFxCompile override _send_to_child pickled_input _WireProtocolPickledInput - _WireProtocolPickledOutput For debugging just serde input output don t run subprocess _run_in_child pickled_input _OutOfProcessFxCompile _SerializedFxCompile Represents FxCompile which run outside current process either subprocess possibly even separate machine override final _send_to_child pickled_input _WireProtocolPickledInput - _WireProtocolPickledOutput f = _send_to_child_async pickled_input For debugging If we want print status updates last = time time while f done print tick time sleep now = time time now - last last = now f result abstractmethod _send_to_child_async pickled_input _WireProtocolPickledInput - Future _WireProtocolPickledOutput _postprocess output _WireProtocolOutput - None Since our metrics gathered subprocess make sure add them here CachedMetricsHelper apply_deltas output metrics This used tests check output specific details For remote things subproc RE we need do ` save_output_code ` here since didn t happen earlier in-process In future doesn t have source_code s CompiledAOTI example we need we ll have grab serialize separately child GraphLowering save_output_code None GraphLowering save_output_code output graph source_code type ignore attr-defined And forward our collected logs The cache cleared when outer function exits functools cache getLogger name str - logging Logger logging getLogger name output warning_replay w output warning_replay warnings warn_explicit message=w message category=w category filename=w filename lineno=w lineno source=w source record output logs logger = getLogger record name logger handle record For debugging - create _FxCompile which writes serialized data file then exits TODO make FxCompileMode value The child runner should look something like torch torch _inductor compile_fx idx = open f tmp pytorch_compile_fx_tmp_input_ idx bin rb f input = compile_fx _WireProtocolPickledInput f read result = compile_fx _SubprocessFxCompile _run_in_child input open f tmp pytorch_compile_fx_tmp_output_ idx bin wb f f write result value final _DebugFileFxCompile _SerializedFxCompile file_index = override _send_to_child pickled_input _WireProtocolPickledInput - _WireProtocolPickledOutput idx = _DebugFileFxCompile file_index _DebugFileFxCompile file_index += name = f tmp aorenste pytorch_compile_fx_tmp_input_ idx bin open name wb f f write pickled_input value print f Wrote name False name = f tmp aorenste pytorch_compile_fx_tmp_actual_ idx bin actual = _run_in_child pickled_input open name wb f f write actual value actual False name = f tmp aorenste pytorch_compile_fx_tmp_output_ idx bin open name rb f result = _WireProtocolPickledOutput f read print f Read name result os _exit -