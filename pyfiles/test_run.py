__future__ annotations copy copy functools total_ordering typing Any TYPE_CHECKING TYPE_CHECKING collections abc Iterable TestRun TestRun defines set tests should run together single pytest invocation It ll either whole test file subset test file This assumes we won t always know full set TestClasses test file So s designed include exclude explicitly requested TestClasses while having accepting there will ambiguous set unknown test classes expliclty called out Those manifest tests haven t been explicitly excluded test_file str _excluded frozenset str Tests should excluded test run _included frozenset str If non-empy only these tests should run test run NB Also called TestRun s test so having field set will allow pytest ignore accordingly __test__ = False __init__ name str excluded Iterable str &#124; None = None included Iterable str &#124; None = None - None excluded included raise ValueError Can t specify both included excluded ins = set included exs = set excluded name assert included excluded Can t specify included excluded tests when specifying test file name test_file test_class = name split ins add test_class test_file = name _excluded = frozenset exs _included = frozenset ins staticmethod empty - TestRun TestRun is_empty - bool Lack test_file means empty run which means there nothing run It s zero test_file is_full_file - bool _included _excluded included - frozenset str _included excluded - frozenset str _excluded get_pytest_filter - str _included join sorted _included _excluded f join sorted _excluded contains test TestRun - bool test_file = test test_file False is_full_file True contains all tests test is_full_file False test contains all tests doesn t Does exclude subset what test excludes test _excluded test _excluded issubset _excluded Does include everything test includes _included test _included issubset _included Getting here means test includes excludes Does exclude anything test includes If we re good _excluded intersection test _included __copy__ - TestRun TestRun test_file excluded=self _excluded included=self _included __bool__ - bool is_empty __repr__ - str r str = f RunTest test_file r += f included _included _included r += f excluded _excluded _excluded r += r __str__ - str is_empty Empty pytest_filter = get_pytest_filter pytest_filter test_file + + pytest_filter test_file __eq__ other object - bool isinstance other TestRun False ret = test_file == other test_file ret = ret _included == other _included ret = ret _excluded == other _excluded ret __hash__ - int hash test_file _included _excluded __or__ other TestRun - TestRun To OR Union test runs means run all tests either two runs specify Is any file empty is_empty other other is_empty copy If ensure we have same file assert test_file == other test_file f Can t exclude other because they re same test file possible cases Either file full file so union everything is_full_file other is_full_file The union whole file TestRun test_file Both files only run what s _included so union union two sets _included other _included TestRun test_file included=self _included union other _included Both files only exclude what s _excluded so union intersection two sets _excluded other _excluded TestRun test_file excluded=self _excluded intersection other _excluded One file includes other excludes so we then continue excluding _excluded set minus whatever _included set included = _included &#124; other _included excluded = _excluded &#124; other _excluded TestRun test_file excluded=excluded - included __sub__ other TestRun - TestRun To subtract test runs means run all tests first run except what second run specifies Is any file empty is_empty TestRun empty other is_empty copy Are you trying subtract tests don t even exist test run test_file = other test_file copy You re subtracting everything other is_full_file TestRun empty return_inclusions_or_empty inclusions frozenset str - TestRun inclusions TestRun test_file included=inclusions TestRun empty other _included _included return_inclusions_or_empty _included - other _included TestRun test_file excluded=self _excluded &#124; other _included _included return_inclusions_or_empty _included other _excluded return_inclusions_or_empty other _excluded - _excluded __and__ other TestRun - TestRun test_file = other test_file TestRun empty &#124; other - - other - other - to_json - dict str Any r dict str Any = test_file test_file _included r included = list _included _excluded r excluded = list _excluded r staticmethod from_json json dict str Any - TestRun TestRun json test_file included=json get included excluded=json get excluded total_ordering ShardedTest test TestRun shard int num_shards int time float &#124; None In seconds __init__ test TestRun &#124; str shard int num_shards int time float &#124; None = None - None isinstance test str test = TestRun test test = test shard = shard num_shards = num_shards time = time property name - str test test_file __eq__ other object - bool isinstance other ShardedTest False test == other test shard == other shard num_shards == other num_shards time == other time __repr__ - str ret = f test shard num_shards time ret += f time s ret __lt__ other object - bool isinstance other ShardedTest raise NotImplementedError This how list implicitly sorted when NamedTuple name = other name name other name shard = other shard shard other shard num_shards = other num_shards num_shards other num_shards None smallest value time None True other time None False time other time __str__ - str f test shard num_shards get_time default float = - float time time None default get_pytest_args - list str filter = test get_pytest_filter filter -k test get_pytest_filter