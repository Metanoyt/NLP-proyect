contextlib io logging os collections abc Callable Generator dataclasses dataclass typing Any Optional Union torch torch _library custom_ops _maybe_get_opdef torch types FileLike log = logging getLogger __name__ MissingOpProfile RuntimeError This raised when we don t have operator profile available given inputs dataclass frozen=True TensorMetadata rank int dtype torch dtype device torch device layout torch layout staticmethod maybe_from_tensor t Any - Optional TensorMetadata isinstance t torch Tensor None TensorMetadata t dim t dtype t device t layout dataclass frozen=True OpProfile args_profile tuple Optional TensorMetadata out_profile Union TensorMetadata tuple TensorMetadata _generate_fake_kernel op_name str op_profile set OpProfile - Callable _match_args args_profile tuple Optional TensorMetadata args Any - bool all TensorMetadata maybe_from_tensor arg == args_profile i i arg enumerate args _generate_res out_profile Union TensorMetadata tuple TensorMetadata - Union torch Tensor list torch Tensor ctx = torch library get_ctx _generate_tensor_out t TensorMetadata - torch Tensor fake_shape = ctx new_dynamic_size _ range t rank fake_strides = - t rank expected = fake_stride = expected i range t rank fake_strides i = fake_stride type ignore assignment fake_stride = fake_stride fake_shape i type ignore assignment torch empty_strided fake_shape fake_strides device=t device dtype=t dtype layout=t layout isinstance out_profile TensorMetadata _generate_tensor_out out_profile _generate_tensor_out t t out_profile _fake_kernel args kwargs type ignore no-untyped-def profile op_profile _match_args profile args_profile args kwargs values _generate_res profile out_profile raise MissingOpProfile f No fake kernel found op_name although we have previously registered some profiles generate fake kernel f no profiles match given inputs args kwargs _fake_kernel contextlib contextmanager unsafe_generate_fake_kernels op_profiles dict str set OpProfile - Generator Registers fake kernel based given operator profiles This fake kernel registration will override any existing fake kernel registrations The input dictionary mapping operator names set operator profiles which we will use generate fake kernels The operator profiles record input output tensor metadata Based information we will match given input recorded profile output same metadata recorded profile If profile doesn t exist then exception will thrown The fake kernel generation considered unsafe because relies rigid pre-defined operator profiles do account potential variations output behavior Specifically generated kernels assume fixed relationship between input output ranks However reality s possible data-dependent operations may produce outputs different ranks even when given inputs same rank The generated fake kernels inflexible unable accommodate these nuances making them potentially unsafe Args op_profiles dict str set OpProfile A dictionary mapping operator name set operator profiles which we will generate fake kernels Examples Example Registering op-profile draft-export torch torch export _draft_export draft_export torch library custom_op mylib foo mutates_args= foo x Tensor y Tensor - Tensor x + y M torch nn Module forward b res = torch ops mylib foo b no fake impl res ep = draft_export M torch ones torch ones torch _library fake_profile unsafe_generate_fake_kernels ep _report op_profiles decomp = ep run_decompositions libs list torch library Library = Stores old fake impls custom ops declared through custom_op old_fake_impls dict str Callable = op_name profiles op_profiles items log warning Registering fake profile s This will override any existing fake kernel registration op_name op_name_split = op_name split namespace op_name_str = op_name_split op_name_split op_str = f namespace op_name_str fake_kernel = _generate_fake_kernel op_str profiles opdef = _maybe_get_opdef op_str If op CustomOpDef save existing abstract_fn so we can restore after contextmanager opdef _abstract_fn None old_fake_impls op_str = opdef _abstract_fn opdef register_fake fake_kernel Create new library so we can register new fake impl These libraries will then destroyed after contextmanager which will automatically restore previously registered fake impls newlib = torch library Library namespace FRAGMENT noqa TOR torch library register_fake op_str fake_kernel lib=newlib allow_override=True libs append newlib try yield libs finally Destroying libraries will automatically restore previously registered fake impls lib libs lib _destroy Restore abstract_fns CustomOpDefs op_str old_fake old_fake_impls items opdef = _maybe_get_opdef op_str assert opdef None opdef register_fake old_fake get_torch_version - str version = torch __version__ split f int version int version generate_yaml_from_profiles op_profiles dict str set OpProfile - str Generates yaml string given operator profiles which can saved file The yaml string can loaded back into operator profile structure using ` read_profiles_from_yaml ` yaml torch _export serde serialize _TORCH_TO_SERIALIZE_DTYPE _TORCH_TO_SERIALIZE_LAYOUT serialize_tensor_metadata t TensorMetadata - dict rank t rank dtype _TORCH_TO_SERIALIZE_DTYPE t dtype value device str t device layout _TORCH_TO_SERIALIZE_LAYOUT t layout value serialize_op_profile op OpProfile - dict args_profile serialize_tensor_metadata arg arg op args_profile arg None out_profile serialize_tensor_metadata op out_profile isinstance op out_profile TensorMetadata serialize_tensor_metadata out out op out_profile serialized_data = operator serialize_op_profile profile profile profiles operator profiles op_profiles items yaml dump torch_version get_torch_version operators serialized_data sort_keys=False save_op_profiles op_profiles dict str set OpProfile f FileLike - None Serializes given operator profiles into yaml format saves given file The operator profile can loaded back using ` load_op_profiles ` yaml_str = generate_yaml_from_profiles op_profiles isinstance f str os PathLike f = os fspath f open f w file file write yaml_str isinstance f io BytesIO f write yaml_str encode utf- raise ValueError f Invalid type file f read_profiles_from_yaml yaml_str str - dict str set OpProfile Reads yaml saved ` save_op_profiles ` returns operator profiles yaml torch _export serde serialize _SERIALIZE_TO_TORCH_DTYPE _SERIALIZE_TO_TORCH_LAYOUT deserialize_tensor_metadata data dict - TensorMetadata TensorMetadata rank=data rank dtype=_SERIALIZE_TO_TORCH_DTYPE data dtype device=torch device data device layout=_SERIALIZE_TO_TORCH_LAYOUT data layout deserialize_op_profile data dict - OpProfile args_profile = tuple deserialize_tensor_metadata arg arg data args_profile out_profile_data = data out_profile out_profile Union tuple TensorMetadata TensorMetadata = tuple deserialize_tensor_metadata out out out_profile_data type ignore assignment isinstance out_profile_data list deserialize_tensor_metadata out_profile_data OpProfile args_profile=args_profile out_profile=out_profile type ignore arg-type loaded_data = yaml safe_load yaml_str loaded_torch_version = loaded_data torch_version loaded_torch_version = get_torch_version raise RuntimeError Unable load outdated profile It saved torch version f loaded_torch_version current torch version get_torch_version operators_data = loaded_data operators operator deserialize_op_profile profile profile profiles operator profiles operators_data items load_op_profiles f FileLike - dict str set OpProfile Loads saved operator profiles ` save_op_profiles ` isinstance f str os PathLike f = os fspath f open f file yaml_str = file read isinstance f io BytesIO yaml_str = f read decode utf- raise ValueError f Invalid type file f read_profiles_from_yaml yaml_str