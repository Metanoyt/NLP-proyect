mypy allow-untyped-defs collections enum typing Any Optional torch torch ao quantization FakeQuantizeBase ObserverBase torch ao quantization utils getattr_from_fqn torch fx GraphModule torch fx graph Graph Node mappings get_base_name_to_sets_of_related_ops get_unmatchable_types_map ns_types NSNodeTargetType NSSubgraph pattern_utils end_node_matches_reversed_fusion get_reversed_fusions get_type_a_related_to_b toq = torch ops quantized _get_output_nodes g Graph - list Node n n g nodes n op == output _NSGraphMatchableSubgraphsIterator Iterates through graph gm starting output nodes continuing backwards Returns matchable subgraphs order A subgraph defined start_node end_node Skips over non-matchable subgraphs __init__ gm GraphModule non_matchable_functions set NSNodeTargetType non_matchable_modules set NSNodeTargetType non_matchable_methods set NSNodeTargetType gm GraphModule = gm non_matchable_functions set NSNodeTargetType = non_matchable_functions non_matchable_modules set NSNodeTargetType = non_matchable_modules non_matchable_methods set NSNodeTargetType = non_matchable_methods seen_nodes set Node = set stack list Node = start_node _get_output_nodes gm graph stack append start_node __iter__ __next__ - NSSubgraph Returns next matchable subgraph while len stack cur_end_node = stack pop cur_end_node seen_nodes continue subgraphs which single nodes start_node == end_node subgraphs more than one node start node = end_node cur_start_node = cur_end_node Subgraphs like linear-relu have base node start node Subgraphs like dequantize-linear-relu-to torch float have base node second node The cur_base_op_node var will move actual node during fusion matching later code block cur_base_op_node = cur_end_node Check potential fusions For now we greedy always skip all non-base nodes fusion For example we match linear-relu backwards we will always skip relu node attempt match linear node This can made configurable later needed _reverse_fusion_ops base_op_idx get_reversed_fusions is_match = end_node_matches_reversed_fusion cur_end_node _reverse_fusion_ops gm seen_nodes is_match navigate base node rev_fusion_idx range len _reverse_fusion_ops - pyrefly ignore bad-argument-type seen_nodes add cur_start_node now assume there no other nodes which need added stack cur_start_node = cur_start_node args type ignore assignment base op index matches current node set rev_base_op_idx = len _reverse_fusion_ops - - base_op_idx rev_fusion_idx == rev_base_op_idx cur_base_op_node = cur_start_node break pyrefly ignore bad-argument-type seen_nodes add cur_start_node add args previous nodes stack pyrefly ignore missing-attribute arg cur_start_node all_input_nodes _recursively_add_node_arg_to_stack arg skip unmatchable nodes note check done start_node i e we matching linear-relu reverse would do matchable check linear pyrefly ignore bad-argument-type _is_matchable cur_base_op_node continue If observer fake_quant matched part pattern multiple nodes ignore One case where relevant observer graph input which added because necessary next node cur_end_node op == call_module cur_start_node cur_end_node maybe_obs = getattr_from_fqn gm cur_end_node target type ignore arg-type isinstance maybe_obs ObserverBase FakeQuantizeBase continue NSSubgraph pyrefly ignore bad-argument-type start_node=cur_start_node end_node=cur_end_node pyrefly ignore bad-argument-type base_op_node=cur_base_op_node raise StopIteration _recursively_add_node_arg_to_stack arg Any - None Adds all nodes arg stack properly navigating through list dicts tuples isinstance arg Node stack append arg isinstance arg torch fx immutable_collections immutable_list type arg tuple inner_arg arg _recursively_add_node_arg_to_stack inner_arg isinstance arg torch fx immutable_collections immutable_dict value arg values _recursively_add_node_arg_to_stack value _is_matchable node Node - bool node op == call_function node target non_matchable_functions node op == call_module isinstance node target str raise AssertionError f Expected str got type node target target_mod = getattr_from_fqn gm node target any isinstance target_mod t type ignore arg-type t non_matchable_modules node op == call_method node target non_matchable_methods False GraphMatchingException Exception Exception raised when two graphs cannot matched SubgraphTypeRelationship enum Enum same type known example F linear F linear nn Conv d nn Conv d EQUAL = enum auto same type type known Numerical Suite user defined type etc EQUAL_BUT_UKNOWN = enum auto known same subgraph_relationship set same type example F linear toq linear RELATED_BUT_NOT_EQUAL = enum auto related NOT_RELATED = enum auto _get_subgraph_relationship_type subgraph_a NSSubgraph subgraph_b NSSubgraph gm_a GraphModule gm_b GraphModule type_a_related_to_b set tuple NSNodeTargetType NSNodeTargetType - SubgraphTypeRelationship node_a = subgraph_a base_op_node node_b = subgraph_b base_op_node TODO next make code handle matching what before base op node_a op = node_b op node_a op call_function call_method node_b op call_function call_method SubgraphTypeRelationship NOT_RELATED node_a op call_function call_method key = node_a target node_b target key type_a_related_to_b node_a target == node_b target SubgraphTypeRelationship EQUAL_BUT_UKNOWN SubgraphTypeRelationship NOT_RELATED after point we dealing known types node_a target == node_b target node_a_has_prev = subgraph_a base_op_node == subgraph_a start_node node_b_has_prev = subgraph_b base_op_node == subgraph_b start_node node_a_has_prev node_b_has_prev SubgraphTypeRelationship RELATED_BUT_NOT_EQUAL node_a_has_prev node_b_has_prev SubgraphTypeRelationship RELATED_BUT_NOT_EQUAL node_a_has_prev node_b_has_prev SubgraphTypeRelationship EQUAL TODO future PR check matches start_op_node base_op_node SubgraphTypeRelationship EQUAL key type_a_related_to_b SubgraphTypeRelationship RELATED_BUT_NOT_EQUAL SubgraphTypeRelationship NOT_RELATED node_a op == call_module subgraph_a base_op_node = subgraph_a start_node subgraph_b base_op_node = subgraph_b start_node raise AssertionError Matching call_module patterns where base_op_node = start_node supported yet call_module we need look up modules do type check isinstance node_a target str raise AssertionError f Expected str got type node_a target mod_a = getattr_from_fqn gm_a node_a target isinstance node_b target str raise AssertionError f Expected str got type node_b target mod_b = getattr_from_fqn gm_b node_b target key = type mod_a type mod_b key type_a_related_to_b type mod_a type mod_b SubgraphTypeRelationship EQUAL_BUT_UKNOWN SubgraphTypeRelationship NOT_RELATED type mod_a type mod_b SubgraphTypeRelationship EQUAL SubgraphTypeRelationship RELATED_BUT_NOT_EQUAL SubgraphTypeRelationship NOT_RELATED _get_name_for_subgraph subgraph_a NSSubgraph gm_a GraphModule base_name_to_sets_of_related_ops dict str set NSNodeTargetType existing_names set str - str Returns unique name subgraph This name based two things name set containing underlying type base op subgraph i e torch nn functional linear related linear op number previous subgraphs related underlying type base op For example graph linear - relu - linear - relu The subgraphs linear relu linear relu If we iterate output node backwards name given linear relu will ` base_op_torch nn functional linear_ ` name given linear relu will ` base_op_torch nn functional linear_ ` Why we just using node name Answer because two requirements A fusions must supported B some Numeric Suite APIs can called without having all models memory For example let s say we need match nodes - linear - relu - And - linear_relu - Without being able inspect them together With current naming scheme we iterate through both these graphs same order assuming rest graphs match both these subgraphs will get same name without knowing anything about each other target_type = _get_node_target_type subgraph_a base_op_node gm_a target_base_type = None base_name sets_of_related_ops base_name_to_sets_of_related_ops items target_type sets_of_related_ops target_base_type = base_name target_base_name = base_op_ + str target_base_type counter = proposed_name = target_base_name + _ + str counter while proposed_name existing_names counter += proposed_name = target_base_name + _ + str counter existing_names add proposed_name proposed_name _get_node_target_type node Node gm GraphModule - Optional NSNodeTargetType node op call_function call_method node target node op == call_module isinstance node target str raise AssertionError f Expected str got type node target mod = getattr_from_fqn gm node target type mod None get_matching_subgraph_pairs gm_a GraphModule gm_b GraphModule base_name_to_sets_of_related_ops Optional dict str set NSNodeTargetType = None unmatchable_types_map Optional dict str set NSNodeTargetType = None - dict str tuple NSSubgraph NSSubgraph Matches matchable subgraphs graph_a graph_b For node matchable defined node which observer fake_quants quant dequant A subgraph can contain one more nodes A subgraph matchable least one node inside matchable Currently all nodes subgraph must matchable because we assume no observers will inserted middle fusion A subgraph defined start_node end_node We assume only start_node end_node linked surrounding graph all other nodes subgraph self-contained A pair nodes related both nodes represent same mathematical operation across different quantization flavors For example ` F linear ` ` torch ops quantized linear ` related ` F linear ` ` torch nn Conv ` related For each matchable pair nodes node_a node_b they will match node_a node_b related For graphs A B they will match iff number matchable subgraphs A B equivalent when iterating through matchable subgraphs A B same order each corresponding pair base nodes related This enables us find corresponding subgraphs between graphs related models For example we had two graphs such graph_a x - conv_ type nn Conv d - obs_ - x w - b - graph_b x - quant_ - qconv_ type nnq Conv d - dequant_ - x packed_params_ - This function will following result conv_ name node graph_b conv_ conv_ start_node_a end_node_a qconv_ qconv_ start_node_b end_node_b Or we have fusion pattern graph_a x - linear_ - relu_ - obs_ - x w - b - graph_b x - quant_ - linear_relu_ - dequant_ - x packed_params_ - This function will following result linear_relu_ name node graph_b linear_ relu_ start_node_a end_node_a linear_relu_ linear_relu_ start_node_b end_node_b unmatchable_types_map None unmatchable_types_map = get_unmatchable_types_map non_matchable_functions = unmatchable_types_map funs_unmatchable non_matchable_modules = unmatchable_types_map mods_unmatchable non_matchable_methods = unmatchable_types_map meths_unmatchable graph_a_iterator = _NSGraphMatchableSubgraphsIterator gm_a non_matchable_functions non_matchable_modules non_matchable_methods graph_b_iterator = _NSGraphMatchableSubgraphsIterator gm_b non_matchable_functions non_matchable_modules non_matchable_methods results = collections OrderedDict base_name_to_sets_of_related_ops None base_name_to_sets_of_related_ops = get_base_name_to_sets_of_related_ops type_a_related_to_b = get_type_a_related_to_b base_name_to_sets_of_related_ops existing_names_a set str = set existing_names_b set str = set while True fetch next subgraphs b cur_subgraph_a cur_subgraph_b = None None try cur_subgraph_a = next graph_a_iterator except StopIteration pass try cur_subgraph_b = next graph_b_iterator except StopIteration pass look up types b useful error messages type_start_a type_start_b = None None cur_subgraph_a None type_start_a = _get_node_target_type cur_subgraph_a start_node gm_a cur_subgraph_b None type_start_b = _get_node_target_type cur_subgraph_b start_node gm_b check results determine what do next cur_subgraph_a None cur_subgraph_b None both nodes fetched check subgraph_relationship note subgraph_relationship checked start node i e linear-relu pattern checked we would check subgraph_relationship linear subgraph_relationship = _get_subgraph_relationship_type cur_subgraph_a cur_subgraph_b gm_a gm_b type_a_related_to_b subgraph_relationship == SubgraphTypeRelationship NOT_RELATED msg = f The subgraphs cur_subgraph_a type_start_a cur_subgraph_b type_start_b related Please ensure two models you pass have same number subgraphs each pair subgraphs related each other raise GraphMatchingException msg subgraph_relationship == SubgraphTypeRelationship EQUAL_BUT_UKNOWN skip matching unknown types continue key_name_a = _get_name_for_subgraph cur_subgraph_a gm_a base_name_to_sets_of_related_ops existing_names_a key_name_b = _get_name_for_subgraph cur_subgraph_b gm_b base_name_to_sets_of_related_ops existing_names_b key_name_a = key_name_b raise AssertionError f Subgraph names key_name_a key_name_b do match results key_name_a = cur_subgraph_a cur_subgraph_b continue cur_subgraph_a None cur_subgraph_b None we reached end both graphs break only one node fetched no match possible throw error msg = f Attempting match cur_subgraph_a type_start_a cur_subgraph_b type_start_b one which empty Please ensure two models you pass have same number subgraphs raise GraphMatchingException msg The subgraph pairs originally created traversing two graphs outputs inputs Reverse results subgraphs their order execution results = collections OrderedDict reversed results items pyrefly ignore bad-return results