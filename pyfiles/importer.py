mypy allow-untyped-defs importlib logging sys abc ABC abstractmethod pyrefly ignore missing-module-attribute pickle type ignore attr-defined _getattribute _Pickler whichmodule _pickle_whichmodule pyrefly ignore missing-module-attribute types ModuleType typing Any Optional _mangling demangle get_mangle_prefix is_mangled __all__ = ObjNotFoundError ObjMismatchError Importer OrderedImporter log = logging getLogger __name__ ObjNotFoundError Exception Raised when importer cannot find object searching its name ObjMismatchError Exception Raised when importer found different object same name user-provided one Importer ABC Represents environment modules By default you can figure out what module object belongs checking __module__ importing result using __import__ importlib import_module torch package introduces module importers other than default one Each PackageImporter introduces new namespace Potentially single name e g foo bar present multiple namespaces It supports two main operations import_module module_name - module object get_name object - parent module name name obj within module The guarantee following round-trip will succeed throw ObjNotFoundError ObjMisMatchError module_name obj_name = env get_name obj module = env import_module module_name obj = getattr module obj_name assert obj obj modules dict str ModuleType abstractmethod import_module module_name str - ModuleType Import ` module_name ` environment The contract same importlib import_module get_name obj Any name Optional str = None - tuple str str Given object name can used retrieve object environment Args obj An object get module-environment-relative name name If set use name instead looking up __name__ __qualname__ ` obj ` This only here match how Pickler handles __reduce__ functions string don t use otherwise Returns A tuple parent_module_name attr_name can used retrieve ` obj ` environment Use like mod = importer import_module parent_module_name obj = getattr mod attr_name Raises ObjNotFoundError we couldn t retrieve ` obj name ObjMisMatchError we found different object same name ` obj ` name None obj _Pickler dispatch get type obj None Honor string variant __reduce__ which will give us global name search environment TODO I guess we should do copyreg too reduce = getattr obj __reduce__ None reduce None try rv = reduce isinstance rv str name = rv except Exception pass name None name = getattr obj __qualname__ None name None name = obj __name__ orig_module_name = whichmodule obj name Demangle module name before importing If obj came out PackageImporter ` __module__ ` will mangled See mangling md details module_name = demangle orig_module_name Check name will indeed correct object try module = import_module module_name sys version_info = pickle _getatribute signature changes take iterable just one object obj = _getattribute module name split obj _ = _getattribute module name except ImportError KeyError AttributeError raise ObjNotFoundError f obj found module_name name None obj obj module_name name get_obj_info obj assert name None module_name = whichmodule obj name is_mangled_ = is_mangled module_name location = get_mangle_prefix module_name is_mangled_ current Python environment importer_name = f importer get_mangle_prefix module_name is_mangled_ sys_importer module_name location importer_name obj_module_name obj_location obj_importer_name = get_obj_info obj obj _module_name obj _location obj _importer_name = get_obj_info obj msg = f \n\nThe object provided obj_module_name f which coming obj_location f \nHowever when we obj _module_name s coming obj _location \nTo fix make sure PackageExporter s importer lists f obj_importer_name before obj _importer_name raise ObjMismatchError msg whichmodule obj Any name str - str Find module name object belongs This should considered internal end-users developers importer can override customize behavior Taken pickle py modified exclude search into sys modules module_name = getattr obj __module__ None module_name None module_name Protect iteration using list copy modules against dynamic modules trigger imports other modules upon calls getattr module_name module modules copy items module_name == __main__ module_name == __mp_main__ bpo- module None continue try _getattribute module name obj module_name except AttributeError pass __main__ _SysImporter Importer An importer implements default behavior Python import_module module_name str importlib import_module module_name whichmodule obj Any name str - str _pickle_whichmodule obj name sys_importer = _SysImporter OrderedImporter Importer A compound importer takes list importers tries them one time The first importer list returns result wins __init__ args _importers list Importer = list args _is_torchpackage_dummy module Returns true iff module empty PackageNode torch package If you intern ` b ` never use ` ` your code then ` ` will empty module no source This can break cases where we trying re-package object after adding real dependency ` ` since OrderedImportere will resolve ` ` dummy package stop there See https github com pytorch pytorch pull #issuecomment- getattr module __torch_package__ False False hasattr module __path__ False hasattr module __file__ True module __file__ None get_name obj Any name Optional str = None - tuple str str importer _importers try importer get_name obj name except ObjNotFoundError ObjMismatchError e warning_message = f Tried call get_name obj obj f name name importer got e log warning warning_message raise ObjNotFoundError f Could find obj obj name name any importers _importers import_module module_name str - ModuleType last_err = None importer _importers isinstance importer Importer raise TypeError f importer Importer All importers OrderedImporter must inherit Importer try module = importer import_module module_name _is_torchpackage_dummy module continue module except ModuleNotFoundError err last_err = err last_err None raise last_err raise ModuleNotFoundError module_name whichmodule obj Any name str - str importer _importers module_name = importer whichmodule obj name module_name = __main__ module_name __main__