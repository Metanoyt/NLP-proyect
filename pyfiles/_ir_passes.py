mypy allow-untyped-defs __future__ annotations logging re typing TYPE_CHECKING torch onnx _internal _lazy_import onnxscript_ir ir torch onnx _internal exporter _constants TYPE_CHECKING collections abc Sequence The opset domain ONNX operators _ONNX_DOMAIN = logger = logging getLogger __name__ rename_inputs model ir Model new_names Sequence str - None TODO Ensure names do have duplicates input new_name zip model graph inputs new_names input metadata_props pkg torch onnx original_node_name = str input name input name = new_name rename_outputs model ir Model new_names Sequence str - None output new_name zip model graph outputs new_names output metadata_props pkg torch onnx original_node_name = str output name output name = new_name _all_values model ir Model Yield all values model Yield all values model yield model graph inputs yield model graph initializers values node ir traversal RecursiveGraphIterator model graph yield node outputs Yield all values functions function model functions values yield function inputs node ir traversal RecursiveGraphIterator function yield node outputs _replace_names shape_expr str rename_mapping dict str str - str Replace all known names shape expression new names old_name new_name rename_mapping items shape_expr = re sub rf \w re escape old_name \w new_name shape_expr shape_expr rename_axis model ir Model rename_mapping dict str str - None Rename dynamic axes model according specified dynamic_axes names NOTE Mapping needs srted length because shape expression could have multiple ways expressed example s sequence_length s past_sequence_length s + s masked_sequence_length We prefer replacement starts longest match sorted_rename_mapping = dict sorted rename_mapping items key=lambda item len item reverse=True value _all_values model value shape None continue new_shape = changed = False dim value shape isinstance dim ir SymbolicDim new_shape append dim continue dim_name = dim value dim_name sorted_rename_mapping new_shape append sorted_rename_mapping dim_name changed = True dim_name None For example s s + s - s s s s new_name = _replace_names dim_name sorted_rename_mapping new_shape append new_name new_name = dim_name changed = True new_shape append None changed value shape = ir Shape new_shape _maybe_set_opset_version opset_imports dict str int domain str version int &#124; None - None Set opset version domain domain opset_imports opset_imports domain = Already set domain == _ONNX_DOMAIN opset_imports domain = _constants TORCHLIB_OPSET version None We don t know opset version so set This valid custom function domains like pkg torch __subgraph__ opset_imports domain = Set known opset version domain opset_imports domain = version add_opset_imports model ir Model - None Collect all opsets used add opset imports model functions node ir traversal RecursiveGraphIterator model graph domain = node domain _maybe_set_opset_version model opset_imports domain node version function model functions values node ir traversal RecursiveGraphIterator function domain = node domain _maybe_set_opset_version function opset_imports domain node version domain version function opset_imports items Add all opsets used function model because ONNX Runtime does handle adding opset imports model after inlining during inference This should happen after all opsets collected function its nodes _maybe_set_opset_version model opset_imports domain version