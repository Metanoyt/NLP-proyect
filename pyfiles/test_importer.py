Owner s oncall package deploy io BytesIO torch torch package Importer OrderedImporter PackageExporter PackageImporter sys_importer torch testing _internal common_utils run_tests try common PackageTestCase except ImportError Support case where we run file directly common PackageTestCase TestImporter PackageTestCase Tests Importer derived classes test_sys_importer package_a package_a subpackage assertIs sys_importer import_module package_a package_a assertIs sys_importer import_module package_a subpackage package_a subpackage test_sys_importer_roundtrip package_a package_a subpackage importer = sys_importer type_ = package_a subpackage PackageASubpackageObject module_name type_name = importer get_name type_ module = importer import_module module_name assertIs getattr module type_name type_ test_single_ordered_importer module_a noqa F package_a buffer = BytesIO PackageExporter buffer pe pe save_module package_a __name__ buffer seek importer = PackageImporter buffer Construct importer-only environment ordered_importer = OrderedImporter importer The module returned environment should same one s importer assertIs ordered_importer import_module package_a importer import_module package_a It should one available outer Python environment assertIsNot ordered_importer import_module package_a package_a We didn t package module so should available assertRaises ModuleNotFoundError ordered_importer import_module module_a test_ordered_importer_basic package_a buffer = BytesIO PackageExporter buffer pe pe save_module package_a __name__ buffer seek importer = PackageImporter buffer ordered_importer_sys_first = OrderedImporter sys_importer importer assertIs ordered_importer_sys_first import_module package_a package_a ordered_importer_package_first = OrderedImporter importer sys_importer assertIs ordered_importer_package_first import_module package_a importer import_module package_a test_ordered_importer_whichmodule OrderedImporter s implementation whichmodule should try each underlying importer s whichmodule order DummyImporter Importer __init__ whichmodule_return _whichmodule_return = whichmodule_return import_module module_name raise NotImplementedError whichmodule obj name _whichmodule_return DummyClass pass dummy_importer_foo = DummyImporter foo dummy_importer_bar = DummyImporter bar dummy_importer_not_found = DummyImporter __main__ __main__ used proxy found CPython foo_then_bar = OrderedImporter dummy_importer_foo dummy_importer_bar assertEqual foo_then_bar whichmodule DummyClass foo bar_then_foo = OrderedImporter dummy_importer_bar dummy_importer_foo assertEqual bar_then_foo whichmodule DummyClass bar notfound_then_foo = OrderedImporter dummy_importer_not_found dummy_importer_foo assertEqual notfound_then_foo whichmodule DummyClass foo test_package_importer_whichmodule_no_dunder_module Exercise corner case where we try pickle object whose __module__ doesn t exist because s C extension torch float example such object C extension type which there no __module__ defined The default pickler finds using special logic traverse sys modules look up ` float ` each module see pickle py whichmodule We must ensure we emulate same behavior PackageImporter my_dtype = torch float Set up PackageImporter which has torch float object pickled buffer = BytesIO PackageExporter buffer exporter exporter save_pickle foo foo pkl my_dtype buffer seek importer = PackageImporter buffer my_loaded_dtype = importer load_pickle foo foo pkl Re-save package only our PackageImporter importer buffer = BytesIO PackageExporter buffer importer=importer exporter exporter save_pickle foo foo pkl my_loaded_dtype buffer seek importer = PackageImporter buffer my_loaded_dtype = importer load_pickle foo foo pkl assertIs my_dtype my_loaded_dtype assertIs my_dtype my_loaded_dtype __name__ == __main__ run_tests