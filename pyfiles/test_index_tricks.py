Owner s module dynamo functools unittest expectedFailure xfail skipIf pytest raises assert_raises assert_raises_regex torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests TEST_WITH_TORCHDYNAMO TestCase xpassIfTorchDynamo_np skip = functools partial skipIf True If we going trace through these we should use NumPy If testing eager mode we use torch _numpy TEST_WITH_TORCHDYNAMO numpy np numpy diag_indices diag_indices_from fill_diagonal index_exp s_ numpy testing assert_ assert_almost_equal assert_array_almost_equal assert_array_equal assert_equal assert_raises_regex torch _numpy np torch _numpy diag_indices diag_indices_from fill_diagonal index_exp s_ torch _numpy testing assert_ assert_almost_equal assert_array_almost_equal assert_array_equal assert_equal xpassIfTorchDynamo_np reason= unravel_index implemented instantiate_parametrized_tests TestRavelUnravelIndex TestCase test_basic assert_equal np unravel_index test new shape argument works properly assert_equal np unravel_index indices= shape= test invalid second keyword argument properly handled including old name ` dims ` assert_raises TypeError np unravel_index indices= hape= assert_raises TypeError np unravel_index hape= assert_raises TypeError np unravel_index ims= assert_raises TypeError np unravel_index dims= assert_equal np ravel_multi_index assert_equal np unravel_index assert_equal np ravel_multi_index assert_raises ValueError np unravel_index - assert_raises TypeError np unravel_index assert_raises ValueError np unravel_index assert_raises ValueError np ravel_multi_index - assert_raises ValueError np ravel_multi_index assert_raises ValueError np ravel_multi_index - assert_raises ValueError np ravel_multi_index assert_raises TypeError np ravel_multi_index assert_equal np unravel_index + + assert_equal np ravel_multi_index + + arr = np array assert_equal np ravel_multi_index arr assert_equal np ravel_multi_index arr order= F assert_equal np ravel_multi_index arr mode= clip assert_equal np ravel_multi_index arr mode= clip wrap assert_equal np ravel_multi_index assert_equal np unravel_index np array assert_equal np unravel_index np array order= F assert_equal np unravel_index test_empty_indices msg = indices must integral provided empty sequence msg = only int indices permitted assert_raises_regex TypeError msg np unravel_index assert_raises_regex TypeError msg np unravel_index assert_raises_regex TypeError msg np unravel_index np array assert_equal np unravel_index np array dtype=int assert_raises_regex TypeError msg np ravel_multi_index assert_raises_regex TypeError msg np ravel_multi_index abc assert_raises_regex TypeError msg np ravel_multi_index np array np array assert_equal np ravel_multi_index np array dtype=int np array dtype=int assert_equal np ravel_multi_index np array dtype=int test_big_indices ravel_multi_index big indices issue np intp == np int arr = assert_equal np ravel_multi_index arr test unravel_index big indices issue assert_raises ValueError np unravel_index - + test overflow checking too big array issue dummy_arr = half_max = np iinfo np intp max assert_equal np ravel_multi_index dummy_arr half_max assert_raises ValueError np ravel_multi_index dummy_arr half_max + assert_equal np ravel_multi_index dummy_arr half_max order= F assert_raises ValueError np ravel_multi_index dummy_arr half_max + order= F test_dtypes Test different data types dtype np int np uint np int np uint np int np uint coords = np array dtype=dtype shape = uncoords = coords + coords assert_equal np ravel_multi_index coords shape uncoords assert_equal coords np unravel_index uncoords shape uncoords = coords + coords assert_equal np ravel_multi_index coords shape order= F uncoords assert_equal coords np unravel_index uncoords shape order= F coords = np array dtype=dtype shape = uncoords = coords + coords + coords assert_equal np ravel_multi_index coords shape uncoords assert_equal coords np unravel_index uncoords shape uncoords = coords + coords + coords assert_equal np ravel_multi_index coords shape order= F uncoords assert_equal coords np unravel_index uncoords shape order= F test_clipmodes Test clipmodes assert_equal np ravel_multi_index - mode= wrap np ravel_multi_index assert_equal np ravel_multi_index - mode= wrap raise clip raise np ravel_multi_index assert_raises ValueError np ravel_multi_index - test_writeability See gh- x y = np unravel_index assert_ x flags writeable assert_ y flags writeable test_ d gh- x = np unravel_index assert_equal x assert_raises_regex ValueError d array np unravel_index assert_raises_regex ValueError out bounds np unravel_index parametrize mode clip wrap raise test_empty_array_ravel mode res = np ravel_multi_index np zeros dtype=np intp mode=mode assert res shape == assert_raises ValueError np ravel_multi_index np zeros dtype=np intp mode=mode test_empty_array_unravel res = np unravel_index np zeros dtype=np intp res tuple three empty arrays assert len res == assert all shape == res assert_raises ValueError np unravel_index xfail reason= mgrid implemented instantiate_parametrized_tests TestGrid TestCase test_basic = mgrid - j b = mgrid - assert_ shape == assert_ b shape == assert_ == - assert_almost_equal - assert_ b == - assert_almost_equal b - b assert_almost_equal b - b + assert_almost_equal - xfail reason= retstep implemented test_linspace_equivalence y st = np linspace retstep=True assert_almost_equal st assert_array_almost_equal y mgrid j test_nd c = mgrid - j - j d = mgrid - - assert_ c shape == assert_ d shape == assert_array_equal c -np ones d assert_array_equal c - np ones d assert_array_almost_equal c - np ones d assert_array_almost_equal c - np ones d assert_array_almost_equal d - d np ones d assert_array_almost_equal d - d np ones d test_sparse grid_full = mgrid - j - j grid_sparse = ogrid - j - j sparse grids can made dense broadcasting grid_broadcast = np broadcast_arrays grid_sparse f b zip grid_full grid_broadcast assert_equal f b parametrize start stop step expected None j - None test_mgrid_size_none_handling start stop step expected regression test None value handling start step values used mgrid internally aims cover previously unexplored code paths nd_grid grid = mgrid start stop step start stop step need smaller grid explore one untested code paths grid_small = mgrid start stop step assert_equal grid size expected assert_equal grid_small size expected xfail reason= mgrid implementd test_accepts_npfloating regression test grid = mgrid grid = mgrid np float np float np float assert_ grid dtype == np float assert_array_almost_equal grid grid different code path single slice grid = mgrid grid = mgrid np float np float np float assert_ grid dtype == np float assert_array_almost_equal grid grid skip reason= longdouble test_accepts_longdouble regression tests grid = mgrid grid = mgrid np longdouble np longdouble np longdouble assert_ grid dtype == np longdouble assert_array_almost_equal grid grid grid c_a = mgrid np longdouble j grid c_b = mgrid np longdouble j assert_ grid c_a dtype == grid c_b dtype == np longdouble assert_array_equal grid c_a grid c_b different code path single slice grid = mgrid grid = mgrid np longdouble np longdouble np longdouble assert_ grid dtype == np longdouble assert_array_almost_equal grid grid skip reason= longdouble test_accepts_npcomplexfloating Related assert_array_almost_equal mgrid j mgrid np complex j different code path single slice assert_array_almost_equal mgrid j mgrid np complex j Related grid _a = mgrid j grid _b = mgrid j assert_ grid _a dtype == grid _b dtype == np float assert_array_equal grid _a grid _b grid _a = mgrid np clongdouble j grid _b = mgrid np clongdouble j assert_ grid _a dtype == grid _b dtype == np longdouble assert_array_equal grid _a grid _b xfail reason= r_ implemented TestConcatenator TestCase test_ d assert_array_equal r_ np array b = np ones c = r_ b b assert_array_equal c test_mixed_type g = r_ assert_ g dtype == f test_more_mixed_type g = r_ - np array np array assert_ g dtype == f test_complex_step Regression test g = r_ j assert_ g shape == Related g = r_ np complex j assert_ g shape == test_ d b = np random rand c = np random rand d = r_ b c append columns assert_ d shape == assert_array_equal d b assert_array_equal d c d = r_ b c assert_ d shape == assert_array_equal d b assert_array_equal d c test_ d assert_equal r_ np array assert_equal r_ np array assert_equal r_ np array xfail reason= ndenumerate implemented TestNdenumerate TestCase test_basic = np array assert_equal list ndenumerate TestIndexExpression TestCase test_regression_ ticket = np arange assert_equal - s_ - assert_equal - index_exp - test_simple_ = np random rand assert_equal index_exp assert_equal s_ xfail reason= ix_ implemented TestIx_ TestCase test_regression_ Test empty untyped inputs create outputs indexing type gh- = ix_ range assert_equal dtype np intp = ix_ assert_equal dtype np intp type specified don t change = ix_ np array dtype=np float assert_equal dtype np float test_shape_and_dtype sizes = Test both lists arrays func range np arange arrays = ix_ func sz sz sizes k sz enumerate zip arrays sizes assert_equal shape k sz assert_ all sh == j sh enumerate shape j = k assert_ np issubdtype dtype np integer test_bool bool_a = True False True True int_a = np nonzero bool_a assert_equal ix_ bool_a int_a test_ d_only idx d = assert_raises ValueError ix_ idx d test_repeated_input length_of_vector = x = np arange length_of_vector out = ix_ x x assert_equal out shape length_of_vector assert_equal out shape length_of_vector check input shape modified assert_equal x shape length_of_vector TestC TestCase xpassIfTorchDynamo_np reason= c_ implemented test_c_ = np c_ np array np array assert_equal TestFillDiagonal TestCase test_basic = np zeros dtype=int fill_diagonal assert_array_equal np array test_tall_matrix = np zeros dtype=int fill_diagonal assert_array_equal np array test_tall_matrix_wrap = np zeros dtype=int fill_diagonal True assert_array_equal np array test_wide_matrix = np zeros dtype=int fill_diagonal assert_array_equal np array test_operate_ d_array = np zeros dtype=int fill_diagonal i = np array assert_equal np where = i i i i test_low_dim_handling raise error low dimensionality = np zeros dtype=int assert_raises ValueError fill_diagonal test_hetero_shape_handling raise error high dimensionality shape mismatch = np zeros dtype=int assert_raises ValueError fill_diagonal TestDiagIndices TestCase test_diag_indices di = diag_indices = np array di = assert_array_equal np array Now we create indices manipulate -d array d = diag_indices And use set diagonal zeros array = np zeros dtype=int d = assert_array_equal np array TestDiagIndicesFrom TestCase test_diag_indices_from x = np random random r c = diag_indices_from x assert_array_equal r np arange assert_array_equal c np arange test_error_small_input x = np ones assert_raises ValueError diag_indices_from x test_error_shape_mismatch x = np zeros dtype=int assert_raises ValueError diag_indices_from x TestNdIndex TestCase xfail reason= ndindex implemented test_ndindex x = list ndindex expected = ix ix e ndenumerate np zeros assert_array_equal x expected x = list ndindex assert_array_equal x expected Test use scalars tuples x = list ndindex assert_array_equal x list ndindex Make sure size argument optional x = list ndindex assert_equal x x = list ndindex assert_equal x Make sure -sized ndindex works correctly x = list ndindex assert_equal x __name__ == __main__ run_tests