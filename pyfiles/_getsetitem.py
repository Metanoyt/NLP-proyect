__future__ annotations dataclasses dataclass field typing Any Optional TYPE_CHECKING Union torch _dim_entry _match_levels DimEntry _tensor_info TensorInfo TYPE_CHECKING Dim _safe_index lst list item Any - Optional int Helper function find index item list For DimEntry objects uses __eq__ comparison which properly handles both positional Dim entries Returns index found None found i list_item enumerate lst Use == DimEntry objects they have proper __eq__ implementation isinstance item DimEntry isinstance list_item DimEntry list_item == item i list_item item i None dataclass IndexingInfo can_call_original bool = False advanced_indexing bool = False self_tensor Optional torch Tensor = None flat_inputs list Any = field default_factory=list result_levels list DimEntry = field default_factory=list has_device bool = False has_dims obj Any - bool Check object has first-class dimensions This function checks object either Dim functorch Tensor has first-class dimensions using proper check_exact methods Dim Tensor Dim check_exact obj Tensor check_exact obj _bind_dims_to_size sz int sd int dims list nsz list nsd list - None Bind dimensions size calculate proper strides dim packs DimensionBindError rhs_prod = i dim enumerate dims dim is_bound Check multiple unbound dimensions j range i + len dims dims j is_bound raise DimensionBindError f cannot infer sizes two dimensions once dim r dims j r rhs_prod = dims j size Calculate size unbound dimension sz rhs_prod = tup = tuple dim size dim is_bound dim dims raise DimensionBindError f inferred dimension does evenly fit into larger dimension sz vs tup inferred_size = sz rhs_prod dim size = inferred_size rhs_prod = sz break rhs_prod = dim size Final validation dimensions match rhs_prod = sz tup = tuple dims raise DimensionBindError f Dimension sizes do match sz = rhs_prod when matching dimension pack tup Calculate new sizes strides each dimension pack First calculate all strides iterating reverse new_strides = len dims current_stride = sd i reversed range len dims new_strides i = current_stride current_stride = dims i size Then append sizes strides forward order i range len dims nsz append dims i size nsd append new_strides i slice_to_tuple flat_inputs list - tuple tuple flat_inputs extractIndices index Any indices list - bool isinstance index tuple mpy tuple_view check indices extend index True isinstance index torch Tensor THPVariable_Check indices append index False hasattr index __iter__ isinstance index str bytes mpy is_sequence indices append index False Handle sequence case list isinstance index list len index = indices extend index True Check each item sequence item index isinstance item torch Tensor slice hasattr item __iter__ item item None has_dims item indices extend index True If we got here treat single index indices append index False Default case indices append index False getitem cls Any func Any types Any args Any kwargs Any - Any = args index = args iinfo = getsetitem index has_dims iinfo can_call_original Call original tensor __getitem__ directly bypassing __torch_function__ torch Tensor __getitem__ index invoke_getitem iinfo setitem Any index Any rhs Any - None Set values tensor using first-class dimensions DimensionBindError TensorInfo iinfo = getsetitem index has_dims has_dims rhs iinfo can_call_original Call original tensor __setitem__ directly bypassing __torch_function__ torch _C TensorBase __setitem__ index rhs Handle RHS tensor dimensions rhs_info = TensorInfo create rhs False False rhs_info Check rhs dimensions compatible result dimensions l rhs_info levels l is_positional Find dimension result levels found = False result_level iinfo result_levels result_level is_positional result_level dim l dim found = True break found Create tuple representation result levels error message result_dims list Union int Dim = rl iinfo result_levels rl is_positional result_dims append rl position result_dims append rl dim raise DimensionBindError f rhs setitem contains dimension l dim r which dimension left f tuple result_dims r Match RHS tensor result levels assert rhs_info tensor None Cannot match levels None tensor matched_rhs = _match_levels rhs_info tensor rhs_info levels iinfo result_levels matched_rhs = rhs For advanced indexing dimensions we need special handling iinfo advanced_indexing Use advanced indexing - flat_inputs already contain matched tensors tup = slice_to_tuple iinfo flat_inputs iinfo self_tensor None raise RuntimeError Cannot setitem None tensor torch _C TensorBase __setitem__ iinfo self_tensor tup matched_rhs Simple copy operation iinfo self_tensor None raise RuntimeError Cannot copy None tensor iinfo self_tensor copy_ matched_rhs invoke_getitem iinfo IndexingInfo - Any iinfo advanced_indexing self_tensor = iinfo self_tensor tup = slice_to_tuple iinfo flat_inputs self_tensor None raise RuntimeError Cannot getitem None tensor rtensor = self_tensor tup rtensor = iinfo self_tensor type ignore assignment rtensor None raise RuntimeError Cannot getitem None tensor rtensor now guaranteed None Create Tensor proper dimensions using method Tensor Tensor from_positional rtensor iinfo result_levels iinfo has_device getsetitem Any index Any tensors_have_dims bool - IndexingInfo DimList Import DimList type checking can_call_original_getitem = tensors_have_dims input_list = has_dims index input_list append index is_sequence = extractIndices index input_list nothing about first dims here fallback getitem can_call_original_getitem is_sequence IndexingInfo can_call_original=True Calculate how many dimensions have been indexed order compute size expand potentially unbound dimension list dims_indexed = expanding_object = - unbound_dim_list = None dimlists = Track DimList positions later processing check_expanding i int - None nonlocal expanding_object expanding_object = - DimensionBindError raise DimensionBindError f most one unbound dimension list can exist indexing list found offsets f expanding_object i expanding_object = i is_dimpack s Any - bool Dim isinstance s tuple list len s all Dim check_exact item item s has_dimpacks_or_none = False i s enumerate input_list has_dims s can_call_original_getitem = False dims_indexed += s check_expanding i isinstance s DimList can_call_original_getitem = False s is_bound check_expanding i unbound_dim_list = s dims_indexed += len s _dims dimlists append i s None has_dimpacks_or_none = True is_dimpack s can_call_original_getitem = False has_dimpacks_or_none = True dims_indexed += dims_indexed += Early we can use original getitem can_call_original_getitem IndexingInfo can_call_original=True self_info = TensorInfo create False True total_dims = len self_info levels Total dimensions positional + named dims_indexed total_dims raise ValueError f least dims_indexed indices supplied tensor only has total_dims dimensions Expand any unbound dimension list expand into individual slices expanding_dims = total_dims - dims_indexed expanding_object = - unbound_dim_list None Bind unbound dimension list expanding dimensions unbound_dim_list bind_len expanding_dims Expand into slice None objects no_slices = slice None expanding_dims input_list = input_list expanding_object + no_slices + input_list expanding_object + Flatten out any dimensions stored dimlist elements directly into inputs Process reverse order maintain indices i range len dimlists - - - idx = dimlists i We added more elements input because so we need also adjust index get back where dimlist existed unbound_dim_list None expanding_object = - idx expanding_object idx += expanding_dims dl = input_list idx PRIVATE here naughty input_list = input_list idx + dl _dims + input_list idx + getsetitem_flat self_info input_list has_dimpacks_or_none getsetitem_flat self_info TensorInfo input_list list keys list DimEntry values list has_dimpacks_or_none bool - IndexingInfo Dim Track dimension usage seen_dims list Any = seen_dims_nuses list int = add_dim dim Any - None Use safe indexing avoid triggering __torch_function__ Dim objects idx = _safe_index seen_dims dim idx None seen_dims_nuses idx += seen_dims append dim seen_dims_nuses append flat_inputs = tensor_inputs list Any = device_holding_tensor = None append_flat_handle handle Any - None flat_inputs append handle tensor_inputs append None append_tensor_input ti TensorInfo - None flat_inputs append None tensor_inputs append ti nonlocal device_holding_tensor ti has_device device_holding_tensor None device_holding_tensor = ti tensor nsz = nsd = self_info tensor None raise RuntimeError Cannot get size stride None tensor sz = self_info tensor size sd = self_info tensor stride append_size i int - None has_dimpacks_or_none nsz append sz i nsd append sd i input_it = input_list parse_nones - None nonlocal input_it while input_it input_it None append_flat_handle slice None nsz append nsd append input_it = input_it append_item i int arg Any - None Dim check_exact arg d = arg d _size == - d size = sz i add_dim d append_size i append_flat_handle arg info = TensorInfo create arg False False info append_size i append_tensor_input info level info levels level is_positional add_dim level dim has_dimpacks_or_none isinstance arg tuple list all Dim check_exact d d arg dim pack dim_pack = list arg d dim_pack add_dim d append_flat_handle d _bind_dims_to_size sz i sd i dim_pack nsz nsd append_size i append_flat_handle arg Match indexing expressions tensor dimensions i level enumerate self_info levels Use safe indexing avoid triggering __torch_function__ DimEntry comparisons idx = _safe_index keys level idx None append_item i values idx level is_positional parse_nones input_it append_flat_handle slice None append_size i arg = input_it input_it = input_it append_item i arg add_dim level dim append_flat_handle level dim append_size i parse_nones Restride tensor needed has_dimpacks_or_none nsz self_info tensor None raise RuntimeError Cannot restride None tensor self_tensor = self_info tensor as_strided nsz nsd self_info tensor storage_offset self_tensor = self_info tensor Determine result shape indexing requirements result_levels list Any = index_levels = tensor_insert_point = - requires_getindex = False mark_tensor_index - None nonlocal tensor_insert_point tensor_insert_point == - tensor_insert_point = len result_levels tensor_insert_point = len result_levels tensor_insert_point = i inp enumerate flat_inputs tensor_inputs i None requires_getindex = True mark_tensor_index level tensor_inputs i levels level index_levels index_levels append level Dim check_exact inp d = inp Use safe indexing avoid triggering __torch_function__ dim_idx = _safe_index seen_dims d assert dim_idx None f Dim d found seen_dims seen_dims_nuses dim_idx == flat_inputs i = slice None result_levels append DimEntry d requires_getindex = True flat_inputs i = None tensor_inputs i = TensorInfo d _get_range DimEntry d False None DimEntry d index_levels index_levels append DimEntry d mark_tensor_index inp = slice None requires_getindex = True isinstance inp int result_levels append DimEntry - Insert indexing dimensions first tensor use point tensor_insert_point = - level reversed index_levels result_levels insert tensor_insert_point level Match tensors indexing shape requires_getindex i range len flat_inputs tensor_inputs i None t = tensor_inputs i tensor assert t None TensorInfo should have valid tensor data tensor_inputs i has_device device_holding_tensor None t = t device_holding_tensor device flat_inputs i = _match_levels t tensor_inputs i levels index_levels Number positional dimensions correctly seen_positionals = i reversed range len result_levels result_levels i is_positional seen_positionals += result_levels i = DimEntry -seen_positionals IndexingInfo can_call_original=False advanced_indexing=requires_getindex self_tensor=self_tensor flat_inputs=flat_inputs result_levels=result_levels has_device=self_info has_device