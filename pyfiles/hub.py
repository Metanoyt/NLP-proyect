mypy allow-untyped-defs contextlib errno hashlib json os re shutil sys tempfile uuid warnings zipfile pathlib Path typing Any Optional Union typing_extensions deprecated urllib error HTTPError URLError urllib parse urlparse noqa F urllib request Request urlopen torch torch serialization MAP_LOCATION _Faketqdm type ignore no-redef __init__ total=None disable=False unit=None args kwargs total = total disable = disable n = Ignore all extra args kwargs lest you want reinvent tqdm update n disable n += n total None sys stderr write f \r n f bytes sys stderr write f \r n float total f sys stderr flush Don t bother implementing use real tqdm you want set_description args kwargs pass write s sys stderr write f s \n close disable = True __enter__ __exit__ exc_type exc_val exc_tb disable sys stderr write \n try tqdm tqdm If tqdm installed use otherwise use fake wrapper except ImportError tqdm = _Faketqdm __all__ = download_url_to_file get_dir help list load load_state_dict_from_url set_dir matches bfd deac resnet -bfd deac pth HASH_REGEX = re compile r - a-f - \ _TRUSTED_REPO_OWNERS = facebookresearch facebookincubator pytorch fairinternal ENV_GITHUB_TOKEN = GITHUB_TOKEN ENV_TORCH_HOME = TORCH_HOME ENV_XDG_CACHE_HOME = XDG_CACHE_HOME DEFAULT_CACHE_DIR = ~ cache VAR_DEPENDENCY = dependencies MODULE_HUBCONF = hubconf py READ_DATA_CHUNK = _hub_dir Optional str = None contextlib contextmanager _add_to_sys_path path sys path insert path try yield finally sys path remove path Copied tools shared module_loader included torch package _import_module name path importlib util importlib abc Loader spec = importlib util spec_from_file_location name path assert spec None module = importlib util module_from_spec spec assert isinstance spec loader Loader spec loader exec_module module module _remove_if_exists path os path exists path os path isfile path os remove path shutil rmtree path _git_archive_link repo_owner repo_name ref See https docs github com en rest reference repos#download-a-repository-archive-zip f https github com repo_owner repo_name zipball ref _load_attr_from_module module func_name Check callable defined module func_name dir module None getattr module func_name _get_torch_home torch_home = os path expanduser os getenv ENV_TORCH_HOME os path join os getenv ENV_XDG_CACHE_HOME DEFAULT_CACHE_DIR torch torch_home _parse_repo_info github github repo_info ref = github split repo_info ref = github None repo_owner repo_name = repo_info split ref None The ref wasn t specified user so we need figure out default branch main master Our assumption main exists then s default branch otherwise s master try urlopen f https github com repo_owner repo_name tree main ref = main except HTTPError e e code == ref = master raise except URLError e No internet connection need check cache last resort possible_ref main master os path exists f get_dir repo_owner _ repo_name _ possible_ref ref = possible_ref break ref None raise RuntimeError It looks like there no internet connection f repo could found cache get_dir e repo_owner repo_name ref _read_url url urlopen url r r read decode r headers get_content_charset utf- _validate_not_a_forked_repo repo_owner repo_name ref Use urlopen avoid depending local git headers = Accept application vnd github v +json token = os environ get ENV_GITHUB_TOKEN token None headers Authorization = f token token url_prefix f https api github com repos repo_owner repo_name branches f https api github com repos repo_owner repo_name tags page = while True page += url = f url_prefix per_page= page= page try response = json loads _read_url Request url headers=headers except HTTPError Retry without token case had insufficient permissions del headers Authorization response = json loads _read_url Request url headers=headers Empty response means no more data process response break br response br name == ref br commit sha startswith ref raise ValueError f Cannot find ref https github com repo_owner repo_name If s commit forked repo please call hub load forked repo directly _get_cache_or_reload github force_reload trust_repo calling_fn verbose=True skip_validation=False Setup hub_dir save downloaded files hub_dir = get_dir os makedirs hub_dir exist_ok=True Parse github repo information repo_owner repo_name ref = _parse_repo_info github Github allows branch name slash causes confusion path both Linux Windows Backslash allowed Github branch name so no need worry about normalized_br = ref replace _ Github renames folder repo-v x x repo- x x We don t know repo name before downloading zip file inspect name To check cached repo exists we need normalize folder names owner_name_branch = _ join repo_owner repo_name normalized_br repo_dir = os path join hub_dir owner_name_branch Check repo trusted list _check_repo_is_trusted repo_owner repo_name owner_name_branch trust_repo=trust_repo calling_fn=calling_fn use_cache = force_reload os path exists repo_dir use_cache verbose sys stderr write f Using cache found repo_dir \n Validate tag branch original repo instead forked repo skip_validation _validate_not_a_forked_repo repo_owner repo_name ref cached_file = os path join hub_dir normalized_br + zip _remove_if_exists cached_file try url = _git_archive_link repo_owner repo_name ref sys stdout write f Downloading url cached_file \n download_url_to_file url cached_file progress=False except HTTPError err err code == Getting Multiple Choices error likely means ref both tag branch repo This can disambiguated explicitly using refs heads refs tags See https git-scm com book en v Git-Internals-Git-References Here we do same git we throw warning assume user wanted branch warnings warn f The ref ref ambiguous Perhaps both tag branch repo Torchhub will now assume s branch You can disambiguate tags branches explicitly passing refs heads branch_name refs tags tag_name ref That might require using skip_validation=True stacklevel= disambiguated_branch_ref = f refs heads ref url = _git_archive_link repo_owner repo_name ref=disambiguated_branch_ref download_url_to_file url cached_file progress=False raise zipfile ZipFile cached_file cached_zipfile extraced_repo_name = cached_zipfile infolist filename extracted_repo = os path join hub_dir extraced_repo_name _remove_if_exists extracted_repo Unzip code rename base folder cached_zipfile extractall hub_dir _remove_if_exists cached_file _remove_if_exists repo_dir shutil move extracted_repo repo_dir rename repo repo_dir _check_repo_is_trusted repo_owner repo_name owner_name_branch trust_repo calling_fn= load hub_dir = get_dir filepath = os path join hub_dir trusted_list os path exists filepath Path filepath touch open filepath file trusted_repos = tuple line strip line file To minimize friction introducing new trust_repo mechanism we consider repo already downloaded torchhub then already trusted even s allowlist trusted_repos_legacy = next os walk hub_dir owner_name = _ join repo_owner repo_name is_trusted = owner_name trusted_repos owner_name_branch trusted_repos_legacy repo_owner _TRUSTED_REPO_OWNERS TODO Remove ` None ` option change default check trust_repo None is_trusted warnings warn You about download run code untrusted repository In future release won t f allowed To add repository your trusted list change command calling_fn trust_repo=False command prompt will appear asking explicit confirmation trust f calling_fn trust_repo=True which will assume prompt answered f yes You can also use calling_fn trust_repo= check which will only prompt f confirmation repo already trusted This will eventually default behaviour stacklevel= trust_repo False trust_repo == check is_trusted response = input f The repository owner_name does belong list trusted repositories such cannot downloaded Do you trust repository wish add trusted list repositories y N response lower y yes is_trusted print The repository already trusted response lower n no raise Exception Untrusted repository noqa TRY raise ValueError f Unrecognized response response At point we re sure user trusts repo wants trust is_trusted open filepath file file write owner_name + \n _check_module_exists name importlib util importlib util find_spec name None _check_dependencies m dependencies = _load_attr_from_module m VAR_DEPENDENCY dependencies None missing_deps = pkg pkg dependencies _check_module_exists pkg missing_deps raise RuntimeError f Missing dependencies join missing_deps _load_entry_from_hubconf m model isinstance model str raise ValueError Invalid input model should string function name Note missing dependency imported top level hubconf will throw before function It s chicken egg situation where we have load hubconf know what re dependencies hubconf requires missing package This fine Python will throw proper error message users _check_dependencies m func = _load_attr_from_module m model func None callable func raise RuntimeError f Cannot find callable model hubconf func get_dir - str r Get Torch Hub cache directory used storing downloaded models weights If func ` ~torch hub set_dir ` called default path ` ` $ TORCH_HOME hub ` ` where environment variable ` ` $ TORCH_HOME ` ` defaults ` ` $ XDG_CACHE_HOME torch ` ` ` ` $ XDG_CACHE_HOME ` ` follows X Design Group specification Linux filesystem layout default value ` ` ~ cache ` ` environment variable set Issue warning move data old env set os getenv TORCH_HUB warnings warn TORCH_HUB deprecated please use env TORCH_HOME instead stacklevel= _hub_dir None _hub_dir os path join _get_torch_home hub set_dir d Union str os PathLike - None r Optionally set Torch Hub directory used save downloaded models weights Args d str path local folder save downloaded models weights global _hub_dir _hub_dir = os path expanduser d list github force_reload=False skip_validation=False trust_repo=None verbose=True r List all callable entrypoints available repo specified ` ` github ` ` Args github str string format repo_owner repo_name ref optional ref tag branch If ` ` ref ` ` specified default branch assumed ` ` main ` ` exists otherwise ` ` master ` ` Example pytorch vision force_reload bool optional whether discard existing cache force fresh download Default ` ` False ` ` skip_validation bool optional ` ` False ` ` torchhub will check branch commit specified ` ` github ` ` argument properly belongs repo owner This will make requests GitHub API you can specify non-default GitHub token setting ` ` GITHUB_TOKEN ` ` environment variable Default ` ` False ` ` trust_repo bool str None ` ` check ` ` ` ` True ` ` ` ` False ` ` ` ` None ` ` This parameter introduced v helps ensuring users only run code repos they trust - If ` ` False ` ` prompt will ask user whether repo should trusted - If ` ` True ` ` repo will added trusted list loaded without requiring explicit confirmation - If ` ` check ` ` repo will checked against list trusted repos cache If present list behaviour will fall back onto ` ` trust_repo=False ` ` option - If ` ` None ` ` will raise warning inviting user set ` ` trust_repo ` ` either ` ` False ` ` ` ` True ` ` ` ` check ` ` This only present backward compatibility will removed v Default ` ` None ` ` will eventually change ` ` check ` ` v verbose bool optional If ` ` False ` ` mute messages about hitting local caches Note message about first download cannot muted Default ` ` True ` ` Returns list The available callables entrypoint Example xdoctest +REQUIRES env TORCH_DOCTEST_HUB entrypoints = torch hub list pytorch vision force_reload=True repo_dir = _get_cache_or_reload github force_reload trust_repo list verbose=verbose skip_validation=skip_validation _add_to_sys_path repo_dir hubconf_path = os path join repo_dir MODULE_HUBCONF hub_module = _import_module MODULE_HUBCONF hubconf_path We take functions starts _ internal helper functions entrypoints = f f dir hub_module callable getattr hub_module f f startswith _ entrypoints help github model force_reload=False skip_validation=False trust_repo=None r Show docstring entrypoint ` ` model ` ` Args github str string format repo_owner repo_name ref optional ref tag branch If ` ` ref ` ` specified default branch assumed ` ` main ` ` exists otherwise ` ` master ` ` Example pytorch vision model str string entrypoint name defined repo s ` ` hubconf py ` ` force_reload bool optional whether discard existing cache force fresh download Default ` ` False ` ` skip_validation bool optional ` ` False ` ` torchhub will check ref specified ` ` github ` ` argument properly belongs repo owner This will make requests GitHub API you can specify non-default GitHub token setting ` ` GITHUB_TOKEN ` ` environment variable Default ` ` False ` ` trust_repo bool str None ` ` check ` ` ` ` True ` ` ` ` False ` ` ` ` None ` ` This parameter introduced v helps ensuring users only run code repos they trust - If ` ` False ` ` prompt will ask user whether repo should trusted - If ` ` True ` ` repo will added trusted list loaded without requiring explicit confirmation - If ` ` check ` ` repo will checked against list trusted repos cache If present list behaviour will fall back onto ` ` trust_repo=False ` ` option - If ` ` None ` ` will raise warning inviting user set ` ` trust_repo ` ` either ` ` False ` ` ` ` True ` ` ` ` check ` ` This only present backward compatibility will removed v Default ` ` None ` ` will eventually change ` ` check ` ` v Example xdoctest +REQUIRES env TORCH_DOCTEST_HUB print torch hub help pytorch vision resnet force_reload=True repo_dir = _get_cache_or_reload github force_reload trust_repo help verbose=True skip_validation=skip_validation _add_to_sys_path repo_dir hubconf_path = os path join repo_dir MODULE_HUBCONF hub_module = _import_module MODULE_HUBCONF hubconf_path entry = _load_entry_from_hubconf hub_module model entry __doc__ load repo_or_dir model args source= github trust_repo=None force_reload=False verbose=True skip_validation=False kwargs r Load model github repo local directory Note Loading model typical use case can also used loading other objects such tokenizers loss functions etc If ` ` source ` ` github ` ` repo_or_dir ` ` expected form ` ` repo_owner repo_name ref ` ` optional ref tag branch If ` ` source ` ` local ` ` repo_or_dir ` ` expected path local directory Args repo_or_dir str If ` ` source ` ` github should correspond github repo format ` ` repo_owner repo_name ref ` ` optional ref tag branch example pytorch vision If ` ` ref ` ` specified default branch assumed ` ` main ` ` exists otherwise ` ` master ` ` If ` ` source ` ` local then should path local directory model str name callable entrypoint defined repo dir s ` ` hubconf py ` ` args optional corresponding args callable ` ` model ` ` source str optional github local Specifies how ` ` repo_or_dir ` ` interpreted Default github trust_repo bool str None ` ` check ` ` ` ` True ` ` ` ` False ` ` ` ` None ` ` This parameter introduced v helps ensuring users only run code repos they trust - If ` ` False ` ` prompt will ask user whether repo should trusted - If ` ` True ` ` repo will added trusted list loaded without requiring explicit confirmation - If ` ` check ` ` repo will checked against list trusted repos cache If present list behaviour will fall back onto ` ` trust_repo=False ` ` option - If ` ` None ` ` will raise warning inviting user set ` ` trust_repo ` ` either ` ` False ` ` ` ` True ` ` ` ` check ` ` This only present backward compatibility will removed v Default ` ` None ` ` will eventually change ` ` check ` ` v force_reload bool optional whether force fresh download github repo unconditionally Does have any effect ` ` source = local ` ` Default ` ` False ` ` verbose bool optional If ` ` False ` ` mute messages about hitting local caches Note message about first download cannot muted Does have any effect ` ` source = local ` ` Default ` ` True ` ` skip_validation bool optional ` ` False ` ` torchhub will check branch commit specified ` ` github ` ` argument properly belongs repo owner This will make requests GitHub API you can specify non-default GitHub token setting ` ` GITHUB_TOKEN ` ` environment variable Default ` ` False ` ` kwargs optional corresponding kwargs callable ` ` model ` ` Returns The output ` ` model ` ` callable when called given ` ` args ` ` ` ` kwargs ` ` Example xdoctest +REQUIRES env TORCH_DOCTEST_HUB github repo repo = pytorch vision model = torch hub load repo resnet weights= ResNet _Weights IMAGENET K_V local directory path = some local path pytorch vision xdoctest +SKIP model = torch hub load path resnet weights= ResNet _Weights DEFAULT source = source lower source github local raise ValueError f Unknown source source Allowed values github &#124; local source == github repo_or_dir = _get_cache_or_reload repo_or_dir force_reload trust_repo load verbose=verbose skip_validation=skip_validation model = _load_local repo_or_dir model args kwargs model _load_local hubconf_dir model args kwargs r Load model local directory ` ` hubconf py ` ` Args hubconf_dir str path local directory contains ` ` hubconf py ` ` model str name entrypoint defined directory s ` ` hubconf py ` ` args optional corresponding args callable ` ` model ` ` kwargs optional corresponding kwargs callable ` ` model ` ` Returns single model corresponding pretrained weights Example xdoctest +SKIP stub local path path = some local path pytorch vision model = _load_local path resnet weights= ResNet _Weights IMAGENET K_V _add_to_sys_path hubconf_dir hubconf_path = os path join hubconf_dir MODULE_HUBCONF hub_module = _import_module MODULE_HUBCONF hubconf_path entry = _load_entry_from_hubconf hub_module model model = entry args kwargs model download_url_to_file url str dst str hash_prefix Optional str = None progress bool = True - None r Download object given URL local path Args url str URL object download dst str Full path where object will saved e g ` ` tmp temporary_file ` ` hash_prefix str optional If None SHA downloaded file should start ` ` hash_prefix ` ` Default None progress bool optional whether display progress bar stderr Default True Example xdoctest +REQUIRES env TORCH_DOCTEST_HUB xdoctest +REQUIRES POSIX torch hub download_url_to_file https s amazonaws com pytorch models resnet - c cde pth tmp temporary_file file_size = None req = Request url headers= User-Agent torch hub u = urlopen req meta = u info hasattr meta getheaders content_length = meta getheaders Content-Length content_length = meta get_all Content-Length content_length None len content_length file_size = int content_length We deliberately save temp file move after download complete This prevents local working checkpoint being overridden broken download We deliberately do use NamedTemporaryFile avoid restrictive file permissions being applied downloaded file dst = os path expanduser dst _ range tempfile TMP_MAX tmp_dst = dst + + uuid uuid hex + partial try f = open tmp_dst w+b except FileExistsError continue break raise FileExistsError errno EEXIST No usable temporary file name found try hash_prefix None sha = hashlib sha tqdm total=file_size disable=not progress unit= B unit_scale=True unit_divisor= pbar while True buffer = u read READ_DATA_CHUNK len buffer == break f write buffer type ignore possibly-undefined hash_prefix None sha update buffer type ignore possibly-undefined pbar update len buffer f close hash_prefix None digest = sha hexdigest type ignore possibly-undefined digest len hash_prefix = hash_prefix raise RuntimeError f invalid hash value expected hash_prefix got digest shutil move f name dst finally f close os path exists f name os remove f name Hub used support automatically extracts zipfile manually compressed users The legacy zip format expects only one file torch save zip We should remove support since zipfile now default zipfile format torch save _is_legacy_zip_format filename str - bool zipfile is_zipfile filename infolist = zipfile ZipFile filename infolist len infolist == infolist is_dir False deprecated Falling back old format This support will deprecated favor default zipfile format introduced Please redo torch save save new zipfile format category=FutureWarning _legacy_zip_load filename str model_dir str map_location MAP_LOCATION weights_only bool - dict str Any Note extractall defaults overwrite file exists No need clean up beforehand We deliberately don t handle tarfile here since our legacy serialization format tar E g resnet - c cde pth which widely used zipfile ZipFile filename f members = f infolist len members = raise RuntimeError Only one file dir allowed zipfile f extractall model_dir extraced_name = members filename extracted_file = os path join model_dir extraced_name torch load extracted_file map_location=map_location weights_only=weights_only load_state_dict_from_url url str model_dir Optional str = None map_location MAP_LOCATION = None progress bool = True check_hash bool = False file_name Optional str = None weights_only bool = False - dict str Any r Loads Torch serialized object given URL If downloaded file zip file will automatically decompressed If object already present ` model_dir ` s deserialized returned The default value ` ` model_dir ` ` ` ` hub_dir checkpoints ` ` where ` ` hub_dir ` ` directory returned func ` ~torch hub get_dir ` Args url str URL object download model_dir str optional directory which save object map_location optional function dict specifying how remap storage locations see torch load progress bool optional whether display progress bar stderr Default True check_hash bool optional If True filename part URL should follow naming convention ` ` filename- sha ext ` ` where ` ` sha ` ` first eight more digits SHA hash contents file The hash used ensure unique names verify contents file Default False file_name str optional name downloaded file Filename ` ` url ` ` will used set weights_only bool optional If True only weights will loaded no complex pickled objects Recommended untrusted sources See func ` ~torch load ` more details Example xdoctest +REQUIRES env TORCH_DOCTEST_HUB state_dict = torch hub load_state_dict_from_url https s amazonaws com pytorch models resnet - c cde pth Issue warning move data old env set os getenv TORCH_MODEL_ZOO warnings warn TORCH_MODEL_ZOO deprecated please use env TORCH_HOME instead stacklevel= model_dir None hub_dir = get_dir model_dir = os path join hub_dir checkpoints os makedirs model_dir exist_ok=True parts = urlparse url filename = os path basename parts path file_name None filename = file_name cached_file = os path join model_dir filename os path exists cached_file sys stdout write f Downloading url cached_file \n hash_prefix = None check_hash r = HASH_REGEX search filename r Optional Match str hash_prefix = r group r None download_url_to_file url cached_file hash_prefix progress=progress _is_legacy_zip_format cached_file _legacy_zip_load cached_file model_dir map_location weights_only torch load cached_file map_location=map_location weights_only=weights_only