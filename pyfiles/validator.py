mypy allow-untyped-defs builtins functools logging math operator collections abc Callable dataclasses dataclass typing Any Optional Union sympy torch torch fx torch fx traceback fx_traceback torch _dynamo exc TorchDynamoException torch _dynamo utils dynamo_timed torch fx node Argument Target torch utils _sympy interp sympy_interp log = logging getLogger __name__ try z type ignore Translation Validation Dynamo guards ======================================== Checks whether optimizations applied collected guards valid In other words whether guard function we actually run does have false positives unsound In order do so we build guards using different information attached each SymNode SymPy expressions FX nodes SymPy expressions have implicit optimizations baked within itself which may have few bugs On other hand we build FX graph manually no optimizations enabled This gives us access ground truth We then convert into Z expressions both SymPy expressions see Note SympyToZ reach ShapeEnv produce_guards function FX nodes see Note PopulateValidator go through ShapeEnv evaluate_expr function Finally we run validation see Note TranslationValidator Better Z string implementation small fraction Z Here things we clean before showing Z expression - Rename few ops e g Distinct == = - Ignore ToInt ToReal operations usually they don t really matter - Transform ToInt into idiv pattern floor division - Collect chain same operations into one z str e z ExprRef - str assert z is_expr e f unsupported expression type e get_args_str e z ExprRef - list str z str e arg i i range e num_args First we simplify given expression This done using rewriting rules so shouldn t take long e = z simplify e Only support function applications Even Z variables fact function applications z is_app e raise ValueError f can t print Z expression e z is_int_value e z is_rational_value e e as_string type ignore attr-defined decl = e decl kind = decl kind op = str decl args = get_args_str e kind == z Z _OP_POWER op = pow kind z Z _OP_ADD z Z _OP_MUL Collect arguments chains ADD MUL This safe since they associative collect_str_args e z is_app e e decl kind == kind z str e x i range e num_args x collect_str_args e arg i args = collect_str_args e kind == z Z _OP_NOT Revert some conversions z simplify applies - = b == Not == b == = b - b == Not = b == b - b == Not = b == b assert e num_args == arg = e arg assert z is_app arg argkind = arg decl kind logic_inverse = z Z _OP_EQ = z Z _OP_LE z Z _OP_GE argkind logic_inverse op = logic_inverse argkind args = get_args_str arg kind z Z _OP_TO_INT z Z _OP_TO_REAL assert e num_args == argstr = z str e arg Check s floor division pattern argstr startswith idiv + argstr Otherwise just ignore argstr kind == z Z _OP_UNINTERPRETED assert e num_args == str decl string = op + + join args f string rstrip We need convert BitVec order use z bitwise ops We assume integers bit If all args boolean then use boolean bitwise op implementation instead provided _bitwise_op bitwise_func bool_func functools wraps bitwise_func wrapper args bool_func None all isinstance arg z BoolRef arg args bool_func args wrapped_args = tuple z Int BV args z BV Int bitwise_func wrapped_args wrapper Implementation Python semantics Z expressions Z Real-Int theory has operators semantics differ Python Therefore order get right we need implement Python semantics we relying Z dataclass _Z Ops Validator used adding assertions needed e g div b requires b = validator TranslationValidator The functions below used conditionally casting between integer reals Returns real expression x staticmethod to_real x z ArithRef - z ArithRef x x is_real z ToReal x Returns integer expression x staticmethod to_int x z ArithRef - z ArithRef x x is_int z ToInt x sym_sum args z ArithRef - z ArithRef sum args Implements Python division semantics div numerator z ArithRef denominator z ArithRef - z ArithRef validator add_assertion denominator = type ignore arg-type _Z Ops to_real numerator _Z Ops to_real denominator floor number z ArithRef - z ArithRef Z ToInt function rounds real number towards negative infinity _Z Ops to_int number Python semantics FloorDiv states before applying floor function operands converted their common type floordiv numerator z ArithRef denominator z ArithRef - z ArithRef cast_result_to_real = numerator is_real denominator is_real result = _Z Ops to_int div numerator denominator Since result already integer we just have check whether we should cast real _Z Ops to_real result cast_result_to_real result ceil number z ArithRef - z ArithRef z If floor number number floor number + number type ignore return-value trunc number z ArithRef - z ArithRef z If number = floor number ceil number type ignore return-value max z ArithRef b z ArithRef - z ArithRef z If b b type ignore return-value min z ArithRef b z ArithRef - z ArithRef z If b b type ignore return-value Python semantics Mod defined p q = p - floordiv p q q It should work both integer reals mod p z ArithRef q z ArithRef - z ArithRef p - floordiv p q q pow base z ArithRef exp z ArithRef - z ArithRef Z can t handle complex numbers very well validator add_assertion z Or base = exp type ignore arg-type base exp sqrt number z ArithRef - z ArithRef Square-root Only work reals number = _Z Ops to_real number The number should positive zero Otherwise Z returns unknown validator add_assertion number = number abs number z ArithRef - z ArithRef z Abs number round_to_int number z ArithRef - z ArithRef Pythons builtin round implements round half even strategy See https en wikipedia org wiki Rounding#Rounding_half_to_even z has equivalent z fpRoundToIntegral z RoundNearestTiesToEven only applies floating point numbers which different real numbers we dealing here Instead we implement round half even terms round half up floor x + round half down ceil x - Assuming round half up default case we need correct - - round down i e use round half down strategy z If mod number z IntVal == ceil number - floor number + bitwise_and = _bitwise_op operator and_ z And bitwise_or = _bitwise_op operator or_ z Or lshift = _bitwise_op operator lshift None rshift = _bitwise_op operator rshift None Lifts callable used Z This function replaces given op function Lifts arguments into Z i e make them inhabitants Z Calls operation corresponds op works Z inhabitants left works z op op Callable validator TranslationValidator - Callable Operations have booleans their argument This needed because argument some FX nodes literal integers instead booleans So whenever flag set we also convert ints booleans boolean_ops = operator not_ as_bool = op boolean_ops Lifts function into z ExprRef domain lift func wrap - z ExprRef isinstance z ArithRef z BoolRef Convert into Z value some supported types below isinstance bool as_bool isinstance int z BoolVal bool isinstance int sympy Integer z IntVal int isinstance float sympy Float z RealVal float raise ValueError f can t lift type type functools wraps func wrapper args Lifts arguments into list Z inhabitants len args == isinstance args list tuple wrapped_args = tuple wrap args wrapped_args = tuple wrap args Run function Z expressions func wrapped_args wrapper ops = _Z Ops validator replacement_map = Operator module operator not_ lift z Not operator and_ lift ops bitwise_and operator or_ lift ops bitwise_or operator lshift lift ops lshift operator rshift lift ops rshift operator floordiv lift ops floordiv operator truediv lift ops div operator mod lift ops mod operator abs lift ops abs builtins round lift ops round_to_int Math module math ceil lift ops ceil math floor lift ops floor math trunc lift ops trunc Torch module torch sym_float lift ops to_real torch sym_max lift ops max torch sym_min lift ops min torch sym_sum lift ops sym_sum torch sym_ite lift lambda b t f t b f torch _sym_sqrt lift ops sqrt type ignore attr-defined Not lifted because we only use function marker adding expression validator input torch _assert torch _assert replacement_map op op replacement_map lift op Processes FX graph populating given validator Note PopulateValidator This walks through each node FX graph translating them into Z world Then whenever finds torch _assert call_function operation adds Z expression corresponding argument validator input PopulateValidator torch fx Interpreter __init__ graph torch fx Graph validator TranslationValidator Reference translation validator validator = validator Build graph module call ` Interpreter ` constructor module = torch fx GraphModule root= graph=graph super __init__ module garbage_collect_values=True placeholder target Target args tuple Argument kwargs dict str Any - Any symbol = fx_traceback get_current_meta symbol validator z var symbol call_function target Target args tuple Argument kwargs dict str Any - Any target torch _assert Lift runs node target function super call_function z op target validator args kwargs type ignore arg-type Adds Z expression corresponding first argument validator input assert len args == f expected argument assertion Got len args validator add_source_expr args type ignore arg-type Translates SymPy expressions into Z expressions Note SympyToZ At time translation all free variables present SymPy expression being translated must already mapped Z integer variable SympyToZ OPERATOR_HANDLES = add mul eq ne lt gt le ge __init__ validator TranslationValidator - None _validator = validator _ops = _Z Ops _validator constant value Any dtype torch dtype - z ExprRef TODO Probably OK relax allow lower precision dtype torch int z IntVal int value dtype torch double z RealVal float value dtype torch bool z BoolVal bool value raise ValueError f unsupported dtype SympyToZ dtype to_dtype x z ArithRef dtype torch dtype - z ArithRef dtype == torch float z ToReal x raise NotImplementedError f to_dtype dtype NYI trunc_to_int x z ArithRef dtype torch dtype - z ArithRef z ToInt x round_to_int x z ArithRef dtype torch dtype - z ArithRef _ops round_to_int x int_truediv numerator z ArithRef denominator z ArithRef - z ArithRef _ops div numerator denominator truediv numerator z ArithRef denominator z ArithRef - z ArithRef _ops div numerator denominator floordiv numerator z ArithRef denominator z ArithRef - z ArithRef _ops floordiv numerator denominator div numerator z ArithRef denominator z ArithRef - z ArithRef _ops floordiv numerator denominator pow base z ArithRef exp z ArithRef - z ArithRef _ops pow base exp pow_by_natural base z ArithRef exp z ArithRef - z ArithRef _ops pow base exp mod p z ArithRef q z ArithRef - z ArithRef _ops mod p q ceil_to_int x z ArithRef dtype torch dtype - z ArithRef _ops ceil x floor_to_int x z ArithRef dtype torch dtype - z ArithRef _ops floor x __getattr__ name str - Any REPLACEMENT = and_ z And or_ z Or not_ z Not bitwise_and _ops bitwise_and bitwise_or _ops bitwise_or lshift _ops lshift rshift _ops rshift floor _ops floor ceil _ops ceil minimum _ops min maximum _ops max name REPLACEMENT REPLACEMENT name name OPERATOR_HANDLES getattr operator name raise AttributeError f unhandled operator name run expr sympy Basic - z ExprRef sympy_interp _validator symbols expr type ignore arg-type Dynamo guards translation validator Note TranslationValidator Verifies whether guards issued ShapeEnv produce_guards sound That whether those target guards only yield TRUE whenever original unoptimized source guards yield TRUE More concretely given source target guard expressions we wish check whether following expression holds Not And source AND And target i e whether there assignment free variables where opposite happens target TRUE source FALSE TranslationValidator __init__ - None log debug new instance Mapping SymPy symbols Z variables symbols dict sympy Symbol z ExprRef = Set source Z expressions They represent generated guards without any kind simplification transformation _source_exprs set z BoolRef = set Set target Z expressions They represent actual checked guards runtime They might simplified transformed versions source guards _target_exprs set z BoolRef = set Set Z expressions representing assertions over both source target expressions _assertions set z BoolRef = set Retrieves corresponding Z variable z var symbol sympy Symbol - z ExprRef assert symbol symbols f Z variable found symbol symbols symbol Create variable Z type symbol doesn t already exists add_var symbol sympy Symbol type type - z ExprRef symbol symbols symbols symbol log debug new variable s s symbol name type __name__ type int var = z Int symbol name If symbol positive SymPy assumption we have convey Z well symbol is_positive type ignore attr-defined _target_exprs add var type float var = z Real symbol name type bool var = z Bool symbol name raise RuntimeError f unsupported type Z variable type symbols symbol = var var Checks whether all symbols already added _check_freesymbols e sympy Basic - None s e free_symbols assert isinstance s sympy Symbol Call z var just check whether there s already Z variable corresponding s z var s to_z _boolean_expr e sympy Basic - z BoolRef z expr = SympyToZ run e assert isinstance z expr z BoolRef f expected boolean expression Got z expr z expr add_source_expr e z BoolRef - None e _source_exprs log debug add source guard s z str e _source_exprs add e add_target_expr e sympy logic boolalg Boolean - None _check_freesymbols e z expr = to_z _boolean_expr e e _target_exprs log debug add target guard s z str z expr _target_exprs add z expr add_assertion e Union z BoolRef sympy Basic - None isinstance e sympy Basic _check_freesymbols e ref = to_z _boolean_expr e ref = e assert isinstance ref z BoolRef ref _assertions log debug add assertion s z str ref _assertions add ref validate - None dynamo_timed TranslationValidator validate _validate _validate - None len _source_exprs == len _target_exprs == If there no source target expressions there s nothing we really wish prove So we just None Here we use QF_NRA logic solver Quantifier-free Non-linear Real Arithmetic Most guards expressions have arithmetic between integer reals no quantifiers potentially non-linear Although there s also QF_NIRA mixed integer-real arithmetic QF_NRA seems work better dynamo test_dynamic_shapes py solver = z SolverFor QF_NRA Set timeout finding solution solver set timeout=translation_validation_timeout Add all assertions solver assertion _assertions solver add assertion Is there any case where s TRUE target expressions FALSE source expressions solver add z Not z And _source_exprs solver add _target_exprs log debug translation validation start r = solver check r == z sat Target expressions unsound Log found model source expressions failed model = solver model raise ValidationException model _assertions _target_exprs failed_source_exprs= inp inp _source_exprs model evaluate inp r == z unknown Could find solution It didn t fail also didn t succeed Canceling validation execution keyboard interrupt also gets branch log warning translation validation could validate got z unknown Target expressions sound assert r == z unsat log debug translation validation success except ImportError _HAS_Z = False __all__ = translation_validation_enabled translation_validation_timeout ValidationException BisectValidationException _HAS_Z = True __all__ = z str z op PopulateValidator SympyToZ TranslationValidator translation_validation_enabled translation_validation_timeout ValidationException BisectValidationException torch fx experimental _config config translation_validation_enabled - bool Checks every time function called case Dynamo option set Z installed _assert_z _installed_if_tv_set _HAS_Z config translation_validation translation_validation_timeout - int config translation_validation_timeout _assert_z _installed_if_tv_set assert _HAS_Z config translation_validation translation validation requires Z package Please either install z -solver disable translation validation ValidationException TorchDynamoException __init__ model assertions target_exprs failed_source_exprs assert _HAS_Z symbolstr sym - str f sym model sym joinlines xs - str \n join f == x x xs model_str = joinlines sorted map symbolstr model assertions_str = joinlines sorted map z str assertions target_exprs_str = joinlines sorted map z str target_exprs failed_source_exprs_str = joinlines sorted map z str failed_source_exprs msg = translation validation failed details = f \ Model model_str Assertions assertions_str Target Expressions target_exprs_str Failed Source Expressions failed_source_exprs_str __str__ f msg \n\n details BisectValidationException TorchDynamoException __init__ validation_exc expr failed_action traced_node msg = f translation validation failed when failed_action expr details = f \ Failure occurred while running node traced_node format_node validation_exc details __str__ f msg \n\n details Checks when module loaded _assert_z _installed_if_tv_set Translation validation bisection Bisect into torch _assert nodes recorded shape_env FX graph raise earliest ValidationException As guards added ShapeEnv evaluate_expr calls some simplification errors might silently happening This function tries nail down exactly which point things went wrong validation perspective bisect shape_env torch fx experimental recording FakeTensorMeta replay_shape_env_events ShapeEnvEvent torch fx experimental symbolic_shapes CURRENT_NODE_KEY ShapeEnv SHAPEENV_EVENT_KEY events = shape_env events Retrieves ShapeEnvEvent associated node get_node_event node torch fx Node - ShapeEnvEvent assert SHAPEENV_EVENT_KEY node meta events node meta SHAPEENV_EVENT_KEY Creates new instance fake updating every symbolic value s ShapeEnv reference one given argument This needed so simplify symbolic expression using ShapeEnv future where may have different set replacements new_with_shape_env shape_env ShapeEnv fake - Any isinstance fake int fake isinstance fake torch SymInt torch SymInt fake node with_shape_env shape_env isinstance fake torch SymFloat torch SymFloat fake node with_shape_env shape_env assert isinstance fake FakeTensorMeta FakeTensorMeta tuple new_with_shape_env shape_env s s fake size tuple new_with_shape_env shape_env s s fake stride new_with_shape_env shape_env fake storage_offset fake is_nested Checks whether given shape_env fails when produce_guards called check_shapeenv_fails shape_env ShapeEnv tracked_fakes Optional list Any - Optional ValidationException assert tracked_fakes None try This produce_guards call best-effort replication since we don t populate EqualityConstraint list Reason we would also have save OutputGraph tracked_fakes_id_to_source shape_env produce_guards new_with_shape_env shape_env fake tracked_fakes source tracked_fakes input_contexts= symbolic_context tracked_fakes None except ValidationException e e Checks whether ShapeEnv reconstructed replaying events until node created fails when produce_guards called check_node_fails node torch fx Node - Optional ValidationException number = node meta SHAPEENV_EVENT_KEY Reconstruct shape_env until event event_number shape_env = replay_shape_env_events events number + shape_env graph lint check_shapeenv_fails shape_env events number tracked_fakes last_exception = check_shapeenv_fails shape_env shape_env _snapshot_tracked_fakes last_exception We don t actually fail due produce_guards call Stop don t bisect log info translation validation succeeded no errors found shape_env should_record_events config translation_validation_no_bisect Bisection off Return last ValidationException we got raise last_exception Cache raised exception any each bisection point exception = Bisection happens assertion nodes recorded FX graph dynamic shapes assert_nodes = node node shape_env graph nodes node target torch _assert Preparing indices binary search The overall invariants - all i left assert_node i doesn t fail - all i = right assert_node i fails - ` right exception ` always holds - ` left = right ` always holds left mid right = len assert_nodes - exception right = check_node_fails assert_nodes right while left right mid = left + right node = assert_nodes mid log debug bisecting s s mid get_node_event node Check whether new shape_env raises ValidationException exception mid = check_node_fails node exception mid right = mid left = mid + assert left exception isinstance exception left ValidationException node = assert_nodes left event = get_node_event node event is_evaluate_expr failed_action = evaluating assert event is_defer_runtime_assert f unexpected event type event failed_action = adding runtime assert args = event args assert args None assert len args = f bisecting expects event name have least positional arguments f Got len args assert isinstance args sympy Basic f bisecting expects event name have SymPy expression its second argument f Got type args raise BisectValidationException exception left expr=args failed_action=failed_action traced_node=node meta CURRENT_NODE_KEY