mypy allow-untyped-defs functools collections abc Hashable dataclasses dataclass fields typing TypeVar typing_extensions dataclass_transform T = TypeVar T bound= _Union _UnionTag str __slots__ = _cls _cls Hashable staticmethod create t cls tag = _UnionTag t assert hasattr tag _cls tag _cls = cls tag __eq__ cmp - bool assert isinstance cmp str other = str cmp assert other _get_field_names _cls f other valid tag _cls Available tags _get_field_names _cls str == other __hash__ hash str functools cache _get_field_names cls - set str f name f fields cls If you turn schema inherits union into dataclass please use decorator configure It s safe faster allows code sharing For example _union_dataclass customizes __eq__ method only check type value property instead default implementation dataclass which goes through every field dataclass dataclass_transform eq_default=False _union_dataclass cls type T - type T assert issubclass cls _Union f cls must inheirt _Union dataclass repr=False eq=False cls _Union _type _UnionTag classmethod create cls kwargs assert len kwargs == obj = cls f name None f fields cls kwargs type ignore arg-type obj _type = _UnionTag create next iter kwargs keys cls obj __post_init__ assert any f name type _type create value f fields type ignore arg-type misc property type - str try _type except AttributeError e raise RuntimeError f Please use type __name__ create instantiate union type e property value getattr type __getattribute__ name attr = super __getattribute__ name attr None name _get_field_names type name = type type ignore arg-type raise AttributeError f Field name set attr __eq__ other object - bool isinstance other _Union False type == other type value == other value __str__ __repr__ __repr__ f type __name__ type = getattr type