mypy allow-untyped-defs operator collections deque typing NamedTuple torch torch fx experimental partitioner_utils Device get_extra_size_of get_latency_of_partitioned_graph get_partition_to_latency_mapping NodeLatency Partition PartitionerConfig PartitionMode torch fx graph_module GraphModule torch fx node map_arg Node torch fx passes graph_manipulation get_size_of_all_nodes torch fx passes split_module split_module DAGNode DAGNode maintains useful information partition submodule its input submodules output submodules __init__ submodule_node Node input_nodes list Node output_nodes list Node logical_device_ids list int size_bytes int - None submodule_node Node = submodule_node input_nodes list Node = input_nodes output_nodes list Node = output_nodes logical_device_ids list int = logical_device_ids size_bytes = size_bytes __str__ - str str submodule_node DAG DAG contains all DAG nodes __init__ - None nodes list DAGNode = create_node submodule_node Node input_nodes list Node output_nodes list Node logical_devices list int size_bytes int - None node = DAGNode submodule_node input_nodes output_nodes logical_devices size_bytes nodes append node PartitionResult NamedTuple NameTuple used returning DAG new fx module dag DAG module_with_submodules GraphModule Followings some helper functions partition manipulation reset_partition_device partitions partition partitions partition logical_device_ids = combine_two_partitions partition_ Partition partition_ Partition partitions list Partition - None Given list partitions its two partitions combine these two partitions into new one appending partitions remove previous two partitions list partitions partition = Partition len partitions partition nodes = partition_ nodes union partition_ nodes partition recalculate_mem_size partitions append partition partitions remove partition_ partitions remove partition_ reorganize_partitions partitions set_parents_and_children partitions list Partition - None Given list partitions mark parents children each partition Go through all nodes partition If node s user other partition then other partition partition s children This partition other partition s parent partition partitions partition children = set partition parents = set partition partitions node partition nodes For each node current partition find its users users = node users n users Find which partition user node belongs Note node itself also belongs partition partition child current partition p partitions p = partition n p nodes node p nodes partition children add p p parents add partition reorganize_partitions partitions list Partition - None Given list partitions reorganize partition id its parents its children each partition Rearrange partition ids i partition enumerate partitions partition partition_id = i set_parents_and_children partitions get_bfs_level_partition partitions list Partition - None Given list partitions mark bfs level each partition current_level set Partition = set visited set Partition = set partition partitions If partition has no parent should root level len partition parents == current_level add partition next_level set Partition = set level = bfs while current_level partition = current_level pop partition bfs_level = level visited add partition children = partition children child children child next_level next_level add child current_level current_level = next_level copy next_level = set level += get_node_to_partition_mapping partitions list Partition - dict Node int Given list partitions node partition mapping node_to_partition dict Node int = partition partitions node partition nodes node_to_partition node = partition partition_id node_to_partition get_logical_id_to_device devices list Device - dict int Device Get mapping device logical ID Device object logical_id_to_device dict int Device = d devices logical_id_to_device d logical_id = d logical_id_to_device get_device_partition_stats partitions list Partition devices list Device - tuple dict Device list Partition dict Device int list Partition Given list partitions list devices returns A mapping device partitions A mapping device its remaining memory size A list partitions do have device logical id device logical_id_to_device = get_logical_id_to_device devices Track partitions device device_to_partitions dict Device list Partition = Track device s left mem size device_to_left_mem_bytes dict Device int = d devices device_to_partitions d = device_to_left_mem_bytes d = d available_mem_bytes Deal partitions already have device also collect all partitions without device no_device_partitions no_device_partitions = partition partitions partition logical_device_ids = logical_id partition logical_device_ids device = logical_id_to_device logical_id device_to_partitions device append partition device_to_left_mem_bytes device -= partition used_mem_bytes no_device_partitions append partition device_to_partitions device_to_left_mem_bytes no_device_partitions get_device_to_partitions_mapping partitions list Partition devices list Device Given list partitions list devices map each partition into device calculate_extra_mem_bytes_needed_for partition Partition partitions list Partition all_nodes set Node = set p partitions all_nodes = all_nodes union p nodes len all_nodes == partition used_mem_bytes all_nodes = all_nodes union partition nodes extra_size_needed = node partition nodes extra_size_needed += get_extra_size_of node all_nodes extra_size_needed find_device_for partition Partition Given partition find logical device partition The algorithm put partition device has just enough mem left partition device_to_left_mem_bytes dictionary between device its left mem size sorted its left mem size d device_to_left_mem_bytes extra_size_needed = calculate_extra_mem_bytes_needed_for partition device_to_partitions d extra_size_needed device_to_left_mem_bytes d device_to_partitions d append partition partition logical_device_ids append d logical_id device_to_left_mem_bytes d -= extra_size_needed True False device_to_partitions device_to_left_mem_bytes no_device_partitions = get_device_partition_stats partitions devices Find devices all partitions without device found_device = True partition no_device_partitions device_to_left_mem_bytes = dict sorted device_to_left_mem_bytes items key=operator itemgetter found_device = find_device_for partition found_device break found_device check_dependency partition Given partition check there circular dependency partition using bfs visited set Partition = partition queue deque Partition = deque partition while queue p = queue popleft child p children child == partition True child visited visited add child queue append child False Partitioner A fx module may fit into one device Partitioner helps partition one fx module into submodules partitions so submodules can executed crossing different accelerators The main function partition_graph It partitions fx module based scheme specified partition_config A DAG structure returned along new fx module submodule nodes __init__ - None partitions list Partition = node_to_partition dict Node int = devices list Device = partition_graph fx_module GraphModule torch_module torch nn Module partitioner_config PartitionerConfig - PartitionResult Given fx module torch module partitioner_config find partitions do partitions then DAG new fx module submodule nodes partitions graph_module = fx_module torch_module = torch_module devices = partitioner_config devices len devices == raise RuntimeError No devices Tag size bytes all nodes graph_module get_size_of_all_nodes graph_module Check there op nodes fx module nodes = graph_module graph nodes all node op placeholder get_attr output node nodes raise RuntimeError No Partition since no operations module Calculate total size fx module total_size_of_graph = node nodes node op == output break total_size_of_graph += node size_bytes total_size Find device max mem size device_with_max_mem = max devices key=lambda d d available_mem_bytes AOT based partition partitioner_config mode == PartitionMode aot_based aot_based_partition partitioner_config node_to_partition_mapping partitioner_config partition_to_logical_device_mapping Single partition whole module can fit into one device total_size_of_graph = device_with_max_mem available_mem_bytes find_single_partition total_size_of_graph logical_device_id=device_with_max_mem logical_id total_size_of_graph sum d available_mem_bytes d devices raise RuntimeError Devices have no enough memory module Sparse nn based partition partitioner_config mode == PartitionMode sparse_nn available_mem_bytes = devices available_mem_bytes all device available_mem_bytes == available_mem_bytes device devices raise RuntimeError All devices must have same memory size sparse_nn_partition only support same memory size TODO add different size support sparse_nn_partition sparse_nn_partition available_mem_bytes Cost aware partition partitioner_config mode == PartitionMode cost_aware cost_aware_partition partitioner_config transfer_rate_bytes_per_sec partitioner_config node_to_latency_mapping KL based partition partitioner_config mode == PartitionMode kl_based kl_based_partition partitioner_config transfer_rate_bytes_per_sec partitioner_config node_to_latency_mapping size_based_partition Saturate host possible partitioner_config saturate_host saturate_host Partition graph module based partition assignment module_with_submodules = do_partition The DAG contains DAGNodes info each partition s input nodes output nodes how partitions connected dag = dump_dag module_with_submodules ret = PartitionResult dag module_with_submodules ret find_single_partition total_size_of_graph logical_device_id int = - None Fit whole fx module into one device partition_ = create_partition node graph_module graph nodes node op == output Skip output node there can nodes after output certain cases continue partition_ nodes add node partition_ used_mem_bytes = total_size_of_graph partition_ logical_device_ids = logical_device_id Get node partition mapping node_to_partition = get_node_to_partition_mapping partitions size_based_partition - None This method partition fx module based memory size It uses greedy approach The result may best The basic idea Step Find device which has enough memory fit current node create empty partition size device Then keep adding following nodes into partition until partition full Step Repeat Step until no device left Step If some nodes left create partition each left node single node partition then try map those partitions into logical devices enough mem left find_device_based_on_size node - Device Given node function find logical device could fit node mem_size_needed = get_extra_size_of node set device = Device - - d devices d occupied_devices d available_mem_bytes = mem_size_needed device = d break device available_mem_bytes raise RuntimeError str node + too large fit any device occupied_devices append device device Track partition its left mem size partition_to_left_mem_bytes dict Partition int = Track all devices have been used occupied_devices list Device = partition = create_partition node graph_module graph nodes node op call_module call_method call_function Check there devices left len partitions = len devices total_size_of_input_nodes = get_extra_size_of node partition nodes Check current partition very first partition partition used_mem_bytes == Find device fit first node available mem size device = find_device_based_on_size node occupied_devices append device Update partition its left mem size partition_to_left_mem_bytes partition = device available_mem_bytes Update available mem current partition partition logical_device_ids append device logical_id The current partition first partition Check current node can fit into current partition partition_to_left_mem_bytes partition total_size_of_input_nodes Check no device left len partitions == len devices No device left Create first single node partition current node create_single_node_partition node continue Some devices still left Create new partition mem size enough current node device = find_device_based_on_size node partition = create_partition total_size_of_input_nodes = get_extra_size_of node partition nodes partition_to_left_mem_bytes partition = device available_mem_bytes partition logical_device_ids append device logical_id partition add_node node partition_to_left_mem_bytes partition -= total_size_of_input_nodes Create single node partitions no device left create_single_node_partition node reorganize_partitions partitions Get node partition mapping node_to_partition = get_node_to_partition_mapping partitions Mapping all partitions into device found_partition_to_device_mapping = get_device_to_partitions_mapping partitions devices found_partition_to_device_mapping raise RuntimeError Cannot Get Valid Partition Logical Device Mapping saturate_host - None Saturate host assigning replicates unused devices enough memory It uses greedy approach find next available set devices place all split partitions For each used device searches idle device minimal memory size can hold all partition located device If search successful all used devices then assigns new devices logical ID corresponding partition device_to_partitions device_to_left_mem_bytes no_device_partitions = get_device_partition_stats partitions devices assert len no_device_partitions == f Expect no_device_partitions has device get len no_device_partitions Devices hold partitions used_devices = d d devices len device_to_partitions d Track replicates assigned devices replicated_device_to_used_device dict Device Device = while len used_devices + len replicated_device_to_used_device = len devices Success flag round success = True Devices have been assigned idle_devices = d d devices d used_devices d replicated_device_to_used_device Temporary mapping replicated device original device temp_replicate_mapping = Find new device replicate all partitions used device used_device used_devices Idle devices have enough memory available_devices = d d idle_devices d available_mem_bytes = used_device available_mem_bytes - device_to_left_mem_bytes used_device len available_devices == success = False break new_device = min available_devices key=lambda d d available_mem_bytes idle_devices remove new_device temp_replicate_mapping new_device = used_device success break replicated_device_to_used_device update temp_replicate_mapping Update logical device IDs assigned partitions replicate_device original_device replicated_device_to_used_device items logical_id = replicate_device logical_id partition device_to_partitions original_device partition logical_device_ids append logical_id p partitions print p logical_device_ids do_partition - GraphModule Return new fx module submodule nodes partitions module_with_submodules = split_module graph_module torch_module lambda node node_to_partition node module_with_submodules dump_dag module_with_submodules GraphModule - DAG Return dag structure new fx module submodules dag = DAG node module_with_submodules graph nodes node op == output break node op placeholder get_attr continue node target operator __getitem__ continue input_nodes dict Node None = map_arg node args input_nodes setdefault map_arg node kwargs input_nodes setdefault When node has two more output nodes outputs its result getitem nodes Those getitem nodes output node node Otherwise output node node itself len node users output_nodes = list node users output_nodes = node partition_id = int node name rsplit _ - device_ids = partitions partition_id logical_device_ids size_bytes = partitions partition_id used_mem_bytes dag create_node node list input_nodes output_nodes device_ids size_bytes dag create_partition - Partition Create partition append partitions partition_id = len partitions partition = Partition partition_id partitions append partition partition create_single_node_partition node Create partition single node partition = create_partition partition add_node node sparse_nn_partition available_mem_bytes int - None This method partition sparse nn module It size based partition different size_based_partition only works when all devices have same memory size available_mem_bytes In future devices different mem sizes will supported like size_based_partition It first traverse all nodes do partitions based same memory size If current partition has no enough memory left new op node call_module call_method call_function new partition created When crossing boundary between non-embedding nodes embedding nodes new partition created regardlessly For example current node non-embedding node next node embedding node new partition created next node After partition partitions combined much possible The rule non-embedding partition only combines another non-embedding one So embedding partitions combine_partitions_based_on_size partitions list Partition available_mem_bytes int - None Combining small partitions together keep less partitions possible Here example algorithm do Assume some partitions we first sort them based partition used memory size partition_ partition_ partition_ partition_ partition_ The available memory step find_partition_to_combine_based_on_size First mark bfs level each partition Second look smallest partition partition_ - = It means any partition has used memory equal less than could combine partition We go largest selection partition_ Check bfs level two partitions level difference less than can combined step repeat step until no partitions can combined find_combination = True while find_combination Sort partitions based memory size sorted_partitions = sorted partitions key=lambda p p used_mem_bytes Mark bfs level get_bfs_level_partition partitions find_combination partitions = find_partition_to_combine_based_on_size sorted_partitions available_mem_bytes pyrefly ignore bad-argument-type partitions calculate_mem_bytes_needed p p Given two partitions calculate how many mem bytes needed two partitions combined nodes = p nodes union p nodes mem_bytes_needed = node nodes mem_bytes_needed += get_extra_size_of node nodes mem_bytes_needed find_partition_to_combine_based_on_size sorted_partitions list Partition available_mem_bytes int partitions list Partition - tuple bool list Partition step combine_partition_based_on_size find_combination = False smallest_partition = sorted_partitions pop p sorted_partitions - abs smallest_partition bfs_level - p bfs_level = Calculate how many bytes needed combined mem_bytes_needed = calculate_mem_bytes_needed p smallest_partition mem_bytes_needed = available_mem_bytes combine_two_partitions p smallest_partition partitions partitions remove smallest_partition partitions remove p partitions append partitions - find_combination = True break find_combination partitions reset_partition_in_sparse_nn partition new_partition=True If crossing boundary between non-embedding nodes embedding nodes create new partition in_embedding_region embedding_partitions append partition non_embedding_partitions append partition new_partition partition = create_partition pyrefly ignore missing-attribute partition left_mem_bytes = available_mem_bytes partition None is_embedding_node node Node - bool Check node embedding node node op == call_module submodule = graph_module atom str node target split hasattr submodule atom raise RuntimeError f Module submodule has no attribute atom submodule = getattr submodule atom Embedding str submodule True False Track embedding partitions non-embedding partitions separately embedding_partitions list Partition = non_embedding_partitions list Partition = A Flag check boundary in_embedding_region bool = False partition = create_partition node graph_module graph nodes node op call_module call_method call_function Check crossing boundary between embedding nodes non embedding nodes is_embedding_node node = in_embedding_region Crossing boundary Check current partition empty partition partition used_mem_bytes = The current partition isn t empty partition Create new one partition = reset_partition_in_sparse_nn partition in_embedding_region = in_embedding_region total_size_of_input_nodes = get_extra_size_of node partition nodes total_size_of_input_nodes + partition used_mem_bytes available_mem_bytes partition = reset_partition_in_sparse_nn partition total_size_of_input_nodes = get_extra_size_of node partition nodes total_size_of_input_nodes available_mem_bytes raise RuntimeError node target + too large fit into device partition add_node node reset_partition_in_sparse_nn partition new_partition=False Set parents children partitions set_parents_and_children partitions Combining non-embedding partitions combine_partitions_based_on_size non_embedding_partitions available_mem_bytes Combining embedding partitions combine_partitions_based_on_size embedding_partitions available_mem_bytes total_size_of_non_embedding_partitions = partition non_embedding_partitions total_size_of_non_embedding_partitions += partition used_mem_bytes Check devices enough all partitions len embedding_partitions len devices msg = Need + str len embedding_partitions + devices only + str len devices + provided raise RuntimeError msg occupied_devices = i partition enumerate embedding_partitions Check all non-embedding partitions can fit into embedding partition devices total_size_of_non_embedding_partitions + partition used_mem_bytes available_mem_bytes raise RuntimeError partition_ + str partition partition_id + embedding partition non embedding partitions can fit into one device Add logical device partition partition logical_device_ids = devices i logical_id occupied_devices append devices i logical_id Add logical devices non_embedding_partitions partition non_embedding_partitions partition logical_device_ids = occupied_devices Get node partition mapping node_to_partition = get_node_to_partition_mapping partitions cost_aware_partition transfer_rate_bytes_per_sec float node_to_latency_mapping dict Node NodeLatency - None This method partition fx module based cost The cost total latency running whole fx module In partitioner_utils py cost model built The cost aware partition algorithm At every beginning each node partition Then we map all partitions devices calculate cost Then try pre-combine any two partitions two partitions can combined bfs level less than two partitions connected can find partition device mapping See any partition pair could reduce current cost Choose pair shows minimum cost then combine them Repeat until cost cannot reduced try_combining_partitions p _index p _index partitions - float Given two partitions list partitions combine these two partitions see what cost modified partition list p = partitions p _index p = partitions p _index If two partitions bfs level less than two partitions connected each other then they can combined abs p bfs_level - p bfs_level = p p parents p p children combine_two_partitions p p partitions Check circular dependency exists after combining check_dependency partitions - float inf Check modified partition list can mapped devices after combination reset_partition_device partitions found_deivce = get_device_to_partitions_mapping partitions devices found_deivce float inf Calculate new cost partition_to_latency_mapping = get_partition_to_latency_mapping partitions node_to_latency_mapping cost = get_latency_of_partitioned_graph partitions partition_to_latency_mapping transfer_rate_bytes_per_sec cost If two partition can combined cost inf float inf search_combination transfer_rate_bytes_per_sec node_to_latency_mapping - bool Given transfer rate between partitions each node s latency find two partitions combine so cost partitions can reduced The algorithm Go through all partition pairs see any pair partitions can combined Calculate cost after combination Select minimum cost combine its corresponding partition pair partition_to_latency_mapping = get_partition_to_latency_mapping partitions node_to_latency_mapping cost = get_latency_of_partitioned_graph partitions partition_to_latency_mapping transfer_rate_bytes_per_sec len partitions == False partition_pair list int = i range len partitions - j range i + len partitions Try combine partition pair see new cost after combination new_cost = try_combining_partitions i j partitions new_cost = cost partition_pair = i j cost = new_cost reorganize_partitions partitions If partition pair found combine them len partition_pair = p = partitions partition_pair p = partitions partition_pair combine_two_partitions p p partitions get_bfs_level_partition partitions reset_partition_device partitions get_device_to_partitions_mapping partitions devices len partition_pair = node graph_module graph nodes node op placeholder get_attr output create_single_node_partition node Set up parent partitions children partitions each partition set_parents_and_children partitions Get bfs level each partition get_bfs_level_partition partitions find_combination = True while find_combination Search pair partition generate minimum new cost then combine them find_combination = search_combination transfer_rate_bytes_per_sec node_to_latency_mapping Make sure all partitions set up correctly reorganize_partitions partitions Set up node partition mapping node_to_partition = get_node_to_partition_mapping partitions kl_based_partition transfer_rate_bytes_per_sec float node_to_latency_mapping dict Node NodeLatency - None This function cost aware partition based Kernighan-Lin algorithm First graph partitioned using size_based_partition Then each node swapped any other node different partition same time cost estimated after swapping For example we have nodes n n n n n Using size_based_partition n n Partition p n n n Partition p The current cost estimated We first tried using n swap n other partition Then we see swapping n n shows lower cost than current cost minimum among other pairs like n None This means moving n Partition without swapping other nodes n n n n We swap n n set new cost current cost Then We repeat process all other nodes until all swapping pairs tried swap_nodes n n p p Either n n could None That means we simply move node another partition n None p remove_node n p add_node n n None p add_node n p remove_node n try_swap_nodes n n p p node_to_latency_mapping transfer_rate_per_sec cost = float inf swap_nodes n n p p Reorganize partitions after swapping reorganize_partitions partitions Check there circular dependency after swapping check_dependency p check_dependency p reset_partition_device partitions partition_to_latency_mapping = get_partition_to_latency_mapping partitions node_to_latency_mapping Check all partitions can mapped logical devices after swapping found_device = get_device_to_partitions_mapping partitions devices found_device cost = float inf cost = get_latency_of_partitioned_graph partitions partition_to_latency_mapping transfer_rate_bytes_per_sec Swap back reset all partitions back original swap_nodes n n p p reorganize_partitions partitions reset_partition_device partitions get_device_to_partitions_mapping partitions devices cost swap_node_to_partition node p p node_to_latency_mapping transfer_rate_per_sec This function helps swap one node partition p all nodes another partition p p _nodes = list p nodes + None min_cost = float inf node_pair list Node = n p _nodes Ignore node op node n None n op placeholder get_attr continue Try swapping node p n p cost = try_swap_nodes node n p p node_to_latency_mapping transfer_rate_per_sec cost min_cost pyrefly ignore bad-assignment node_pair = node n min_cost = cost cost node_pair type ignore possibly-undefined First use size_base_partition size_based_partition partition_to_latency_mapping = get_partition_to_latency_mapping partitions node_to_latency_mapping Calculate cost partitions cost = get_latency_of_partitioned_graph partitions partition_to_latency_mapping transfer_rate_bytes_per_sec Keep tracking node pair shows better cost node_pair list Node = Keep tracking partition pair node pair partition_pair list Partition = Collect all op nodes graph op_nodes = n n graph_module graph nodes n op placeholder get_attr output node op_nodes Find which partition current node belongs p _index = node_to_partition node p = partitions p _index Go through all other partitions swap other nodes those partitions p _index _ enumerate partitions p _index = p _index p = partitions p _index new_cost new_node_pair = swap_node_to_partition node p p node_to_latency_mapping transfer_rate_bytes_per_sec Update cost Track swapped node pair their partitions new_cost cost cost = new_cost node_pair = new_node_pair partition_pair = p p Do swapping after trying all nodes partition len node_pair = swap_nodes node_pair node_pair partition_pair partition_pair reorganize_partitions partitions get_device_to_partitions_mapping partitions devices reorganize_partitions partitions Mapping device partition get_device_to_partitions_mapping partitions devices aot_based_partition node_to_partition_mapping partition_to_logical_device_mapping This function helps rebuild partitions given nodes its corresponding partition id partition_id_to_partition_mapping dict int Partition = node_to_partition = node_to_partition_mapping node node_to_partition partition_id = node_to_partition node If requested partition has been created create partition partition_id partition_id_to_partition_mapping partition = Partition partition_id partitions append partition partition_id_to_partition_mapping partition_id = partition partition logical_device_ids = partition_to_logical_device_mapping partition_id partition = partition_id_to_partition_mapping node_to_partition node Add current node into partition partition add_node node