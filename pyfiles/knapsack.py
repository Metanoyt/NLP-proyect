torch greedy_knapsack memory list float runtimes list float max_memory float - tuple float list int list int n = len runtimes items = list range n Sort items based ratio runtime memory descending order items = sorted items key=lambda i runtimes i memory i reverse=True total_memory = total_runtime = items_to_save = items_to_allow_recomputing = i items total_memory + memory i = max_memory total_memory += memory i total_runtime += runtimes i items_to_save append i items_to_allow_recomputing append i total_runtime items_to_save items_to_allow_recomputing ilp_knapsack memory list float runtimes list float max_memory float - tuple float list int list int numpy np try scipy optimize Bounds LinearConstraint milp except ImportError raise RuntimeError To use ILP memory budget checkpointing you need install scipy None np_memory = np array memory np_runtimes = np array runtimes c = -np_runtimes type ignore operator memory_constraint = LinearConstraint A=np_memory ub=np array max_memory constraints = memory_constraint integrality = np ones_like c res = milp c=c constraints=constraints integrality=integrality bounds=Bounds res success raise RuntimeError Somehow scipy solving failed items_to_save = items_to_allow_recomputing = idx i enumerate res x i == items_to_save append idx items_to_allow_recomputing append idx -res fun items_to_save items_to_allow_recomputing dp_knapsack memory list float runtime list float max_memory float - tuple float list int list int Scaling factor convert floating point weights integers S = Quantize memory weights quantized_memory = torch tensor round m S m memory dtype=torch long device= cpu runtimes = torch tensor runtime dtype=torch float device= cpu Quantized pseudopolynomial DP - Knapsack quantized_max_memory = round max_memory S n = len memory Initialize DP table TODO chilli I think needed memory can optimized sliding window trick + Hirschberg trick https codeforces com blog entry #comment- dp = torch zeros n + quantized_max_memory + dtype=torch float device= cpu i range n + current_memory = quantized_memory i - current_runtime = runtimes i - Copy previous row dp i = dp i - Update dp i j all j = current_memory current_memory == dp i = dp i - + current_runtime dp i current_memory = torch maximum dp i - current_memory dp i - -current_memory + current_runtime Backtrack find items included knapsack saved_items = recomputable_items = j int = quantized_max_memory i range n - dp i j = dp i - j saved_items append i - Include item indexing j -= int quantized_memory i - item recomputable_items append i - saved_items reverse To get items order they added The maximum runtime can achieved within max_memory constraint max_runtime = dp n quantized_max_memory item max_runtime saved_items recomputable_items