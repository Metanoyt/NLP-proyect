mypy allow-untyped-defs functools partial torch torch futures Future functions rpc_async constants UNSET_RPC_TIMEOUT _local_invoke rref func_name args kwargs getattr rref local_value func_name args kwargs functions async_execution _local_invoke_async_execution rref func_name args kwargs getattr rref local_value func_name args kwargs _invoke_rpc rref rpc_api func_name timeout args kwargs _rref_type_cont rref_fut rref_type = rref_fut value _invoke_func = _local_invoke Bypass ScriptModules when checking async function attribute bypass_type = issubclass rref_type torch jit ScriptModule issubclass rref_type torch _C ScriptModule bypass_type func = getattr rref_type func_name hasattr func _wrapped_async_rpc_function _invoke_func = _local_invoke_async_execution rpc_api rref owner _invoke_func args= rref func_name args kwargs timeout=timeout rref_fut = rref _get_type timeout=timeout blocking=False rpc_api rpc_async rref_fut wait _rref_type_cont rref_fut A little explanation rpc_async returns Future pointing value ` func_name ` returns ` Future T ` Calling _rref_type_cont ` then ` lambda causes Future wrapping IOW ` then ` returns ` Future Future T ` To address we Future completed result async call result Future = Future _wrap_rref_type_cont fut try _rref_type_cont fut then _complete_op except BaseException ex noqa B result set_exception ex _complete_op fut try result set_result fut value except BaseException ex noqa B result set_exception ex rref_fut then _wrap_rref_type_cont result This manages proxied RPC API calls RRefs It entirely used C++ see python_rpc_handler cpp RRefProxy __init__ rref rpc_api timeout=UNSET_RPC_TIMEOUT rref = rref rpc_api = rpc_api rpc_timeout = timeout __getattr__ func_name partial _invoke_rpc rref rpc_api func_name rpc_timeout