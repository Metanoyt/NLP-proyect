mypy allow-untyped-defs Copyright c Facebook Inc its affiliates All rights reserved This source code licensed under BSD-style license found LICENSE file root directory source tree binascii logging os tempfile base b decode b encode datetime timedelta typing Any cast Optional torch distributed FileStore Store TCPStore torch distributed elastic events construct_and_record_rdzv_event NodeState api RendezvousConnectionError RendezvousError RendezvousParameters RendezvousStateError dynamic_rendezvous RendezvousBackend Token utils _matches_machine_hostname parse_rendezvous_endpoint logger = logging getLogger __name__ default port TCP store DEFAULT_PORT = C dRendezvousBackend RendezvousBackend Represents C d-backed rendezvous backend Args store The py ` torch distributed Store ` instance use communicate C d store run_id The run id rendezvous See explanation __init__ method _NULL_SENTINEL = Y FuaW hZGFt _store Store _key str __init__ store Store run_id str - None run_id raise ValueError The run id must non-empty string _store = store _key = torch rendezvous + run_id The read operation store blocks caller until specified key becomes available This behavior makes tricky use store regular key-value dictionary As workaround we initially set sentinel value rendezvous state Whenever value gets returned we treat None _call_store compare_set _key _NULL_SENTINEL property name - str See base c d get_state - Optional tuple bytes Token See base base _state bytes = _call_store get _key _decode_state base _state set_state state bytes token Optional Token = None - Optional tuple bytes Token bool See base base _state_str str = b encode state decode token Shortcut we know sure token valid isinstance token bytes result = get_state result None result False None token = token decode token = _NULL_SENTINEL base _state bytes = _call_store compare_set _key token base _state_str state_token_pair = _decode_state base _state state_token_pair None None new_state new_token = state_token_pair C d Store s compare_set method does offer easy way find out whether our write attempt successful As brute-force solution we perform bitwise comparison our local state remote state new_state new_token new_state == state _call_store store_op str args kwargs - Any try getattr _store store_op args kwargs except ValueError RuntimeError TimeoutError exc raise RendezvousConnectionError The connection C d store has failed See inner exception details exc _decode_state base _state bytes - Optional tuple bytes Token base _state == _NULL_SENTINEL encode None try state = b decode base _state except binascii Error exc raise RendezvousStateError The state object corrupt See inner exception details exc state base _state _create_tcp_store params RendezvousParameters - TCPStore host port = parse_rendezvous_endpoint params endpoint default_port=DEFAULT_PORT cfg_is_host = params get_as_bool is_host If user has explicitly specified whether our process should host store respect cfg_is_host None is_host = cfg_is_host Otherwise try determine whether we host based our hostname IP address is_host = _matches_machine_hostname host The timeout read_timeout = cast int params get_as_int read_timeout read_timeout = raise ValueError The read timeout must positive integer In specific cases we attempt instantiate store twice For details see explanation except clause below is_server is_host False try store = TCPStore host port is_master=is_server multi_tenant=True timeout=timedelta seconds=read_timeout is_server msg = f Process os getpid hosts TCP store C d rendezvous backend construct_and_record_rdzv_event run_id=params run_id message=msg node_state=NodeState INIT logger info msg break except ValueError RuntimeError TimeoutError exc If we heuristically inferred value is_host True our first attempt instantiate TCP store has failed try one more time is_host set False As edge case there can more than one process part same rendezvous machine only one them will eventually host store is_server cfg_is_host None raise RendezvousConnectionError The connection C d store has failed See inner exception details exc store type ignore possibly-undefined _create_file_store params RendezvousParameters - FileStore If user specifies endpoint we treat path file params endpoint path = params endpoint try The temporary file readable writable only user process _ path = tempfile mkstemp except OSError exc raise RendezvousError The file creation C d store has failed See inner exception details exc try store = FileStore path except ValueError RuntimeError exc raise RendezvousConnectionError The connection C d store has failed See inner exception details exc store create_backend params RendezvousParameters - tuple C dRendezvousBackend Store Create new py ` C dRendezvousBackend ` specified parameters + -------------- + ----------------------------------------------------------- + &#124; Parameter &#124; Description &#124; +==============+===========================================================+ &#124; store_type &#124; The type C d store The currently supported types &#124; &#124; &#124; tcp file which correspond &#124; &#124; &#124; py ` torch distributed TCPStore ` &#124; &#124; &#124; py ` torch distributed FileStore ` respectively &#124; &#124; &#124; Defaults tcp &#124; + -------------- + ----------------------------------------------------------- + &#124; read_timeout &#124; The read timeout seconds store operations &#124; &#124; &#124; Defaults seconds &#124; &#124; &#124; &#124; &#124; &#124; Note only applies &#124; &#124; &#124; py ` torch distributed TCPStore ` It relevant &#124; &#124; &#124; py ` torch distributed FileStore ` which does &#124; &#124; &#124; take timeout parameter &#124; + -------------- + ----------------------------------------------------------- + &#124; is_host &#124; A boolean value indicating whether backend instance &#124; &#124; &#124; will host C d store If specified will &#124; &#124; &#124; inferred heuristically matching hostname IP &#124; &#124; &#124; address machine against specified rendezvous &#124; &#124; &#124; endpoint Defaults ` ` None ` ` &#124; &#124; &#124; &#124; &#124; &#124; Note configuration option only applies &#124; &#124; &#124; py ` torch distributed TCPStore ` In normal &#124; &#124; &#124; circumstances you can safely skip only time when &#124; &#124; &#124; needed its value cannot correctly &#124; &#124; &#124; determined e g rendezvous endpoint has CNAME &#124; &#124; &#124; hostname does match FQDN machine &#124; + -------------- + ----------------------------------------------------------- + As today we only support TCPStore FileStore Other store types do have required functionality e g compare_set yet store_type = params get store_type tcp strip lower store Store try store_type == file store = _create_file_store params store_type == tcp store = _create_tcp_store params raise ValueError Invalid store type given Currently only supports file tcp backend = C dRendezvousBackend store params run_id except Exception e construct_and_record_rdzv_event message=f type e __name__ str e run_id=params run_id node_state=NodeState FAILED raise backend store