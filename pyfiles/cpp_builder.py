This CPP builder designed support both Windows Linux OS The design document please check RFC https github com pytorch pytorch issues copy ctypes errno functools json locale logging os platform re shlex shutil subprocess sys sysconfig tempfile textwrap warnings collections abc Sequence ctypes cdll wintypes ctypes util find_library pathlib Path typing Any Optional Union torch torch _dynamo utils dynamo_timed torch _inductor config exc torch _inductor cpu_vec_isa invalid_vec_isa VecISA torch _inductor runtime runtime_utils cache_dir torch torch_version TorchVersion config is_fbcode triton fb build _run_build_command build_paths torch _inductor fb utils log_global_cache_errors log_global_cache_stats log_global_cache_vals use_global_cache log_global_cache_errors args Any kwargs Any - None type ignore misc pass log_global_cache_stats args Any kwargs Any - None type ignore misc pass log_global_cache_vals args Any kwargs Any - None type ignore misc pass use_global_cache - bool type ignore misc False Windows need setup temp dir store obj files _BUILD_TEMP_DIR = CxxBuild _HERE = os path abspath __file__ _TORCH_PATH = os path dirname os path dirname _HERE _LINKER_SCRIPT = os path join _TORCH_PATH _inductor script ld initialize variables compilation _IS_LINUX = sys platform startswith linux _IS_MACOS = sys platform startswith darwin _IS_WINDOWS = sys platform == win MINGW_GXX = x _ -w -mingw -g++ SUBPROCESS_DECODE_ARGS = locale getpreferredencoding _IS_WINDOWS log = logging getLogger __name__ =============================== toolchain =============================== functools lru_cache cpp_compiler_search search str - str torch _inductor codecache get_lock_dir LOCK_TIMEOUT cxx search try cxx None gxx package only available Linux according https anaconda org conda-forge gxx sys platform = linux continue Do install GXX default os getenv TORCH_INDUCTOR_INSTALL_GXX continue torch utils _filelock FileLock lock_dir = get_lock_dir lock = FileLock os path join lock_dir g++ lock timeout=LOCK_TIMEOUT lock cxx = install_gcc_via_conda subprocess check_output cxx -- version cxx except subprocess SubprocessError FileNotFoundError ImportError continue raise exc InvalidCxxCompiler install_gcc_via_conda - str On older systems quick way get modern compiler prefix = os path join cache_dir gcc cxx_path = os path join prefix bin g++ os path exists cxx_path log info Downloading GCC via conda conda = os environ get CONDA_EXE conda conda None conda = shutil which conda conda None subprocess check_call conda create f -- prefix= prefix -- channel=conda-forge -- quiet -y python= gxx stdout=subprocess PIPE cxx_path functools cache check_compiler_exist_windows compiler str - None Check compiler ready case end user activate MSVC environment try subprocess check_output compiler help stderr=subprocess STDOUT except FileNotFoundError exc raise RuntimeError f Compiler compiler found exc except subprocess SubprocessError Expected some compiler clang clang++ exist they support ` help ` args pass WinPeFileVersionInfo __init__ file_path str - None file_path = file_path version_dll = ctypes WinDLL version dll type ignore attr-defined _setup_functions _get_version_info _setup_functions - None version_dll GetFileVersionInfoSizeW argtypes = wintypes LPCWSTR wintypes LPDWORD version_dll GetFileVersionInfoSizeW restype = wintypes DWORD version_dll GetFileVersionInfoW argtypes = wintypes LPCWSTR wintypes DWORD wintypes DWORD wintypes LPVOID version_dll GetFileVersionInfoW restype = wintypes BOOL version_dll VerQueryValueW argtypes = wintypes LPCVOID wintypes LPCWSTR ctypes POINTER ctypes c_void_p ctypes POINTER wintypes UINT version_dll VerQueryValueW restype = wintypes BOOL _get_version_info - None dummy = wintypes DWORD size = version_dll GetFileVersionInfoSizeW file_path ctypes byref dummy size == raise RuntimeError f Can t get version info size file_path version_info = ctypes create_string_buffer size success = version_dll GetFileVersionInfoW file_path size version_info success raise RuntimeError f Can t get version info file_path get_language_id - int lp_buffer = ctypes c_void_p u_len = wintypes UINT success = version_dll VerQueryValueW version_info r \VarFileInfo\Translation ctypes byref lp_buffer ctypes byref u_len success u_len value == translations = lang_id int = lp_buffer value None i range u_len value offset = i data = ctypes string_at lp_buffer value + offset lang_id = int from_bytes data little code_page = int from_bytes data little translations append lang_id code_page Handle case where lp_buffer value None print Buffer None lang_id functools cache check_msvc_cl_language_id compiler str - None Torch compile only work MSVC English language pack well Check MSVC s language pack https github com pytorch pytorch issues #issuecomment- get_msvc_cl_path - tuple bool str Finds path cl exe using vswhere exe vswhere_path = os path join os environ get ProgramFiles x C \\Program Files x Microsoft Visual Studio Installer vswhere exe os path exists vswhere_path vswhere_path = os path join os environ get ProgramFiles C \\Program Files Microsoft Visual Studio Installer vswhere exe os path exists vswhere_path False vswhere exe found try Get Visual Studio installation path cmd = vswhere_path -latest -prerelease -products -requires Microsoft VisualStudio Component VC Tools x x -property installationPath vs_install_path = subprocess check_output cmd text=True encoding= utf- strip vs_install_path False Find latest MSVC toolset version within installation msvc_tools_path = os path join vs_install_path VC Tools MSVC os path exists msvc_tools_path False Get latest toolset version directory toolset_versions = d d os listdir msvc_tools_path os path isdir os path join msvc_tools_path d toolset_versions False latest_toolset_version = sorted toolset_versions reverse=True Construct full cl exe path cl_path = os path join msvc_tools_path latest_toolset_version bin HostX x cl exe os path exists cl_path True cl_path Fallback older versions different architectures needed cl_path = os path join msvc_tools_path latest_toolset_version bin HostX x cl exe os path exists cl_path True cl_path except subprocess CalledProcessError FileNotFoundError False False _is_msvc_cl compiler os path exists compiler Passed compiler path cl_exe_path = compiler b_ret cl_exe_path = get_msvc_cl_path b_ret False version_info = WinPeFileVersionInfo cl_exe_path lang_id = version_info get_language_id lang_id = MSVC English language id x DEC value raise RuntimeError Torch compile only support MSVC English language pack Please reinstall its language pack English functools cache check_mingw_win _flavor compiler str - str Check MinGW ` compiler ` exists s flavor win posix try out = subprocess check_output compiler -v stderr=subprocess STDOUT text=True except FileNotFoundError e raise RuntimeError f Compiler compiler found e except Exception e raise RuntimeError f Failed run compiler -v e flavor str &#124; None = None line out splitlines Thread model line flavor = line split - strip lower flavor None raise RuntimeError f Cannot determine flavor compiler win posix No Thread model found compiler -v flavor win posix raise RuntimeError f Only win pofix flavor compiler supported The flavor flavor flavor get_cpp_compiler - str config aot_inductor cross_target_platform == windows sys platform = win we re doing cross-compilation compiler = MINGW_GXX config aot_inductor package_cpp_only check_mingw_win _flavor compiler compiler _IS_WINDOWS compiler = os environ get CXX cl compiler = normalize_path_separator compiler check_compiler_exist_windows compiler check_msvc_cl_language_id compiler config is_fbcode build_paths cc isinstance config cpp cxx list tuple search = tuple config cpp cxx search = config cpp cxx compiler = cpp_compiler_search search compiler get_ld_and_objcopy use_relative_path bool - tuple str str _IS_WINDOWS raise RuntimeError Windows supported yet config is_fbcode ld = build_paths ld objcopy = build_paths objcopy_fallback use_relative_path build_paths objcopy ld = ld objcopy = objcopy ld objcopy convert_cubin_to_obj cubin_file str kernel_name str ld str objcopy str - str obj_file = cubin_file + o Convert cubin o cmd = f ld -r -b binary -z noexecstack -o obj_file cubin_file subprocess run cmd split capture_output=True text=True check=True Rename data rodata cmd = f objcopy -- rename-section data= rodata alloc load readonly data contents obj_file subprocess run cmd split capture_output=True text=True check=True By default objcopy will create _start _size _end symbols using full path Rename use unique kernel name file_name = re sub r \W _ cubin_file cmd = objcopy + f -- redefine-sym _binary_ file_name _start=__ kernel_name _start + f -- redefine-sym _binary_ file_name _size=__ kernel_name _size + f -- redefine-sym _binary_ file_name _end=__ kernel_name _end + obj_file subprocess run cmd split capture_output=True text=True check=True obj_file functools cache _is_apple_clang cpp_compiler str - bool version_string = subprocess check_output cpp_compiler -- version decode utf Apple version_string splitlines functools cache _is_clang cpp_compiler str - bool Mac OS apple clang maybe named gcc need check compiler info sys platform == darwin _is_apple_clang cpp_compiler _IS_WINDOWS clang suite have many compilers only clang-cl supported re search r clang$ &#124; clang\+\+$ cpp_compiler raise RuntimeError Please use clang-cl due torch compile only support MSVC-like CLI compiler flags syntax bool re search r clang-cl cpp_compiler bool re search r clang &#124; clang\+\+ cpp_compiler functools cache _is_gcc cpp_compiler str - bool Since clang++ ends g++ regex match below would validate _is_clang cpp_compiler False bool re search r gcc &#124; g\+\+ &#124; gnu-c\+\+ cpp_compiler functools cache _is_msvc_cl cpp_compiler str - bool _IS_WINDOWS False try output_msg = subprocess check_output cpp_compiler help stderr=subprocess STDOUT strip decode SUBPROCESS_DECODE_ARGS Microsoft output_msg splitlines except FileNotFoundError False False functools cache _is_intel_compiler cpp_compiler str - bool _check_minimal_version compiler_version TorchVersion - None On Windows early version icx has ` -print-file-name ` issue can t preload correctly inductor min_version = _IS_WINDOWS compiler_version TorchVersion min_version raise RuntimeError f Intel Compiler error less than minimal version min_version try output_msg = subprocess check_output cpp_compiler -- version stderr=subprocess DEVNULL strip decode SUBPROCESS_DECODE_ARGS is_intel_compiler = Intel output_msg splitlines is_intel_compiler _IS_WINDOWS re search r icx$ &#124; icx-cc$ cpp_compiler raise RuntimeError Please use icx-cl due torch compile only support MSVC-like CLI compiler flags syntax Version check icx_ver_search = re search r \d+ \d+ \d+ \d+ output_msg icx_ver_search None icx_ver = icx_ver_search group _check_minimal_version TorchVersion icx_ver is_intel_compiler except FileNotFoundError False except subprocess SubprocessError -- version args support False False functools cache is_gcc - bool _is_gcc get_cpp_compiler functools cache is_clang - bool _is_clang get_cpp_compiler functools cache is_intel_compiler - bool _is_intel_compiler get_cpp_compiler functools cache is_apple_clang - bool _is_apple_clang get_cpp_compiler functools cache is_msvc_cl - bool _is_msvc_cl get_cpp_compiler functools cache get_compiler_version_info compiler str - str env = os environ copy env LC_ALL = C Don t localize output try version_string = subprocess check_output compiler -v stderr=subprocess STDOUT env=env decode SUBPROCESS_DECODE_ARGS except Exception try version_string = subprocess check_output compiler -- version stderr=subprocess STDOUT env=env decode SUBPROCESS_DECODE_ARGS except Exception Multiple lines one line string version_string = version_string replace \r _ version_string = version_string replace \n _ version_string =============================== cpp builder =============================== _append_list dest_list list str src_list list str - None dest_list extend copy deepcopy item item src_list _remove_duplication_in_list orig_list list str - list str new_list list str = item orig_list item new_list new_list append item new_list _create_if_dir_not_exist path_dir str - None os path exists path_dir try Path path_dir mkdir parents=True exist_ok=True except OSError exc Guard against race condition exc errno = errno EEXIST raise RuntimeError f Fail create path path_dir exc _remove_dir path_dir str - None os path exists path_dir root dirs files os walk path_dir topdown=False name files file_path = os path join root name os remove file_path name dirs dir_path = os path join root name os rmdir dir_path os rmdir path_dir _run_compile_cmd cmd_line str cwd str - None cmd = shlex split cmd_line try subprocess run cmd cwd=cwd check=True stdout=subprocess PIPE stderr=subprocess STDOUT except subprocess CalledProcessError e output = e stdout decode SUBPROCESS_DECODE_ARGS openmp_problem = omp h file found output libomp output openmp_problem sys platform == darwin instruction = \n\nOpenMP support found Please try one following solutions \n Set ` CXX ` environment variable compiler other than Apple clang++ g++ has builtin OpenMP support \n install OpenMP via conda ` conda install llvm-openmp ` \n install libomp via brew ` brew install libomp ` \n manually setup OpenMP set ` OMP_PREFIX ` environment variable point path ` include omp h ` under output += instruction raise exc CppCompileError cmd output e run_compile_cmd cmd_line str cwd str - None dynamo_timed compile_file _run_compile_cmd cmd_line cwd normalize_path_separator orig_path str - str _IS_WINDOWS orig_path replace os sep orig_path BuildOptionsBase This Base store cxx build options template Actually build cxx shared library We just need select compiler maintains suitable args __init__ compiler str = definitions Optional list str = None include_dirs Optional list str = None cflags Optional list str = None ldflags Optional list str = None libraries_dirs Optional list str = None libraries Optional list str = None passthrough_args Optional list str = None aot_mode bool = False use_relative_path bool = False compile_only bool = False precompiling bool = False preprocessing bool = False - None _compiler = compiler _definitions list str = definitions _include_dirs list str = include_dirs _cflags list str = cflags _ldflags list str = ldflags _libraries_dirs list str = libraries_dirs _libraries list str = libraries Some args hard abstract OS compatible passthrough directly _passthrough_args list str = passthrough_args Optionally path precompiled header which should included build command line precompiled_header Optional str = None _aot_mode bool = aot_mode _use_relative_path bool = use_relative_path _compile_only bool = compile_only _precompiling bool = precompiling _preprocessing bool = preprocessing _process_compile_only_options - None _compile_only _libraries_dirs = _libraries = _remove_duplicate_options - None _definitions = _remove_duplication_in_list _definitions _include_dirs = _remove_duplication_in_list _include_dirs _cflags = _remove_duplication_in_list _cflags _ldflags = _remove_duplication_in_list _ldflags _libraries_dirs = _remove_duplication_in_list _libraries_dirs _libraries = _remove_duplication_in_list _libraries _passthrough_args = _remove_duplication_in_list _passthrough_args _finalize_options - None _process_compile_only_options _remove_duplicate_options get_compiler - str _compiler get_definitions - list str _definitions get_include_dirs - list str _include_dirs get_cflags - list str _cflags get_ldflags - list str _ldflags get_libraries_dirs - list str _libraries_dirs get_libraries - list str _libraries get_passthrough_args - list str _passthrough_args get_aot_mode - bool _aot_mode get_use_relative_path - bool _use_relative_path get_compile_only - bool _compile_only get_precompiling - bool _precompiling get_preprocessing - bool _preprocessing save_flags_to_json file str - None attrs = compiler get_compiler definitions get_definitions include_dirs get_include_dirs cflags get_cflags ldflags get_ldflags libraries_dirs get_libraries_dirs libraries get_libraries passthrough_args get_passthrough_args aot_mode get_aot_mode use_relative_path get_use_relative_path compile_only get_compile_only open file w f json dump attrs f _get_warning_all_cflag warning_all bool = True - list str _IS_WINDOWS Wall warning_all _get_cpp_std_cflag std_num str = c++ - list str _IS_WINDOWS On Windows only c++ can support ` std enable_if_t ` Ref https learn microsoft com en-us cpp overview cpp-conformance-improvements- view=msvc- #checking-for-abstract-class-types noqa B Note Only setup c++ Windows inductor I tried upgrade all project c++ failed https github com pytorch pytorch pull std_num = c++ f std std_num f std= std_num _get_os_related_cpp_cflags cpp_compiler str - list str _IS_WINDOWS cflags = wd wd wd wd wd wd wd wd wd wd EHsc For Intel oneAPI ref https learn microsoft com en-us cpp build reference zc-cplusplus view=msvc- Zc __cplusplus Enable max compatible msvc oneAPI headers ref https github com pytorch pytorch blob db c ad e ada e df ba cb e feb cmake public utils cmake#L -L noqa B permissive- cflags = Wno-unused-variable Wno-unknown-pragmas _is_clang cpp_compiler ignored_optimization_argument = Werror=ignored-optimization-argument config aot_inductor raise_error_on_ignored_optimization Wno-ignored-optimization-argument cflags append ignored_optimization_argument _is_gcc cpp_compiler Issue all warnings demanded strict ISO C ISO C++ Ref https github com pytorch pytorch issues #issuecomment- cflags append pedantic cflags _get_os_related_cpp_definitions cpp_compiler str - list str os_definitions list str = _IS_WINDOWS On Windows we need disable min max macro avoid C error PyTorch CMake https github com pytorch pytorch blob eee ebd e e b CMakeLists txt#L -L os_definitions append NOMINMAX os_definitions _get_ffast_math_flags - list str _IS_WINDOWS flags = ffast-math equivalent these flags https github com gcc-mirror gcc blob ad c ccd f fca b ea gcc opts cc#L -L however gcc sets FTZ DAZ flags runtime x even we have -ffast-math -fno-unsafe-math-optimizations because flags runtime added linking crtfastmath o This done spec file which only does globbing -ffast-math flags = fno-trapping-math funsafe-math-optimizations ffinite-math-only fno-signed-zeros fno-math-errno flags append fno-finite-math-only config cpp enable_unsafe_math_opt_flag flags append fno-unsafe-math-optimizations flags append f ffp-contract= config cpp enable_floating_point_contract_flag is_gcc flags append fexcess-precision=fast flags _get_inductor_debug_symbol_cflags - tuple list str list str When we turn generate debug symbol On Windows should create module_name pdb file It helps debug WinDBG On Linux should create some debug sections binary file cflags list str = ldflags list str = _IS_WINDOWS cflags = ZI _DEBUG ldflags = DEBUG ASSEMBLYDEBUG OPT REF OPT ICF cflags append g cflags ldflags _get_optimization_cflags cpp_compiler str min_optimize bool = False - tuple list str list str cflags list str = ldflags list str = b_debug_build = config aot_inductor debug_compile os environ get TORCHINDUCTOR_DEBUG_SYMBOL == wrapper_opt_level = config aot_inductor compile_wrapper_opt_level b_debug_build cflags ldflags = _get_inductor_debug_symbol_cflags _IS_WINDOWS cflags += Od Ob Oy- cflags append O _IS_WINDOWS cflags = O min_optimize O cflags = wrapper_opt_level min_optimize O DNDEBUG cflags += _get_ffast_math_flags _IS_WINDOWS pass sys platform = darwin macos unknown argument -fno-tree-loop-vectorize _is_gcc cpp_compiler cflags append fno-tree-loop-vectorize https stackoverflow com questions why-does-march-native-not-work-on-apple-m ` -march=native ` unrecognized option M config is_fbcode platform machine == ppc le cflags append mcpu=native cflags append march=native config aot_inductor enable_lto _is_clang cpp_compiler cflags append flto=thin cflags ldflags _get_shared_cflags do_link bool - list str _IS_WINDOWS MSVC ` MD ` using python ` ucrtbase dll ` lib runtime https learn microsoft com en-us cpp c-runtime-library crt-library-features view=msvc- DLL MD platform system == Darwin clang get_cpp_compiler This causes undefined symbols behave same linux shared fPIC undefined dynamic_lookup flags = do_link flags append shared flags append fPIC flags get_cpp_options cpp_compiler str do_link bool warning_all bool = True extra_flags Sequence str = min_optimize bool = False - tuple list str list str list str list str list str list str list str definitions list str = include_dirs list str = cflags list str = ldflags list str = libraries_dirs list str = libraries list str = passthrough_args list str = opt_cflags opt_ldflags = _get_optimization_cflags cpp_compiler min_optimize cflags = opt_cflags + _get_shared_cflags do_link + _get_warning_all_cflag warning_all + _get_cpp_std_cflag + _get_os_related_cpp_cflags cpp_compiler definitions += _get_os_related_cpp_definitions cpp_compiler _IS_WINDOWS config aot_inductor enable_lto _is_clang cpp_compiler ldflags append fuse-ld=lld ldflags append flto=thin passthrough_args append join extra_flags config aot_inductor cross_target_platform == windows passthrough_args extend -static-libstdc++ -static-libgcc check_mingw_win _flavor MINGW_GXX == posix passthrough_args append -Wl -Bstatic -lwinpthread -Wl -Bdynamic definitions include_dirs cflags ldflags + opt_ldflags libraries_dirs libraries passthrough_args CppOptions BuildOptionsBase This inherited BuildOptionsBase cxx build options This option need contains basic cxx build option which contains OS related args Toolchains related args Cxx standard related args Note This Options good assist modules build such x _isa_help __init__ compile_only bool = False warning_all bool = True extra_flags Sequence str = use_relative_path bool = False compiler str = min_optimize bool = False precompiling bool = False preprocessing bool = False - None super __init__ compile_only=compile_only use_relative_path=use_relative_path precompiling=precompiling preprocessing=preprocessing _compiler = compiler compiler get_cpp_compiler definitions include_dirs cflags ldflags libraries_dirs libraries passthrough_args = get_cpp_options cpp_compiler=self _compiler do_link=not compile_only precompiling preprocessing extra_flags=extra_flags warning_all=warning_all min_optimize=min_optimize _append_list _definitions definitions _append_list _include_dirs include_dirs _append_list _cflags cflags _append_list _ldflags ldflags _append_list _libraries_dirs libraries_dirs _append_list _libraries libraries _append_list _passthrough_args passthrough_args _finalize_options _get_torch_cpp_wrapper_definition - list str TORCH_INDUCTOR_CPP_WRAPPER STANDALONE_TORCH_HEADER _use_custom_generated_macros - list str C _USING_CUSTOM_GENERATED_MACROS _use_fb_internal_macros - list str _IS_WINDOWS config is_fbcode fb_internal_macros = C _USE_GLOG C _USE_MINIMAL_GLOG C _DISABLE_TENSORIMPL_EXTENSIBILITY fb_internal_macros _setup_standard_sys_libs cpp_compiler str aot_mode bool use_relative_path bool - tuple list str list str list str cflags list str = include_dirs list str = passthrough_args list str = _IS_WINDOWS cflags include_dirs passthrough_args config is_fbcode TODO T Can we unify these flags triton_cc_command cflags append nostdinc Note order include paths do matter result we need have several branches interleaved here include_dirs append build_paths sleef_include include_dirs append build_paths openmp_include include_dirs append build_paths python_include include_dirs append build_paths cc_include include_dirs append build_paths libgcc_include include_dirs append build_paths libgcc_arch_include include_dirs append build_paths libgcc_backward_include include_dirs append build_paths glibc_include include_dirs append build_paths linux_kernel_include include_dirs append include aot_mode use_relative_path linker_script = _LINKER_SCRIPT linker_script = os path basename _LINKER_SCRIPT _is_clang cpp_compiler passthrough_args append -- rtlib=compiler-rt passthrough_args append -fuse-ld=lld passthrough_args append f -Wl -- script= linker_script passthrough_args append -B + build_paths glibc_lib passthrough_args append -L + build_paths glibc_lib cflags include_dirs passthrough_args _get_build_args_of_chosen_isa vec_isa VecISA - tuple list str list str macros list str = build_flags list str = vec_isa = invalid_vec_isa Add Windows support later macros extend copy deepcopy x x vec_isa build_macro build_flags = vec_isa build_arch_flags config is_fbcode cap = str vec_isa upper macros = f CPU_CAPABILITY= cap f CPU_CAPABILITY_ cap f HAVE_ cap _CPU_DEFINITION macros build_flags _get_torch_related_args include_pytorch bool aot_mode bool - tuple list str list str list str torch utils cpp_extension include_paths TORCH_LIB_PATH libraries = include_dirs = include_paths config aot_inductor link_libtorch libraries_dirs = TORCH_LIB_PATH sys platform = darwin config is_fbcode libraries extend torch torch_cpu aot_mode libraries append torch_python libraries_dirs = config aot_inductor cross_target_platform == windows aoti_shim_library = config aot_inductor aoti_shim_library assert aoti_shim_library config aot_inductor aoti_shim_library must set when cross_target_platform windows isinstance aoti_shim_library str libraries append aoti_shim_library assert isinstance aoti_shim_library list libraries extend aoti_shim_library config aot_inductor cross_target_platform == windows assert config aot_inductor aoti_shim_library_path config aot_inductor aoti_shim_library_path must set path AOTI shim library when cross_target_platform windows libraries_dirs append config aot_inductor aoti_shim_library_path _IS_WINDOWS libraries append sleef include_dirs libraries_dirs libraries _get_python_include_dirs - list str include_dir = Path sysconfig get_path include On Darwin Python executable framework can non-existing Library Python include path which case one should use Headers folder framework include_dir exists platform system == Darwin std_lib = Path sysconfig get_path stdlib include_dir = std_lib parent parent Headers absolute include_dir Python h exists warnings warn f Can t find Python h str include_dir str include_dir _get_python_related_args - tuple list str list str python_include_dirs = _get_python_include_dirs python_include_path = sysconfig get_path include scheme= nt _IS_WINDOWS posix_prefix python_include_path None python_include_dirs append python_include_path _IS_WINDOWS python_lib_path = str Path sysconfig get_path include scheme= nt parent libs absolute python_lib_path = sysconfig get_config_var LIBDIR config is_fbcode python_include_dirs append build_paths python_include python_include_dirs python_lib_path functools cache is_conda_llvm_openmp_installed - bool try command = conda list llvm-openmp -- json output = subprocess check_output command split decode utf len json loads output except subprocess SubprocessError FileNotFoundError False functools cache homebrew_libomp - tuple bool str try check ` brew ` installed shutil which brew None False get location ` libomp ` installed location ` libomp ` would installed see https github com Homebrew brew issues #issuecomment- details libomp_path = subprocess check_output brew -- prefix libomp decode utf strip check ` libomp ` installed omp_available = os path exists libomp_path omp_available libomp_path except subprocess SubprocessError False functools cache perload_clang_libomp_win cpp_compiler str omp_name str - None try output = subprocess check_output cpp_compiler -print-file-name=bin decode utf omp_path = os path join output rstrip omp_name os path isfile omp_path os environ KMP_DUPLICATE_LIB_OK = TRUE cdll LoadLibrary omp_path except subprocess SubprocessError pass functools cache perload_icx_libomp_win cpp_compiler str - None _load_icx_built_in_lib_by_name cpp_compiler str lib_name str - bool try output = subprocess check_output cpp_compiler f -print-file-name= lib_name stderr=subprocess DEVNULL decode SUBPROCESS_DECODE_ARGS omp_path = output rstrip os path isfile omp_path os environ KMP_DUPLICATE_LIB_OK = TRUE cdll LoadLibrary omp_path True except subprocess SubprocessError pass False Intel Compiler implemented more math libraries than clang performance proposal We need preload them like openmp library preload_list = libiomp md dll openmp svml_dispmd dll svml library libmmd dll libm lib_name preload_list _load_icx_built_in_lib_by_name cpp_compiler lib_name _get_openmp_args cpp_compiler str - tuple list str list str list str list str list str list str cflags list str = ldflags list str = include_dir_paths list str = lib_dir_paths list str = libs list str = passthrough_args list str = config aot_inductor cross_target_platform == windows cflags ldflags include_dir_paths lib_dir_paths libs passthrough_args _IS_MACOS Per https mac r-project org openmp right way pass ` openmp ` flags MacOS via ` -Xclang ` cflags append Xclang cflags append fopenmp only Apple builtin compilers Apple Clang++ require openmp omp_available = _is_apple_clang cpp_compiler check ` OMP_PREFIX ` environment first omp_prefix = os getenv OMP_PREFIX omp_prefix None header_path = os path join omp_prefix include omp h valid_env = os path exists header_path valid_env include_dir_paths append os path join omp_prefix include lib_dir_paths append os path join omp_prefix lib warnings warn environment variable ` OMP_PREFIX ` invalid omp_available = omp_available valid_env omp_available libs append omp prefer use openmp ` conda install llvm-openmp ` conda_prefix = os getenv CONDA_PREFIX omp_available conda_prefix None omp_available = is_conda_llvm_openmp_installed omp_available conda_lib_path = os path join conda_prefix lib include_dir_paths append os path join conda_prefix include lib_dir_paths append conda_lib_path Prefer Intel OpenMP x machine os uname machine == x _ os path exists os path join conda_lib_path libiomp dylib libs append iomp next try use openmp ` brew install libomp ` omp_available omp_available libomp_path = homebrew_libomp omp_available include_dir_paths append os path join libomp_path include lib_dir_paths append os path join libomp_path lib openmp still available we let compiler have try raise error together instructions compilation error later _IS_WINDOWS On Windows ` clang ` ` icx ` have their specific openmp implenmention And openmp lib compiler s some sub-directory For dynamic library DLL load Windows native APIs ` LoadLibraryA ` ` LoadLibraryExA ` their search dependencies have some rules https learn microsoft com en-us windows win api libloaderapi nf-libloaderapi-loadlibraryexa#searching-for-dlls-and-dependencies In some case rules may include compiler s sub-directories So can t search load compiler s openmp library correctly And then whole application would broken To avoid openmp load failed we can automatic locate openmp binary preload For clang function ` perload_clang_libomp_win ` For icx function ` perload_icx_libomp_win ` _is_clang cpp_compiler cflags append openmp libs append libomp perload_clang_libomp_win cpp_compiler libomp dll _is_intel_compiler cpp_compiler cflags append Qiopenmp libs append libiomp md perload_icx_libomp_win cpp_compiler openmp openmp llvm llvm Windows new openmp https devblogs microsoft com cppblog msvc-openmp-update msvc openmp https learn microsoft com zh-cn cpp build reference openmp-enable-openmp- - -support view=msvc- cflags append openmp cflags append openmp experimental MSVC CL config is_fbcode include_dir_paths append build_paths openmp_include openmp_lib = build_paths openmp_lib_so fb_openmp_extra_flags = f -Wp -fopenmp openmp_lib passthrough_args append fb_openmp_extra_flags libs append omp _is_clang cpp_compiler TODO fix issue can t find omp h cflags append fopenmp libs append gomp _is_intel_compiler cpp_compiler cflags append fiopenmp cflags append fopenmp libs append gomp cflags ldflags include_dir_paths lib_dir_paths libs passthrough_args _get_libstdcxx_args - tuple list str list str For fbcode cpu case we should link stdc++ instead assuming binary where dlopen executed built dynamic stdc++ lib_dir_paths list str = libs list str = config is_fbcode lib_dir_paths = sysconfig get_config_var LIBDIR libs append stdc++ lib_dir_paths libs get_mmap_self_macro use_mmap_weights bool use_mmap_weights_external bool - list str macros = use_mmap_weights use_mmap_weights_external raise RuntimeError Only one use_mmap_weights use_mmap_weights_external should true use_mmap_weights macros append USE_MMAP_SELF use_mmap_weights_external macros append USE_MMAP_EXTERNAL macros get_caching_allocator_macro - list str torch _inductor config macros = config aot_inductor weight_use_caching_allocator macros append AOT_INDUCTOR_USE_CACHING_ALLOCATOR macros get_cpp_torch_options cpp_compiler str vec_isa VecISA include_pytorch bool aot_mode bool use_relative_path bool use_mmap_weights bool use_mmap_weights_external bool - tuple list str list str list str list str list str list str list str This function used get build args torch related build options Torch include_directories libraries libraries_directories Python include_directories libraries libraries_directories OpenMP related Torch MACROs MISC Return build args definitions list str = include_dirs list str = cflags list str = ldflags list str = libraries_dirs list str = libraries list str = passthrough_args list str = torch_cpp_wrapper_definitions = _get_torch_cpp_wrapper_definition use_custom_generated_macros_definitions = _use_custom_generated_macros sys_libs_cflags sys_libs_include_dirs sys_libs_passthrough_args = _setup_standard_sys_libs cpp_compiler aot_mode use_relative_path isa_macros isa_ps_args_build_flags = _get_build_args_of_chosen_isa vec_isa torch_include_dirs torch_libraries_dirs torch_libraries = _get_torch_related_args include_pytorch=include_pytorch aot_mode=aot_mode python_include_dirs python_libraries_dirs = _get_python_related_args omp_cflags omp_ldflags omp_include_dir_paths omp_lib_dir_paths omp_lib omp_passthrough_args = _get_openmp_args cpp_compiler fb_macro_passthrough_args = _use_fb_internal_macros mmap_self_macros = get_mmap_self_macro use_mmap_weights use_mmap_weights_external caching_allocator_macros = get_caching_allocator_macro definitions = torch_cpp_wrapper_definitions + use_custom_generated_macros_definitions + isa_macros + fb_macro_passthrough_args + mmap_self_macros + caching_allocator_macros include_dirs = sys_libs_include_dirs + python_include_dirs + torch_include_dirs + omp_include_dir_paths cflags = sys_libs_cflags + omp_cflags ldflags = omp_ldflags libraries_dirs = python_libraries_dirs + torch_libraries_dirs + omp_lib_dir_paths libraries = torch_libraries + omp_lib passthrough_args = sys_libs_passthrough_args + isa_ps_args_build_flags + omp_passthrough_args definitions include_dirs cflags ldflags libraries_dirs libraries passthrough_args CppTorchOptions CppOptions This inherited CppTorchOptions which automatic contains base cxx build options And then will maintains torch related build args Torch include_directories libraries libraries_directories Python include_directories libraries libraries_directories OpenMP related Torch MACROs MISC __init__ vec_isa VecISA = invalid_vec_isa include_pytorch bool = False warning_all bool = True aot_mode bool = False compile_only bool = False use_relative_path bool = False use_mmap_weights bool = False use_mmap_weights_external bool = False shared bool = True extra_flags Sequence str = compiler str = min_optimize bool = False precompiling bool = False preprocessing bool = False - None super __init__ compile_only=compile_only warning_all=warning_all extra_flags=extra_flags use_relative_path=use_relative_path compiler=compiler min_optimize=min_optimize precompiling=precompiling preprocessing=preprocessing _aot_mode = aot_mode torch_definitions torch_include_dirs torch_cflags torch_ldflags torch_libraries_dirs torch_libraries torch_passthrough_args = get_cpp_torch_options cpp_compiler=self _compiler vec_isa=vec_isa include_pytorch=include_pytorch aot_mode=aot_mode use_relative_path=use_relative_path use_mmap_weights=use_mmap_weights use_mmap_weights_external=use_mmap_weights_external _append_list _definitions torch_definitions _append_list _include_dirs torch_include_dirs _append_list _cflags torch_cflags _append_list _ldflags torch_ldflags _append_list _libraries_dirs torch_libraries_dirs _append_list _libraries torch_libraries _append_list _passthrough_args torch_passthrough_args _finalize_options _set_gpu_runtime_env - None config is_fbcode torch version hip None CUDA_HOME os environ CUDA_PATH os environ os environ CUDA_HOME = build_paths sdk_home functools lru_cache _find_libcudart_static path str - Optional Path lib_dirs = list Path path rglob libcudart_static lib_dirs lib_dirs resolve parent log_msg = f libcudart_static found under path log info log_msg None _transform_cuda_paths lpaths list str - None This handles two cases Cases where libs e g lib cuda- lib cuda- stubs Linux machines may have CUDA installed under either lib lib i path enumerate lpaths CUDA_HOME os environ path startswith os environ CUDA_HOME lib_dir Optional Path = _find_libcudart_static path lib_dir None continue lpaths i = str lib_dir stub_dir = lib_dir stubs stub_dir exists lpaths append str stub_dir get_cpp_torch_device_options device_type str aot_mode bool = False compile_only bool = False - tuple list str list str list str list str list str list str list str This function used get build args device related build options Device include_directories libraries libraries_directories Device MACROs MISC Return build args definitions list str = include_dirs list str = cflags list str = ldflags list str = libraries_dirs list str = libraries list str = passthrough_args list str = config is_fbcode CUDA_HOME os environ CUDA_PATH os environ os environ CUDA_HOME = build_paths sdk_home _set_gpu_runtime_env torch utils cpp_extension include_dirs = cpp_extension include_paths device_type config aot_inductor link_libtorch None link_libtorch = config aot_inductor link_libtorch libraries_dirs = cpp_extension library_paths device_type torch_include_dirs=link_libtorch cross_target_platform=config aot_inductor cross_target_platform device_type == cuda definitions append USE_ROCM torch version hip USE_CUDA torch version hip None config is_fbcode link_libtorch libraries += amdhip libraries += torch_hip definitions append __HIP_PLATFORM_AMD__ config is_fbcode link_libtorch libraries += cuda libraries += cuda torch_cuda config aot_inductor cross_target_platform == windows libraries += cudart _transform_cuda_paths libraries_dirs device_type == xpu definitions append USE_XPU xpu_error_string = Intel GPU driver properly installed please follow instruction https github com pytorch pytorch tab=readme-ov-file#intel-gpu-support _IS_WINDOWS ze_root = os getenv LEVEL_ZERO_V _SDK_PATH ze_root None raise OSError xpu_error_string include_dirs += os path join ze_root include libraries_dirs += os path join ze_root lib Suppress multi-line comment warnings sycl headers cflags += Wno-comment find_library ze_loader raise OSError xpu_error_string libraries += ze_loader sycl link_libtorch libraries += torch_xpu device_type == mps definitions append USE_MPS config is_fbcode include_dirs append build_paths sdk_include aot_mode device_type == cuda torch version hip None compile_only Only add link args when compile_only false passthrough_args = -Wl -Bstatic -lcudart_static -Wl -Bdynamic device_type == cpu stdcxx_lib_dir_paths stdcxx_libs = _get_libstdcxx_args libraries_dirs += stdcxx_lib_dir_paths libraries += stdcxx_libs config aot_inductor custom_op_libs libraries += config aot_inductor custom_op_libs definitions include_dirs cflags ldflags libraries_dirs libraries passthrough_args CppTorchDeviceOptions CppTorchOptions This inherited CppTorchOptions which automatic contains base cxx build options torch common build options And then will maintains cuda xpu device related build args __init__ vec_isa VecISA = invalid_vec_isa include_pytorch bool = False device_type str = cuda aot_mode bool = False compile_only bool = False use_relative_path bool = False use_mmap_weights bool = False use_mmap_weights_external bool = False shared bool = True extra_flags Sequence str = min_optimize bool = False precompiling bool = False preprocessing bool = False - None super __init__ vec_isa=vec_isa include_pytorch=include_pytorch aot_mode=aot_mode compile_only=compile_only use_relative_path=use_relative_path use_mmap_weights=use_mmap_weights use_mmap_weights_external=use_mmap_weights_external extra_flags=extra_flags min_optimize=min_optimize precompiling=precompiling preprocessing=preprocessing device_definitions list str = device_include_dirs list str = device_cflags list str = device_ldflags list str = device_libraries_dirs list str = device_libraries list str = device_passthrough_args list str = device_definitions device_include_dirs device_cflags device_ldflags device_libraries_dirs device_libraries device_passthrough_args = get_cpp_torch_device_options device_type=device_type aot_mode=aot_mode compile_only=compile_only _append_list _definitions device_definitions _append_list _include_dirs device_include_dirs _append_list _cflags device_cflags _append_list _ldflags device_ldflags _append_list _libraries_dirs device_libraries_dirs _append_list _libraries device_libraries _append_list _passthrough_args device_passthrough_args _finalize_options _finalize_options - None super _finalize_options config is_fbcode Re-order library search paths case there lib conflicts also live FBCode python lib dir _ python_lib_dirs = _get_python_related_args assert len python_lib_dirs == f Python lib dirs python_lib_dirs python_lib_dirs _libraries_dirs _libraries_dirs remove python_lib_dirs _libraries_dirs append python_lib_dirs get_name_and_dir_from_output_file_path file_path str - tuple str str This function help prepare parameters new cpp_builder Example input_code tmp tmpof n g t c c crkkcdvhdxpktrmjxbqkqyq hmxpqsfza pxcf mwk lphygc cpp name dir = get_name_and_dir_from_output_file_path input_code Run result name = c crkkcdvhdxpktrmjxbqkqyq hmxpqsfza pxcf mwk lphygc dir = tmp tmpof n g t c put name dir CppBuilder s name output_dir CppBuilder -- get_target_file_path will format output path according OS Linux tmp tmppu g mm zh czhwiz z ca ep qkxenxerfjxy kehw h cjk ven qu hql i so Windows Windows temp path tmppu g mm zh czhwiz z ca ep qkxenxerfjxy kehw h cjk ven qu hql i dll name_and_ext = os path basename file_path name _ext = os path splitext name_and_ext dir = os path dirname file_path name dir CppBuilder CppBuilder cpp jit builder supports both Windows Linux MacOS Args name Build target name final target file will append extension type automatically Due CppBuilder supports multiple OS will maintains ext OS difference sources Source code file list built BuildOption Build options builder output_dir The output_dir target file will output The default value empty string then use current dir output dir Final target file output_dir name ext staticmethod __get_python_module_flags - tuple str str extension = pyd _IS_WINDOWS so output_flags = Fe _IS_WINDOWS -o extension output_flags staticmethod __get_object_flags - tuple str str extension = obj _IS_WINDOWS o output_flags = c Fo _IS_WINDOWS -c -o codespell ignore extension output_flags staticmethod __get_precompiled_header_flags - tuple str str extension = pch _IS_WINDOWS is_gcc gch output_flags = Fp _IS_WINDOWS -o extension output_flags staticmethod __get_preprocessor_output_flags - tuple str str extension = i output_flags = EP P _IS_WINDOWS -E -P -o extension output_flags __init__ name str sources Union str list str BuildOption BuildOptionsBase output_dir str = - None _compiler = _cflags_args = _definitions_args = _include_dirs_args = _ldflags_args = _libraries_dirs_args = _libraries_args = _passthrough_parameters_args = When relative path used we need maintain source dir list _orig_source_paths = _output_dir = _target_file = _use_relative_path bool = False _aot_mode bool = False _name = name _target_name = config aot_inductor model_name_for_generated_files aoti_model Code start here initial internal variables firstly _build_option = BuildOption _compiler = BuildOption get_compiler _use_relative_path = BuildOption get_use_relative_path _aot_mode = BuildOption get_aot_mode _output_dir = output_dir _compile_only = BuildOption get_compile_only _precompiling = BuildOption get_precompiling _preprocessing = BuildOption get_preprocessing Only one these options any should true any given time assert sum _compile_only _precompiling _preprocessing = _do_link = _compile_only _precompiling _preprocessing MSVC produces two files when precompiling actual pch file well object file which must linked into final library This assumes only one output file note so now we ll error out here assert _IS_WINDOWS _precompiling Cannot currently precompile headers Windows _compile_only file_ext output_flags = __get_object_flags _precompiling file_ext output_flags = __get_precompiled_header_flags _preprocessing file_ext output_flags = __get_preprocessor_output_flags file_ext output_flags = __get_python_module_flags _target_file = os path join _output_dir f _name file_ext relative_target_file = os path basename _target_file _use_relative_path _target_file _IS_WINDOWS _preprocessing The target file name automatically determined MSVC _output = output_flags _output = f output_flags relative_target_file _output = f output_flags relative_target_file isinstance sources str sources = sources Use relative paths only when requested typically remote builds config is_fbcode _use_relative_path Will create another temp directory building so do NOT use absolute path _orig_source_paths = list sources sources = os path basename i i sources _precompiling assert len sources == See above we can currently assume MSVC _sources_args = f -x c++-header sources _sources_args = join sources cflag BuildOption get_cflags _IS_WINDOWS _cflags_args += f cflag _cflags_args += f - cflag definition BuildOption get_definitions _IS_WINDOWS _definitions_args += f D definition _definitions_args += f -D definition precompiled_header = BuildOption precompiled_header _IS_WINDOWS log warning Precompiled header support MSVC currently unavailable ignoring s precompiled_header _include_dirs_args = f -include precompiled_header inc_dir BuildOption get_include_dirs _IS_WINDOWS _include_dirs_args += f I inc_dir _include_dirs_args += f -I shlex quote inc_dir ldflag BuildOption get_ldflags _IS_WINDOWS _ldflags_args += f ldflag _ldflags_args += f - ldflag lib_dir BuildOption get_libraries_dirs _IS_WINDOWS _libraries_dirs_args += f LIBPATH lib_dir _libraries_dirs_args += f -L lib_dir lib BuildOption get_libraries _IS_WINDOWS _libraries_args += f lib lib _libraries_args += f -l lib passthrough_arg BuildOption get_passthrough_args _passthrough_parameters_args += f passthrough_arg get_command_line - str format_build_command compiler str sources str include_dirs_args str definitions_args str cflags_args str ldflags_args str libraries_args str libraries_dirs_args str passthrough_args str output str - str _IS_WINDOWS https learn microsoft com en-us cpp build walkthrough-compile-a-c-program-on-the-command-line view=msvc- https stackoverflow com cmd = f compiler include_dirs_args definitions_args cflags_args f sources passthrough_args output _do_link cmd += f LD link libraries_dirs_args libraries_args ldflags_args cmd = normalize_path_separator cmd cmd = f compiler sources definitions_args cflags_args f include_dirs_args passthrough_args output _do_link cmd += f ldflags_args libraries_args libraries_dirs_args cmd command_line = format_build_command compiler=self _compiler sources=self _sources_args include_dirs_args=self _include_dirs_args definitions_args=self _definitions_args cflags_args=self _cflags_args ldflags_args=self _ldflags_args libraries_args=self _libraries_args libraries_dirs_args=self _libraries_dirs_args passthrough_args=self _passthrough_parameters_args output=self _output command_line get_target_file_path - str normalize_path_separator _target_file build_fbcode_re - None dynamo_timed compile_file command = get_command_line split try output_path = _target_file When we build remotely we need make sure carefully copy any files required during compilation process into our build directly This where all ATen c Torch includes come torch_includes_path = os path join _TORCH_PATH include tempfile TemporaryDirectory tmp_dir Copy everything tmp compilation folder shutil copy _LINKER_SCRIPT os path join tmp_dir script ld src _orig_source_paths shutil copy src os path join tmp_dir os path basename src dest_include_path = os path join tmp_dir include shutil copytree torch_includes_path dest_include_path Run build tmp_output_path = _run_build_command command tmp_dir os path basename output_path Copy output build os path exists output_path os remove output_path shutil copy tmp_output_path output_path output_path endswith o os chmod output_path o output_path endswith so os chmod output_path o except subprocess CalledProcessError e output = e output decode utf- raise exc CppCompileError command output e build - None It must need temporary directory store object files Windows After build completed delete temporary directory save disk space _use_relative_path remote build uses relative path build_fbcode_re _create_if_dir_not_exist _output_dir _build_tmp_dir = os path join _output_dir f _name _ _BUILD_TEMP_DIR _create_if_dir_not_exist _build_tmp_dir build_cmd = get_command_line run_compile_cmd build_cmd cwd=_build_tmp_dir _remove_dir _build_tmp_dir save_compile_cmd_to_cmake cmake_path str device_type str - None Save global cmake settings here e g compiler options If targeting CUDA also emit custom function embed CUDA kernels definitions = join _build_option get_definitions target_library_type = STATIC config aot_inductor dynamic_linkage SHARED contents = textwrap dedent f cmake_minimum_required VERSION FATAL_ERROR project _target_name LANGUAGES CXX set CMAKE_CXX_STANDARD Set library target add_library _target_name target_library_type config aot_inductor link_libtorch config test_configs use_libtorch When compile_standalone True generated cpp project should use Torch But unit testing purpose we need use Torch here contents += textwrap dedent May need point CMAKE_PREFIX_PATH right torch location find_package Torch REQUIRED flags macros here mostly CPU specific Not emitting them GPU models will make generated CMake file more portable won t really hurt performance NOTE standalone focuses GPU now For CPU some flags macros may still needed contents += textwrap dedent f Add macro definitions target_compile_definitions _target_name PRIVATE definitions Add compile flags target_compile_options _target_name PRIVATE _cflags_args Backend-specific flags target_compile_options _target_name PRIVATE _passthrough_parameters_args -c When compile_standalone True use TorchStandalone instead Torch contents += textwrap dedent f find_package TorchStandalone REQUIRED Set up include directories find headers correct paths target_include_directories _target_name PRIVATE $ TorchStandalone_INCLUDE_DIRS target_include_directories _target_name PRIVATE $ TorchStandalone_INCLUDE_DIRS standalone device_type == cuda torch version hip None torch _inductor codecache _nvcc_arch_as_compile_option current_arch = _nvcc_arch_as_compile_option contents += textwrap dedent f enable_language CUDA set CMAKE_CUDA_STANDARD find_package CUDAToolkit REQUIRED target_include_directories _target_name PRIVATE $ CUDAToolkit_INCLUDE_DIRS target_compile_definitions _target_name PRIVATE USE_CUDA target_link_libraries _target_name PRIVATE cuda CUDA cudart_static find_program OBJCOPY_EXECUTABLE objcopy NOT OBJCOPY_EXECUTABLE message FATAL_ERROR objcopy found Cannot embed fatbin object file endif set KERNEL_TARGETS set KERNEL_OBJECT_FILES Function embed single kernel function embed_gpu_kernel KERNEL_NAME PTX_FILE set FATBIN_BASENAME $ KERNEL_NAME fatbin set FATBIN_FILE $ CMAKE_CURRENT_BINARY_DIR $ FATBIN_BASENAME set OBJECT_BASENAME $ KERNEL_NAME fatbin o set OBJECT_FILE $ CMAKE_CURRENT_BINARY_DIR $ OBJECT_BASENAME --- Define UNIQUE C symbol names --- set SYMBOL_START __$ KERNEL_NAME _start set SYMBOL_END __$ KERNEL_NAME _end set SYMBOL_SIZE __$ KERNEL_NAME _size string REGEX REPLACE ^a-zA-Z - _ MANGLED_BASENAME $ FATBIN_FILE set OBJCOPY_START_SYM _binary_$ MANGLED_BASENAME _start set OBJCOPY_END_SYM _binary_$ MANGLED_BASENAME _end set OBJCOPY_SIZE_SYM _binary_$ MANGLED_BASENAME _size --- PTX FATBIN Command Target --- add_custom_command OUTPUT $ FATBIN_FILE COMMAND $ CUDAToolkit_NVCC_EXECUTABLE -- fatbin $ PTX_FILE -o $ FATBIN_FILE $ NVCC_GENCODE_FLAGS -gencode arch=compute_ current_arch code=compute_ current_arch -gencode arch=compute_ current_arch code=sm_ current_arch DEPENDS $ PTX_FILE --- FATBIN Object File o Command --- add_custom_command OUTPUT $ OBJECT_FILE COMMAND $ CMAKE_LINKER -r -b binary -z noexecstack -o $ OBJECT_FILE $ FATBIN_FILE COMMAND $ OBJCOPY_EXECUTABLE -- rename-section data= rodata alloc load readonly data contents $ OBJECT_FILE COMMAND $ OBJCOPY_EXECUTABLE -- redefine-sym $ OBJCOPY_START_SYM =$ SYMBOL_START -- redefine-sym $ OBJCOPY_END_SYM =$ SYMBOL_END -- redefine-sym $ OBJCOPY_SIZE_SYM =$ SYMBOL_SIZE $ OBJECT_FILE DEPENDS $ FATBIN_FILE add_custom_target build_kernel_object_$ KERNEL_NAME DEPENDS $ OBJECT_FILE --- Add list linking later --- set KERNEL_TARGETS $ KERNEL_TARGETS build_kernel_object_$ KERNEL_NAME PARENT_SCOPE set KERNEL_OBJECT_FILES $ KERNEL_OBJECT_FILES $ OBJECT_FILE PARENT_SCOPE endfunction open cmake_path w f f write contents save_src_to_cmake cmake_path str src_path str - None Remove directory part file_path src_path = $ CMAKE_CURRENT_SOURCE_DIR + Path src_path name open cmake_path f f write f target_sources _target_name PRIVATE src_path \n save_kernel_asm_to_cmake cmake_path str asm_files list str - None TODO make work beyond CUDA open cmake_path f asm_file asm_files kernel_name = Path asm_file name split asm_file = f $ CMAKE_CURRENT_SOURCE_DIR Path asm_file name contents = textwrap dedent f embed_gpu_kernel kernel_name asm_file f write contents asm_files f write f add_dependencies _target_name $ KERNEL_TARGETS \n f write f target_link_libraries _target_name PRIVATE $ KERNEL_OBJECT_FILES \n save_link_cmd_to_cmake cmake_path str - None lflags = join _build_option get_ldflags libs = join _build_option get_libraries contents = textwrap dedent f Add linker flags target_link_options _target_name PRIVATE lflags Add libraries target_link_libraries _target_name PRIVATE libs assert os path exists cmake_path f save_link_cmd_to_cmakefile expects cmake_path already exist open cmake_path f f write contents run_asm_build_object src str target str cwd str - None get_asm_compiler - str _IS_WINDOWS ASM_CC = ml ASM_CC = get_cpp_compiler Intel compiler support compile asm switch gcc _is_intel_compiler ASM_CC ASM_CC = gcc ASM_CC get_command_line asm_cc str src str target str - str _IS_WINDOWS Format reference https learn microsoft com en-us cpp assembler masm ml-and-ml -command-line-reference view=msvc- cmd = f asm_cc src c Fo target codespell ignore Fo cmd = f asm_cc -c src -o target cmd asm_cc = get_asm_compiler cmd = get_command_line asm_cc=asm_cc src=normalize_path_separator src target=normalize_path_separator target run_compile_cmd cmd cwd=normalize_path_separator cwd