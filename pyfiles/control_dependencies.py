mypy allow-untyped-defs Effect ordering pass inductor This pass adds ordering dependencies FX graphs using control_deps HOP precise control over scheduling constraints When you need exact ordering between operations e g collective_start - mm - wait pass wraps operations control_deps make dependencies explicit typing Any torch fx fx torch _higher_order_ops utils register_fake torch _ops HigherOrderOperator torch utils _ordered_set OrderedSet ControlDeps HigherOrderOperator Higher-order operator enforces ordering making dependencies explicit Schema control_deps additional_deps target args kwargs - result where - additional_deps tuple tensors must computed before op - subgraph GraphModule containing exact operation execute - args kwargs arguments target function This ensures all tensors additional_deps computed before target executes creating explicit scheduling dependencies __init__ - None super __init__ control_deps __call__ additional_deps subgraph args kwargs Call operator dependencies subgraph Args additional_deps Tuple tensors must computed first subgraph GraphModule containing exact operation execute args Arguments pass subgraph isinstance additional_deps tuple list raise TypeError f additional_deps must tuple list got type additional_deps __name__ isinstance subgraph fx GraphModule callable subgraph raise TypeError f subgraph must GraphModule callable got type subgraph __name__ super __call__ additional_deps subgraph args kwargs control_deps = ControlDeps Register fake implementation tracing register_fake control_deps _ additional_deps subgraph args kwargs Fake tensor implementation - execute subgraph subgraph args kwargs get_subgraph_name gm fx GraphModule name name = f subgraph_ name hasattr gm name name i = while hasattr gm f name _ i i += f name _ i preserve_node_ordering graph fx Graph additional_deps_map dict fx Node OrderedSet fx Node verbose bool = False - None Preserve node ordering using control_deps HOP subgraph This function wraps operations control_deps Makes additional dependencies explicit first argument Creates subgraph internally preserve exact original operation Preserves original node names Args graph The FX graph modify additional_deps_map Mapping dependent nodes their dependencies verbose If True print debug information additional_deps_map Track replacements so we can update dependencies replacements dict fx Node fx Node = Process each node needs additional dependencies dependent_node dep_nodes additional_deps_map items assert dependent_node op == call_function dependent_node op original_name = dependent_node name original_args = dependent_node args original_kwargs = dependent_node kwargs original_meta = dependent_node meta copy updated_dep_nodes = replacements get dep dep dep dep_nodes Create subgraph preserves exact original operation subgraph_module = _create_subgraph_for_node graph dependent_node owning_mod = graph owning_module assert owning_mod None subgraph_attr_name = get_subgraph_name owning_mod original_name setattr graph owning_module subgraph_attr_name subgraph_module Create control_deps call Additional dependencies first arg explicit Subgraph via get_attr like b b gemm pass Original arguments only fx Node args kwargs passed graph inserting_before dependent_node Create get_attr node subgraph get_subgraph = graph get_attr subgraph_attr_name add additional args node_args = original_args isinstance fx Node value original_kwargs values isinstance value fx Node node_args append value Create temporary name first ordered_node = graph call_function control_deps args= tuple updated_dep_nodes additional_deps get_subgraph subgraph via get_attr like b b gemm node_args original node arguments both args kwargs kwargs= name=f __temp_ original_name Temporary name avoid conflict Copy metadata original node ordered_node meta = original_meta will constrained target node subgraph exists ordered_node meta pop eager_input_vals None Replace all uses original node ordered version dependent_node replace_all_uses_with ordered_node Remove original node graph graph erase_node dependent_node Now rename ordered node original name ordered_node name = original_name PRESERVE ORIGINAL NAME Track replacement future dependencies replacements dependent_node = ordered_node _create_subgraph_for_node graph fx Graph node fx Node - fx GraphModule Create subgraph exactly recreates node s operation The subgraph takes only fx Node arguments recreates operation exact target args structure kwargs Args graph The parent graph node The node wrap subgraph Returns A GraphModule containing subgraph Get owning module torch distributed breakpoint owning_module = graph owning_module Create new graph subgraph subgraph = fx Graph owning_module new_args list Any = placeholder_idx = _ arg enumerate node args isinstance arg fx Node new_args append arg continue placeholder = subgraph placeholder f arg_ placeholder_idx placeholder_idx += val arg meta placeholder meta update arg meta new_args append placeholder type ignore arg-type new_kwargs dict str Any = key value node kwargs items isinstance value fx Node new_kwargs key = value continue placeholder = subgraph placeholder f kwarg_ key val value meta placeholder meta update value meta new_kwargs key = placeholder type ignore assignment Recreate exact original operation subgraph assert callable node target result = subgraph call_function node target tuple new_args new_kwargs type ignore arg-type Copy metadata original node result meta update node meta out = subgraph output result val result meta out meta val = result meta val fx GraphModule owning_module subgraph