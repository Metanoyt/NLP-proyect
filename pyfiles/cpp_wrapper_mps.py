typing Any Optional sympy torch torch utils _ordered_set OrderedSet ir GraphPartitionSignature virtualized V cpp_wrapper_cpu CppWrapperCpu cpp_wrapper_gpu CppWrapperGpu wrapper KernelCallLine PythonWrapperCodegen CppWrapperMps CppWrapperGpu Generates cpp wrapper running MPS calls metal kernels __init__ - None super __init__ _used_kernel_names OrderedSet str = OrderedSet _lambda_counter int = staticmethod create is_subgraph bool subgraph_name Optional str parent_wrapper Optional PythonWrapperCodegen partition_signatures Optional GraphPartitionSignature = None - CppWrapperMps CppWrapperMps _generate_kernel_call_helper kernel_name str call_args list str device Optional torch device = None triton bool = True arg_types Optional tuple Any = None raw_keys Optional tuple Any = None raw_args Optional tuple Any = None triton_meta Optional dict str Any = None graph_name str = original_fxnode_name Optional str = None - None Generates MPS kernel call code It should look something like ` ` ` auto mps_lib_ _lambda = AOTIMetalKernelFunctionHandle handle aoti_torch_mps_start_encoding handle aoti_torch_mps_set_arg_tensor handle buf aoti_torch_mps_set_arg_tensor handle arg _ aoti_torch_mps_set_arg_tensor handle arg _ aoti_torch_mps_dispatch_single handle static_cast uint _t LL std function void AOTIMetalKernelFunctionHandle mps_lib_ _func_wrapper = mps_lib_ _lambda aoti_torch_mps_run_command_block get_mps_lib_ _handle aoti_torch_mps_shared_callback mps_lib_ _func_wrapper ` ` ` device = device V graph get_current_device_or_throw device type == cpu Even CppWrapperGpu we may see cpp kernels CppWrapperCpu _generate_kernel_call_helper kernel_name call_args device=device triton=triton arg_types=arg_types raw_keys=raw_keys raw_args=raw_args triton_meta=triton_meta assert device type == mps assert arg_types None new_args = idx arg arg_type enumerate zip call_args - arg_types - isinstance arg_type torch dtype new_args append f aoti_torch_mps_set_arg_tensor handle idx arg arg_type int sympy core symbol Symbol new_args append f aoti_torch_mps_set_arg_int handle idx arg raise NotImplementedError f Unsupported arg type arg_type arg arg kernel kernel_name threads group_size = call_args - call_args - threads None raise NotImplementedError No threads group_size provided Check threads single value array-like structure threads_str = str threads is_single_value = threads_str startswith threads_str endswith threads_str count == threads_str startswith is_single_value Extract single value braces present threads_str startswith threads_str endswith single_value = threads_str - strip Remove braces single_value = threads_str group_size None new_args append f aoti_torch_mps_dispatch_single handle single_value Extract group size value s also braces group_size_str = str group_size group_size_str startswith group_size_str endswith group_size_value = group_size_str - strip group_size_value = group_size_str new_args append f aoti_torch_mps_dispatch_single_with_group_size handle single_value group_size_value Handle array case - need convert initializer list array Use kernel name make variable names unique threads_var = f kernel_name _threads_array group_size_var = f kernel_name _group_size_array Extract array size initializer list string get_array_size array_str str - int Remove braces whitespace content = array_str strip content startswith content endswith content = content - strip content Empty array Count elements counting commas accounting nested structures depth = comma_count = char content char depth += char depth -= char == depth == comma_count += comma_count + Number elements = commas + threads_size = get_array_size threads_str group_size None new_args append new_args append f uint _t threads_var = threads new_args append f aoti_torch_mps_dispatch_array handle threads_var threads_size new_args append group_size_str = str group_size group_size_size = get_array_size group_size_str new_args append new_args append f uint _t threads_var = threads new_args append f uint _t group_size_var = group_size dispatch_args = f handle threads_var threads_size group_size_var group_size_size new_args append f aoti_torch_mps_dispatch_array_with_group_size dispatch_args new_args append debug printer related logic cpp kernel type debug_printer_manager = V graph wrapper_code debug_printer debug_printer_manager set_printer_args call_args - kernel_name None None cpp debug_printer_manager write_mps_kernel_call kernel_name new_args write_mps_kernel_call name str call_args list str - None Generate unique variable names avoid duplicate declarations when same MPS lib used multiple times unique_suffix = _lambda_counter _lambda_counter += lambda_name = f name _lambda_ unique_suffix wrapper_name = f name _func_wrapper_ unique_suffix Generate function call code current location Create lambda captures reference pass its pointer through void writeline f auto lambda_name = AOTIMetalKernelFunctionHandle handle writeline aoti_torch_mps_start_encoding handle Output call args directly since we re capturing reference call_arg call_args writeline f call_arg writeline writeline Pass lambda pointer through void writeline f std function void AOTIMetalKernelFunctionHandle wrapper_name = lambda_name writeline f aoti_torch_mps_run_command_block get_ name _handle aoti_torch_mps_shared_callback wrapper_name staticmethod get_device_include_path device str - str assert V graph aot_mode #include torch csrc inductor aoti_include mps h \n #include torch csrc inductor aoti_torch c shim_mps h codegen_additional_funcs - None Generate thread-safe lazy singleton pattern MPS shader libraries RAII cleanup The generated code will look like ` ` ` AOTIMetalKernelFunctionHandle get_mps_lib_ _handle static auto kernel_handle = AOTIMetalShaderLibraryHandle lib_handle = nullptr AOTIMetalKernelFunctionHandle kern_handle = nullptr aoti_torch_mps_create_shader_library mps_lib_ _source lib_handle aoti_torch_mps_get_kernel_function lib_handle generated_kernel kern_handle RAII wrapper custom deleter auto lib_deleter = AOTIMetalShaderLibraryHandle h h aoti_torch_mps_delete_shader_library h using LibDeleter = decltype lib_deleter using LibPtr = std unique_ptr AOTIMetalShaderLibraryOpaque LibDeleter Return pair kernel handle library smart pointer cleanup std make_pair kern_handle LibPtr lib_handle lib_deleter kernel_handle first ` ` ` Add shimified handles functions shader_libraries OrderedSet str = OrderedSet line lines isinstance line KernelCallLine continue line device type = mps continue Extract library name kernel name e g mps_lib_ kernel calls line kernel_name _used_kernel_names _used_kernel_names add line kernel_name shader_libraries add line kernel_name NOTE For shimified version we expect shader source constant generated existing MPS shader generation process instead instantiating DynamicMetalShaderLibrary directly we ll use our shim functions The existing codegen should produce something like const char mps_lib_ _source = R MTL shader_source MTL instead native mps DynamicMetalShaderLibrary mps_lib_ R MTL shader_source MTL Generate thread-safe lazy singleton RAII each library lib_name shader_libraries prefix splice f AOTIMetalKernelFunctionHandle get_ lib_name _handle static auto kernel_handle = AOTIMetalShaderLibraryHandle lib_handle = nullptr AOTIMetalKernelFunctionHandle kern_handle = nullptr aoti_torch_mps_create_shader_library lib_name _source lib_handle aoti_torch_mps_get_kernel_function lib_handle generated_kernel kern_handle RAII wrapper custom deleter auto lib_deleter = AOTIMetalShaderLibraryHandle h h aoti_torch_mps_delete_shader_library h using LibDeleter = decltype lib_deleter using LibPtr = std unique_ptr AOTIMetalShaderLibraryOpaque LibDeleter Return pair kernel handle library smart pointer cleanup std make_pair kern_handle LibPtr lib_handle lib_deleter kernel_handle first