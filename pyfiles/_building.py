NOTES We need typing module will handling Python ONNX type promotion use For example we have torch ops aten add Tensor we need promote same type Tensor The same thing needs work torch ops aten add Tensor well which means we need mechanism ` mypy allow-untyped-defs mypy disable-error-code=union-attr __future__ annotations copy inspect logging collections abc Iterable Mapping Sequence typing Any TYPE_CHECKING Union onnxscript onnxscript evaluator ir onnxscript ir convenience ir_convenience torch torch onnx _internal exporter _errors _schemas _tensors TYPE_CHECKING onnx logger = logging getLogger __name__ ValidAttributeType = Union ir TensorProtocol int float bool str Sequence int Sequence float None AllowedArgType = Union ir Value Sequence Union ir Value ValidAttributeType ValidAttributeType Logic adapting inputs general Python PyTorch inputs ONNX ir Value _construct_named_inputs_and_attrs signature _schemas OpSignature args Sequence AllowedArgType kwargs Mapping str AllowedArgType - tuple dict str AllowedArgType dict str ValidAttributeType Construct two mappings name inputs named attributes based signature args kwargs This function uses OpSignature determine which argument args kwargs corresponds which parameter signature ONNX node inputs stored named_inputs attributes stored named_attrs If _optional input_ provided filled None Args signature The OpSignature node args The positional arguments node kwargs The keyword arguments node Returns A tuple two mappings named_inputs named_attrs Raises ValueError If required parameter provided Construct named_inputs named_attrs mapping based args kwargs signature Loop over all parameters signature args together b Depending param is_input Record named_inputs param name = arg named_attrs param name = arg c Handle kwargs well d Fill None input provided named_inputs dict str Any = named_attrs dict str Any = reversed_args_stack = list reversed args param signature params isinstance param _schemas Parameter Handle inputs reversed_args_stack First exhaust positional arguments param variadic Handle variadic arguments named_inputs param name = tuple args reversed_args_stack clear named_inputs param name = reversed_args_stack pop type ignore assignment param name kwargs named_inputs param name = kwargs param name type ignore assignment param required raise ValueError f Required parameter param name provided f Signature signature Args args Kwargs kwargs logger debug Optional parameter s provided Added None Signature s param name signature named_inputs param name = None type ignore assignment Handle attributes attribute ValidAttributeType &#124; ir Attr assert isinstance param _schemas AttributeParameter f Expected AttributeParameter got type param reversed_args_stack First exhaust positional arguments attribute = reversed_args_stack pop type ignore assignment param name kwargs attribute = kwargs param name type ignore assignment param default None attribute = param default attribute = None attribute None param required raise ValueError f Required attribute param name provided f Signature signature Args args Kwargs kwargs logger debug Optional attribute s None Dropped Signature s param name signature continue isinstance attribute ir Attr Turn attribute default value into actual parameter node attr_copied = copy copy attribute Make sure name same parameter name name default parameter attr_copied name = param name attribute = attr_copied isinstance attribute int param type == ir AttributeType FLOAT Convert attribute float needed This happens PyTorch where attribute marked float can passed int attribute = float attribute named_attrs param name = attribute named_inputs named_attrs type ignore return-value _resolve_parameter_dtypes signature _schemas OpSignature named_inputs Mapping str AllowedArgType - Mapping _schemas TypeConstraintParam ir TypeProtocol Determine which parameter takes which type Handle non-tensor input corner cases type promotion Requires All ir Value name_inputs should have type set Their type should compatible type_constraint corresponding parameter signature Args signature The OpSignature node named_inputs The mapping parameter names their arguments Returns A mapping Constraint names ir TypeProtocol Create type_binding dict str ir TypeProtocol b Iterate over all named_inputs b Find corresponding parameter signature b If argument Python constant skip b If argument ir Value Bind constraint arg type type_binding = name arg named_inputs items param = signature params_map name assert isinstance param _schemas Parameter f Expected Parameter got type param isinstance arg int float bool str Sequence torch Tensor Skip Python constants because we do know what dtype they should take yet continue isinstance arg ir Value arg type None Skip ir Value type set continue NOTE We assume arg type compatible type_constraint assert arg type None f Expected type set arg TODO justinchuby Implement type promotion logic here type_binding param type_constraint = arg type type_binding _determine_input_dtype param _schemas Parameter arg AllowedArgType type_binding Mapping _schemas TypeConstraintParam ir TypeProtocol - ir DataType Determine dtype input mix Python constants ir Value param type_constraint type_binding A known dtype available because resolved type_binding param type_constraint dtype len param type_constraint allowed_types == Only one type allowed type constraint next iter param type_constraint allowed_types dtype No dtype information available Infer Python constant Sequence case mix Python constants ir Value isinstance arg bool ir DataType BOOL isinstance arg float ir DataType FLOAT isinstance arg int ir DataType INT isinstance arg str ir DataType STRING isinstance arg ir Tensor ir TensorProtocol arg dtype isinstance arg complex ir DataType FLOAT arg None ir DataType UNDEFINED Handle sequences isinstance arg tuple list len arg == Special case Treat empty sequence INT they typically used shape ir DataType INT Try obtain dtype one values val arg isinstance val ir Value val dtype None val dtype any isinstance val float val arg If any float present dtype float ir DataType FLOAT any isinstance val int val arg Otherwise any int present dtype int ir DataType INT raise ValueError f Could determine dtype input param name f param= param arg= arg param_type_constraint= param type_constraint f type_binding= type_binding _allowed_types_are_sequence_types allowed_types Iterable ir TypeProtocol - bool Check all allowed types Sequence types all isinstance t ir SequenceType t allowed_types _get_or_create_constant constant_farm dict tuple bool &#124; int &#124; float &#124; str &#124; tuple int &#124; tuple float ir DataType ir Value arg bool &#124; int &#124; float &#124; str &#124; tuple int &#124; tuple float &#124; tuple bool &#124; list int &#124; list float &#124; list bool dtype ir DataType opset onnxscript values Opset - ir Value float representation complex numbers isinstance arg complex Convert complex number float pyrefly ignore bad-assignment arg = arg real arg imag isinstance arg list Make arg hashable arg = tuple arg type ignore assignment constant_value = constant_farm get arg dtype type ignore arg-type constant_value None constant_tensor = ir tensor value=arg dtype=dtype type ignore arg-type constant_value = opset Constant value=constant_tensor constant_farm arg dtype = constant_value type ignore arg-type index constant_value _process_python_constants signature _schemas OpSignature named_inputs dict str AllowedArgType type_binding Mapping _schemas TypeConstraintParam ir TypeProtocol constant_farm dict tuple bool &#124; int &#124; float &#124; str &#124; tuple int &#124; tuple float ir DataType ir Value opset onnxscript values Opset - dict str ir Value &#124; None Convert Python constants Constant nodes list Sequence nodes based dtype information The added constants will replacing values named_inputs place Args signature The OpSignature node named_inputs The mapping parameter names their arguments type_binding A mapping Constraint names ir DataType constant_farm A dictionary py_value ir DataType ir Value store deduplicated constants opset The Opset use creating Constant nodes Returns A mapping parameter names Python constants converted constant Nodes Convert Python constants Constant nodes based dtype information construct sequences Iterate over all parameters signature second time b If parameter to_resolve_type - If param constraint type_binding Get constant constant_farm deduplicated otherwise set named_inputs param name = Constant value dtype=type_binding param constraint - Otherwise set named_inputs param name = Constant value name arg named_inputs items param = signature params_map name assert isinstance param _schemas Parameter f Expected Parameter got type param isinstance arg ir Value TODO justinchuby Cast ir Value here needed continue isinstance arg Sequence len arg any isinstance val ir Value val arg Skip sequence ir Value This variadic input Sequence input It will handled _process_python_sequences continue param variadic Handled _process_python_sequences continue _allowed_types_are_sequence_types param type_constraint allowed_types Handled _process_python_sequences continue dtype = _determine_input_dtype param arg type_binding arg None constant_value = None isinstance arg ir Tensor ir TensorProtocol constant_value = opset Constant value=arg Deduplicate constants constant_value = _get_or_create_constant constant_farm arg dtype opset type ignore arg-type named_inputs param name = constant_value named_inputs type ignore return-value _reshape_to_ d_tensor opset onnxscript values Opset arg ir Value - ir Value Reshape input D tensor opset Reshape arg opset Constant value=ir tensor - dtype=ir DataType INT _process_python_sequences signature _schemas OpSignature named_inputs dict str AllowedArgType type_binding Mapping _schemas TypeConstraintParam ir TypeProtocol constant_farm dict tuple bool &#124; int &#124; float &#124; str &#124; ir TensorProtocol &#124; tuple int &#124; tuple float ir DataType ir Value opset onnxscript values Opset Handle three types sequences Variadic inputs Sequence input ir Value Sequence Python constants contains ir Value name arg named_inputs items param = signature params_map name assert isinstance param _schemas Parameter f Expected Parameter got type param isinstance arg tuple list continue len arg == Skip empty sequences continue Sequence input ir Value _allowed_types_are_sequence_types param type_constraint allowed_types Turn list into Sequence node Constant op creation will handled variadic case below when calling SequenceConstruct op named_inputs name = opset SequenceConstruct arg continue Variadic inputs NOTE Variadic operators like Max can called mixed ir Value Python constants like ` Max ir Value ` We need convert Python constants Constant nodes param variadic all isinstance val ir Value val arg Skip variadic input all values ir Value continue dtype = _determine_input_dtype param arg type_binding new_args = val arg isinstance val ir Value new_args append val constant_tensor = ir tensor value=val dtype=dtype type ignore arg-type constant_value = opset Constant value=constant_tensor new_args append constant_value named_inputs name = new_args continue Concat list single input E g Value should converted op Concat Value Constant when expected input type INT We assume only happens D cases all isinstance val ir Value val arg expanded_args = _reshape_to_ d_tensor opset val val arg named_inputs name = opset Concat expanded_args axis= continue dtype = _determine_input_dtype param arg type_binding new_args = val arg isinstance val ir Value new_args append _reshape_to_ d_tensor opset val val None Skip None values continue isinstance val ir Tensor ir TensorProtocol new_args append _reshape_to_ d_tensor opset opset Constant value=val Turn Python constant into D tensor constant assert isinstance val bool int float f Expected int float got type val new_args append _get_or_create_constant constant_farm val dtype opset type ignore arg-type named_inputs name = opset Concat new_args axis= continue named_inputs _determine_output_number signature _schemas OpSignature named_attrs Mapping str ValidAttributeType - int Determine number outputs node heuristics signature domain == signature name == BatchNormalization named_attrs get training_mode signature name == Split num_outputs = named_attrs get num_outputs num_outputs None isinstance num_outputs int num_outputs raise ValueError Could determine number outputs Split num_outputs must provided len signature outputs _construct_node signature _schemas OpSignature named_inputs Mapping str ir Value &#124; None named_attrs Mapping str ValidAttributeType opset onnxscript values Opset num_outputs int - ir Node Construct node inputs attributes Variadic inputs flattened Args signature The OpSignature node named_inputs The mapping parameter names their arguments When we do have schema operator we do know names inputs which case names can anything because they used function The data structure passed consistency other functions named_attrs The mapping attribute names their values num_outputs The number outputs node inputs list ir Value &#124; None = Flatten variadic inputs value named_inputs values isinstance value Sequence inputs extend value inputs append value If final inputs None strip them node inputs input reversed inputs input None break inputs pop Construct filter out None attributes attributes = attr attr ir_convenience convert_attributes named_attrs attr value None outputs = _tensors SymbolicTensor opset _ range num_outputs ir Node signature domain signature name inputs=inputs attributes=attributes outputs=outputs version=signature opset_version OpRecorder evaluator Evaluator An onnxscript Evaluator captures graph into ONNX IR __init__ opset onnxscript values Opset constant_farm dict Any ir Value nodes list ir Node = opset = opset functions dict ir OperatorIdentifier onnxscript OnnxFunction &#124; ir Function = constant_farm = constant_farm _call_op op_signature _schemas OpSignature named_inputs dict str AllowedArgType named_attrs dict str ValidAttributeType num_outputs int - Sequence _tensors SymbolicTensor Record nodes given opschema arguments Args op_signature The OpSchema containing node signature named_inputs The mapping parameter names their arguments named_attrs The mapping attribute names their values type_binding = _resolve_parameter_dtypes op_signature named_inputs try converted_named_inputs = _process_python_constants op_signature named_inputs type_binding constant_farm opset converted_named_inputs = _process_python_sequences op_signature converted_named_inputs type ignore arg-type type_binding constant_farm opset except Exception e raise _errors GraphConstructionError f Error processing Python constants operator op_signature domain op_signature name f named_inputs= named_inputs named_attrs= named_attrs opset= opset op_signature= op_signature e try nodes append node = _construct_node op_signature converted_named_inputs named_attrs opset num_outputs except Exception e raise _errors GraphConstructionError f Error constructing node operator op_signature domain op_signature name f named_inputs= named_inputs converted_named_inputs= converted_named_inputs f named_attrs= named_attrs opset= opset op_signature= op_signature e node outputs type ignore return-value eval schema onnx defs OpSchema args Sequence AllowedArgType type ignore override kwargs Mapping str AllowedArgType - _tensors SymbolicTensor &#124; Sequence _tensors SymbolicTensor try op_signature = _schemas OpSignature from_opschema schema named_inputs named_attrs = _construct_named_inputs_and_attrs op_signature args kwargs TODO justinchuby Handle cast schema name == CastLike assert len named_inputs == Skip CastLike input output types same src_input = named_inputs input target_type = named_inputs target_type isinstance src_input ir Value isinstance target_type ir Value src_input dtype None target_type dtype None dtypes available src_input dtype == target_type dtype Same type No cast needed src_input type ignore return-value Create Cast node opset Cast src_input to=target_type dtype type ignore union-attr return-value num_outputs = _determine_output_number op_signature named_attrs outputs = _call_op op_signature named_inputs named_attrs num_outputs len outputs == outputs outputs except Exception e raise _errors GraphConstructionError f Error calling operator schema name args args kwargs kwargs e eval_function type ignore override function onnxscript OnnxFunction args Sequence AllowedArgType kwargs Mapping str AllowedArgType - _tensors SymbolicTensor &#124; Sequence _tensors SymbolicTensor &#124; bool &#124; int try NOTE signature should written function registration process hasattr function _pt_onnx_signature op_signature = function _pt_onnx_signature type ignore attr-defined op_signature = _schemas OpSignature from_function function function function_ir domain function name opset_version=function opset version function _pt_onnx_signature = op_signature type ignore attr-defined named_inputs named_attrs = _construct_named_inputs_and_attrs op_signature args kwargs TODO after torchlib migration Remove traceable function handling NOTE We need call traceable functions after _construct_named_inputs_and_attrs call because will filter out unexpected kwargs us function traceable Trace function call instead adding function node Turn ir Attr objects into Python constants first named_attrs = name attr value isinstance attr ir Attr attr name attr named_attrs items Use type binding resolve dtypes inputs convert Python constants Constant nodes type_binding = _resolve_parameter_dtypes op_signature named_inputs try _process_python_sequences here because we want preserve python list properties function call converted_named_inputs = _process_python_constants op_signature named_inputs type_binding constant_farm opset except Exception e raise _errors GraphConstructionError f Error processing Python constants operator op_signature domain op_signature name f named_inputs= named_inputs named_attrs= named_attrs opset= opset op_signature= op_signature e function function converted_named_inputs named_attrs outputs = _call_op op_signature named_inputs named_attrs len op_signature outputs functions function function_ir domain function name = function len outputs == outputs outputs except Exception e try source_file = inspect getsourcefile function function _ lineno = inspect getsourcelines function function except Exception source_file = lineno = None raise _errors GraphConstructionError f Error calling function function name args args kwargs kwargs + f The function defined source_file lineno source_file e