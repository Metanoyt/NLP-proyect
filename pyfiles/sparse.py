mypy ignore-errors os torch torch testing make_tensor noqa F torch testing _internal opinfo core noqa F BinaryUfuncInfo ErrorInput generate_elementwise_binary_tensors ReductionOpInfo sample_inputs_reduction SampleInput _check_validate op_info sample _check_fail sample try op_info sample sample_input input sample sample_input args sample sample_input kwargs except sample error_type pass except Exception msg raise AssertionError noqa B f op_info name sample sample_input= expected exception f sample error_type sample error_regex got type msg __name__ msg raise AssertionError f op_info name sample sample_input= expected exception f sample error_type sample error_regex got none _check_success sample try op_info sample input sample args sample kwargs except Exception msg raise AssertionError noqa B f op_info name sample= expected succeed f got type msg __name__ msg isinstance sample ErrorInput _check_fail sample _check_success sample _sample_inputs_sparse sample_inputs maybe_failing_sample_inputs validate_sample_input op_info args kwargs check_validate = os environ get PYTORCH_TEST_CHECK_VALIDATE_SPARSE_SAMPLES == sample sample_inputs op_info args kwargs sample = validate_sample_input op_info sample check_validate=check_validate isinstance sample SampleInput yield sample Error inputs handled error_inputs_sparse sample maybe_failing_sample_inputs op_info args kwargs sample = validate_sample_input op_info sample check_validate=check_validate isinstance sample SampleInput yield sample _error_inputs_sparse maybe_failing_sample_inputs validate_sample_input op_info args kwargs check_validate = os environ get PYTORCH_TEST_CHECK_VALIDATE_SPARSE_SAMPLES == sample maybe_failing_sample_inputs op_info args kwargs sample = validate_sample_input op_info sample check_validate=check_validate isinstance sample ErrorInput yield sample Sample inputs handled sample_inputs_sparse _apply_requires_grad_to_samples sample_inputs Decorator _maybe_failing_sample_inputs_ generator functions clones sets requires_grad argument tensors sample input arguments This needed when generated samples share tensor instances wrapper op_info device dtype requires_grad layout kwargs apply_requires_grad x isinstance x torch Tensor x requires_grad requires_grad x is_floating_point x is_complex x x detach clone requires_grad_ requires_grad requires_grad sample_input sample_inputs op_info device dtype requires_grad layout kwargs yield sample_input transform apply_requires_grad yield sample_inputs op_info device dtype requires_grad layout kwargs wrapper sample_inputs_sparse_reduction op_info device dtype requires_grad layout blocksize=None kwargs Sample inputs reduction operations sparse tensors layout_name = str layout split - rsplit _coo op_supports_layout = getattr op_info supports_ + layout_name op_supports_layout sample_input sample_inputs_reduction op_info device dtype requires_grad kwargs sample_input input ndim == scalar sparse tensors supported continue layout torch sparse_csr torch sparse_csc torch sparse_bsr torch sparse_bsc sample_input input ndim conversion sparse compressed tensors requires least dimensional tensors continue sample_input input ndim sample_input input == any Skip batched sparse compressed samples contain explicit zeros because to_sparse layout= will fail see gh- TODO remove if-block after gh- fixed continue layout torch sparse_bsr torch sparse_bsc blocksize None blocksize = yield SampleInput sample_input input detach to_sparse layout=layout blocksize=blocksize requires_grad_ requires_grad args=sample_input args kwargs=sample_input kwargs layout torch sparse_coo dtype is_floating_point dtype is_complex uncoalesced samples inp = sample_input input detach to_sparse layout=layout inp = torch sparse_coo_tensor inp indices repeat inp values repeat inp shape dtype=inp dtype device=inp device assert inp is_coalesced yield SampleInput inp requires_grad_ requires_grad args=sample_input args kwargs=sample_input kwargs sample_input input ndim hybrid samples yield SampleInput sample_input input detach to_sparse layout=layout blocksize=blocksize dense_dim=sample_input input ndim - requires_grad_ requires_grad args=sample_input args kwargs=sample_input kwargs _validate_sample_input_sparse_reduction op_info sample check_validate=False Return specified sample when valid supported operation Otherwise sample ErrorInput instance When check_validate True result validated against calling op sample UNSPECIFIED = object op_info name == sum sample = _validate_sample_input_sparse_reduction_sum sample op_info name == masked sum mask = sample kwargs get mask UNSPECIFIED mask None UNSPECIFIED mask ndim mask layout torch strided mask == any TODO remove if-block after gh- fixed sample = ErrorInput sample error_regex= Expect same number specified elements per batch sample kwargs get keepdim sample = ErrorInput sample error_type= AssertionError RuntimeError error_regex= reduction operations CSR &#124; CSC tensors keepdim=False unsupported mask UNSPECIFIED sample = ErrorInput sample error_type=ValueError error_regex= masked expects explicit mask sparse_csr tensor input sample input ndim sample = ErrorInput sample error_regex= crow_indices supposed vector got dimensional tensor op_info name masked amax masked amin masked mean masked prod t_inp = sample input mask = sample kwargs get mask mask None mask ndim mask layout torch strided mask == any TODO remove if-block after gh- fixed sample = ErrorInput sample error_regex= Expect same number specified elements per batch mask None sample = ErrorInput sample error_type=ValueError error_regex= masked expects explicit mask sparse_csr tensor input mask layout sample input layout mask ndim op_info name == masked mean sample = ErrorInput sample error_type=TypeError error_regex= where received invalid combination arguments - got Tensor Tensor NoneType sample kwargs get keepdim sample = ErrorInput sample error_type= AssertionError RuntimeError error_regex= reduction operations CSR &#124; CSC tensors keepdim=False unsupported sample input ndim sample kwargs get dim mask ndim mask layout torch strided sample kwargs get dim == - sample = ErrorInput sample error_regex= tensor dimensionality must sum batch base dense dimensionalities op_info name == masked prod sample = ErrorInput sample error_regex= input_dim == INTERNAL ASSERT FAILED sample = ErrorInput sample error_type=AssertionError error_regex= Sparse CSR tensors D only support reduction along dim sample input ndim sample = ErrorInput sample error_regex= crow_indices supposed vector got dimensional tensor mask layout t_inp layout mask _nnz = t_inp _nnz t_inp dense_dim sample = ErrorInput sample error_regex= Index tensor must have same number dimensions src tensor check_validate _check_validate op_info sample sample _validate_sample_input_sparse_reduction_sum sample check_validate=False NOTE When fixing failing sample case remove corresponding if-block t_inp t_kwargs = sample input sample kwargs dim = t_kwargs get dim keepdim = t_kwargs get keepdim layout = t_inp layout isinstance dim int list tuple layout torch sparse_csr torch sparse_csc torch sparse_bsr torch sparse_bsc layout torch sparse_csc torch sparse_bsr torch sparse_bsc ErrorInput sample error_regex= Currently only compressed sparse format supported sum dim_IntList CSR got layout layout torch sparse_csr torch sparse_csc keepdim ErrorInput sample error_regex= reduction operations CSR tensors keepdim=False unsupported t_inp dim = ErrorInput sample error_regex= input_dim == INTERNAL ASSERT layout == torch sparse_csr t_inp dtype == torch bool ErrorInput sample error_regex= _sparse_csr_sum_cpu implemented Bool t_inp dtype == torch complex ErrorInput sample error_regex= _sparse_csr_sum_cuda implemented ComplexHalf sample _maybe_failing_sample_inputs_sparse_reduction_sum op_info device dtype requires_grad layout kwargs Generator samples known fail failing past NOTE When fixing failing case remove Exception comment keep ` yield sample ` statement layout torch sparse_csr torch sparse_csc NotImplementedError Could run aten sum IntList_out arguments SparseCsrCPU backend yield SampleInput torch tensor dtype=dtype to_sparse layout=layout requires_grad_ requires_grad kwargs=dict dim= keepdim=True yield SampleInput torch tensor dtype=dtype to_sparse layout=layout dense_dim= requires_grad_ requires_grad kwargs=dict dim= yield SampleInput torch tensor dtype=dtype to_sparse layout=layout requires_grad_ requires_grad kwargs=dict dim= yield SampleInput torch tensor dtype=dtype to_sparse layout=layout requires_grad_ requires_grad kwargs=dict dim= keepdim=True yield SampleInput torch tensor dtype=dtype to_sparse layout=layout dense_dim= requires_grad_ requires_grad kwargs=dict dim= RuntimeError torch empty Only batched sparse compressed non-block tensors supported got size yield SampleInput torch tensor dtype=dtype to_sparse layout=layout requires_grad_ requires_grad kwargs=dict dim= layout torch sparse_bsr torch sparse_bsc RuntimeError empty_sparse_compressed expected sparse compressed non-block tensor layout got SparseBsr yield SampleInput torch tensor dtype=dtype to_sparse layout=layout blocksize= requires_grad_ requires_grad kwargs=dict dim= keepdim=True yield SampleInput torch tensor dtype=dtype to_sparse layout=layout dense_dim= blocksize= requires_grad_ requires_grad kwargs=dict dim= yield SampleInput torch tensor dtype=dtype to_sparse layout=layout blocksize= requires_grad_ requires_grad kwargs=dict dim= yield SampleInput torch tensor dtype=dtype to_sparse layout=layout blocksize= requires_grad_ requires_grad kwargs=dict dim= keepdim=True yield SampleInput torch tensor dtype=dtype to_sparse layout=layout blocksize= dense_dim= requires_grad_ requires_grad kwargs=dict dim= RuntimeError torch empty Only batched sparse compressed non-block tensors supported got size yield SampleInput torch tensor dtype=dtype to_sparse layout=layout blocksize= requires_grad_ requires_grad kwargs=dict dim= sample_inputs_sparse_reduction_sum op_info device dtype requires_grad layout kwargs Sample inputs sum sparse tensors yield _sample_inputs_sparse sample_inputs_sparse_reduction _maybe_failing_sample_inputs_sparse_reduction_sum _validate_sample_input_sparse_reduction op_info device dtype requires_grad layout kwargs error_inputs_sparse_reduction_sum op_info device layout kwargs Error inputs sum sparse tensors dtype = torch float requires_grad = False yield _error_inputs_sparse _maybe_failing_sample_inputs_sparse_reduction_sum _validate_sample_input_sparse_reduction op_info device dtype requires_grad layout kwargs sample_inputs_sparse_elementwise_binary_operation op_info device dtype requires_grad layout kwargs Sample inputs elementwise binary operations sparse tensors The samples include regular zero-sized batched hybrid sparse tensors well rhs scalars All tensors full tensors _to_sparse tensor kwargs tensor detach to_sparse kwargs requires_grad_ requires_grad sample_input generate_elementwise_binary_tensors op_info device=device dtype=dtype requires_grad=requires_grad exclude_zero=True kwargs lhs rhs = sample_input input sample_input args min_dense_dim = max_dense_dim = lhs ndim - layout torch sparse_csr torch sparse_csc torch sparse_bsr torch sparse_bsc lhs ndim sparse compressed tensors sparse_dim must continue max_dense_dim = lhs ndim - dense_dim range min_dense_dim max_dense_dim + layout torch sparse_bsr torch sparse_bsc blocksizes = lhs numel blocksizes append lhs shape lhs ndim - - dense_dim lhs shape lhs ndim - - dense_dim blocksizes = None blocksize blocksizes to_sparse_kwargs = dict layout=layout dense_dim=dense_dim blocksize=blocksize lhs_sparse = _to_sparse lhs to_sparse_kwargs rhs_sparse = _to_sparse rhs to_sparse_kwargs op sparse sparse yield SampleInput lhs_sparse args= rhs_sparse sample_input args kwargs=sample_input kwargs op sparse scalar yield SampleInput lhs_sparse args= make_tensor dtype=dtype device=device requires_grad=requires_grad sample_input args kwargs=sample_input kwargs _validate_sample_input_elementwise_binary_sparse_mul sample NOTE When fixing failing sample case remove corresponding if-block t_inp t_args = sample input sample args batch_dim = t_inp dim - t_inp dense_dim - t_inp sparse_dim layout = t_inp layout dtype = t_inp dtype layout torch sparse_csr batch_dim t_args ndim ErrorInput sample error_regex= coo_to_sparse_csr conversion Sparse SparseCsr input tensors sparse_dim = supported layout torch sparse_csc t_args ndim ErrorInput sample error_regex= Expected result Tensor format CSR layout torch sparse_bsr t_args ndim ErrorInput sample error_regex= empty_sparse_compressed expected sparse compressed non-block tensor layout got SparseBsr layout torch sparse_bsc t_args ndim ErrorInput sample error_regex= empty_sparse_compressed expected sparse compressed non-block tensor layout got SparseBsc layout torch sparse_coo dtype torch bool t_args ndim t_inp is_cpu t_inp numel t_inp dense_dim ErrorInput sample error_regex= \ addcmul_cpu_out\ implemented Bool layout torch sparse_coo torch sparse_csr dtype torch bool t_inp _nnz t_args ndim t_inp is_cpu t_inp numel ErrorInput sample error_regex= \ mul_out_sparse\ implemented Bool layout torch sparse_csr t_args layout torch strided t_args ndim t_args ndim t_inp ndim ErrorInput sample error_regex= sparse_mask_sparse_csr expects D layout torch sparse_csr t_args layout torch strided t_args ndim t_args layout layout t_inp shape = t_args shape ErrorInput sample error_regex= expects sparse inputs equal dimensionality number sparse dimensions shape sparse dimensions layout torch sparse_csr t_inp dense_dim t_inp _nnz t_inp is_cpu dtype torch float t_args ndim ErrorInput sample error_regex= \ addcmul_cpu_out\ implemented Half sample _apply_requires_grad_to_samples _maybe_failing_sample_inputs_sparse_elementwise_binary_mul op_info device dtype requires_grad layout kwargs Generator samples known fail failing past NOTE When fixing failing case remove Exception comment keep ` yield sample ` statement blocksize = layout torch sparse_bsr torch sparse_bsc None regular = torch tensor device=device dtype=dtype to_sparse layout=layout dense_dim= blocksize=blocksize batch = torch tensor device=device dtype=dtype to_sparse layout=layout dense_dim= blocksize=blocksize hybrid = torch tensor device=device dtype=dtype to_sparse layout=layout dense_dim= blocksize=blocksize layout torch sparse_csr RuntimeError crow_indices supposed vector got dimensional tensor yield SampleInput batch args= batch RuntimeError Only tensors two sparse dimensions can converted SparseCsr layout got sparse dimensions yield SampleInput torch zeros_like hybrid requires_grad_ requires_grad args= torch zeros_like hybrid requires_grad_ requires_grad dtype torch complex RuntimeError mul_out_sparse implemented ComplexHalf yield SampleInput regular args= regular dtype torch bool regular is_cpu RuntimeError mul_out_sparse implemented Bool yield SampleInput regular args= regular layout torch sparse_csc RuntimeError Expected result Tensor format CSR yield SampleInput regular args= regular layout torch sparse_bsr RuntimeError empty_sparse_compressed expected sparse compressed non-block tensor layout got SparseBsr yield SampleInput regular args= regular layout torch sparse_bsc RuntimeError empty_sparse_compressed expected sparse compressed non-block tensor layout got SparseBsc yield SampleInput regular args= regular layout torch sparse_coo dtype torch complex RuntimeError mul_out_sparse implemented ComplexHalf yield SampleInput regular args= regular dtype torch bool regular is_cpu RuntimeError mul_out_sparse implemented Bool yield SampleInput regular args= regular dtype torch bool torch float regular is_cpu RuntimeError addcmul_cpu_out implemented Bool &#124; Half yield SampleInput hybrid args= hybrid _validate_sample_input_sparse_elementwise_binary_operation op_info sample check_validate=False op_info name == mul sample = _validate_sample_input_elementwise_binary_sparse_mul sample check_validate _check_validate op_info sample sample sample_inputs_sparse_mul op_info device dtype requires_grad layout kwargs Sample inputs mul operation sparse tensors yield _sample_inputs_sparse sample_inputs_sparse_elementwise_binary_operation _maybe_failing_sample_inputs_sparse_elementwise_binary_mul _validate_sample_input_sparse_elementwise_binary_operation op_info device dtype requires_grad layout kwargs error_inputs_sparse_mul op_info device layout kwargs Error inputs mul operation sparse tensors dtype = torch float requires_grad = False yield _error_inputs_sparse _maybe_failing_sample_inputs_sparse_elementwise_binary_mul _validate_sample_input_sparse_elementwise_binary_operation op_info device dtype requires_grad layout kwargs _sample_inputs_sparse_like_fns op_info device dtype requires_grad layout kwargs torch testing _internal common_utils TestCase tensor TestCase generate_simple_inputs layout device=device dtype=dtype enable_batch=True enable_hybrid=True enable_zero_sized=True enable_non_contiguous_indices=False enable_non_contiguous_values=False yield SampleInput tensor args= kwargs= yield SampleInput tensor args= kwargs=dict device=device dtype=dtype layout=layout dtype torch float yield SampleInput tensor args= kwargs=dict dtype=torch float torch cuda is_available other_device = cuda tensor device type == cpu cpu yield SampleInput tensor args= kwargs=dict device=other_device layout torch sparse_csr other_layout = torch sparse_csc layout torch sparse_csc other_layout = torch sparse_csr layout torch sparse_bsr other_layout = torch sparse_bsc layout torch sparse_bsc other_layout = torch sparse_bsr other_layout = torch strided yield SampleInput tensor args= kwargs=dict layout=other_layout layout torch sparse_coo yield SampleInput tensor args= kwargs=dict layout=torch sparse_coo _validate_sample_input_sparse_like_fns op_info sample check_validate=False sample input layout torch sparse_csr torch sparse_csc torch sparse_bsr torch sparse_bsc op_info name = zeros_like sample kwargs get layout sample input layout = sample input layout ErrorInput sample error_regex= empty_like different sparse layout supported \\ Sparse Csc &#124; Csr &#124; Bsc &#124; Bsr you requested Sparse Csr &#124; Csc &#124; Bsr &#124; Bsc \\ sample input layout torch sparse_coo ErrorInput sample error_regex= Could run aten normal_ arguments Sparse CPU &#124; CUDA backend check_validate _check_validate op_info sample sample _maybe_failing_sample_inputs_sparse_like_fns op_info device dtype requires_grad layout kwargs torch cuda is_available layout torch sparse_coo other_device = cuda torch device device type == cpu cpu layout torch sparse_csr other_layout = torch sparse_csc layout torch sparse_csc other_layout = torch sparse_csr layout torch sparse_bsr other_layout = torch sparse_bsc layout torch sparse_bsc other_layout = torch sparse_bsr other_layout = torch strided blocksize = layout torch sparse_bsr torch sparse_bsc None yield SampleInput torch tensor dtype=dtype device=device to_sparse layout=layout blocksize=blocksize kwargs=dict device=other_device yield SampleInput torch tensor dtype=dtype device=device to_sparse layout=layout blocksize=blocksize kwargs=dict layout=other_layout sample_inputs_sparse_like_fns op_info device dtype requires_grad layout kwargs Sample inputs like-functions sparse tensors yield _sample_inputs_sparse _sample_inputs_sparse_like_fns _maybe_failing_sample_inputs_sparse_like_fns _validate_sample_input_sparse_like_fns op_info device dtype requires_grad layout kwargs error_inputs_sparse_like_fns op_info device layout kwargs Error inputs like-functions sparse tensors dtype = torch float requires_grad = False yield _error_inputs_sparse _maybe_failing_sample_inputs_sparse_like_fns _validate_sample_input_sparse_like_fns op_info device dtype requires_grad layout kwargs _validate_sample_input_sparse_default op_info sample check_validate=False op_info name == to_sparse sample input layout torch sparse_csr torch sparse_csc torch sparse_bsr torch sparse_bsc len sample args == isinstance sample args int sample args = sample = ErrorInput sample error_regex= sparse dim argument must sparse_compressed_to_sparse check_validate _check_validate op_info sample sample validate_sample_input_sparse op_info sample check_validate=False Return specified sample when valid supported operation Otherwise sample ErrorInput instance When check_validate True result validated against calling op sample isinstance op_info ReductionOpInfo _validate_sample_input_sparse_reduction op_info sample check_validate=check_validate isinstance op_info BinaryUfuncInfo _validate_sample_input_sparse_elementwise_binary_operation op_info sample check_validate=check_validate _validate_sample_input_sparse_default op_info sample check_validate=check_validate