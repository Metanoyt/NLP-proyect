Owner s oncall distributed copy deepcopy torch torch nn nn torch distributed _composable _get_registry contract torch testing _internal common_utils run_tests skipIfTorchDynamo TestCase ToyModel nn Module __init__ - None super __init__ seq = nn Sequential nn Linear _ range seq = nn Sequential nn Linear _ range p = nn Parameter torch randn requires_grad=True b = torch zeros buffer forward x y torch no_grad b += x sum + y sum p + seq x + seq y TestContract TestCase skipIfTorchDynamo Dynamo does support state key test_add_hooks forward_pre_hook module nn Module inp tuple torch Tensor - tuple torch Tensor inp forward_hook module nn Module inp tuple torch Tensor out torch Tensor - torch Tensor out backward_pre_hook module nn Module grad_output torch Tensor - torch Tensor grad_output backward_hook module nn Module grad_input tuple torch Tensor grad_output torch Tensor - tuple torch Tensor grad_input contract noop_api module nn Module - nn Module module register_forward_pre_hook forward_pre_hook module register_forward_hook forward_hook module register_full_backward_pre_hook backward_pre_hook module register_full_backward_hook backward_hook module model = ToyModel model_with_hooks = deepcopy model noop_api model seq noop_api model seq x y = torch randn torch randn model x y sum backward model_with_hooks x y sum backward p p zip model parameters model_with_hooks parameters assertEqual p p skipIfTorchDynamo Dynamo does support state key test_modify_fqn ModelWrapper nn Module __init__ module super __init__ module = module forward x module x contract wrap_module module nn Module - nn Module ModelWrapper module model = ToyModel regex = Checking parameters Composable distributed API implementations cannot modify FQNs assertRaisesRegex RuntimeError regex wrap_module model seq skipIfTorchDynamo Dynamo does support state key test_state check_and_update_state_hook module nn Module inp tuple torch Tensor - tuple torch Tensor assertEqual api state module dummy_state api state module dummy_state = inp FIXME circular reference looks bit weird Shall we make state top-level API instead attached contract API contract api module nn Module - nn Module api state module dummy_state = module register_forward_pre_hook check_and_update_state_hook module model = ToyModel api model seq assertEqual api state model seq dummy_state model torch zeros torch zeros assertEqual api state model seq dummy_state skipIfTorchDynamo Dynamo does support state key test_registry contract api module nn Module - nn Module module contract api module nn Module - nn Module module model = ToyModel model = api model assertEqual len _get_registry model assertTrue api _get_registry model model = api model assertEqual len _get_registry model assertTrue _get_registry model keys api api assertEqual None _get_registry model seq assertEqual None _get_registry model seq assertRaisesRegex AssertionError api has already been applied model = api model skipIfTorchDynamo Dynamo does support state key test_multi_module_api contract multi_module_api modules list nn Module - nn Module modules model = nn Sequential nn Linear _ range multi_module_api model model multi_module_api model model multi_module_api model Check modules have same state registry iff they shared same API call states = multi_module_api state module module model assertEqual states states assertEqual states states assertNotEqual states states assertNotEqual states states assertNotEqual states states registries = _get_registry module module model assertEqual registries registries assertEqual registries registries assertNotEqual registries registries assertNotEqual registries registries assertNotEqual registries registries Check applying API module multiple times errors model = nn Sequential nn Linear _ range multi_module_api model model assertRaisesRegex AssertionError Each distinct composable distributed API can only applied r module once multi_module_api has already been applied following module multi_module_api model model __name__ == __main__ run_tests