This module provides iterator-related variable tracking functionality Dynamo It implements variable classes handling Python iterators itertools functions during symbolic execution tracing The module includes - Base iterator variable classes tracking iterator state - Implementations built-in iterators zip map filter - Support itertools functions product accumulate combinations etc - Mutation tracking reconstruction capabilities iterator operations These classes integrate Dynamo s variable tracking system enable proper handling iterator operations during code transformation optimization itertools collections abc Callable typing Any Sequence TYPE_CHECKING Union graph_break_hints polyfills variables bytecode_transformation create_build_tuple create_call_function create_call_function_ex create_instruction exc handle_observed_exception ObservedUserStopIteration raise_observed_exception unimplemented_v UserError base ValueMutationNew VariableTracker constant ConstantVariable TYPE_CHECKING torch _dynamo codegen PyCodegen torch _dynamo symbolic_convert InstructionTranslator MAX_ITERATOR_LIMIT = k ItertoolsVariable VariableTracker __init__ value Any kwargs Any - None super __init__ kwargs value = value __repr__ - str f ItertoolsVariable value as_python_constant - Any value call_function tx InstructionTranslator args Sequence VariableTracker kwargs dict str VariableTracker - VariableTracker See also module ` torch _dynamo polyfills itertools ` value itertools product any kw = repeat kw kwargs keys unimplemented_v gb_type= Unsupported kwargs itertools product context=f call_function args kwargs explanation=f Expected kwargs repeat got f join set kwargs keys - repeat hints= graph_break_hints USER_ERROR repeat kwargs keys r = kwargs repeat as_python_constant r = seqs = arg force_unpack_var_sequence tx arg args items = variables TupleVariable list item item itertools product seqs repeat=r variables ListIteratorVariable items mutation_type=ValueMutationNew value itertools combinations kwargs len args == args has_unpack_var_sequence tx args is_python_constant iterable = args unpack_var_sequence tx r = args as_python_constant items = item itertools combinations iterable r items append variables TupleVariable list item variables ListIteratorVariable items mutation_type=ValueMutationNew value itertools groupby any kw = key kw kwargs keys unimplemented_v gb_type= Unsupported kwargs itertools groupby context=f call_function args kwargs explanation=f Expected kwargs key got f join set kwargs keys - key hints= graph_break_hints USER_ERROR retrieve_const_key key VariableTracker - Any isinstance key variables SymNodeVariable key evaluate_expr isinstance key variables ConstantVariable key as_python_constant unimplemented_v gb_type= Unsupported key type itertools groupby context=f call_function args kwargs explanation= Dynamo does know how trace f itertools groupby key type str type key We only support grouping keys constants int float str etc hints= graph_break_hints SUPPORTABLE len args == args has_unpack_var_sequence tx seq = args unpack_var_sequence tx unimplemented_v gb_type= Unsupported arguments itertools groupby context=f call_function args kwargs explanation= Dynamo does know how trace f itertools groupby args args kwargs kwargs itertools groupby expects iterable group optional key function determine groupings hints= Make sure arguments itertools groupby correct graph_break_hints SUPPORTABLE key kwargs keyfunc x VariableTracker - Any retrieve_const_key kwargs get key call_function tx x type ignore union-attr keyfunc x VariableTracker - Any retrieve_const_key x result = try k v itertools groupby seq key=keyfunc result append variables TupleVariable variables ConstantVariable create k variables ConstantVariable is_literal k k variables ListIteratorVariable list v mutation_type=ValueMutationNew mutation_type=ValueMutationNew except Exception e unimplemented_v gb_type= Unexpected failure during itertools groupby iteration context=f call_function args kwargs explanation= Unexpected failure invoking function during groupby hints= graph_break_hints SUPPORTABLE from_exc=e variables ListIteratorVariable result mutation_type=ValueMutationNew value itertools repeat len args variables RepeatIteratorVariable args mutation_type=ValueMutationNew tx inline_user_function_return VariableTracker build tx polyfills repeat args kwargs value itertools count variables CountIteratorVariable args mutation_type=ValueMutationNew value itertools permutations len args == len args == args is_python_constant kwargs len args == r = args as_python_constant r = None items = variables TupleVariable list item item itertools permutations args force_unpack_var_sequence tx r variables ListIteratorVariable items mutation_type=ValueMutationNew super call_function tx args kwargs IteratorVariable VariableTracker __init__ kwargs Any - None super __init__ kwargs next_variable tx InstructionTranslator - VariableTracker unimplemented_v gb_type= Unimplemented next call context=f next explanation= This abstract method must implemented hints= graph_break_hints DYNAMO_BUG NOTE only call when unpacking iterator safely done eagerly Normally iterators accessed lazily Example safe eager unpacking list map f seq Example unsafe eager unpacking list islice map f seq force_unpack_var_sequence tx InstructionTranslator - list VariableTracker result list VariableTracker = force_apply_to_var_sequence tx result append result force_apply_to_var_sequence tx InstructionTranslator fn Callable Any Any - None while True try fn next_variable tx except ObservedUserStopIteration handle_observed_exception tx break don t call force_unpack_var_sequence since can mutate IteratorVariable state has_force_unpack_var_sequence tx InstructionTranslator - bool True call_obj_hasattr tx InstructionTranslator name str - VariableTracker name == __iter__ name == __next__ variables ConstantVariable create True super call_obj_hasattr tx name call_method tx InstructionTranslator name str args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __iter__ name == __next__ next_variable tx super call_method tx name args kwargs ObjectIteratorVariable IteratorVariable VariableTracker iter obj implements iterator protocol i e has ` __next__ ` method We use track state iterator handle case when iterator exhausted Example usage b = iter obj list b exhaust iterator list b empty list __init__ obj VariableTracker kwargs Any - None super __init__ kwargs obj = obj generator_exhausted = False next_variable tx InstructionTranslator - VariableTracker generator_exhausted raise_observed_exception StopIteration tx try obj next_variable tx except ObservedUserStopIteration Do rely object always StopIteration once exhausted generator_exhausted = True raise RepeatIteratorVariable IteratorVariable __init__ item VariableTracker kwargs Any - None super __init__ kwargs item = item Repeat needs no mutation clone next_variable tx InstructionTranslator - VariableTracker item reconstruct codegen PyCodegen - None codegen add_push_null lambda codegen extend_output codegen create_load_python_module itertools codegen create_load_attr repeat codegen item codegen extend_output create_call_function False CountIteratorVariable IteratorVariable __init__ item Union int VariableTracker = step Union int VariableTracker = kwargs Any - None super __init__ kwargs isinstance item VariableTracker item = ConstantVariable create item isinstance step VariableTracker step = ConstantVariable create step item = item step = step next_variable tx InstructionTranslator - VariableTracker assert is_mutable old_item = item tx output side_effects mutation item = item call_method tx __add__ step old_item reconstruct codegen PyCodegen - None codegen add_push_null lambda codegen extend_output codegen create_load_python_module itertools codegen create_load_attr count codegen item codegen step codegen extend_output create_call_function False ZipVariable IteratorVariable Represents zip iterables _nonvar_fields = index strict IteratorVariable _nonvar_fields __init__ iterables list VariableTracker strict bool = False kwargs Any - None super __init__ kwargs assert isinstance iterables list can list Variable VariableTracker next_variable implemented iterables = iterables index = strict = strict python_type - type zip type ignore type-arg zip has_unpack_var_sequence tx InstructionTranslator - bool all isinstance list has_unpack_var_sequence tx iterables unpack_var_sequence tx InstructionTranslator - list VariableTracker assert has_unpack_var_sequence tx iterables = iterables isinstance list iterables append index iterables append unpack_var_sequence tx kwargs = strict strict strict zipped = zip iterables kwargs variables TupleVariable list var var zipped next_variable tx InstructionTranslator - VariableTracker assert is_mutable len iterables == raise_observed_exception StopIteration tx old_index = index args = get_item Union list VariableTracker VariableTracker - VariableTracker isinstance list old_index = len raise_observed_exception StopIteration tx old_index next_variable tx idx int &#124; None = None try idx enumerate iterables noqa B args append get_item except ObservedUserStopIteration strict idx == all other iterables should exhausted iterables try get_item except ObservedUserStopIteration handle_observed_exception tx continue no ObservedUserStopIteration - fall through UserError break all iterables exhausted raise original error raise handle_observed_exception tx raise UserError ValueError type ignore arg-type zip has one argument len differing others None raise tx output side_effects mutation index += variables TupleVariable args reconstruct_items codegen PyCodegen - None iterables isinstance list remaining_items = index codegen foreach remaining_items codegen append_output create_build_tuple len remaining_items codegen reconstruct codegen PyCodegen - None codegen add_push_null lambda codegen load_import_from builtins zip call_function_ex=True reconstruct_items codegen codegen append_output create_build_tuple len iterables codegen extend_output codegen create_load_const strict codegen create_load_const strict create_instruction BUILD_MAP arg= create_call_function_ex True False MapVariable ZipVariable Represents map fn iterables __init__ fn VariableTracker iterables list VariableTracker kwargs Any - None super __init__ iterables kwargs fn = fn python_type - type map has_unpack_var_sequence tx InstructionTranslator - bool False next_variable tx InstructionTranslator - VariableTracker args = super next_variable tx fn call_function tx args items type ignore attr-defined reconstruct codegen PyCodegen - None codegen add_push_null lambda codegen load_import_from builtins map call_function_ex=True codegen fn reconstruct_items codegen codegen extend_output create_build_tuple len iterables + create_call_function_ex False False FilterVariable IteratorVariable Represents filter fn iterable _nonvar_fields = index IteratorVariable _nonvar_fields __init__ fn VariableTracker iterable list VariableTracker kwargs Any - None super __init__ kwargs fn = fn iterable = iterable index = python_type - type filter has_unpack_var_sequence tx InstructionTranslator - bool isinstance iterable list iterable has_unpack_var_sequence tx unpack_var_sequence tx InstructionTranslator - list VariableTracker assert has_unpack_var_sequence tx = None isinstance iterable list = iterable index = iterable unpack_var_sequence tx filtered = fn call_function tx variables TupleVariable filtered next_variable tx InstructionTranslator - VariableTracker _next - VariableTracker old_index = index isinstance iterable list old_index = len iterable raise_observed_exception StopIteration tx iterable old_index iterable next_variable tx A do-while loop find elements make fn true while True item = _next index += isinstance fn ConstantVariable fn value None res = item res = fn call_function tx item pred_res = variables UserFunctionVariable polyfills predicate call_function tx res pred_res as_python_constant item reconstruct_items codegen PyCodegen - None isinstance iterable list remaining_items = iterable index codegen foreach remaining_items codegen append_output create_build_tuple len remaining_items codegen iterable reconstruct codegen PyCodegen - None codegen add_push_null lambda codegen load_import_from builtins filter codegen fn reconstruct_items codegen codegen extend_output create_call_function False