Owner s oncall jit ruff noqa F os sys typing Any Tuple torch torch nn nn Make helper files test importable pytorch_test_dir = os path dirname os path dirname os path realpath __file__ sys path append pytorch_test_dir typing List torch Tensor torch jit Future torch testing _internal common_utils raise_on_run_directly torch testing _internal jit_utils _inline_everything JitTestCase TestAsync JitTestCase test_async_python torch jit script foo x torch neg x x = torch rand fut = torch jit fork foo x y_hat = foo x y = torch jit wait fut assert nothing only make sure fake python path works test_async_future_type_python foo inp futures = torch jit annotate List torch jit Future torch Tensor _ range futures append torch jit fork lambda x x inp all_outputs = future futures all_outputs append torch jit wait future all_outputs assert nothing just make sure python type parsing works foo torch randn test_async_parsing torch jit script foo x Tensor - List Tensor torch neg x x t torch jit script bar x futures = torch jit annotate List Future List Tensor _ range future = torch jit annotate Future List Tensor torch jit fork foo x futures append future output = torch jit annotate List List Tensor i range output append torch jit wait futures i output x = torch rand result = bar x assertEqual len result test_async_script torch jit script foo x torch neg x x x = torch rand torch jit script wait_script x fut = torch jit fork foo x y_hat = foo x y = torch jit wait fut y y_hat y y_hat = wait_script x assertEqual y y_hat test_async_script_capture Mod torch jit ScriptModule __constants__ = const __init__ - None super __init__ const = param = nn Parameter torch randn torch jit script_method foo x x torch neg x param const torch neg x param torch jit script_method forward x x fut = torch jit fork foo x x y_hat = foo x x y = torch jit wait fut y y_hat x = torch rand x = torch rand m = Mod torch jit optimized_execution False y y_hat = m forward x x assertEqual y y_hat test_async_script_nested torch jit script foo x torch neg x x x = torch rand torch jit script wait_script x fut = torch jit _fork foo x y_hat = foo x y = torch jit _wait fut y y_hat torch jit script wait_script_nest x fut = torch jit _fork wait_script x torch jit _wait fut y y_hat = wait_script_nest x assertEqual y y_hat test_async_script_no_script_mod x = torch rand assertRaisesRegexWithHighlight RuntimeError cannot call value torch jit _fork x torch jit script wait_script x fut = torch jit _fork x fut test_async_script_multi_waits torch jit script foo x torch neg x t + x torch jit script wait_script x fut = torch jit _fork foo x wait twice same future y = torch jit _wait fut y = torch jit _wait fut y y x = torch rand y y = wait_script x assertEqual y y test_async_script_multi_forks torch jit script foo x torch neg x t + x torch jit script foo x y torch neg x t + x + torch neg y t torch jit script foo x y z torch neg z t + y t + x x = torch rand x = torch rand x = torch rand torch jit script wait_script x x x f = torch jit _fork foo x f = torch jit _fork foo x x f = torch jit _fork foo x x x f = torch jit _fork foo x f = torch jit _fork foo x x ignore some forks y = torch jit _wait f y = torch jit _wait f y = torch jit _wait f y y y y y y = wait_script x x x assertEqual y foo x assertEqual y foo x x assertEqual y foo x x x test_async_kwargs foo x x x + x x = torch rand x = torch rand y_hat = foo x x Cover tracing bare functions permutations args kwargs func lambda x x torch jit _wait torch jit _fork foo x x lambda x x torch jit _wait torch jit _fork foo x x =x lambda x x torch jit _wait torch jit _fork foo x =x x =x lambda x x torch jit _wait torch jit _fork foo x =x x =x wrapper func torch jit trace func x x assertEqual wrapper x x y_hat assertEqual wrapper x x =x y_hat assertEqual wrapper x =x x =x y_hat assertEqual wrapper x =x x =x y_hat Cover scripting torch jit script foo_script_args x x torch jit _wait torch jit _fork foo x x torch jit script foo_script_kwargs x x torch jit _wait torch jit _fork foo x =x x =x wrapper foo_script_args foo_script_kwargs assertEqual wrapper x x y_hat assertEqual wrapper x x =x y_hat assertEqual wrapper x =x x =x y_hat assertEqual wrapper x =x x =x y_hat _inline_everything test_async_script_trace Traced nn Module forward x torch neg x x Mod torch jit ScriptModule __init__ - None super __init__ x = torch rand traced = torch jit trace Traced x _force_outplace=True torch jit script_method forward x Tensor - Tuple List Tensor Tuple Tensor Tensor Tensor future = torch jit _fork traced x future = torch jit _fork torch neg x tensor_tuple = torch jit _wait future tensor_single = torch jit _wait future tensor_list = tensor_list append tensor_tuple tensor_list append tensor_single nested structure tensors tensor_list tensor_tuple tensor_tuple TupleCl nn Module __init__ - None super __init__ module = Mod forward x z = torch neg x y = module x list = z y y y y y tuple list x = torch rand module = torch jit trace TupleCl x _force_outplace=True Make sure we have forks assertGraphContainsExactly module graph kind= prim fork num_kind_nodes= Make sure neg root graph negs subgraphs assertGraphContainsExactly module graph kind= aten neg num_kind_nodes= assertGraphContainsExactly module graph kind= aten neg num_kind_nodes= consider_subgraphs=True y = torch neg x assertEqual module x y y y y x x test_async_script_error x = torch rand torch jit script foo x error here x t + x torch jit script wait_script x fut = torch jit _fork foo x torch jit _wait fut torch jit script wait_script_nest x fut = torch jit _fork wait_script x torch jit _wait fut no future error_msg = The size must match size tensor assertRaisesRegexWithHighlight Exception error_msg x t + x foo x one future assertRaisesRegexWithHighlight Exception error_msg torch jit _fork foo x wait_script x two futures different error x = torch rand assertRaisesRegexWithHighlight Exception expects tensor = dimensions torch jit _fork wait_script x wait_script_nest x test_async_grad_guard_with_grad torch jit script foo x y = x y requires_grad torch jit script bar x fut = torch jit _fork foo x requires_grad_in_fork = torch jit _wait fut z = x requires_grad_in_fork z requires_grad x = torch randn requires_grad=True torch enable_grad inside_fork after_wait = bar x assertEqual inside_fork True assertEqual after_wait True test_async_grad_guard_no_grad torch jit script foo x y = x y requires_grad torch jit script bar x fut = torch jit _fork foo x requires_grad_in_fork = torch jit _wait fut z = x requires_grad_in_fork z requires_grad x = torch randn requires_grad=True torch no_grad inside_fork after_wait = bar x assertEqual inside_fork False assertEqual after_wait False test_trace_fork_wait fork_body x x neg x neg + fn x fut = torch jit _fork fork_body x vals = torch jit _wait fut vals vals x - traced = torch jit trace fn torch rand x = torch rand assertEqual fn x traced x assertGraphContainsExactly traced graph kind= prim fork num_kind_nodes= assertGraphContainsExactly traced graph kind= aten wait num_kind_nodes= assertGraphContainsExactly traced graph kind= aten neg num_kind_nodes= consider_subgraphs=True test_trace_fork_wait_leaking my_list = fork_body x my_list append x + x + fn x fut = torch jit _fork fork_body x val = torch jit _wait fut my_list assertRaisesRegexWithHighlight RuntimeError did have observable data dependence trace inputs probably indicates your program cannot understood tracer traced = torch jit trace fn torch rand check_trace=False test_trace_fork_wait_inline fork_body x x + x + fn x fut = torch jit _fork fork_body x val = torch jit _wait fut val traced = torch jit trace fn torch rand torch _C _jit_pass_inline_fork_wait traced graph assertGraphContainsExactly traced graph kind= prim fork num_kind_nodes= assertGraphContainsExactly traced graph kind= aten wait num_kind_nodes= assertGraphContainsExactly traced graph kind= aten add num_kind_nodes= test_trace_fork_wait_list_modulecalls add_one input input + torch ones input size TestListFutureModule nn Module forward input input_list = _ range input_list append input fut_list List Future torch Tensor = input_tensor input_list fut_list append torch jit _fork add_one input_tensor list future tensor here ensure tracing module calls correct types fut_list TestModuleWrapper nn Module __init__ - None super __init__ list_fut_mod = TestListFutureModule forward input fut_list = list_fut_mod input res = input fut fut_list res = res + fut wait res checkTrace TestModuleWrapper torch randn test_trace_modulecalls_with_different_output_types add_one input input + torch ones input size DifferentOutputModule nn Module forward input fut_res = torch jit _fork add_one input different types module call input fut_res TestModule nn Module __init__ - None super __init__ gen_output = DifferentOutputModule forward input res fut_res = gen_output input res = res + fut_res wait res checkTrace TestModule torch randn test_no_future_subtype_message assertRaisesRegexWithHighlight RuntimeError Future without contained type torch jit script forward x futs = torch jit annotate List torch jit Future test_future_subtyping Test futures subtype each other properly Successful subtyping returns_int x int - int x + x + returns_future_any x int - torch jit Future Any torch jit _fork returns_int x torch jit script fn_int x int - Any fut = returns_future_any x fut wait Unsuccessful subtyping assertRaisesRegexWithHighlight RuntimeError r annotated having type Future\ float\ actually type Future\ int\ fut = returns_future_float x returns_future_float x int - torch jit Future float torch jit _fork returns_int x torch jit script fn_float x int - Any fut = returns_future_float x fut wait __name__ == __main__ raise_on_run_directly test test_jit py