__future__ annotations typing NoReturn TYPE_CHECKING torchgen api types ArrayRefCType BaseCType Binding boolT ConstRefCType deviceT Expr intArrayRefT iOptTensorListRefT layoutT ListCType longT memoryFormatT MutRefCType NamedCType opmath_t OptionalCType optionalIntArrayRefT optionalScalarRefT optionalSymIntArrayRefT optionalTensorRefT scalar_t scalarT scalarTypeT SpecialArgName symIntArrayRefT SymIntT tensorOptionsT tensorT VectorCType TYPE_CHECKING collections abc Sequence This file implements small program synthesis engine implements conversions between one API another The key data type file NamedCType short Named C++ semantic type A NamedCType represents C++ type plus semantic information about what represents For example consider argument bool pin_memory its normal C++ type bool its C++ semantic type also keeps track represents pin_memory you can t just use random other boolean context where you need pin_memory The translator takes list needed NamedCTypes then figures out how construct expressions these NamedCTypes given bindings Many these expressions trivial I need Tensor other there s Tensor other scope others more nontrivial may require packing unpacking Some examples non-trivial action - Need dtype binding Well maybe dtype isn t available context instead options you need extract there Gather - Need context binding Well maybe context isn t available context you need construct dtype device etc Scatter - Need memory_format binding Well actually s available both memory_format options so you had better make sure they consistent Join options_ctype = NamedCType options ConstRefCType BaseCType tensorOptionsT out_tensor_ctype = NamedCType out ConstRefCType BaseCType tensorT longVec_ctype = VectorCType BaseCType longT longSymVec_ctype = VectorCType BaseCType SymIntT optionalLongVec_ctype = OptionalCType VectorCType BaseCType longT optionalScalar_ctype = OptionalCType BaseCType scalarT optionalTensor_ctype = OptionalCType BaseCType tensorT UnsatError RuntimeError pass Given set in-scope bindings set target bindings synthesize list expressions uses only in-scope bindings bindings have all types goals You may want use function you re generating code function like void f args g exprs g different API you need generate exprs Typically list Bindings convenient get you usually call something like arguments get them technically you only need less information bindings un-ordered list Exprs sufficient similarly goals ordered list NamedCType goals sufficient If you doing something more complicated e g tracking set bindings context you may find using these smaller types more convenient translate bindings Sequence Expr &#124; Binding goals Sequence NamedCType &#124; Binding method bool = False allow_expensive_conversions bool = False - list Expr binding_exprs list Expr = b bindings isinstance b Binding binding_exprs append Expr expr=b name type=b nctype binding_exprs append b goal_ctypes list NamedCType = g goals isinstance g Binding goal_ctypes append g nctype goal_ctypes append g Add all bindings context ctx dict NamedCType str = b binding_exprs ctx b type = b expr While we re do some simple forward inference looking through constructors NB When should you do forward inference versus backward inference The general idea - Backward inference WHEN goal gets smaller - Forward inference WHEN hypothesis gets smaller This helps ensure termination backward inference starts goal tries make simpler simpler until s trivial goal can grow size we blow up really huge goal size Similarly forward inference we take hypotheses decompose them into simpler hypotheses hypotheses could expand size we also have potential nontermination In code below forward inference only ever carried out single step you could imagine repeated application forward inference being profitable A good starting point literature exploring more about proof search these lecture notes https www cs cmu edu ~fp courses oregon-m -focusing pdf TODO My kingdom pattern matcher https www python org dev peps pep- TODO This could get us recomputation trouble b expr nontrivial Fix implementing some sort sharing so multiple goals share same expression we only compute once This seems matter practice compiler often unwilling CSE nontrivial expressions like scalar scalar_t t = b type isinstance t ConstRefCType isinstance t elem OptionalCType isinstance t elem elem BaseCType str t elem elem type == Tensor ctx NamedCType t elem elem name ConstRefCType BaseCType tensorT = f b expr has_value b expr Tensor t type == ConstRefCType OptionalCType BaseCType tensorT ctx NamedCType t name BaseCType optionalTensorRefT = f b expr has_value b expr defined OptionalTensorRef b expr OptionalTensorRef t type == ConstRefCType BaseCType scalarT ctx NamedCType t name BaseCType opmath_t = f b expr opmath_t t type == ConstRefCType OptionalCType BaseCType scalarT ctx NamedCType t name BaseCType optionalScalarRefT = f b expr has_value OptionalScalarRef b expr value OptionalScalarRef t type == BaseCType scalar_t ctx NamedCType t name BaseCType opmath_t = f static_cast opmath_t b expr Note IOptTensorListRef t type == ConstRefCType ListCType OptionalCType BaseCType tensorT ctx NamedCType t name BaseCType iOptTensorListRefT = f IOptTensorListRef b expr Add implicit bindings generated code inside Tensor method method ctx NamedCType MutRefCType BaseCType tensorT = const_cast Tensor ctx NamedCType ConstRefCType BaseCType tensorT = const_cast Tensor This better Byte-for-byte compat ctx NamedCType ConstRefCType BaseCType tensorT = unsat goal NamedCType - NoReturn ctx_desc = \n join f t cpp_type t name e t e ctx items raise UnsatError f Failed synthesize expression goal cpp_type goal name When I failed following bindings available context ctx_desc This probably means there missing rule rules torchgen api translate Check module more information A shitty backtracking search implementation It s shitty because does backtracking via stack bad idea most part tries avoid backtracking In particular direct=True we won t try do any fancy synthesis just trivial conversions e g T OK const T So all existing rules function simply try solve immediately bail things don t work out solve goal NamedCType direct bool - str direct_solve goal NamedCType - str solve goal direct=True goal ctx Trivial ctx goal const satisfied mutable isinstance goal type ConstRefCType try WARNING strictly decreasing careful add direct conversion goes satisfies mutable const solve NamedCType goal name MutRefCType goal type elem direct=direct except UnsatError pass mutable satisfied value isinstance goal type MutRefCType try solve NamedCType goal name goal type elem direct=direct except UnsatError pass TODO These referentially equal shouldn t have do ensuring we don t use type synonym IntArrayRef codegen would help goal type == ArrayRefCType BaseCType longT solve NamedCType goal name BaseCType intArrayRefT direct=direct direct unsat goal For now all these rules mutually exclusive goal == NamedCType memory_format OptionalCType BaseCType memoryFormatT memory_format = direct_solve NamedCType SpecialArgName possibly_redundant_memory_format OptionalCType BaseCType memoryFormatT No need join memory_format options target API takes options directly Otherwise will cause redundant memory_format error options_ctype goal_ctypes memory_format try options = direct_solve options_ctype f c impl check_tensor_options_and_extract_memory_format options memory_format except UnsatError memory_format goal == NamedCType options BaseCType tensorOptionsT dtype = direct_solve NamedCType dtype OptionalCType BaseCType scalarTypeT pin_memory = direct_solve NamedCType pin_memory OptionalCType BaseCType boolT device = direct_solve NamedCType device OptionalCType BaseCType deviceT layout = direct_solve NamedCType layout OptionalCType BaseCType layoutT f TensorOptions dtype dtype layout layout device device pinned_memory pin_memory goal == NamedCType dtype OptionalCType BaseCType scalarTypeT try options = direct_solve options_ctype f c optTypeMetaToScalarType options dtype_opt except UnsatError out_tensor = direct_solve out_tensor_ctype f out_tensor scalar_type goal == NamedCType layout OptionalCType BaseCType layoutT try options = direct_solve options_ctype f options layout_opt except UnsatError out_tensor = direct_solve out_tensor_ctype f out_tensor layout goal == NamedCType device OptionalCType BaseCType deviceT try options = direct_solve options_ctype f options device_opt except UnsatError out_tensor = direct_solve out_tensor_ctype f out_tensor device goal == NamedCType pin_memory OptionalCType BaseCType boolT try options = direct_solve options_ctype f options pinned_memory_opt except UnsatError If we re calling factory op its out= variant We don t actually care about value pin_memory out_tensor = direct_solve out_tensor_ctype std nullopt We can always do translations value types reference types like vector int - IntArrayRef goal type == BaseCType intArrayRefT try direct_solve NamedCType goal name longVec_ctype except UnsatError We can also go SymIntArrayRef - IntArrayRef symIntArrayRef_type = direct_solve NamedCType goal name BaseCType symIntArrayRefT f C _AS_INTARRAYREF_SLOW symIntArrayRef_type goal type == BaseCType symIntArrayRefT try r = direct_solve NamedCType goal name BaseCType intArrayRefT f c fromIntArrayRefSlow r except UnsatError direct_solve NamedCType goal name longSymVec_ctype goal type == BaseCType SymIntT direct_solve NamedCType goal name BaseCType longT goal type == OptionalCType BaseCType SymIntT argname = direct_solve NamedCType goal name OptionalCType BaseCType longT f argname has_value std make_optional c SymInt argname std nullopt goal type == BaseCType longT symInt_type = direct_solve NamedCType goal name BaseCType SymIntT f symInt_type guard_int __FILE__ __LINE__ goal type == OptionalCType BaseCType longT argname = direct_solve NamedCType goal name OptionalCType BaseCType SymIntT f argname has_value std make_optional argname - guard_int __FILE__ __LINE__ std nullopt goal type == BaseCType optionalIntArrayRefT try direct_solve NamedCType goal name optionalLongVec_ctype except UnsatError argname = direct_solve NamedCType goal name BaseCType optionalSymIntArrayRefT f argname has_value std make_optional C _AS_INTARRAYREF_SLOW argname std nullopt goal type == BaseCType optionalSymIntArrayRefT TODO You might also want solve longSymVec_ctype optional version argname = direct_solve NamedCType goal name BaseCType optionalIntArrayRefT f argname has_value std make_optional c fromIntArrayRefSlow argname std nullopt goal type == BaseCType optionalScalarRefT direct_solve NamedCType goal name optionalScalar_ctype goal type == BaseCType optionalTensorRefT direct_solve NamedCType goal name optionalTensor_ctype Note translation C++ reference value types The below cases all when we have argument reference type corresponding goal value type These needed when we populate inputs lambda capture we need guarantee lifetime each captured argument We guard explicit kwarg because converting value type expensive O n convert IntArrayRef vector int so caller translate should explicit they need allow_expensive_conversions goal type == VectorCType BaseCType longT intArrayRef_ctype = NamedCType goal name BaseCType intArrayRefT argname = direct_solve intArrayRef_ctype f argname vec goal type == VectorCType BaseCType SymIntT symIntArrayRef_ctype = NamedCType goal name BaseCType symIntArrayRefT argname = direct_solve symIntArrayRef_ctype f argname vec goal type == OptionalCType VectorCType BaseCType longT optionalIntArrayRef_ctype = NamedCType goal name BaseCType optionalIntArrayRefT argname = direct_solve optionalIntArrayRef_ctype f argname has_value std make_optional argname - vec std nullopt goal type == OptionalCType BaseCType scalarT optionalScalarRef_ctype = NamedCType goal name BaseCType optionalScalarRefT argname = direct_solve optionalScalarRef_ctype f argname has_value std make_optional argname std nullopt goal type == OptionalCType BaseCType scalarT optionalTensorRef_ctype = NamedCType goal name BaseCType optionalTensorRefT argname = direct_solve optionalTensorRef_ctype f argname has_value std make_optional argname std nullopt Technically we also need handle cases C++ containers holding reference types But there currently aren t any ops require lambda capture codegen With arguments like std vector IntArrayRef If changes we ll have add translation here We allow const casting tensors since const-correctness bit broken Tensor We could probably generalize non-tensor types too goal type == MutRefCType BaseCType tensorT const_ref_tensor_ctype = NamedCType goal name ConstRefCType BaseCType tensorT argname = direct_solve const_ref_tensor_ctype f const_cast Tensor argname unsat goal Expr solve g direct=False g g goal_ctypes