Owner s module PrivateUse _codecs io os tempfile unittest numpy torch torch serialization safe_globals torch testing _internal common_utils run_tests skipIfTorchDynamo TemporaryFileName TestCase TestStorage TestCase skipIfTorchDynamo unsupported aten is_pinned default test_rewrapped_storage pinned_a = torch randn pin_memory rewrapped_a = torch tensor dtype=torch float set_ pinned_a untyped_storage size= stride= storage_offset= assertTrue rewrapped_a is_pinned assertNotEqual pinned_a data_ptr rewrapped_a data_ptr TestSerialization TestCase test_serialization storage = torch UntypedStorage device=torch device openreg assertEqual torch serialization location_tag storage openreg storage = torch UntypedStorage device=torch device openreg assertEqual torch serialization location_tag storage openreg storage_cpu = torch empty storage storage_openreg = torch serialization default_restore_location storage_cpu openreg assertTrue storage_openreg is_openreg tensor = torch empty device= openreg assertEqual torch _utils get_tensor_metadata tensor metadata = version_number True format_number True torch _utils set_tensor_metadata tensor metadata assertEqual torch _utils get_tensor_metadata tensor metadata tempfile TemporaryDirectory tmpdir path = os path join tmpdir data pt torch save tensor path tensor_openreg = torch load path assertTrue tensor_openreg is_openreg assertEqual torch _utils get_tensor_metadata tensor_openreg metadata tensor_cpu = torch load path map_location= cpu assertFalse tensor_cpu is_openreg assertEqual torch _utils get_tensor_metadata tensor_cpu skipIfTorchDynamo unittest skipIf numpy __version__ versions serialize dtypes differently how s serialized data_legacy_numpy test_open_device_numpy_serialization This tests legacy _rebuild_device_tensor_from_numpy serialization path data_legacy_numpy = b PK\x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x b \x \x \x \x \x \x \x archive data pklFB\x e\x ZZZZZZZZZZZZZZ\x \x q\x X\x b \x \x \x xq\x ctorch _utils\n_rebuild_device_tensor_from_numpy\nq\x cnumpy core m b ultiarray\n_reconstruct\nq\x cnumpy\nndarray\nq\x K\x \x q\x c_codecs\nencode\nq\x b X\x \x \x \x bq\x X\x \x \x \x latin q\x \x q\tRq\n\x q\x bRq\x c K\x K\x K b \x \x q\rcnumpy\ndtype\nq\x eX\x \x \x \x f q\x f\x \x \x q\x Rq\x K\x X\x b \x \x \x q\x NNNJ\xff\xff\xff\xffJ\xff\xff\xff\xffK\x tq\x b\x h\x X\x c\x \x b \x \x \x \xc \x \x \x \x \x \x \x \x \xc \x \x \x \xc \xa \x \x \xc b \x q\x h\x \x q\x Rq\x tq\x bctorch\nfloat \nq\x X\t\x \x \x openreg q\x \x b tq\x aRq\x bs PK\x \x \xdfE\xd \xcaS\x \x \x S\x \x \x PK\x \x \x \x \x b \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x b archive byteorderFB \x ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZlittlePK\x \x b \x =\xe \x \x \x \x \x \x \x \x \x PK\x \x \x \x \x \x \x \x \x \x b \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x f\x =\x archive versionFB \x b ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ \nPK\x \x \xd \x egU\x \x \x b \x \x \x \x \x PK\x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x b \x \x \x \x \x \x \x \x e\x \x archive data serialization_idFB \x ZZZZZZZZZZZZZ b ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ PK\x \x \xee \xcd b \x d \x \x \x \x \x \x PK\x \x \x \x \x \x \x \x \x \x \x \x \x \x b \xdfE\xd \xcaS\x \x \x S\x \x \x \x \x \x \x \x \x \x \x \x \x \x \x b \x \x \x \x \x \x archive data pklPK\x \x \x \x \x \x \x \x \x \x \x \x b \x \x \x =\xe \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x b \x \x \x \x \x \xa \x \x \x archive byteorderPK\x \x \x \x \x \x \x \x \x b \x \x \x \x \x \xd \x egU\x \x \x \x \x \x \x \x \x f\x \x \x \x \x \x b \x \x \x \x \x \x \x \x \x \x \x archive versionPK\x \x \x \x \x \x \x b \x \x \x \x \x \x \x \xee \xcd\x d \x \x \x \x \x \x \x e\x \x \x \x b \x \x \x \x \x \x \x \x \x \x \x \x \x archive data serialization_idPK\x b \x \x \x \x \x \x \x \x \x e\x -\x \x \x \x \x \x \x \x \x \x \x \x b \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x b \x \x \x \x \x PK\x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x b PK\x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x \x buf_data_legacy_numpy = io BytesIO data_legacy_numpy safe_globals numpy core multiarray _reconstruct numpy core multiarray _reconstruct numpy __version__ = numpy core multiarray _reconstruct numpy ndarray numpy dtype _codecs encode numpy dtypes Float DType sd_loaded = torch load buf_data_legacy_numpy weights_only=True buf_data_legacy_numpy seek Test map_location sd_loaded_cpu = torch load buf_data_legacy_numpy weights_only=True map_location= cpu expected = torch tensor dtype=torch float device= openreg assertEqual sd_loaded x cpu expected cpu assertFalse sd_loaded x is_cpu assertTrue sd_loaded_cpu x is_cpu test_open_device_cpu_serialization default_protocol = torch serialization DEFAULT_PROTOCOL unittest mock patch object torch _C _has_storage return_value=False x = torch randn x_openreg = x openreg sd = x x_openreg rebuild_func = x_openreg _reduce_ex_internal default_protocol assertTrue rebuild_func torch _utils _rebuild_device_tensor_from_cpu_tensor Test map_location TemporaryFileName f torch save sd f sd_loaded = torch load f weights_only=True Test map_location sd_loaded_cpu = torch load f weights_only=True map_location= cpu assertFalse sd_loaded x is_cpu assertEqual sd_loaded x cpu x assertTrue sd_loaded_cpu x is_cpu Test metadata_only TemporaryFileName f assertRaisesRegex RuntimeError Cannot serialize tensors backends no storage under skip_data context manager torch serialization skip_data torch save sd f __name__ == __main__ run_tests