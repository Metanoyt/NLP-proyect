Owner s module dynamo contextlib functools itertools operator sys warnings unittest expectedFailure xfail skipIf skipif SkipTest numpy pytest pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests skipIfTorchDynamo slowTest slow subtest TEST_WITH_TORCHDYNAMO TestCase xpassIfTorchDynamo_np TEST_WITH_TORCHDYNAMO numpy np numpy testing _gen_alignment_data assert_ assert_almost_equal assert_equal torch _numpy np torch _numpy testing _gen_alignment_data assert_ assert_almost_equal assert_equal skip = functools partial skipif True IS_PYPY = False types = np bool_ np byte np ubyte np short np intc np int_ np longlong np single np double np csingle np cdouble floating_types = np floating __subclasses__ complex_floating_types = np complexfloating __subclasses__ objecty_things = object None reasonable_operators_for_scalars = operator lt operator le operator eq operator ne operator ge operator gt operator add operator floordiv operator mod operator mul operator pow operator sub operator truediv This compares scalarmath against ufuncs TestTypes TestCase test_types atype types = atype assert_ == f error atype r got r test_type_add list types k atype enumerate types a_scalar = atype a_array = np array dtype=atype l btype enumerate types b_scalar = btype b_array = np array dtype=btype c_scalar = a_scalar + b_scalar c_array = a_array + b_array It comparing type numbers new ufunc function-finding mechanism finds lowest function which both inputs can cast - which produces l when you do q + b The old function finding mechanism skipped ahead based first argument does produce properly symmetric results assert_equal c_scalar dtype c_array dtype error types f k d np dtype atype name + l d np dtype btype name test_type_create atype types = np array atype b = atype assert_equal b skipIfTorchDynamo freezes under torch Dynamo loop unrolling huh test_leak test leak scalar objects leak would show up valgrind still-reachable ~ MB _ range np add TestBaseMath TestCase test_blocked test alignments offsets simd instructions alignments vz + vs - + dt sz np float np float np int out inp inp msg _gen_alignment_data dtype=dt type= binary max_size=sz exp = np ones_like inp inp = np ones_like inp inp = np zeros_like inp assert_almost_equal np add inp inp exp err_msg=msg assert_almost_equal np add inp exp + err_msg=msg assert_almost_equal np add inp exp err_msg=msg np add inp inp out=out assert_almost_equal out exp err_msg=msg inp += np arange inp size dtype=dt + assert_almost_equal np square inp np multiply inp inp err_msg=msg skip true divide ints dt = np int assert_almost_equal np reciprocal inp np divide inp err_msg=msg inp = np ones_like inp np add inp out=out assert_almost_equal out exp + err_msg=msg inp = np ones_like inp np add inp out=out assert_almost_equal out exp + err_msg=msg xpassIfTorchDynamo_np reason= pytorch does have view test_lower_align check data aligned element size i e doubles aligned bytes i d = np zeros dtype=np int - view np float o = np zeros dtype=np int - view np float assert_almost_equal d + d d np add d d out=o np add np ones_like d d out=o np add d np ones_like d out=o np add np ones_like d d np add d np ones_like d TestPower TestCase test_small_types t np int np int np float = t b = assert_ b == f error t r got b r test_large_types t np int np int np float np float = t b = msg = f error t r got b r np issubdtype t np integer assert_ b == msg assert_almost_equal b err_msg=msg skip reason= NP_VER fails CI older NumPy xpassIfTorchDynamo_np reason= Value-based casting - - pytorch test_integers_to_negative_integer_power Note combination uint signed integer has common type np float The other combinations should all raise ValueError integer negative integer exp = np array - dt dt bhil - possible special case base = np array dt dt bhilB i i itertools product base exp i dtype = np uint assert_raises ValueError operator pow i i res = operator pow i i assert_ res dtype type np float assert_almost_equal res - - possible special case base = np array - dt dt bhil i i itertools product base exp i dtype = np uint assert_raises ValueError operator pow i i res = operator pow i i assert_ res dtype type np float assert_almost_equal res - - perhaps generic base = np array dt dt bhilB i i itertools product base exp i dtype = np uint assert_raises ValueError operator pow i i res = operator pow i i assert_ res dtype type np float assert_almost_equal res test_mixed_types typelist = np int np int np float np float np float np int np int np int np int t typelist t typelist = t b = t result = b msg = f error t r t r got result r expected r np issubdtype np dtype result np integer assert_ result == msg assert_almost_equal result err_msg=msg test_modular_power modular power implemented so ensure errors = b = c = expected = pow b c noqa F t np int np float np complex note -operand power only dispatches first argument assert_raises TypeError operator pow t b c assert_raises TypeError operator pow np array t b c floordiv_and_mod x y x y x y _signs dt dt np typecodes UnsignedInteger + + - instantiate_parametrized_tests TestModulus TestCase test_modulus_basic dt = np typecodes AllInteger + np typecodes Float dt = Bbhil + efd op floordiv_and_mod divmod dt dt itertools product dt dt sg sg itertools product _signs dt _signs dt fmt = op s dt s dt s sg s sg s msg = fmt op __name__ dt dt sg sg = np array sg dtype=dt b = np array sg dtype=dt div rem = op b assert_equal div b + rem err_msg=msg sg == - assert_ b rem = msg assert_ b rem = msg slow test_float_modulus_exact test float results exact small integers This also holds same integers scaled powers two nlst = list range - plst = list range dividend = nlst + + plst divisor = nlst + plst arg = list itertools product dividend divisor tgt = divmod t t arg b = np array arg dtype=int T convert exact integer results Python float so signed zero can used checked tgtdiv tgtrem = np array tgt dtype=float T tgtdiv = np where tgtdiv == b ^ - tgtdiv tgtrem = np where tgtrem == b - tgtrem op floordiv_and_mod divmod dt np typecodes Float msg = f op op __name__ dtype dt fa = astype dt fb = b astype dt use list comprehension so a_ b_ scalars div rem = zip op a_ b_ a_ b_ zip fa fb assert_equal div tgtdiv err_msg=msg assert_equal rem tgtrem err_msg=msg test_float_modulus_roundoff gh- dt = np typecodes Float dt = efd op floordiv_and_mod divmod dt dt itertools product dt dt sg sg itertools product + - + - fmt = op s dt s dt s sg s sg s msg = fmt op __name__ dt dt sg sg = np array sg e- dtype=dt b = np array sg e- dtype=dt div rem = op b Equal assertion should hold when fmod used assert_equal div b + rem err_msg=msg sg == - assert_ b rem = msg assert_ b rem = msg parametrize dt efd test_float_modulus_corner_cases dt dt == e FIXME make xfail raise SkipTest RuntimeError nextafter_cpu implemented Half b = np array dtype=dt = np nextafter np array dtype=dt -b rem = operator mod b assert_ rem = b f dt dt rem = operator mod -a -b assert_ rem = -b f dt dt Check nans inf suppress_warnings sup sup filter RuntimeWarning invalid value encountered remainder sup filter RuntimeWarning divide zero encountered remainder sup filter RuntimeWarning divide zero encountered floor_divide sup filter RuntimeWarning divide zero encountered divmod sup filter RuntimeWarning invalid value encountered divmod dt efd fone = np array dtype=dt fzer = np array dtype=dt finf = np array np inf dtype=dt fnan = np array np nan dtype=dt rem = operator mod fone fzer assert_ np isnan rem f dt dt MSVC returns NaN here so disable check rem = operator mod fone finf assert_ rem == fone dt s dt rem = operator mod fone fnan assert_ np isnan rem f dt dt rem = operator mod finf fone assert_ np isnan rem f dt dt op floordiv_and_mod divmod div mod = op fone fzer assert_ np isinf div assert_ np isnan mod TestComplexDivision TestCase skip reason= With pytorch + j nan + nan j inf + nan j test_zero_division t np complex np complex = t b = t assert_ np isinf b b = t complex np inf np inf assert_ np isinf b b = t complex np inf np nan assert_ np isinf b b = t complex np nan np inf assert_ np isinf b b = t complex np nan np nan assert_ np isnan b b = t assert_ np isnan b test_signed_zeros t np complex np complex tupled numerator denominator expected testing expected == numerator denominator data = - - - - - - - - - - - - - - - - - - - - - - - - - cases data n = cases d = cases ex = cases result = t complex n n t complex d d check real imag parts separately avoid comparison array context which does account signed zeros assert_equal result real ex assert_equal result imag ex test_branches t np complex np complex tupled numerator denominator expected testing expected == numerator denominator data = trigger branch real fabs denom imag fabs denom followed condition neither == data append trigger branch real fabs denom imag fabs denom followed condition both == performed test_zero_division so skipped trigger branch real fabs denom imag fabs denom data append cases data n = cases d = cases ex = cases result = t complex n n t complex d d check real imag parts separately avoid comparison array context which does account signed zeros assert_equal result real ex assert_equal result imag ex TestConversion TestCase test_int_from_long NB test assumes default fp type float l = e e e - e - e - e li = - - - T None np float np int = np array l dtype=T assert_equal int _m _m li skipif numpy __version__ reason= NP_VER fails NumPy x xpassIfTorchDynamo_np reason= pytorch does emit warning test_iinfo_long_values_ code bBh pytest warns DeprecationWarning res = np array np iinfo code max + dtype=code tgt = np iinfo code min assert_ res == tgt test_iinfo_long_values_ code np typecodes AllInteger res = np array np iinfo code max dtype=code tgt = np iinfo code max assert_ res == tgt code np typecodes AllInteger res = np dtype code type np iinfo code max tgt = np iinfo code max assert_ res == tgt test_int_raise_behaviour overflow_error_func dtype dtype np iinfo dtype max + code np int_ np longlong assert_raises OverflowError RuntimeError overflow_error_func code test_numpy_scalar_relational_operators All integer dt np typecodes AllInteger assert_ np array dtype=dt f type dt failed assert_ np array dtype=dt f type dt failed dt np typecodes AllInteger assert_ np array dtype=dt np array dtype=dt f type dt dt failed assert_ np array dtype=dt np array dtype=dt f type dt dt failed Signed integers floats dt bhl + np typecodes Float assert_ np array - dtype=dt f type dt failed assert_ np array - dtype=dt f type dt failed assert_ - == np array - dtype=dt f type dt failed dt bhl + np typecodes Float assert_ np array dtype=dt np array - dtype=dt f type dt dt failed assert_ np array dtype=dt np array - dtype=dt f type dt dt failed assert_ np array - dtype=dt == np array - dtype=dt f type dt dt failed test_numpy_scalar_relational_operators_ Unsigned integers dt B assert_ - np array dtype=dt f type dt failed assert_ - np array dtype=dt f type dt failed assert_ - = np array dtype=dt f type dt failed unsigned vs signed dt bhil assert_ np array dtype=dt np array - dtype=dt f type dt dt failed assert_ np array dtype=dt np array - dtype=dt f type dt dt failed assert_ np array dtype=dt = np array - dtype=dt f type dt dt failed test_scalar_comparison_to_none Scalars should just False give warnings The comparisons flagged pep ignore warnings catch_warnings record=True w warnings filterwarnings always FutureWarning assert_ np float None assert_ np float None assert_ len w == TestRepr test_repr t types val = t val_repr = repr val val = eval val_repr assert_equal val val xpassIfTorchDynamo_np reason= can delegate repr pytorch TestRepr TestCase _test_type_repr t finfo = np finfo t last_fraction_bit_idx = finfo nexp + finfo nmant last_exponent_bit_idx = finfo nexp storage_bytes = np dtype t itemsize could add some more types list below which small denorm small norm Values https en wikipedia org wiki IEEE_ constr = np array x storage_bytes dtype=np uint which == small denorm byte = last_fraction_bit_idx bytebit = - last_fraction_bit_idx constr byte = bytebit which == small norm byte = last_exponent_bit_idx bytebit = - last_exponent_bit_idx constr byte = bytebit raise ValueError hmm val = constr view t val_repr = repr val val = t eval val_repr val == val e- assert_equal val val test_float_repr long double test cannot work because eval goes through python float t np float np float _test_type_repr t skip reason= Array scalars do decay python scalars TestMultiply TestCase test_seq_repeat Test basic sequences get repeated when multiplied numpy integers And errors raised when multiplied others Some behaviour may controversial could open change accepted_types = set np typecodes AllInteger deprecated_types = forbidden_types = set np typecodes All - accepted_types - deprecated_types forbidden_types -= V can t default-construct void scalars seq_type list tuple seq = seq_type numpy_type accepted_types i = np dtype numpy_type type assert_equal seq i seq int i assert_equal i seq int i seq numpy_type deprecated_types i = np dtype numpy_type type assert_equal assert_warns DeprecationWarning operator mul seq i seq int i assert_equal assert_warns DeprecationWarning operator mul i seq int i seq numpy_type forbidden_types i = np dtype numpy_type type assert_raises TypeError operator mul seq i assert_raises TypeError operator mul i seq test_no_seq_repeat_basic_array_like Test array-like which does know how multiplied does attempt sequence repeat raise TypeError See also gh- ArrayLike __init__ arr arr = arr __array__ arr Test simple ArrayLike above memoryviews original report arr_like ArrayLike np ones memoryview np ones assert_array_equal arr_like np float np full assert_array_equal np float arr_like np full assert_array_equal arr_like np int_ np full assert_array_equal np int_ arr_like np full TestNegative TestCase test_exceptions = np ones dtype=np bool_ XXX TypeError numpy RuntimeError torch assert_raises TypeError RuntimeError operator neg test_result types = np typecodes AllInteger + np typecodes AllFloat suppress_warnings sup sup filter RuntimeWarning dt types = np ones dtype=dt dt np typecodes UnsignedInteger st = np dtype dt type max = st np iinfo dt max assert_equal operator neg max assert_equal operator neg + TestSubtract TestCase test_exceptions = np ones dtype=np bool_ assert_raises TypeError RuntimeError XXX TypeError numpy operator sub RuntimeError torch test_result types = np typecodes AllInteger + np typecodes AllFloat suppress_warnings sup sup filter RuntimeWarning dt types = np ones dtype=dt assert_equal operator sub instantiate_parametrized_tests TestAbs TestCase _test_abs_func absfunc test_dtype x = test_dtype - assert_equal absfunc x x = test_dtype res = absfunc x assert_equal checks zero signedness assert_equal res x = test_dtype - res = absfunc x assert_equal res x = test_dtype np finfo test_dtype max assert_equal absfunc x x real suppress_warnings sup sup filter UserWarning x = test_dtype np finfo test_dtype tiny assert_equal absfunc x x real x = test_dtype np finfo test_dtype min assert_equal absfunc x -x real parametrize dtype floating_types + complex_floating_types test_builtin_abs dtype _test_abs_func abs dtype parametrize dtype floating_types + complex_floating_types test_numpy_abs dtype _test_abs_func np abs dtype instantiate_parametrized_tests TestBitShifts TestCase parametrize type_code np typecodes AllInteger parametrize op operator rshift operator lshift test_shift_all_bits type_code op Shifts where shift amount width type wider gh- dt = np dtype type_code nbits = dt itemsize dt np dtype np uint np dtype np uint np dtype np uint raise SkipTest NYI bitshift uint val - shift nbits nbits + val_scl = np array val astype dt shift_scl = dt type shift res_scl = op val_scl shift_scl val_scl op operator rshift sign bit preserved assert_equal res_scl - type_code i l shift == np iinfo type_code bits FIXME make xfail raise SkipTest https github com pytorch pytorch issues assert_equal res_scl Result scalars should same arrays val_arr = np array val_scl dtype=dt shift_arr = np array shift dtype=dt res_arr = op val_arr shift_arr assert_equal res_arr res_scl skip reason= Will rely pytest hashing instantiate_parametrized_tests TestHash TestCase parametrize type_code np typecodes AllInteger test_integer_hashes type_code scalar = np dtype type_code type i range assert hash i == hash scalar i parametrize type_code np typecodes AllFloat test_float_and_complex_hashes type_code scalar = np dtype type_code type val np pi np inf numpy_val = scalar val Cast back Python case NumPy scalar has less precision numpy_val dtype kind == c val = complex numpy_val val = float numpy_val assert val == numpy_val assert hash val == hash numpy_val hash float np nan = hash float np nan If Python distinguishes different NaNs we do so too gh- assert hash scalar np nan = hash scalar np nan parametrize type_code np typecodes Complex test_complex_hashes type_code Test some complex valued hashes specifically scalar = np dtype type_code type val np pi + j np inf - j j + j numpy_val = scalar val assert hash complex numpy_val == hash numpy_val contextlib contextmanager recursionlimit n o = sys getrecursionlimit try sys setrecursionlimit n yield finally sys setrecursionlimit o instantiate_parametrized_tests TestScalarOpsMisc TestCase xfail reason= pytorch does warn overflow parametrize dtype Bbhil parametrize operation lambda min max max + max lambda min max min - max lambda min max max max test_scalar_integer_operation_overflow dtype operation st = np dtype dtype type min = st np iinfo dtype min max = st np iinfo dtype max pytest warns RuntimeWarning match= overflow encountered operation min max skip reason= integer overflow UB crashes pytorch under ASAN parametrize dtype bhil parametrize operation lambda min neg_ -min lambda min neg_ abs min lambda min neg_ min neg_ subtest lambda min neg_ min neg_ decorators= skip reason= broken some platforms test_scalar_signed_integer_overflow dtype operation The minimum signed integer can overflow some additional operations st = np dtype dtype type min = st np iinfo dtype min neg_ = st - pytest warns RuntimeWarning match= overflow encountered operation min neg_ skipif numpy __version__ reason= NP_VER fails NumPy x xpassIfTorchDynamo_np reason= pytorch does warn overflow parametrize dtype B test_scalar_unsigned_integer_overflow dtype val = np dtype dtype type pytest warns RuntimeWarning match= overflow encountered -val zero = np dtype dtype type -zero does warn xfail reason= pytorch raises RuntimeError division zero parametrize dtype np typecodes AllInteger parametrize operation lambda val zero val zero lambda val zero val zero test_scalar_integer_operation_divbyzero dtype operation st = np dtype dtype type val = st zero = st pytest warns RuntimeWarning match= divide zero operation val zero ops_with_names = __lt__ __gt__ operator lt True __le__ __ge__ operator le True __eq__ __eq__ operator eq True Note __op__ __rop__ may identical here __ne__ __ne__ operator ne True __gt__ __lt__ operator gt True __ge__ __le__ operator ge True __floordiv__ __rfloordiv__ operator floordiv False __truediv__ __rtruediv__ operator truediv False __add__ __radd__ operator add False __mod__ __rmod__ operator mod False __mul__ __rmul__ operator mul False __pow__ __rpow__ operator pow False __sub__ __rsub__ operator sub False instantiate_parametrized_tests TestScalarSubclassingMisc TestCase skip reason= We do support subclassing scalars parametrize __op__ __rop__ op cmp ops_with_names parametrize sctype np float np float test_subclass_deferral sctype __op__ __rop__ op cmp This test covers scalar subclass deferral Note exceedingly complicated especially since tends fall back array paths these additionally add array priority mechanism The behaviour modified subtly make closer how Python scalars work Due its complexity fact subclassing NumPy scalars probably bad idea begin There probably room adjustments here myf_simple sctype pass myf_simple sctype pass op_func other __op__ rop_func other __rop__ myf_op = type myf_op sctype __op__ op_func __rop__ rop_func inheritance has override correctly lost res = op myf_simple myf_simple assert type res sctype type res np bool_ assert op myf_simple myf_simple == op inherited Two independent subclasses do really define order This could attempted we do since Python s ` int ` does neither assert op myf_op myf_simple == __op__ assert op myf_simple myf_op == op inherited skip reason= We do support subclassing scalars parametrize __op__ __rop__ op cmp ops_with_names parametrize subtype float int complex np float np _no_nep _warning test_pyscalar_subclasses subtype __op__ __rop__ op cmp op_func other __op__ rop_func other __rop__ Check deferring indicated using ` __array_ufunc__ ` myt = type myt subtype __op__ op_func __rop__ rop_func __array_ufunc__ None Just like normally we should never presume we can modify float assert op myt np float == __op__ assert op np float myt == __rop__ op operator mod operator floordiv subtype complex module support complex Do test __rop__ == __op__ When no deferring indicated subclasses handled normally myt = type myt subtype __rop__ rop_func Check float float subclass float may behave differently res = op myt np float expected = op subtype np float assert res == expected assert type res type expected res = op np float myt expected = op np float subtype assert res == expected assert type res type expected __name__ == __main__ run_tests