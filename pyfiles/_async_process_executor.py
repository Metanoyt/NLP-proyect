pyre-strict mypy allow-untyped-defs logging os concurrent futures Future ThreadPoolExecutor dataclasses dataclass enum Enum typing Any Optional Union uuid uuid torch distributed dist torch multiprocessing mp torch distributed checkpoint _async_executor _AsyncCheckpointExecutor torch distributed checkpoint logger _dcp_method_logger _init_logger torch distributed checkpoint metadata Metadata STATE_DICT_TYPE torch distributed checkpoint planner SavePlanner torch distributed checkpoint storage StorageWriter torch distributed checkpoint utils _DistWrapper torch distributed elastic agent server api _get_fq_hostname torch distributed elastic utils distributed get_free_port logger = logging getLogger _CheckpointSaveProcessControlOpts Enum INIT_COMPLETE = init_complete TERMINATE = terminate dataclass init=False unsafe_hash=True _CheckpointRequestIdentifier checkpoint_id Union str os PathLike None uuid str __init__ checkpoint_id Union str os PathLike None checkpoint_id = checkpoint_id uuid = str uuid dataclass _AsyncCheckpointRequest staged_state_dict STATE_DICT_TYPE checkpoint_request_id _CheckpointRequestIdentifier storage_writer Optional StorageWriter = None planner Optional SavePlanner = None no_dist bool = False use_collectives bool = True dataclass init=False _ProcessGroupInitInfo local_rank int global_rank int world_size int tcp_store_master_addr str tcp_store_master_port int __init__ process_group Optional dist ProcessGroup = None local_rank = dist get_node_local_rank fallback_rank= global_rank = dist get_rank process_group world_size = dist get_world_size process_group Let coordinator rank find free port localhost Broadcast master_addr free_port all ranks each rank checkpoint daemon process will use TCPStore master_addr master_port collective communication dist_wrapper _DistWrapper = _DistWrapper group=process_group use_dist=True coordinator_rank= get_master_addr_and_port - tuple str int master_addr = os environ get MASTER_ADDR master_addr None master_addr = _get_fq_hostname master_addr get_free_port tcp_store_master_addr tcp_store_master_port = dist_wrapper broadcast step= get_master_addr_and_port map_fun=get_master_addr_and_port _AsyncCheckpointProcess __init__ pg_init_info _ProcessGroupInitInfo ctx = mp get_context spawn _process_pipe child_end = ctx Pipe _save_process = ctx Process target=self _checkpointing_subprocess args= pg_init_info child_end daemon=True _save_process start Close parent s copy child end after we pass into child so recv s will fail-fast child process dies child_end close Wait checkpoint background process initialize Using default GLOO init timeout response = _wait_for_response timeout= response == _CheckpointSaveProcessControlOpts INIT_COMPLETE raise AssertionError f Expected INIT_COMPLETE response got response __del__ - None _save_process is_alive try logger info Terminating checkpoint background process _send _CheckpointSaveProcessControlOpts TERMINATE _save_process join timeout= finally _save_process is_alive logger warning Checkpoint background process still alive after termination request Sending SIGTERM _save_process terminate _send data Any - None _process_pipe send data _wait_for_response timeout Optional float = None - Any _save_process is_alive logger info Checkpoint background process dead calling join _save_process join raise RuntimeError f Checkpoint background process dead Exit code _save_process exitcode timeout None _process_pipe poll timeout=timeout raise RuntimeError f Timed out after timeout s while waiting response checkpointer process pid _save_process pid try response = _process_pipe recv except EOFError raise RuntimeError noqa B f Checkpoint background process dead Exit code _save_process exitcode isinstance response BaseException raise response response save staged_state_dict STATE_DICT_TYPE checkpoint_id Union str os PathLike None = None storage_writer Optional StorageWriter = None planner Optional SavePlanner = None no_dist bool = False use_collectives bool = True - Metadata Create unique identifier locate requests responses checkpoint daemon process checkpoint_request_id = _CheckpointRequestIdentifier checkpoint_id async_cp_request = _AsyncCheckpointRequest staged_state_dict=staged_state_dict checkpoint_request_id=checkpoint_request_id storage_writer=storage_writer planner=planner no_dist=no_dist use_collectives=use_collectives _send async_cp_request result = _wait_for_response isinstance result Metadata raise AssertionError f Expected Metadata response got type result result staticmethod _execute_save state_dict STATE_DICT_TYPE checkpoint_request_id _CheckpointRequestIdentifier storage_writer Optional StorageWriter = None planner Optional SavePlanner = None no_dist bool = False use_collectives bool = True - Metadata torch distributed checkpoint state_dict_saver save metadata = save state_dict checkpoint_id=checkpoint_request_id checkpoint_id storage_writer=storage_writer planner=planner no_dist=no_dist use_collectives=use_collectives metadata staticmethod _checkpointing_subprocess pg_init_info _ProcessGroupInitInfo parent_conn - None Phase Process Group Initialization Only needs execute once during lifetime checkpoint background process try _init_logger pg_init_info global_rank Setup environment variables process group initialization os environ TORCHELASTIC_USE_AGENT_STORE = False os environ MASTER_ADDR = pg_init_info tcp_store_master_addr os environ MASTER_PORT = str pg_init_info tcp_store_master_port os environ LOCAL_RANK = str pg_init_info local_rank os environ RANK = str pg_init_info global_rank os environ WORLD_SIZE = str pg_init_info world_size logger info Initializing dist ProcessGroup checkpoint background process NOTE GLOO backend enforced here dist init_process_group backend=dist Backend GLOO dist barrier logger info Checkpoint background process running parent_conn send _CheckpointSaveProcessControlOpts INIT_COMPLETE except BaseException e noqa B logger error f Checkpoint background process failed during initialization e noqa G parent_conn send e Phase Serving Loop try while True logger info Waiting checkpoint save request obj = parent_conn recv isinstance obj _CheckpointSaveProcessControlOpts obj == _CheckpointSaveProcessControlOpts TERMINATE logger info Terminating checkpoint background process isinstance obj _AsyncCheckpointRequest raise AssertionError f Expected _AsyncCheckpointRequest got type obj logger info f Received async checkpoint request id= obj checkpoint_request_id checkpoint_id noqa G try response = _AsyncCheckpointProcess _execute_save obj staged_state_dict checkpoint_request_id=obj checkpoint_request_id storage_writer=obj storage_writer planner=obj planner no_dist=obj no_dist use_collectives=obj use_collectives parent_conn send response logger info f Completed checkpoint save request checkpoint_id= obj checkpoint_request_id noqa G except BaseException e noqa B logger error f Checkpoint save failed checkpoint_id= obj checkpoint_request_id checkpoint_id e noqa G parent_conn send e Continue serving loop - don t exit process finally logger info Checkpoint background process shutting down dist destroy_process_group parent_conn close _CHECKPOINT_PROCESS Optional _AsyncCheckpointProcess = None _ProcessBasedAsyncCheckpointExecutor _AsyncCheckpointExecutor __init__ - None _executor = ThreadPoolExecutor max_workers= staticmethod _execute_save_impl pg_init_info Optional _ProcessGroupInitInfo staging_future_or_state_dict Union Future STATE_DICT_TYPE STATE_DICT_TYPE checkpoint_id Union str os PathLike None = None storage_writer Optional StorageWriter = None planner Optional SavePlanner = None process_group Optional dist ProcessGroup = None no_dist bool = False use_collectives bool = True - Metadata global _CHECKPOINT_PROCESS _CHECKPOINT_PROCESS None pg_init_info None raise AssertionError pg_init_info must None when _CHECKPOINT_PROCESS None ckpt_kwargs = ckpt_id = getattr storage_writer checkpoint_id None None ckpt_kwargs checkpoint_id = ckpt_id ckpt_kwargs process_group = process_group _dcp_method_logger ckpt_kwargs create_checkpoint_daemon_process - None global _CHECKPOINT_PROCESS pyrefly ignore bad-argument-type _CHECKPOINT_PROCESS = _AsyncCheckpointProcess pg_init_info=pg_init_info create_checkpoint_daemon_process _CHECKPOINT_PROCESS None raise AssertionError _CHECKPOINT_PROCESS must None after initialization staged_state_dict = staging_future_or_state_dict result isinstance staging_future_or_state_dict Future staging_future_or_state_dict _CHECKPOINT_PROCESS save staged_state_dict=staged_state_dict checkpoint_id=checkpoint_id storage_writer=storage_writer planner=planner no_dist=no_dist use_collectives=use_collectives execute_save staging_future_or_state_dict Union Future STATE_DICT_TYPE STATE_DICT_TYPE checkpoint_id Union str os PathLike None = None storage_writer Optional StorageWriter = None planner Optional SavePlanner = None process_group Optional dist ProcessGroup = None no_dist bool = False use_collectives bool = True - Future NOTE - Checkpoint process implemented daemon process The AsyncCheckpointProcess lifetime tied lifetime main process e g trainer process - The first call execute_save_in_process will initialize checkpoint daemon process Subsequent async checkpoint requests will need process initialization Therefore first async checkpoint request will take longer complete - Process initialization can have significant overhead dominated latency all ranks spawn background process + process group initialization background process global _CHECKPOINT_PROCESS pg_init_info Optional _ProcessGroupInitInfo = None _CHECKPOINT_PROCESS None Find free port coordinator rank broadcast all ranks pg_init_info = _ProcessGroupInitInfo process_group f Future = _executor submit _execute_save_impl pg_init_info=pg_init_info staging_future_or_state_dict=staging_future_or_state_dict checkpoint_id=checkpoint_id storage_writer=storage_writer planner=planner no_dist=no_dist use_collectives=use_collectives f add_done_callback lambda f _executor shutdown wait=False f