mypy allow-untyped-defs torch fx experimental migrate_gradual_types constraint BinConstraintD BinConstraintT BVar Conj Disj DVar F is_algebraic_expression is_bool_expr is_dim Prod T TVar torch fx experimental migrate_gradual_types constraint_generator ConstraintGenerator torch fx experimental migrate_gradual_types constraint_transformation transform_constraint torch fx experimental migrate_gradual_types operation op_add op_div op_eq op_gt op_leq op_lt op_mod op_mul op_neq op_sub torch fx tensor_type Dyn TensorType try z type ignore torch fx experimental migrate_gradual_types z _types D tensor_type z _dyn HAS_Z = True transform_to_z constraint counter dimension_dict isinstance constraint Conj conjuncts = c constraint conjucts new_c counter = transform_to_z c counter dimension_dict conjuncts append new_c z And conjuncts counter isinstance constraint Disj disjuncts = c constraint disjuncts new_c counter = transform_to_z c counter dimension_dict disjuncts append new_c z Or disjuncts counter isinstance constraint T True counter isinstance constraint F False counter isinstance constraint BinConstraintT constraint op == op_eq lhs counter = transform_var constraint lhs counter dimension_dict rhs counter = transform_var constraint rhs counter dimension_dict lhs == rhs counter raise NotImplementedError Method yet implemented isinstance constraint BinConstraintD constraint op == op_eq isinstance constraint lhs BVar is_bool_expr constraint rhs transformed_rhs counter = transform_to_z constraint rhs counter dimension_dict transformed_lhs = z Bool constraint lhs c transformed_lhs == transformed_rhs counter is_dim constraint lhs is_dim constraint rhs dimension transformations we consider encoding lhs counter = transform_dimension constraint lhs counter dimension_dict rhs counter = transform_dimension constraint rhs counter dimension_dict lhs == rhs counter then we have algebraic expression which means we disregard first element encoding lhs counter = transform_algebraic_expression constraint lhs counter dimension_dict rhs counter = transform_algebraic_expression constraint rhs counter dimension_dict lhs == rhs counter The assumption here LHS RHS must dimensions constraint op == op_neq assert is_dim constraint lhs assert is_dim constraint rhs lhs counter = transform_dimension constraint lhs counter dimension_dict rhs counter = transform_dimension constraint rhs counter dimension_dict constraint rhs == Dyn constraint lhs == Dyn constraint rhs == Dyn lhs arg == counter constraint lhs == Dyn rhs arg == counter one instances number isinstance constraint lhs int isinstance constraint rhs int isinstance constraint lhs int z Or rhs arg == z And rhs arg == lhs arg = rhs arg counter isinstance constraint rhs int z Or lhs arg == z And lhs arg == lhs arg = rhs arg counter z Or z And lhs arg == rhs arg = z And lhs arg = rhs arg == z And lhs arg = rhs arg = lhs arg = rhs arg counter constraint op == op_leq dimensions dyn will come into effect there would have been another constraint specifying given dimension dyn assert is_dim constraint lhs is_dim constraint rhs lhs counter = transform_algebraic_expression constraint lhs counter dimension_dict rhs counter = transform_algebraic_expression constraint rhs counter dimension_dict lhs = rhs counter constraint op == op_gt assert is_dim constraint lhs is_dim constraint rhs lhs counter = transform_algebraic_expression constraint lhs counter dimension_dict rhs counter = transform_algebraic_expression constraint rhs counter dimension_dict lhs rhs counter constraint op == op_lt assert is_dim constraint lhs is_dim constraint rhs lhs counter = transform_algebraic_expression constraint lhs counter dimension_dict rhs counter = transform_algebraic_expression constraint rhs counter dimension_dict lhs rhs counter raise NotImplementedError operation yet implemented raise NotImplementedError Operation yet implemented transform_var tensor counter dimension_dict Transforms tensor variables format understood z Args tensor Tensor variable tensor type potentially variable dimensions Returns Transformed variable z format isinstance tensor TensorType res = t tensor __args__ transformed counter = transform_dimension t counter dimension_dict res append transformed assert len res = len tensor __args__ == tensor_type tensor res counter len tensor __args__ == tensor_type tensor res res counter len tensor __args__ == tensor_type tensor res res res counter len tensor __args__ == tensor_type tensor res res res res counter tensor == Dyn z _dyn counter isinstance tensor TVar z Const tensor tvar tensor_type counter transform_dimension dimension counter dimension_dict Takes dimension variable number transforms tuple according our scheme Args dimension The dimension transformed counter variable tracking Returns tuple current counter dimension == Dyn counter += D z Int counter counter isinstance dimension int D dimension counter isinstance dimension DVar dimension c dimension_dict D z Int dimension_dict dimension c z Int dimension c counter counter += dimension_dict dimension c = counter D z Int counter z Int dimension c counter transform_algebraic_expression expr counter dimension_dict Transforms algebraic expression z format Args expr An expression either dimension variable algebraic-expression Returns transformed expression assert is_algebraic_expression expr is_dim expr is_dim expr transformed counter = transform_dimension expr counter dimension_dict transformed arg counter isinstance expr Prod dims = dim expr products assert is_dim dim d counter = transform_dimension dim counter dimension_dict dims append d arg z Product dims counter is_algebraic_expression expr lhs counter = transform_algebraic_expression expr lhs counter dimension_dict rhs counter = transform_algebraic_expression expr rhs counter dimension_dict expr op == op_sub c = lhs - rhs expr op == op_add c = lhs + rhs expr op == op_div c = lhs rhs expr op == op_mul c = lhs rhs expr op == op_mod c = lhs rhs raise NotImplementedError operation yet implemented c counter raise RuntimeError transform_all_constraints traced counter= Given trace generates constraints transforms them z format dimension_dict = type ignore var-annotated generator = ConstraintGenerator traced new_constraints counter = generator generate_constraints counter print new_constraints conjucts print new_constraints conjucts sep= \n transform precision matching consistency till obtaining fixed point new_constraints counter = iterate_till_fixed_point new_constraints counter print new_constraints print new_constraints conjucts new_constraints conjucts = new_constraints conjucts - print new_constraints conjucts sep= \n transformed counter = transform_to_z new_constraints counter dimension_dict print transformed transformed iterate_till_fixed_point constraints counter Transform constraints till reaching fixed point old_c = None while old_c = constraints old_c = constraints constraints counter = transform_constraint constraints counter constraints counter transform_all_constraints_trace_time tracer_root graph node counter= Takes node graph generates two sets constraints One set constraints node s constraints another set constraints negation node s constraints Args tracer_root root getting module instances graph graph so far tracing process node node represents conditional counter variable tracking Returns Two sets constraints One conjunction conditional constraint other conjunction its negation dimension_dict = type ignore var-annotated generator = ConstraintGenerator tracer_root graph new_constraints counter = generator generate_constraints counter condition_constraint = new_constraints conjucts - we know constraint conjunction where last constraint about conditional so remove last constraint new_constraints conjucts = new_constraints conjucts - transform precision matching consistency till obtaining fixed point new_constraints counter = iterate_till_fixed_point new_constraints counter since function returns list one element we get first element we only interested RHS case because LHS just stores result we make sure constraint form c = b where b boolean expression we consider b constraint rhs transformation assert isinstance condition_constraint lhs BVar assert is_bool_expr condition_constraint rhs condition_constraint_rhs = condition_constraint rhs transform condition constraint condition_constraint_rhs counter = iterate_till_fixed_point condition_constraint_rhs counter transformed counter = transform_to_z new_constraints counter dimension_dict transformed_condition_constraint counter = transform_to_z condition_constraint_rhs counter dimension_dict negation_transformed_condition_constraint = z Not transformed_condition_constraint z And transformed transformed_condition_constraint z And transformed negation_transformed_condition_constraint evaluate_conditional_with_constraints tracer_root graph node counter= user_constraints=None Given IR node representing conditional evaluate conditional its negation Args tracer_root Tracer root module instances node The node evaluated Returns results evaluating condition negation rest constraints transformed_positive transformed_negative = transform_all_constraints_trace_time tracer_root graph node counter s = z Solver s add transformed_positive user_constraints None s add user_constraints condition = s check s = z Solver s add transformed_negative user_constraints None s add user_constraints negation = s check condition negation except ImportError HAS_Z = False