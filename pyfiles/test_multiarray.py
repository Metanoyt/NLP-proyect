Owner s module dynamo builtins collections abc ctypes functools io itertools mmap operator os sys tempfile warnings weakref contextlib contextmanager decimal Decimal pathlib Path tempfile mkstemp unittest expectedFailure xfail skipIf skipif SkipTest numpy pytest pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests slowTest slow subtest TEST_WITH_TORCHDYNAMO TestCase xfailIfTorchDynamo xpassIfTorchDynamo_np If we going trace through these we should use NumPy If testing eager mode we use torch _numpy TEST_WITH_TORCHDYNAMO numpy np numpy testing assert_ assert_allclose assert_almost_equal assert_array_almost_equal assert_array_equal assert_array_less assert_equal assert_raises_regex assert_warns suppress_warnings torch _numpy np torch _numpy testing assert_ assert_allclose assert_almost_equal assert_array_almost_equal assert_array_equal assert_array_less assert_equal assert_raises_regex assert_warns suppress_warnings skip = functools partial skipif True IS_PYPY = False IS_PYSTON = False HAS_REFCOUNT = True numpy __version__ numpy + see https numpy org doc stable release -notes html#renamed-numpy-core-to-numpy-core numpy _core tests _locales CommaDecimalPointLocale numpy core tests _locales CommaDecimalPointLocale numpy testing _private utils _no_tracing requires_memory #### stubs make pytest pass collections stage #### defined numpy testing _utils py runstring astr dict exec astr dict contextmanager temppath args kwargs Context manager temporary files Context manager returns path closed temporary file Its parameters same tempfile mkstemp passed directly function The underlying file removed when context exited so should closed time Windows does allow temporary file opened already open so underlying file must closed after opening before can opened again fd path = mkstemp args kwargs os close fd try yield path finally os remove path FIXME np asanyarray = np asarray np asfortranarray = np asarray #### end stubs _aligned_zeros shape dtype=float order= C align=None Allocate new ndarray aligned memory The ndarray guaranteed aligned twice requested alignment Eg align= guarantees aligned If align=None uses dtype alignment dtype = np dtype dtype dtype == np dtype object Can t do fall back standard allocation which should always sufficiently aligned align None raise ValueError object array alignment supported np zeros shape dtype=dtype order=order align None align = dtype alignment hasattr shape __len__ shape = shape size = functools reduce operator mul shape dtype itemsize buf = np empty size + align + np uint ptr = buf __array_interface__ data offset = ptr align offset = offset = align - offset ptr align == offset += align Note slices producing -size arrays do necessarily change data pointer --- so we use allocate size+ buf = buf offset offset + size + - buf fill data = np ndarray shape dtype buf order=order data xpassIfTorchDynamo_np reason= TODO flags instantiate_parametrized_tests TestFlag TestCase setUp = np arange xfail test_writeable mydict = locals flags writeable = False assert_raises ValueError runstring = mydict assert_raises ValueError runstring itemset mydict flags writeable = True = = test_writeable_any_base Ensure any base being writeable sufficient change flag especially interesting arrays array interface arr = np arange subclass np ndarray pass Create subclass so base will collapsed OK change view = arr view subclass view = view arr flags writeable = False view flags writeable = False view flags writeable = True Can set True again arr = np arange frominterface __init__ arr arr = arr __array_interface__ = arr __array_interface__ view = np asarray frominterface view = view view flags writeable = False view flags writeable = True view flags writeable = False view flags writeable = False assert_raises ValueError Must assume writeable since only base view flags writeable = True test_writeable_from_readonly gh- - make sure fromstring buffer readonly buffers set writeable False data = b \x vals = np frombuffer data B assert_raises ValueError vals setflags write=True types = np dtype vals u res S values = np core records fromstring data types vals = values vals assert_raises ValueError vals setflags write=True test_writeable_from_buffer data = bytearray b \x vals = np frombuffer data B assert_ vals flags writeable vals setflags write=False assert_ vals flags writeable False vals setflags write=True assert_ vals flags writeable types = np dtype vals u res S values = np core records fromstring data types vals = values vals assert_ vals flags writeable vals setflags write=False assert_ vals flags writeable False vals setflags write=True assert_ vals flags writeable skipif IS_PYPY reason= PyPy always copies test_writeable_pickle pickle Small arrays will copied without setting base See condition using PyArray_SetBaseObject array_setstate = np arange v range pickle HIGHEST_PROTOCOL vals = pickle loads pickle dumps v assert_ vals flags writeable assert_ isinstance vals base bytes test_warnonwrite = np arange flags _warn_on_write = True warnings catch_warnings record=True w warnings filterwarnings always = = only warn once assert_ len w == parametrize flag flag_value writeable writeable True True Delete _warn_on_write after deprecation simplify parameterization _warn_on_write True False writeable False False test_readonly_flag_protocols flag flag_value writeable = np arange setattr flags flag flag_value MyArr __array_struct__ = __array_struct__ assert memoryview readonly writeable assert __array_interface__ data writeable assert np asarray MyArr flags writeable writeable xfail test_otherflags assert_equal flags carray True assert_equal flags C True assert_equal flags farray False assert_equal flags behaved True assert_equal flags fnc False assert_equal flags forc True assert_equal flags owndata True assert_equal flags writeable True assert_equal flags aligned True assert_equal flags writebackifcopy False assert_equal flags X False assert_equal flags WRITEBACKIFCOPY False xfail invalid dtype test_string_align = np zeros dtype=np dtype &#124; S assert_ flags aligned power two accessed byte-wise thus considered aligned = np zeros dtype=np dtype &#124; S assert_ flags aligned xfail structured dtypes test_void_align = np zeros dtype=np dtype i b i assert_ flags aligned xpassIfTorchDynamo_np reason= TODO hash TestHash TestCase see test_int st ut s np int np uint np int np uint np int np uint np int np uint i range s assert_equal hash st - i hash - i err_msg=f st r - i d assert_equal hash st i - hash i - err_msg=f st r i - d assert_equal hash st i - hash i - err_msg=f st r i d - i = max i - assert_equal hash ut i - hash i - err_msg=f ut r i - d assert_equal hash ut i - hash i - err_msg=f ut r i d - xpassIfTorchDynamo_np reason= TODO hash TestAttributes TestCase setUp one = np arange two = np arange reshape three = np arange dtype=np float reshape test_attributes assert_equal one shape assert_equal two shape assert_equal three shape three shape = assert_equal three shape three shape = assert_equal one strides one itemsize num = two itemsize assert_equal two strides num num num = three itemsize assert_equal three strides num num num assert_equal one ndim assert_equal two ndim assert_equal three ndim num = two itemsize assert_equal two size assert_equal two nbytes num assert_equal two itemsize two dtype itemsize xfailIfTorchDynamo use ndarray tensor _base track base tensor test_attributes_ assert_equal two base np arange test_dtypeattr assert_equal one dtype np dtype np int_ assert_equal three dtype np dtype np float assert_equal one dtype char l assert_equal three dtype char d assert_ three dtype str assert_equal one dtype str i assert_equal three dtype str f test_stridesattr x = one make_array size offset strides np ndarray size buffer=x dtype=int offset=offset x itemsize strides=strides x itemsize assert_equal make_array - np array assert_raises ValueError make_array - assert_raises ValueError make_array - assert_raises ValueError make_array assert_equal make_array np array Check behavior reported gh- assert_raises ValueError make_array np array - - make_array test_set_stridesattr x = one make_array size offset strides try r = np ndarray size dtype=int buffer=x offset=offset x itemsize except Exception e raise RuntimeError e noqa B r strides = strides = strides x itemsize r assert_equal make_array - np array assert_equal make_array np array assert_raises ValueError make_array - assert_raises ValueError make_array - assert_raises RuntimeError make_array Check true extent array used Test relies as_strided base exposing buffer x = np lib stride_tricks as_strided np arange set_strides arr strides arr strides = strides assert_raises ValueError set_strides x x itemsize x itemsize Test offset calculations x = np lib stride_tricks as_strided np arange dtype=np int - shape= strides= - assert_raises ValueError set_strides x - - = x - strides = strides = test d arr_ d = np array arr_ d strides = assert_raises TypeError set_strides arr_ d None test_fill t bhilqpBHILQPfdgFDGO x = np empty t y = np empty t x fill y = assert_equal x y test_fill_max_uint x = np empty dtype=np uint y = np empty dtype=np uint value = - y = value x fill value assert_array_equal x y test_fill_struct_array Filling scalar x = np array dtype= i f x fill x assert_equal x f x f Filling tuple can converted scalar x = np zeros dtype= f b i x fill - assert_array_equal x assert_array_equal x b - - test_fill_readonly gh- = np zeros setflags write=False pytest raises ValueError match= read-only fill instantiate_parametrized_tests TestArrayConstruction TestCase test_array d = np ones r = np array d d assert_equal r np ones d = np ones tgt = np ones r = np array d d assert_equal r tgt tgt = r = np array d d + assert_equal r tgt d = np ones r = np array d d assert_equal r np ones d = np ones r = np array d d d d assert_equal r np ones d = np ones r = np array d d assert_equal r np ones tgt = np ones dtype=bool tgt = False tgt = False r = np array True True False False False True assert_equal r tgt r = np array True False True False False True assert_equal r tgt T skip reason= object arrays test_array_object d = np ones r = np array d d + d + dtype=object assert_equal len r assert_equal r d d + assert_equal r d + test_array_empty assert_raises TypeError np array test_ d_array_shape assert np ones np array shape == test_array_copy_false d = np array e = np array d copy=False d = assert_array_equal e xpassIfTorchDynamo_np reason= order= F test_array_copy_false_ d = np array e = np array d copy=False order= F d = assert_array_equal e e = assert_array_equal d test_array_copy_true d = np array e = np array d copy=True d = e = - assert_array_equal e - assert_array_equal d xfail reason= order= F test_array_copy_true_ d = np array e = np array d copy=True order= F d = e = assert_array_equal e assert_array_equal d xfailIfTorchDynamo test_array_cont d = np ones assert_ np ascontiguousarray d flags c_contiguous assert_ np ascontiguousarray d flags f_contiguous assert_ np asfortranarray d flags c_contiguous assert_ np asfortranarray d flags f_contiguous XXX f ordering d = np ones assert_ np ascontiguousarray d flags c_contiguous assert_ np asfortranarray d flags f_contiguous parametrize func subtest np array name= array subtest np asarray name= asarray subtest np asanyarray name= asanyarray subtest np ascontiguousarray name= ascontiguousarray subtest np asfortranarray name= asfortranarray test_bad_arguments_error func pytest raises TypeError func dtype= bad dtype pytest raises TypeError func missing arguments pytest raises TypeError func too many arguments skip reason= np array w keyword argument parametrize func subtest np array name= array subtest np asarray name= asarray subtest np asanyarray name= asanyarray subtest np ascontiguousarray name= ascontiguousarray subtest np asfortranarray name= asfortranarray test_array_as_keyword func This should likely made positional only do change name accidentally func np array func object= func a= TestAssignment TestCase test_assignment_broadcasting = np arange reshape Broadcasting input output = np arange assert_equal = np arange reshape assert_equal For compatibility = limited version broadcasting output input This behavior inconsistent NumPy broadcasting general because only uses one two broadcasting rules adding new dimension left shape applied output instead input In NumPy kind broadcasting assignment will likely disallowed = np flip np arange reshape assert_equal The other type broadcasting would require reduction operation assign b = b assert_raises RuntimeError ValueError assign np arange reshape test_assignment_errors Address issue C pass = np zeros assign v = v assert_raises RuntimeError TypeError assign C assert_raises TypeError ValueError assign numpy raises we do skip reason= object arrays test_unicode_assignment gh- numpy core numeric set_string_function contextmanager inject_str s replace ndarray __str__ temporarily set_string_function lambda x s repr=False try yield finally set_string_function None repr=False d = np array test d = np array done inject_str bad d = d previously would invoke __str__ assert_equal d done would crash same reason np array np array \xe \xe \xf skip reason= object arrays test_stringlike_empty_list gh- u = np array done b = np array b done bad_sequence __getitem__ value pass __len__ raise RuntimeError assert_raises ValueError operator setitem u assert_raises ValueError operator setitem b assert_raises ValueError operator setitem u bad_sequence assert_raises ValueError operator setitem b bad_sequence skipif torch _numpy == np __name__ reason= torch _numpy does support extended floats complex dtypes test_longdouble_assignment only relevant longdouble larger than float we re looking loss precision dtype np longdouble np clongdouble gh- tinyb = np nextafter np longdouble astype dtype tinya = np nextafter np longdouble - astype dtype construction tiny d = np array tinya assert_equal tiny d tinya scalar = scalar tiny d = tinyb assert_equal tiny d tinyb d = scalar tiny d = tinya assert_equal tiny d tinya d = d tiny d = tinyb assert_equal tiny d tinyb scalar = d tiny d = tinyb assert_equal tiny d tinyb arr = np array np array tinya assert_equal arr tinya skip reason= object arrays test_cast_to_string cast str should do str scalar str scalar item Example In python str float truncated so we want avoid str np float item would incorrectly truncate = np zeros dtype= S = np array dtype= f assert_equal b TestDtypedescr TestCase test_construction d = np dtype i assert_equal d np dtype np int d = np dtype f assert_equal d np dtype np float skip reason= TODO zero-rank FIXME revert skip into xfail TestZeroRank TestCase setUp d = np array np array x object test_ellipsis_subscript b = d assert_equal assert_equal b x assert_ base ` ` numpy assert_ b base b ` b b ` numpy test_empty_subscript b = d assert_equal assert_equal b x assert_ type dtype type assert_ type b str test_invalid_subscript b = d assert_raises IndexError lambda x x assert_raises IndexError lambda x x b assert_raises IndexError lambda x x np array int assert_raises IndexError lambda x x np array int b test_ellipsis_subscript_assignment b = d = assert_equal b = assert_equal b item test_empty_subscript_assignment b = d = assert_equal b = assert_equal b item test_invalid_subscript_assignment b = d assign x i v x i = v assert_raises IndexError assign assert_raises IndexError assign b assert_raises ValueError assign test_newaxis b = d assert_equal np newaxis shape assert_equal np newaxis shape assert_equal np newaxis shape assert_equal np newaxis shape assert_equal np newaxis np newaxis shape assert_equal np newaxis np newaxis shape assert_equal np newaxis np newaxis shape assert_equal np newaxis shape test_invalid_newaxis b = d subscript x i x i assert_raises IndexError subscript np newaxis assert_raises IndexError subscript np newaxis test_constructor x = np ndarray x = assert_equal x y = np ndarray buffer=x y = assert_equal x strides shape must same length pytest raises ValueError np ndarray strides= pytest raises ValueError np ndarray strides= test_output x = np array assert_raises ValueError np add x x test_real_imag contiguity checks gh- x = np array j xr = x real xi = x imag assert_equal xr np array assert_ type xr np ndarray assert_equal xr flags contiguous True assert_equal xr flags f_contiguous True assert_equal xi np array assert_ type xi np ndarray assert_equal xi flags contiguous True assert_equal xi flags f_contiguous True TestScalarIndexing TestCase setUp d = np array test_ellipsis_subscript = d assert_equal assert_equal shape test_empty_subscript = d assert_equal assert_equal shape test_invalid_subscript = d assert_raises IndexError lambda x x assert_raises IndexError lambda x x np array int test_invalid_subscript_assignment = d assign x i v x i = v assert_raises IndexError TypeError assign test_newaxis = d assert_equal np newaxis shape assert_equal np newaxis shape assert_equal np newaxis shape assert_equal np newaxis shape assert_equal np newaxis np newaxis shape assert_equal np newaxis np newaxis shape assert_equal np newaxis np newaxis shape assert_equal np newaxis shape test_invalid_newaxis = d subscript x i x i assert_raises IndexError subscript np newaxis assertion fails because NPY_MAXDIMS = assert_raises IndexError subscript np newaxis xfail reason= pytorch disallows overlapping assignments test_overlapping_assignment With positive strides = np arange - = assert_equal = np arange = - assert_equal With positive negative strides = np arange = - assert_equal = np arange reshape - = - assert_equal = np arange reshape - - = - assert_equal With just one element overlapping = np arange = assert_equal = np arange = assert_equal = np arange - = assert_equal = np arange = - assert_equal = np arange - = - assert_equal = np arange - = - assert_equal skip reason= object void structured dtypes instantiate_parametrized_tests TestCreation TestCase Test np array constructor test_from_attribute x __array__ dtype=None pass assert_raises ValueError np array x test_from_string types = np typecodes AllInteger + np typecodes Float nstr = result = np array dtype=int type types msg = f String conversion type assert_equal np array nstr dtype=type result err_msg=msg test_void arr = np array dtype= V assert arr dtype == V current default Same length scalars those go same void work arr = np array b b dtype= V assert arr dtype == V Promoting different lengths will fail pre worked going via S casting V pytest raises TypeError np array b b dtype= V pytest raises TypeError np array b b dtype= V Check same casting path arr = np array b b dtype= O astype V assert arr dtype == V pytest raises TypeError np array b b dtype= O astype V parametrize idx pytest param Ellipsis id= arr pytest param id= scalar idx subtest Ellipsis name= arr subtest name= scalar test_structured_void_promotion idx arr = np array np array dtype= i i idx np array dtype= i i idx dtype= V assert_array_equal arr np array dtype= i i The following fails promote two dtypes resulting error pytest raises TypeError np array np array dtype= i i idx np array dtype= i i i idx dtype= V test_too_big_error smallest integer greater than sqrt - smallest integer greater than sqrt - We want make sure square byte array those dimensions too big bit systems respectively np iinfo intp max == - shape = np iinfo intp max == - shape = assert_raises ValueError np empty shape dtype=np int assert_raises ValueError np zeros shape dtype=np int assert_raises ValueError np ones shape dtype=np int skipif np dtype np intp itemsize = reason= malloc may fail bit systems test_malloc_fails This test guaranteed fail due too large allocation assert_raises np core _exceptions _ArrayMemoryError np empty np iinfo np intp max dtype=np uint test_zeros types = np typecodes AllInteger + np typecodes AllFloat dt types d = np zeros dtype=dt assert_equal np count_nonzero d true ieee floats assert_equal d sum assert_ d any d = np zeros dtype= i assert_equal np count_nonzero d assert_equal d sum assert_ d any d = np zeros dtype= i assert_equal np count_nonzero d assert_equal d sum assert_ d any d = np zeros dtype= i i assert_equal np count_nonzero d slow test_zeros_big test big array they might allocated different system types = np typecodes AllInteger + np typecodes AllFloat dt types d = np zeros dtype=dt assert_ d any This test can fail -bit systems due insufficient contiguous memory Deallocating previous array increases chance success del d test_zeros_obj test initialization PyLong d = np zeros dtype=object assert_array_equal d assert_equal np count_nonzero d test_zeros_obj_obj d = np zeros dtype= k object assert_array_equal d k test_zeros_like_like_zeros test zeros_like returns same zeros c np typecodes All c == V continue d = np zeros dtype=c assert_array_equal np zeros_like d d assert_equal np zeros_like d dtype d dtype explicitly check some special cases d = np zeros dtype= S assert_array_equal np zeros_like d d assert_equal np zeros_like d dtype d dtype d = np zeros dtype= U assert_array_equal np zeros_like d d assert_equal np zeros_like d dtype d dtype d = np zeros dtype= i assert_array_equal np zeros_like d d assert_equal np zeros_like d dtype d dtype d = np zeros dtype= i assert_array_equal np zeros_like d d assert_equal np zeros_like d dtype d dtype d = np zeros dtype= M s assert_array_equal np zeros_like d d assert_equal np zeros_like d dtype d dtype d = np zeros dtype= M s assert_array_equal np zeros_like d d assert_equal np zeros_like d dtype d dtype d = np zeros dtype= f f assert_array_equal np zeros_like d d assert_equal np zeros_like d dtype d dtype test_empty_unicode don t throw decode errors garbage memory i range d = np empty i dtype= U str d test_sequence_non_homogeneous assert_equal np array dtype object assert_equal np array dtype object assert_equal np array dtype object assert_equal np array dtype object assert_equal np array j j dtype complex assert_equal np array j j dtype complex assert_equal np array j dtype complex test_non_sequence_sequence Should segfault Class Fail breaks sequence protocol new style classes i e those derived object Class Map mapping type indicated raising ValueError At some point we may raise warning instead error Fail case Fail __len__ __getitem__ index raise ValueError Map __len__ __getitem__ index raise KeyError = np array Map assert_ shape == assert_ dtype == np dtype object assert_raises ValueError np array Fail test_no_len_object_type gh- want object array iterable object without len Point __init__ - None pass __getitem__ ind ind ind raise IndexError d = np array Point Point Point assert_equal d dtype np dtype object test_false_len_sequence gh- segfault example C __getitem__ i raise IndexError __len__ = np array C segfault assert_equal len test_false_len_iterable Special case where bad __getitem__ makes us fall back __iter__ C __getitem__ x raise Exception noqa TRY __iter__ iter __len__ = np empty assert_raises ValueError = C Segfault assert_equal np array C list C test_failed_len_sequence gh- A __init__ data _data = data __getitem__ item type _data item __len__ len _data len d should give len d will fail d = A assert_equal len np array d test_array_too_big Test array creation succeeds arrays addressable intp byte level fails too large arrays buf = np zeros max_bytes = np iinfo np intp max dtype intp S b dtype = np dtype dtype itemsize = dtype itemsize np ndarray buffer=buf strides= shape= max_bytes itemsize dtype=dtype assert_raises ValueError np ndarray buffer=buf strides= shape= max_bytes itemsize + dtype=dtype _ragged_creation seq without dtype=object ragged object raises pytest raises ValueError match= detected shape np array seq np array seq dtype=object test_ragged_ndim_object Lists mismatching depths treated object arrays = _ragged_creation assert_equal shape assert_equal dtype object = _ragged_creation assert_equal shape assert_equal dtype object = _ragged_creation assert_equal shape assert_equal dtype object test_ragged_shape_object The ragged dimension list turned into object array = _ragged_creation assert_equal shape assert_equal dtype object = _ragged_creation assert_equal shape assert_equal dtype object = _ragged_creation assert shape == assert dtype == object test_array_of_ragged_array outer = np array None None outer = outer = np array assert np array outer shape == assert np array outer shape == outer_ragged = np array None None outer_ragged = np array outer_ragged = np array should both these emit deprecation warnings assert np array outer_ragged shape == assert np array outer_ragged shape == test_deep_nonragged_object None these should raise even though they missing dtype=object np array Decimal np array Decimal np array Decimal parametrize dtype object O O O O O parametrize function np ndarray np empty lambda shape dtype np empty_like np empty shape dtype=dtype test_object_initialized_to_None function dtype NumPy has support object fields NULL meaning None generally we should always fill proper None downstream may rely For fully initialized arrays arr = function dtype=dtype We expect fill value None which NULL expected = np array None tobytes expected = expected arr nbytes len expected assert arr tobytes == expected TestBool TestCase xfail reason= bools interned test_test_interning = np bool_ b = np bool_ False assert_ b = np bool_ b = np bool_ True assert_ b assert_ np array True assert_ np array True test_sum d = np ones dtype=bool assert_equal d sum d size assert_equal d sum d size assert_equal d - sum d - size xpassIfTorchDynamo_np reason= frombuffer test_sum_ d = np frombuffer b \xff\xff dtype=bool assert_equal d sum d size assert_equal d sum d size assert_equal d - sum d - size check_count_nonzero power length powers = i i range length i range power l = i x = x powers = np array l dtype=bool c = builtins sum l assert_equal np count_nonzero c av = view np uint av = assert_equal np count_nonzero c av = assert_equal np count_nonzero c av av = = xFF assert_equal np count_nonzero c test_count_nonzero check all bit combinations length array covers most cases byte unrolled code check_count_nonzero slow test_count_nonzero_all check all combinations length array covers all cases byte unrolled code check_count_nonzero test_count_nonzero_unaligned prevent mistakes e g gh- o range = np zeros dtype=bool o + o = True assert_equal np count_nonzero builtins sum tolist = np ones dtype=bool o + o = False assert_equal np count_nonzero builtins sum tolist _test_cast_from_flexible dtype empty string - false n range v = np array b dtype n assert_equal bool v False assert_equal bool v False assert_equal v astype bool False assert_ isinstance v astype bool np ndarray assert_ v astype bool np False_ anything - true n range val b b b v = np array val dtype n assert_equal bool v True assert_equal bool v True assert_equal v astype bool True assert_ isinstance v astype bool np ndarray assert_ v astype bool np True_ skip reason= np void test_cast_from_void _test_cast_from_flexible np void xfail reason= See gh- test_cast_from_unicode _test_cast_from_flexible np str_ xfail reason= See gh- test_cast_from_bytes _test_cast_from_flexible np bytes_ instantiate_parametrized_tests TestMethods TestCase sort_kinds = quicksort heapsort stable xpassIfTorchDynamo_np reason= all where= test_all_where = np array True False True False False False True True True wh_full = np array True False True False False False True False True wh_lower = np array False False True _ax None assert_equal all axis=_ax where=wh_lower np all wh_lower axis=_ax assert_equal np all axis=_ax where=wh_lower wh_lower all axis=_ax assert_equal all where=wh_full True assert_equal np all where=wh_full True assert_equal all where=False True assert_equal np all where=False True xpassIfTorchDynamo_np reason= any where= test_any_where = np array True False True False False False True True True wh_full = np array False True False True True True False False False wh_middle = np array False True False _ax None assert_equal any axis=_ax where=wh_middle np any wh_middle axis=_ax assert_equal np any axis=_ax where=wh_middle wh_middle any axis=_ax assert_equal any where=wh_full False assert_equal np any where=wh_full False assert_equal any where=False False assert_equal np any where=False False xpassIfTorchDynamo_np reason= TODO compress test_compress tgt = arr = np arange reshape out = arr compress axis= assert_equal out tgt tgt = out = arr compress axis= assert_equal out tgt tgt = arr = np arange reshape out = arr compress axis= assert_equal out tgt arr = np arange reshape out = arr compress assert_equal out test_choose x = np ones dtype=int y = np ones dtype=int x = np ones dtype=int y = np ones dtype=int ind = np array A = ind choose x y assert_equal A A = ind choose x y assert_equal A A = ind choose x y assert_equal A out = np array ret = np choose np array out=out assert out ret assert_equal out xpassIfTorchDynamo_np reason= choose mode= implemented test_choose_ gh- check overlap out x = np arange y = np choose x x x out=x mode= wrap assert_equal y np array test_prod ba = ba = ctype np int np int np float np float np complex np complex = np array ba ctype = np array ba ctype ctype b assert_raises ArithmeticError prod assert_raises ArithmeticError prod axis= assert_equal prod axis= assert_array_equal prod axis= np array ctype assert_array_equal prod axis=- np array ctype test_repeat m = np array m_rect = m reshape A = m repeat assert_equal A A = m repeat assert_equal A A = m_rect repeat axis= assert_equal A A = m_rect repeat axis= assert_equal A A = m_rect repeat axis= assert_equal A A = m_rect repeat axis= assert_equal A xpassIfTorchDynamo_np reason= reshape order= F test_reshape arr = np array tgt = assert_equal arr reshape tgt tgt = assert_equal arr reshape tgt tgt = assert_equal arr reshape order= F tgt tgt = assert_equal arr T reshape order= C tgt test_round check_round arr expected round_args assert_equal arr round round_args expected With output array out = np zeros_like arr res = arr round round_args out=out assert_equal out expected assert out res check_round np array check_round np array check_round np array - check_round np array Complex rounding check_round np array + j + j check_round np array + j + j - test_squeeze = np array assert_equal squeeze assert_equal squeeze axis= assert_raises ValueError squeeze axis= noop pytorch assert_equal squeeze axis= test_transpose = np array assert_equal transpose assert_raises RuntimeError ValueError lambda transpose assert_raises RuntimeError ValueError lambda transpose assert_raises RuntimeError ValueError lambda transpose test_sort test ordering floats complex containing nans It only necessary check less-than comparison so sorts only follow insertion sort path sufficient We only test doubles complex doubles logic same check doubles msg = Test real sort order nans = np array np nan b = np sort assert_equal b np flip msg xpassIfTorchDynamo_np reason= sort complex test_sort_complex_nans check complex msg = Test complex sort order nans = np zeros dtype=np complex real += np nan np nan np nan imag += np nan np nan np nan b = np sort assert_equal b - msg all c scalar sorts use same code different types so suffices run quick check one type The number sorted items must greater than ~ check actual algorithm because quick merge sort fall over insertion sort small arrays parametrize dtype np uint np float np float np float test_sort_unsigned dtype = np arange dtype=dtype b = np flip kind sort_kinds msg = f scalar sort kind= kind c = copy c sort kind=kind assert_equal c msg c = b copy c sort kind=kind assert_equal c msg parametrize dtype np int np int np int np int np float np float np float test_sort_signed dtype = np arange - dtype=dtype b = np flip kind sort_kinds msg = f scalar sort kind= kind c = copy c sort kind=kind assert_equal c msg c = b copy c sort kind=kind assert_equal c msg xpassIfTorchDynamo_np reason= sort complex parametrize dtype np float np float parametrize part real imag test_sort_complex part dtype test complex sorts These use same code scalars compare function differs cdtype = np single np csingle np double np cdouble dtype = np arange - dtype=dtype b = - copy ai = + j astype cdtype bi = b + j astype cdtype setattr ai part setattr bi part kind sort_kinds msg = f complex sort part part == kind= kind c = ai copy c sort kind=kind assert_equal c ai msg c = bi copy c sort kind=kind assert_equal c ai msg test_sort_axis check axis handling This should same all type specific sorts so we only check one type one kind = np array b = np array c = np array d = copy d sort axis= assert_equal d b test sort axis= d = copy d sort axis= assert_equal d c test sort axis= d = copy d sort assert_equal d c test sort default axis test_sort_size_ check axis handling multidimensional empty arrays = np array = reshape axis range -a ndim ndim msg = f test empty array sort axis= axis assert_equal np sort axis=axis msg msg = test empty array sort axis=None assert_equal np sort axis=None ravel msg skip reason= waaay tooo sloooow test_sort_degraded test degraded dataset would take minutes run normal qsort d = np arange do = d copy x = d create median killer where each median sorted second last element quicksort partition while x size mid = x size x mid x - = x - x mid x = x - assert_equal np sort d do assert_equal d np argsort d do xfail reason= order= F test_copy assert_fortran arr assert_ arr flags fortran assert_ arr flags f_contiguous assert_ arr flags c_contiguous assert_c arr assert_ arr flags fortran assert_ arr flags f_contiguous assert_ arr flags c_contiguous = np empty order= F Test copying Fortran array assert_c copy assert_c copy C assert_fortran copy F assert_fortran copy A Now test starting C array = np empty order= C assert_c copy assert_c copy C assert_fortran copy F assert_c copy A skip reason= no ctypes attribute parametrize dtype np int test__deepcopy__ dtype Force entry NULLs into array = np empty dtype=dtype ctypes memset ctypes data nbytes Ensure no error raised see gh- b = __deepcopy__ = pytest raises AssertionError assert_array_equal b test_argsort all c scalar argsorts use same code different types so suffices run quick check one type The number sorted items must greater than ~ check actual algorithm because quick merge sort fall over insertion sort small arrays dtype np int np uint np float = np arange dtype=dtype b = np flip kind sort_kinds msg = f scalar argsort kind= kind dtype= dtype assert_equal copy argsort kind=kind msg assert_equal b copy argsort kind=kind b msg skip reason= argsort complex test_argsort_complex = np arange dtype=np float b = np flip test complex argsorts These use same code scalars compare function differs ai = j + bi = b j + kind sort_kinds msg = f complex argsort kind= kind assert_equal ai copy argsort kind=kind msg assert_equal bi copy argsort kind=kind b msg ai = + j bi = b + j kind sort_kinds msg = f complex argsort kind= kind assert_equal ai copy argsort kind=kind msg assert_equal bi copy argsort kind=kind b msg test argsort complex arrays requiring byte-swapping gh- endianness dt np typecodes Complex arr = np array + j + j + j dtype=endianness + dt msg = f byte-swapped complex argsort dtype= dt assert_equal arr argsort np arange len arr dtype=np intp msg xpassIfTorchDynamo_np reason= argsort axis TODO test_argsort_axis check axis handling This should same all type specific argsorts so we only check one type one kind = np array b = np array c = np array assert_equal copy argsort axis= b assert_equal copy argsort axis= c assert_equal copy argsort c check axis handling multidimensional empty arrays = np array = reshape axis range -a ndim ndim msg = f test empty array argsort axis= axis assert_equal np argsort axis=axis np zeros_like dtype=np intp msg msg = test empty array argsort axis=None assert_equal np argsort axis=None np zeros_like ravel dtype=np intp msg check stable argsorts stable r = np arange scalars = np zeros assert_equal argsort kind= m r complex = np zeros dtype=complex assert_equal argsort kind= m r string = np array aaaaaaaaa i range assert_equal argsort kind= m r unicode = np array aaaaaaaaa i range dtype=np str_ assert_equal argsort kind= m r xpassIfTorchDynamo_np reason= TODO searchsorted nans differs pytorch parametrize subtest np array np nan dtype=np float name= f subtest np array np nan dtype=np float name= f subtest np array np nan name= default_dtype test_searchsorted_floats test floats arrays containing nans Explicitly test half single double precision floats verify NaN-handling correct msg = f Test real dtype searchsorted nans side= l b = searchsorted side= left assert_equal b np arange msg msg = f Test real dtype searchsorted nans side= r b = searchsorted side= right assert_equal b np arange msg check keyword arguments searchsorted v= x = np array np nan dtype= float y = np searchsorted x x - assert_equal y xfail reason= searchsorted_out_cpu implemented ComplexDouble test_searchsorted_complex test complex arrays containing nans The search sorted routines use compare functions array type so checks consistent sort order check double complex = np zeros dtype=np complex real += np nan np nan np nan imag += np nan np nan np nan msg = Test complex searchsorted nans side= l b = searchsorted side= left assert_equal b np arange msg msg = Test complex searchsorted nans side= r b = searchsorted side= right assert_equal b np arange msg msg = Test searchsorted little endian side= l = np array dtype= i b = searchsorted np array dtype= i assert_equal b msg msg = Test searchsorted big endian side= l = np array dtype= i b = searchsorted np array dtype= i assert_equal b msg test_searchsorted_n_elements Check elements = np ones b = searchsorted left assert_equal b b = searchsorted right assert_equal b = np ones Check element b = searchsorted left assert_equal b b = searchsorted right assert_equal b Check all elements equal = np ones b = searchsorted left assert_equal b b = searchsorted right assert_equal b xpassIfTorchDynamo_np reason= RuntimeError storage_offset must divisible test_searchsorted_unaligned_array Test searching unaligned array = np arange aligned = np empty itemsize size + dtype= uint unaligned = aligned view dtype unaligned = Test searching unaligned array b = unaligned searchsorted left assert_equal b b = unaligned searchsorted right assert_equal b + Test searching unaligned keys b = searchsorted unaligned left assert_equal b b = searchsorted unaligned right assert_equal b + test_searchsorted_resetting Test smart resetting binsearch indices = np arange b = searchsorted left assert_equal b b = searchsorted right assert_equal b test_searchsorted_type_specific Test all type specific binary search functions types = join np typecodes AllInteger np typecodes Float dt types dt == = np arange dtype=dt out = np arange = np arange dtype=dt out = np arange b = searchsorted left assert_equal b out b = searchsorted right assert_equal b out + xpassIfTorchDynamo_np reason= ndarray ctor test_searchsorted_type_specific_ Test all type specific binary search functions types = join np typecodes AllInteger np typecodes AllFloat dt types dt == = np arange dtype=dt = np arange dtype=dt Test empty array use fresh array get warnings valgrind access happens e = np ndarray shape= buffer=b dtype=dt b = e searchsorted left assert_array_equal b np zeros len dtype=np intp b = searchsorted e left assert_array_equal b np zeros dtype=np intp test_searchsorted_with_invalid_sorter = np array assert_raises TypeError RuntimeError np searchsorted sorter= assert_raises ValueError RuntimeError np searchsorted sorter= assert_raises ValueError RuntimeError np searchsorted sorter= bounds check XXX torch does raise assert_raises ValueError np searchsorted sorter= assert_raises ValueError np searchsorted sorter= - assert_raises ValueError np searchsorted sorter= - xpassIfTorchDynamo_np reason= storage_offset must divisible test_searchsorted_with_sorter = np random rand s = argsort b = np sort k = np linspace assert_equal b searchsorted k searchsorted k sorter=s = np array s = argsort k = expected = assert_equal searchsorted k side= left sorter=s expected expected = assert_equal searchsorted k side= right sorter=s expected Test searching unaligned array keys = np arange = keys copy np random shuffle s s = argsort aligned = np empty itemsize size + dtype= uint unaligned = aligned view dtype Test searching unaligned array unaligned = b = unaligned searchsorted keys left s assert_equal b keys b = unaligned searchsorted keys right s assert_equal b keys + Test searching unaligned keys unaligned = keys b = searchsorted unaligned left s assert_equal b keys b = searchsorted unaligned right s assert_equal b keys + Test all type specific indirect binary search functions types = join np typecodes AllInteger np typecodes AllFloat dt types dt == = np array dtype=dt We want sorter array type different np intp all platforms check s = np array dtype=np int out = np array = np array dtype=dt We want sorter array type different np intp all platforms check s = np array dtype=np int out = np array dtype=np intp b = searchsorted left s assert_equal b out b = searchsorted right s assert_equal b out + Test empty array use fresh array get warnings valgrind access happens e = np ndarray shape= buffer=b dtype=dt b = e searchsorted left s assert_array_equal b np zeros len dtype=np intp b = searchsorted e left s assert_array_equal b np zeros dtype=np intp Test non-contiguous sorter array = np array srt = np empty dtype=np intp srt = - srt = s = srt out = np array dtype=np intp b = searchsorted left s assert_equal b out b = searchsorted right s assert_equal b out + xpassIfTorchDynamo_np reason= TODO argpartition parametrize dtype efdFDBbhil test_argpartition_out_of_range dtype Test out range values kth raise error gh- d = np arange astype dtype=dtype assert_raises ValueError d argpartition assert_raises ValueError d argpartition - xpassIfTorchDynamo_np reason= TODO partition parametrize dtype efdFDBbhil test_partition_out_of_range dtype Test out range values kth raise error gh- d = np arange astype dtype=dtype assert_raises ValueError d partition assert_raises ValueError d partition - xpassIfTorchDynamo_np reason= TODO argpartition test_argpartition_integer Test non-integer values kth raise error d = np arange assert_raises TypeError d argpartition Test also generic type argpartition which uses sorting used bound check kth d_obj = np arange dtype=object assert_raises TypeError d_obj argpartition xpassIfTorchDynamo_np reason= TODO partition test_partition_integer Test out range values kth raise error gh- d = np arange assert_raises TypeError d partition Test also generic type partition which uses sorting used bound check kth d_obj = np arange dtype=object assert_raises TypeError d_obj partition xpassIfTorchDynamo_np reason= TODO partition parametrize kth_dtype Bbhil test_partition_empty_array kth_dtype check axis handling multidimensional empty arrays kth = np array dtype=kth_dtype = np array shape = axis range -a ndim ndim msg = f test empty array partition axis= axis assert_equal np partition kth axis=axis msg msg = test empty array partition axis=None assert_equal np partition kth axis=None ravel msg xpassIfTorchDynamo_np reason= TODO argpartition parametrize kth_dtype Bbhil test_argpartition_empty_array kth_dtype check axis handling multidimensional empty arrays kth = np array dtype=kth_dtype = np array shape = axis range -a ndim ndim msg = f test empty array argpartition axis= axis assert_equal np partition kth axis=axis np zeros_like dtype=np intp msg msg = test empty array argpartition axis=None assert_equal np partition kth axis=None np zeros_like ravel dtype=np intp msg xpassIfTorchDynamo_np reason= TODO partition test_partition d = np arange assert_raises TypeError np partition d kind= assert_raises ValueError np partition d kind= nonsense assert_raises ValueError np argpartition d kind= nonsense assert_raises ValueError d partition axis= kind= nonsense assert_raises ValueError d argpartition axis= kind= nonsense k introselect d = np array assert_array_equal np partition d kind=k d assert_array_equal np argpartition d kind=k d d = np ones assert_array_equal np partition d kind=k d assert_array_equal d np argpartition d kind=k np partition d kind=k kth modified kth = np array okth = kth copy np partition np arange kth assert_array_equal kth okth r d = np array r tgt = np sort d assert_array_equal np partition d kind=k tgt assert_array_equal np partition d kind=k tgt assert_array_equal d np argpartition d kind=k np partition d kind=k assert_array_equal d np argpartition d kind=k np partition d kind=k i range d size d i partition kind=k assert_array_equal d tgt r d = np array r tgt = np sort d assert_array_equal np partition d kind=k tgt assert_array_equal np partition d kind=k tgt assert_array_equal np partition d kind=k tgt assert_array_equal d np argpartition d kind=k np partition d kind=k assert_array_equal d np argpartition d kind=k np partition d kind=k assert_array_equal d np argpartition d kind=k np partition d kind=k i range d size d i partition kind=k assert_array_equal d tgt d = np ones assert_array_equal np partition d kind=k d assert_array_equal d np argpartition d kind=k np partition d kind=k sorted d = np arange assert_equal np partition d kind=k assert_equal np partition d kind=k assert_array_equal d np argpartition d kind=k np partition d kind=k assert_array_equal d np argpartition d kind=k np partition d kind=k rsorted d = np arange - assert_equal np partition d kind=k assert_equal np partition d kind=k assert_array_equal d np argpartition d kind=k np partition d kind=k assert_array_equal d np argpartition d kind=k np partition d kind=k assert_array_equal np partition d - kind=k np partition d kind=k assert_array_equal np partition d - kind=k np partition d kind=k assert_array_equal d np argpartition d - kind=k np partition d kind=k median killer O n^ pure median pivot quickselect exercises median median code used keep O n d = np arange x = np roll d d size mid = x size + assert_equal np partition x mid mid mid d = np arange x = np roll d d size + mid = x size + assert_equal np partition x mid mid mid max d = np ones d = assert_equal np partition d - - assert_equal np partition d - assert_equal d np argpartition d - - assert_equal d np argpartition d - d = np nan assert_ np isnan d np argpartition d - - assert_ np isnan np partition d - - equal elements d = np arange tgt = np sort np arange np random shuffle d i range d size assert_equal np partition d i kind=k i tgt i assert_array_equal d np argpartition d kind=k np partition d kind=k assert_array_equal d np argpartition d kind=k np partition d kind=k i range d size d i partition kind=k assert_array_equal d tgt d = np array kth = assert_equal np partition d kth kind=k kth assert_equal d np argpartition d kth kind=k kth d = np array d partition kind=k assert_raises ValueError d partition assert_raises np AxisError d partition axis= assert_raises ValueError np partition d assert_raises np AxisError np partition d axis= assert_raises ValueError d argpartition assert_raises np AxisError d argpartition axis= assert_raises ValueError np argpartition d assert_raises np AxisError np argpartition d axis= d = np arange reshape d partition axis= kind=k d partition axis= kind=k np partition d axis= kind=k np partition d axis= kind=k np partition d axis=None kind=k np partition d axis=None kind=k d argpartition axis= kind=k d argpartition axis= kind=k np argpartition d axis= kind=k np argpartition d axis= kind=k np argpartition d axis=None kind=k np argpartition d axis=None kind=k assert_raises ValueError d partition axis= assert_raises ValueError d partition axis= assert_raises TypeError d partition axis=None assert_raises ValueError np partition d axis= assert_raises ValueError np partition d axis=None assert_raises ValueError d argpartition axis= assert_raises ValueError d argpartition axis= assert_raises ValueError np argpartition d axis= assert_raises ValueError np argpartition d axis=None td = dt s dt np int np float np complex s dt s td aae = assert_array_equal = assert_ d = np arange s dtype=dt np random shuffle d d = np tile np arange s dtype=dt map np random shuffle d d = np transpose d i range d size p = np partition d i kind=k assert_equal p i i all before smaller assert_array_less p i p i all after larger assert_array_less p i p i + aae p d np argpartition d i kind=k p = np partition d i axis= kind=k aae p i np array i d shape dtype=dt array_less does seem work right p i T = p i all msg=f i d p i r = p i T r p i + T p i all msg=f i d p i r p i + T r aae p d np arange d shape None np argpartition d i axis= kind=k p = np partition d i axis= kind=k aae p i np array i d shape dtype=dt array_less does seem work right p i = p i all msg=f i d p i r = p i r p i + p i all msg=f i d p i r p i + r aae p d np argpartition d i axis= kind=k np arange d shape None check inplace dc = d copy dc partition i kind=k assert_equal dc np partition d i kind=k dc = d copy dc partition i axis= kind=k assert_equal dc np partition d i axis= kind=k dc = d copy dc partition i axis= kind=k assert_equal dc np partition d i axis= kind=k assert_partitioned d kth prev = k np sort kth assert_array_less d prev k d k err_msg=f kth k d assert_ d k = d k all msg=f kth k d d k r greater equal d k d prev = k + xpassIfTorchDynamo_np reason= TODO partition test_partition_iterative d = np arange kth = assert_raises ValueError d partition kth assert_raises ValueError d argpartition kth d = np arange reshape assert_raises ValueError d partition kth axis= assert_raises ValueError d partition kth axis= assert_raises ValueError np partition d kth axis= assert_raises ValueError np partition d kth axis=None d = np array p = np partition d assert_partitioned p assert_partitioned d np argpartition d assert_array_equal p np partition d - - assert_array_equal p d np argpartition d - - d = np arange np random shuffle d d partition range d size assert_array_equal np arange d np random shuffle d assert_array_equal np arange d d argpartition range d size test unsorted kth d = np arange np random shuffle d keys = np array - np random shuffle d p = np partition d keys assert_partitioned p keys p = d np argpartition d keys assert_partitioned p keys np random shuffle keys assert_array_equal np partition d keys p assert_array_equal d np argpartition d keys p equal kth d = np arange - assert_partitioned np partition d assert_partitioned np partition d + + assert_partitioned d np argpartition d assert_partitioned d np argpartition d + + d = np arange np random shuffle d d = np tile np arange map np random shuffle d d = np transpose d kth = - p = np partition d kth axis= pa = d np arange d shape None d argpartition kth axis= assert_array_equal p pa i range d shape assert_partitioned p i kth p = np partition d kth axis= pa = d np argpartition d kth axis= np arange d shape None assert_array_equal p pa i range d shape assert_partitioned p i kth xpassIfTorchDynamo_np reason= TODO partition test_partition_fuzz few rounds random data testing j range i range j - d = np arange j np random shuffle d d = d np random randint idx = np random randint d size kth = idx i i + tgt = np sort d kth assert_array_equal np partition d kth kth tgt err_msg=f data d r \n kth kth r xpassIfTorchDynamo_np reason= TODO partition parametrize kth_dtype Bbhil test_argpartition_gh kth_dtype A test functionality argpartition lists kth = np array dtype=kth_dtype d = p = np argpartition d kth assert_partitioned np array d p xpassIfTorchDynamo_np reason= TODO order= F test_flatten x = np array np int x = np array np int y = np array np int y f = np array np int y = np array np int y f = np array np int assert_equal x flatten y assert_equal x flatten F y f assert_equal x flatten F x T flatten assert_equal x flatten y assert_equal x flatten F y f assert_equal x flatten F x T flatten parametrize func np dot np matmul test_arr_mult func = np array b = np array d = np arange reshape ddt = np array dtd = np array gemm vs syrk optimizations et np float np float np complex np complex eaf = astype et assert_equal func eaf eaf eaf assert_equal func eaf T eaf eaf assert_equal func eaf eaf T eaf assert_equal func eaf T eaf T eaf assert_equal func eaf T copy eaf eaf assert_equal func eaf eaf T copy eaf assert_equal func eaf T copy eaf T copy eaf syrk validations et np float np float np complex np complex eaf = astype et ebf = b astype et assert_equal func ebf ebf eaf assert_equal func ebf T ebf eaf assert_equal func ebf ebf T eaf assert_equal func ebf T ebf T eaf syrk - different shape et np float np float np complex np complex edf = d astype et eddtf = ddt astype et edtdf = dtd astype et assert_equal func edf edf T eddtf assert_equal func edf T edf edtdf assert_equal func edf edf shape edf T func edf edf shape copy edf T copy assert_equal func edf edf edf shape T func edf copy edf edf shape T copy skip reason= dot matmul negative strides parametrize func np dot np matmul test_arr_mult_ func syrk - different shape stride view validations et np float np float np complex np complex edf = d astype et assert_equal func edf - edf T func edf - copy edf T copy assert_equal func edf - edf T func edf - copy edf T copy assert_equal func edf edf - T func edf edf - T copy assert_equal func edf edf - T func edf edf - T copy parametrize func np dot np matmul parametrize dtype ifdFD test_no_dgemv func dtype check vector arg contiguous before gemv gh- = np arange dtype=dtype reshape b = np broadcast_to ret = func b ret = func b copy assert_equal ret ret ret = func b T T ret = func b T copy T assert_equal ret ret skip reason= __array_interface__ parametrize func np dot np matmul parametrize dtype ifdFD test_no_dgemv_ func dtype check unaligned data dt = np dtype dtype = np zeros dt itemsize + dtype= int view dtype = reshape b = make sure aligned assert_ __array_interface__ data dt itemsize = ret = func b ret = func copy b copy assert_equal ret ret ret = func b T T ret = func b T copy T copy assert_equal ret ret test_dot = np array b = np array c = np array - function versus methods assert_equal np dot b dot b assert_equal np dot np dot b c dot b dot c test passing output array c = np zeros_like dot b c assert_equal c np dot b test keyword args c = np zeros_like dot b=b out=c assert_equal c np dot b xpassIfTorchDynamo_np reason= _aligned_zeros test_dot_out_mem_overlap np random seed Test BLAS non-BLAS code paths including all dtypes dot supports dtypes = np dtype code code np typecodes All code USVM dtype dtypes = np random rand astype dtype Valid dot output arrays must aligned b = _aligned_zeros dtype=dtype b = np random rand y = np dot b x = np dot b out=b assert_equal x y err_msg=repr dtype Check invalid output array assert_raises ValueError np dot b out=b assert_raises ValueError np dot b out=b T xpassIfTorchDynamo_np reason= TODO overlapping memor matmul test_matmul_out overlapping memory = np arange reshape b = np matmul c = np matmul out=a assert_ c assert_equal c b = np arange reshape c = np matmul out=a - assert_ c base base assert_equal c b test_diagonal = np arange reshape assert_equal diagonal assert_equal diagonal assert_equal diagonal assert_equal diagonal - assert_raises np AxisError diagonal axis = axis = assert_raises np AxisError diagonal axis = axis = assert_raises np AxisError diagonal axis = axis = assert_raises ValueError RuntimeError diagonal axis = axis = b = np arange reshape assert_equal b diagonal assert_equal b diagonal assert_equal b diagonal assert_equal b diagonal - assert_raises ValueError RuntimeError b diagonal axis = axis = assert_equal b diagonal assert_equal b diagonal assert_equal b diagonal offset= axis = axis = Order axis argument doesn t matter assert_equal b diagonal xfail reason= no readonly views test_diagonal_view_notwriteable = np eye diagonal assert_ flags writeable assert_ flags owndata = np diagonal np eye assert_ flags writeable assert_ flags owndata = np diag np eye assert_ flags writeable assert_ flags owndata test_diagonal_memleak Regression test bug crept one point = np zeros HAS_REFCOUNT assert_ sys getrefcount _ range diagonal HAS_REFCOUNT assert_ sys getrefcount test_size_zero_memleak Regression test issue Exercises special-case code path dot products length zero cblasfuncs making specific floating dtypes = np array dtype=np float x = np array _ range np dot out=x HAS_REFCOUNT assert_ sys getrefcount x test_trace = np arange reshape assert_equal trace assert_equal trace assert_equal trace assert_equal trace - b = np arange reshape assert_equal b trace assert_equal b trace assert_equal b trace assert_equal b trace - assert_equal b trace assert_equal b trace assert_equal b trace assert_equal b trace offset= axis = axis = out = np array ret = trace out=out assert ret out test_put icodes = np typecodes AllInteger fcodes = np typecodes AllFloat dt icodes + fcodes tgt = np array dtype=dt test -d = np zeros dtype=dt put assert_equal tgt test -d = np zeros dtype=dt put assert_equal tgt reshape dt tgt = np array False True False True False True dtype=dt test -d = np zeros dtype=dt put True assert_equal tgt test -d = np zeros dtype=dt put True assert_equal tgt reshape when calling np put make sure TypeError raised object isn t ndarray bad_array = assert_raises TypeError np put bad_array xpassIfTorchDynamo_np reason= TODO implement order= F test_ravel = np array assert_equal ravel assert_ ravel flags owndata assert_equal ravel F assert_equal ravel order= C assert_equal ravel order= F assert_equal ravel order= A assert_ ravel order= A flags owndata assert_equal ravel order= K assert_ ravel order= K flags owndata assert_equal ravel reshape - = np array order= F assert_equal ravel assert_equal ravel order= A assert_equal ravel order= K assert_ ravel order= A flags owndata assert_ ravel order= K flags owndata assert_equal ravel reshape - assert_equal ravel order= A reshape - order= A = np array - assert_equal ravel assert_equal ravel order= C assert_equal ravel order= F assert_equal ravel order= A K doesn t reverse axes negative strides assert_equal ravel order= K assert_ ravel order= K flags owndata Test simple -d copy behaviour = np arange assert_ ravel K flags owndata assert_ ravel C flags owndata assert_ ravel F flags owndata Not contiguous -sized axis non matching stride = np arange = reshape swapaxes - - strides = list strides strides = strides = strides assert_ ravel order= K flags owndata assert_equal ravel K np arange contiguous -sized axis non matching stride works = np arange = reshape swapaxes - - strides = list strides strides = strides = strides assert_ np may_share_memory ravel order= K assert_equal ravel order= K np arange Test negative strides very interesting since non-contiguous = np arange - reshape assert_ ravel order= C flags owndata assert_ ravel order= K flags owndata assert_equal ravel C assert_equal ravel K -element tidy strides test = np array strides = If following stride NPY_RELAXED_STRIDES_DEBUG messing them up purpose np ones strides == assert_ np may_share_memory ravel K assert_equal ravel K strides dtype itemsize order C F A K -d corner case = np array assert_equal ravel order assert_ np may_share_memory ravel order Test certain non-inplace ravels work right mostly K b = np arange reshape = b assert_equal ravel K assert_equal ravel C assert_equal ravel A assert_equal ravel F = b assert_equal ravel K assert_equal ravel C assert_equal ravel A assert_equal ravel F xfailIfTorchDynamo flags OWNDATA test_swapaxes = np arange reshape copy idx = np indices shape assert_ flags OWNDATA b = copy check exceptions assert_raises np AxisError swapaxes - assert_raises np AxisError swapaxes assert_raises np AxisError swapaxes - assert_raises np AxisError swapaxes i range - j range - k src enumerate b c = src swapaxes i j check shape shape = list src shape shape i = src shape j shape j = src shape i assert_equal c shape shape str i j k check array contents i i i i = dim - dim c shape j j j j = dim - dim src shape assert_equal src idx j idx j idx j idx j c idx i idx i idx i idx i str i j k check view always returned gh- assert_ c flags OWNDATA str i j k check non-contiguous input array k == b = c test_conjugate = np array - j + j + j ac = conj assert_equal real ac real assert_equal imag -ac imag assert_equal ac conjugate assert_equal ac np conjugate = np array - j + j + j F ac = conj assert_equal real ac real assert_equal imag -ac imag assert_equal ac conjugate assert_equal ac np conjugate = np array ac = conj assert_equal ac assert_equal ac conjugate assert_equal ac np conjugate = np array ac = conj assert_equal ac assert_equal ac conjugate assert_equal ac np conjugate test_conjugate_out Minimal test out argument being passed correctly NOTE The ability pass ` out ` currently undocumented = np array - j + j + j out = np empty_like res = conjugate out assert res out assert_array_equal out conjugate test__complex__ dtypes = i i i i u f d F D dt dtypes = np array dtype=dt b = np array dtype=dt c = np array dtype=dt msg = f dtype dt ap = complex assert_equal ap msg bp = complex b assert_equal bp b msg cp = complex c assert_equal cp c msg test__complex__should_not_work dtypes = i i i i u f d F D dt dtypes = np array dtype=dt assert_raises TypeError ValueError complex c = np array e- dtype=dt assert_raises TypeError ValueError complex c TestCequenceMethods TestCase test_array_contains assert_ np arange reshape assert_ np arange reshape TestBinop TestCase test_inplace test refcount inplace conversion assert_array_almost_equal np array np array d = np array assert_array_almost_equal d d np array = np array b = np array c = + b c = - b c = b c = b assert_equal b assert_almost_equal c c = + b b - b assert_equal b assert_equal c true divide = np array b = np array c = b assert_almost_equal c decimal= assert_equal assert_equal b TestSubscripting TestCase test_test_zero_rank x = np array assert_ isinstance x np int_ np ndarray assert_ type x np ndarray TestFancyIndexing TestCase test_list x = np ones x = assert_array_equal x np array x = np ones x = assert_array_equal x np array test_tuple x = np ones x = assert_array_equal x np array x = np ones x = assert_array_equal x np array test_mask x = np array m = np array bool assert_array_equal x m np array test_mask x = np array m = np array bool m = np array bool m = np array bool assert_array_equal x m np array assert_array_equal x m np array assert_array_equal x m np array test_assign_mask x = np array m = np array bool x m = assert_array_equal x np array test_assign_mask xorig = np array m = np array bool m = np array bool m = np array bool x = xorig copy x m = assert_array_equal x np array x = xorig copy x m = assert_array_equal x np array x = xorig copy x m = assert_array_equal x np array instantiate_parametrized_tests TestArgmaxArgminCommon TestCase sizes = parametrize size axis list itertools chain size axis axis list range -len size len size + None size sizes skipif numpy __version__ reason= keepdims new numpy parametrize method np argmax np argmin test_np_argmin_argmax_keepdims size axis method arr = np random normal size=size size None size == arr = np asarray arr contiguous arrays axis None new_shape = _ range len size new_shape = list size new_shape axis = new_shape = tuple new_shape _res_orig = method arr axis=axis res_orig = _res_orig reshape new_shape res = method arr axis=axis keepdims=True assert_equal res res_orig assert_ res shape == new_shape outarray = np empty res shape dtype=res dtype res = method arr axis=axis out=outarray keepdims=True assert_ res outarray assert_equal res outarray len size wrong_shape = list new_shape axis None wrong_shape axis = wrong_shape = wrong_outarray = np empty wrong_shape dtype=res dtype pytest raises ValueError method arr T axis=axis out=wrong_outarray keepdims=True non-contiguous arrays axis None new_shape = _ range len size new_shape = list size - new_shape axis = new_shape = tuple new_shape _res_orig = method arr T axis=axis res_orig = _res_orig reshape new_shape res = method arr T axis=axis keepdims=True assert_equal res res_orig assert_ res shape == new_shape outarray = np empty new_shape - dtype=res dtype outarray = outarray T res = method arr T axis=axis out=outarray keepdims=True assert_ res outarray assert_equal res outarray len size one dimension lesser non-zero sized array should raise error pytest raises ValueError method arr axis=axis out=outarray keepdims=True len size wrong_shape = list new_shape axis None wrong_shape axis = wrong_shape = wrong_outarray = np empty wrong_shape dtype=res dtype pytest raises ValueError method arr T axis=axis out=wrong_outarray keepdims=True xpassIfTorchDynamo_np reason= TODO implement choose parametrize method max min test_all method = np random normal arg_method = getattr arg + method val_method = getattr method i range ndim a_maxmin = val_method i aarg_maxmin = arg_method i axes = list range ndim axes remove i assert_ np all a_maxmin == aarg_maxmin choose transpose i axes parametrize method argmax argmin test_output_shape method see also gh- = np ones arg_method = getattr method Check some simple shape mismatches out = np ones dtype=np int_ assert_raises ValueError arg_method - out out = np ones dtype=np int_ assert_raises ValueError arg_method - out these could relaxed possibly used allow even previous out = np ones dtype=np int_ assert_raises ValueError arg_method - out out = np ones dtype=np int_ arg_method - out=out assert_equal out arg_method - parametrize ndim parametrize method argmax argmin test_ret_is_out ndim method = np ones + ndim arg_method = getattr method out = np empty ndim dtype=np intp ret = arg_method axis= out=out assert ret out parametrize arr_method np_method argmax np argmax argmin np argmin test_np_vs_ndarray arr_method np_method make sure both ndarray argmax argmin numpy argmax argmin support out axis args = np random normal size= arg_method = getattr arr_method check positional args out = np zeros dtype=int out = np zeros dtype=int assert_equal arg_method out np_method out assert_equal out out check keyword args out = np zeros dtype=int out = np zeros dtype=int assert_equal arg_method out=out axis= np_method out=out axis= assert_equal out out instantiate_parametrized_tests TestArgmax TestCase usg_data = sg_data = usg_data + - - - - - - - - darr = np array d dtype=t d d t itertools product usg_data np uint darr += np array d dtype=t d d t itertools product sg_data np int np int np int np int np float np float darr += np array d dtype=t d d t itertools product np nan np nan np nan np nan np nan To hit tail SIMD multi-level x x inner loops variant SIMD widths - + np nan - - + np nan - - + np nan - - + np nan - - + np nan - np float np float nan_arr = darr + RuntimeError max_values_cpu implemented ComplexDouble complex np nan complex np nan complex np nan complex np nan complex np nan complex np nan np nan complex np nan complex np nan complex np nan complex np nan np nan complex np nan complex np nan complex np nan complex np nan complex np nan np nan complex complex complex complex complex complex complex complex complex False False False False True False False False True False True False False False False True False True False False parametrize data nan_arr test_combinations data arr pos = data suppress_warnings sup sup filter RuntimeWarning invalid value encountered reduce val = np max arr assert_equal np argmax arr pos err_msg=f arr r assert_equal arr np argmax arr val err_msg=f arr r add padding test SIMD loops rarr = np repeat arr rpos = pos assert_equal np argmax rarr rpos err_msg=f rarr r assert_equal rarr np argmax rarr val err_msg=f rarr r padd = np repeat np min arr rarr = np concatenate arr padd rpos = pos assert_equal np argmax rarr rpos err_msg=f rarr r assert_equal rarr np argmax rarr val err_msg=f rarr r test_maximum_signed_integers = np array - - dtype=np int assert_equal np argmax = repeat assert_equal np argmax = np array - - dtype=np int assert_equal np argmax = repeat assert_equal np argmax = np array - - dtype=np int assert_equal np argmax = repeat assert_equal np argmax = np array - - dtype=np int assert_equal np argmax = repeat assert_equal np argmax instantiate_parametrized_tests TestArgmin TestCase usg_data = sg_data = usg_data + - - - - - - - - darr = np array d dtype=t d d t itertools product usg_data np uint darr += np array d dtype=t d d t itertools product sg_data np int np int np int np int np float np float darr += np array d dtype=t d d t itertools product np nan np nan np nan np nan np nan To hit tail SIMD multi-level x x inner loops variant SIMD widths - + np nan - - + np nan - - + np nan - - + np nan - - + np nan - np float np float nan_arr = darr + RuntimeError min_values_cpu implemented ComplexDouble complex np nan complex np nan complex np nan complex np nan complex np nan complex np nan np nan complex np nan complex np nan complex np nan complex np nan np nan complex np nan complex np nan complex np nan complex np nan complex np nan np nan complex complex complex complex complex complex complex complex complex True True True True False True True True False True False True True True True False True False True True parametrize data nan_arr test_combinations data arr pos = data suppress_warnings sup sup filter RuntimeWarning invalid value encountered reduce min_val = np min arr assert_equal np argmin arr pos err_msg=f arr r assert_equal arr np argmin arr min_val err_msg=f arr r add padding test SIMD loops rarr = np repeat arr rpos = pos assert_equal np argmin rarr rpos err_msg=f rarr r assert_equal rarr np argmin rarr min_val err_msg=f rarr r padd = np repeat np max arr rarr = np concatenate arr padd rpos = pos assert_equal np argmin rarr rpos err_msg=f rarr r assert_equal rarr np argmin rarr min_val err_msg=f rarr r test_minimum_signed_integers = np array - - + - dtype=np int assert_equal np argmin = repeat assert_equal np argmin = np array - - + - dtype=np int assert_equal np argmin = repeat assert_equal np argmin = np array - - + - dtype=np int assert_equal np argmin = repeat assert_equal np argmin = np array - - + - dtype=np int assert_equal np argmin = repeat assert_equal np argmin TestMinMax TestCase xpassIfTorchDynamo_np test_scalar assert_raises np AxisError np amax assert_raises np AxisError np amin assert_equal np amax axis= assert_equal np amin axis= assert_equal np amax axis=None assert_equal np amin axis=None test_axis assert_raises np AxisError np amax assert_equal np amax axis= TestNewaxis TestCase test_basic sk = np array - res = sk np newaxis assert_almost_equal res ravel sk _sctypes = int np int np int np int np int uint np uint np uint np uint np uint float np float np float complex np complex np complex no complex torch _numpy + np clongdouble hasattr np clongdouble TestClip TestCase _check_range x cmin cmax assert_ np all x = cmin assert_ np all x = cmax _clip_type type_group array_max clip_min clip_max inplace=False expected_min=None expected_max=None expected_min None expected_min = clip_min expected_max None expected_max = clip_max T _sctypes type_group sys byteorder == little byte_orders = = byte_orders = = byteorder byte_orders dtype = np dtype T newbyteorder byteorder x = np random random array_max astype dtype inplace The tests call us pass clip_min clip_max might fit destination dtype They written assuming previous unsafe casting which now must passed explicitly avoid warning x clip clip_min clip_max x casting= unsafe x = x clip clip_min clip_max byteorder = = x dtype byteorder == &#124; byteorder = &#124; assert_equal x dtype byteorder byteorder _check_range x expected_min expected_max x skip reason= endianness test_basic inplace False True _clip_type float - inplace=inplace _clip_type float inplace=inplace _clip_type int - inplace=inplace _clip_type int inplace=inplace _clip_type uint inplace=inplace _clip_type uint - inplace=inplace expected_min= test_max_or_min val = np array x = val clip assert_ np all x = x = val clip min= assert_ np all x = x = val clip max= assert_ np all x = test_nan input_arr = np array - np nan np nan result = input_arr clip - expected = np array - np nan np nan assert_array_equal result expected xpassIfTorchDynamo_np reason= TODO TestCompress TestCase test_axis tgt = arr = np arange reshape out = np compress arr axis= assert_equal out tgt tgt = out = np compress arr axis= assert_equal out tgt test_truncate tgt = arr = np arange reshape out = np compress arr axis= assert_equal out tgt test_flatten arr = np arange reshape out = np compress arr assert_equal out xpassIfTorchDynamo_np reason= TODO instantiate_parametrized_tests TestPutmask TestCase tst_basic x T mask val np putmask x mask val assert_equal x mask np array val T test_ip_types unchecked_types = bytes str np void x = np random random mask = x val - types efdFDBbhil T types T unchecked_types val np dtype T kind == u val = np iinfo T max - tst_basic x copy astype T T mask val Also test string length which uses untypical length dt = np dtype S tst_basic x astype dt dt type mask dt type val test_mask_size assert_raises ValueError np putmask np array True parametrize greater True False test_byteorder greater dtype = i greater i x = np array dtype np putmask x True False True - assert_array_equal x - - test_record_array Note mixed byteorder rec = np array - dtype= x f y f z f np putmask rec x True False assert_array_equal rec x assert_array_equal rec y assert_array_equal rec z np putmask rec y True False assert_array_equal rec x assert_array_equal rec y assert_array_equal rec z test_overlaps gh- check overlap x = np array True False True False np putmask x True True True x assert_equal x np array True True False True x = np array True False True False np putmask x x True False True assert_equal x np array True True True True test_writeable = np arange flags writeable = False pytest raises ValueError np putmask = test_kwargs x = np array np putmask x - - assert_array_equal x - x = np array np putmask x mask= values= - - assert_array_equal x - x = np array np putmask x values= - - mask= assert_array_equal x - pytest raises TypeError np putmask a=x values= - - mask= instantiate_parametrized_tests TestTake TestCase tst_basic x ind = list range x shape assert_array_equal np take x ind axis= x test_ip_types x = np random random x = np reshape x types efdFDBbhil T types tst_basic x copy astype T test_raise x = np random random x = np reshape x assert_raises IndexError np take x axis= assert_raises IndexError np take x - axis= assert_array_equal np take x - axis= x xpassIfTorchDynamo_np reason= XXX take mode= clip test_clip x = np random random x = np reshape x assert_array_equal np take x - axis= mode= clip x assert_array_equal np take x axis= mode= clip x xpassIfTorchDynamo_np reason= XXX take mode= wrap test_wrap x = np random random x = np reshape x assert_array_equal np take x - axis= mode= wrap x assert_array_equal np take x axis= mode= wrap x assert_array_equal np take x axis= mode= wrap x xpassIfTorchDynamo_np reason= XXX take mode= wrap test_out_overlap gh- check overlap out x = np arange y = np take x out=x mode= wrap assert_equal y np array parametrize shape test_ret_is_out shape d arrays should exception rule x = np arange inds = np zeros shape dtype=np intp out = np zeros shape dtype=x dtype ret = np take x inds out=out assert ret out xpassIfTorchDynamo_np reason= TODO instantiate_parametrized_tests TestLexsort TestCase parametrize dtype np uint np int np int np int np int np float np float np float test_basic dtype = np array dtype=dtype b = np array dtype=dtype idx = np lexsort b expected_idx = np array assert_array_equal idx expected_idx assert_array_equal idx np sort test_mixed = np array b = np array dtype= datetime D idx = np lexsort b expected_idx = np array assert_array_equal idx expected_idx test_datetime = np array dtype= datetime D b = np array dtype= datetime D idx = np lexsort b expected_idx = np array assert_array_equal idx expected_idx = np array dtype= timedelta D b = np array dtype= timedelta D idx = np lexsort b expected_idx = np array assert_array_equal idx expected_idx test_object gh- = np random choice b = np random choice abc xy wz efghi qwst x u b left = np lexsort u astype O right = np argsort u kind= mergesort assert_array_equal left right u v b b idx = np lexsort u v assert_array_equal idx np lexsort u astype O v assert_array_equal idx np lexsort u v astype O u v = np array u dtype= object np array v dtype= object assert_array_equal idx np lexsort u v test_invalid_axis gh- x = np linspace reshape assert_raises np AxisError np lexsort x axis= skip reason= dont worry about IO TestIO TestCase Test tofile fromfile tobytes fromstring pytest fixture x shape = rand = np random random x = rand shape + rand shape astype complex j x = np nan np inf -np inf np nan x pytest fixture params= string path_obj tmp_filename tmp_path request This fixture covers two cases one where filename string another where pathlib object filename = tmp_path file request param == string filename = str filename filename test_nofile should probably supported file now test proper errors b = io BytesIO assert_raises OSError np fromfile b np uint d = np ones assert_raises OSError lambda x x tofile b d test_bool_fromstring v = np array True False True False dtype=np bool_ y = np fromstring - sep= dtype=np bool_ assert_array_equal v y test_uint _fromstring d = np fromstring dtype=np uint sep= e = np array dtype=np uint assert_array_equal d e test_int _fromstring d = np fromstring - dtype=np int sep= e = np array - dtype=np int assert_array_equal d e test_fromstring_count d = np fromstring sep= dtype=np int count= assert d shape == test_empty_files_text tmp_filename open tmp_filename w pass y = np fromfile tmp_filename assert_ y size == Array empty test_empty_files_binary tmp_filename open tmp_filename wb pass y = np fromfile tmp_filename sep= assert_ y size == Array empty test_roundtrip_file x tmp_filename open tmp_filename wb f x tofile f NB doesn t work flush+seek due use C stdio open tmp_filename rb f y = np fromfile f dtype=x dtype assert_array_equal y x flat test_roundtrip x tmp_filename x tofile tmp_filename y = np fromfile tmp_filename dtype=x dtype assert_array_equal y x flat test_roundtrip_dump_pathlib x tmp_filename p = Path tmp_filename x dump p y = np load p allow_pickle=True assert_array_equal y x test_roundtrip_binary_str x s = x tobytes y = np frombuffer s dtype=x dtype assert_array_equal y x flat s = x tobytes F y = np frombuffer s dtype=x dtype assert_array_equal y x flatten F test_roundtrip_str x x = x real ravel s = join map str x y = np fromstring s sep= NB str imbues less precision nan_mask = ~np isfinite x assert_array_equal x nan_mask y nan_mask assert_array_almost_equal x ~nan_mask y ~nan_mask decimal= test_roundtrip_repr x x = x real ravel s = join map repr x y = np fromstring s sep= assert_array_equal x y test_unseekable_fromfile x tmp_filename gh- x tofile tmp_filename fail args kwargs raise OSError Can tell seek open tmp_filename rb buffering= f f seek = fail f tell = fail assert_raises OSError np fromfile f dtype=x dtype test_io_open_unbuffered_fromfile x tmp_filename gh- x tofile tmp_filename open tmp_filename rb buffering= f y = np fromfile f dtype=x dtype assert_array_equal y x flat test_largish_file tmp_filename check fallocate path files MB d = np zeros d tofile tmp_filename assert_equal os path getsize tmp_filename d nbytes assert_array_equal d np fromfile tmp_filename check offset open tmp_filename r+b f f seek d nbytes d tofile f assert_equal os path getsize tmp_filename d nbytes check append mode gh- open tmp_filename w close delete file contents open tmp_filename ab f d tofile f assert_array_equal d np fromfile tmp_filename open tmp_filename ab f d tofile f assert_equal os path getsize tmp_filename d nbytes test_io_open_buffered_fromfile x tmp_filename gh- x tofile tmp_filename open tmp_filename rb buffering=- f y = np fromfile f dtype=x dtype assert_array_equal y x flat test_file_position_after_fromfile tmp_filename gh- sizes = io DEFAULT_BUFFER_SIZE io DEFAULT_BUFFER_SIZE io DEFAULT_BUFFER_SIZE size sizes open tmp_filename wb f f seek size - f write b \ mode rb r+b err_msg = f size d mode open tmp_filename mode f f read np fromfile f dtype=np float count= pos = f tell assert_equal pos err_msg=err_msg test_file_position_after_tofile tmp_filename gh- sizes = io DEFAULT_BUFFER_SIZE io DEFAULT_BUFFER_SIZE io DEFAULT_BUFFER_SIZE size sizes err_msg = f size d open tmp_filename wb f f seek size - f write b \ f seek f write b np array dtype=np float tofile f pos = f tell assert_equal pos + + err_msg=err_msg open tmp_filename r+b f f read f seek seek between read write required ANSI C np array dtype=np float tofile f pos = f tell assert_equal pos err_msg=err_msg test_load_object_array_fromfile tmp_filename gh- open tmp_filename w f Ensure we have file consistent contents pass open tmp_filename rb f assert_raises_regex ValueError Cannot read into object array np fromfile f dtype=object assert_raises_regex ValueError Cannot read into object array np fromfile tmp_filename dtype=object test_fromfile_offset x tmp_filename open tmp_filename wb f x tofile f open tmp_filename rb f y = np fromfile f dtype=x dtype offset= assert_array_equal y x flat open tmp_filename rb f count_items = len x flat offset_items = len x flat offset_bytes = x dtype itemsize offset_items y = np fromfile f dtype=x dtype count=count_items offset=offset_bytes assert_array_equal y x flat offset_items offset_items + count_items subsequent seeks should stack offset_bytes = x dtype itemsize z = np fromfile f dtype=x dtype offset=offset_bytes assert_array_equal z x flat offset_items + count_items + open tmp_filename wb f x tofile f sep= open tmp_filename rb f assert_raises_regex TypeError offset argument only permitted binary files np fromfile tmp_filename dtype=x dtype sep= offset= skipif IS_PYPY reason= bug PyPy s PyNumber_AsSsize_t test_fromfile_bad_dup x tmp_filename dup_str fd abc dup_bigint fd old_dup = os dup try open tmp_filename wb f x tofile f dup exc dup_str TypeError dup_bigint OSError os dup = dup assert_raises exc np fromfile f finally os dup = old_dup _check_from s value filename kw sep kw y = np frombuffer s kw y = np fromstring s kw assert_array_equal y value open filename wb f f write s y = np fromfile filename kw assert_array_equal y value pytest fixture params= period comma decimal_sep_localization request Including fixture test will automatically execute both types decimal separator So test_decimal decimal_sep_localization pass equivalent following two tests test_decimal_period_separator pass test_decimal_comma_separator CommaDecimalPointLocale pass request param == period yield request param == comma CommaDecimalPointLocale yield raise AssertionError request param test_nan tmp_filename decimal_sep_localization _check_from b nan +nan -nan NaN nan foo +NaN BAR -NAN q_u_u_x_ np nan np nan np nan np nan np nan np nan np nan tmp_filename sep= test_inf tmp_filename decimal_sep_localization _check_from b inf +inf -inf infinity -Infinity iNfInItY -inF np inf np inf -np inf np inf -np inf np inf -np inf tmp_filename sep= test_numbers tmp_filename decimal_sep_localization _check_from b - e - e+ - e - e tmp_filename sep= test_binary tmp_filename _check_from b \x \x \x \x \x \x \x \x \x \x \x np array tmp_filename dtype= f slow takes minute mechanical hard drive test_big_binary Test workarounds -bit limit MSVC fwrite fseek ftell These normally would hang doing something like See https github com numpy numpy issues sys platform = win GCC sys version try before workarounds only up - worked fourgbplus = + testbytes = np arange dtype=np int n = len testbytes flike = tempfile NamedTemporaryFile f = flike file np tile testbytes fourgbplus testbytes nbytes tofile f flike seek = np fromfile f dtype=np int flike close assert_ len == fourgbplus check only start end speed assert_ n == testbytes all assert_ -n == testbytes all except MemoryError ValueError pass test_string tmp_filename _check_from b tmp_filename sep= test_counted_string tmp_filename decimal_sep_localization _check_from b tmp_filename count= sep= _check_from b tmp_filename count= sep= _check_from b tmp_filename count=- sep= test_string_with_ws tmp_filename _check_from b tmp_filename dtype=int sep= test_counted_string_with_ws tmp_filename _check_from b tmp_filename count= dtype=int sep= test_ascii tmp_filename decimal_sep_localization _check_from b tmp_filename sep= _check_from b tmp_filename dtype=float sep= test_malformed tmp_filename decimal_sep_localization assert_warns DeprecationWarning _check_from b tmp_filename sep= test_long_sep tmp_filename _check_from b _x_ _x_ _x_ tmp_filename sep= _x_ test_dtype tmp_filename v = np array dtype=np int_ _check_from b v tmp_filename sep= dtype=np int_ test_dtype_bool tmp_filename can t use _check_from because fromstring can t handle True False v = np array True False True False dtype=np bool_ s = b - open tmp_filename wb f f write s y = np fromfile tmp_filename sep= dtype=np bool_ assert_ y dtype == assert_array_equal y v test_tofile_sep tmp_filename decimal_sep_localization x = np array dtype=float open tmp_filename w f x tofile f sep= open tmp_filename f s = f read assert_equal s y = np array float p p s split assert_array_equal x y test_tofile_format tmp_filename decimal_sep_localization x = np array dtype=float open tmp_filename w f x tofile f sep= format= f open tmp_filename f s = f read assert_equal s test_tofile_cleanup tmp_filename x = np zeros dtype=object open tmp_filename wb f assert_raises OSError lambda x tofile f sep= Dup-ed file handle should closed remove will fail Windows OS os remove tmp_filename Also make sure we close Python handle assert_raises OSError lambda x tofile tmp_filename os remove tmp_filename test_fromfile_subarray_binary tmp_filename Test subarray dtypes which absorbed into shape x = np arange dtype= i reshape x tofile tmp_filename res = np fromfile tmp_filename dtype= i assert_array_equal x res x_str = x tobytes assert_warns DeprecationWarning binary fromstring deprecated res = np fromstring x_str dtype= i assert_array_equal x res test_parsing_subarray_unsupported tmp_filename We currently do support parsing subarray dtypes data = pytest raises ValueError np fromstring data dtype= i sep= open tmp_filename w f f write data pytest raises ValueError np fromfile tmp_filename dtype= i sep= test_read_shorter_than_count_subarray tmp_filename Test requesting more values does cause any problems conjunction subarray dimensions being absorbed into array dimension expected = np arange dtype= i reshape - binary = expected tobytes pytest raises ValueError pytest warns DeprecationWarning np fromstring binary dtype= i count= expected tofile tmp_filename res = np fromfile tmp_filename dtype= i count= assert_array_equal res expected xpassIfTorchDynamo_np reason= TODO instantiate_parametrized_tests TestFromBuffer TestCase parametrize byteorder subtest little name= little subtest big name= big parametrize dtype float int complex test_basic byteorder dtype dt = np dtype dtype newbyteorder byteorder x = np random random astype dt buf = x tobytes assert_array_equal np frombuffer buf dtype=dt x flat xpassIfTorchDynamo_np parametrize obj np arange subtest decorators= xfailIfTorchDynamo test_array_base obj Objects including NumPy arrays which do use ` release_buffer ` slot should directly used base object See also gh- isinstance obj str parametrize breaks bytes objects obj = bytes obj enconding= latin- new = np frombuffer obj assert new base obj test_empty assert_array_equal np frombuffer b np array skip fails CI we unlikely implement skipif IS_PYPY reason= PyPy s memoryview currently does track exports See https github com pypy pypy issues test_mmap_close The old buffer protocol safe some things new one But ` frombuffer ` always used old one long time Checks safe new one using memoryviews tempfile TemporaryFile mode= wb tmp tmp write b asdf tmp flush mm = mmap mmap tmp fileno arr = np frombuffer mm dtype=np uint pytest raises BufferError mm close cannot close while array uses buffer del arr mm close skip reason= TODO FIXME skip - xfail shape = raises TestFlat TestCase setUp = np arange = reshape shape = flags writeable = False = b = = b = test_contiguous testpassed = False try flat = except ValueError testpassed = True assert_ testpassed assert_ flat == test_discontiguous testpassed = False try b flat = except ValueError testpassed = True assert_ testpassed assert_ b flat == test___array__ c = flat __array__ d = b flat __array__ e = flat __array__ f = b flat __array__ assert_ c flags writeable False assert_ d flags writeable False assert_ e flags writeable True assert_ f flags writeable False assert_ c flags writebackifcopy False assert_ d flags writebackifcopy False assert_ e flags writebackifcopy False assert_ f flags writebackifcopy False skipif HAS_REFCOUNT reason= Python lacks refcounts test_refcount includes regression test reference count error gh- inds = np intp np array True size np array None indtype = np dtype np intp rc_indtype = sys getrefcount indtype ind inds rc_ind = sys getrefcount ind _ range try flat ind except IndexError pass assert_ abs sys getrefcount ind - rc_ind assert_ abs sys getrefcount indtype - rc_indtype test_index_getset = np arange reshape flat pytest raises AttributeError index = _ pass Check value ` index ` updated correctly see also gh- If type incorrect would show up big-endian machines assert index == base size TestResize TestCase _no_tracing test_basic x = np array IS_PYPY x resize refcheck=False x resize assert_array_equal x ravel np array ravel assert_array_equal x ravel skip reason= how find someone refencing array test_check_reference x = np array y = x assert_raises ValueError x resize del y avoid pyflakes unused variable warning _no_tracing test_int_shape x = np eye IS_PYPY x resize refcheck=False x resize assert_array_equal x np eye test_none_shape x = np eye x resize None assert_array_equal x np eye x resize assert_array_equal x np eye test_ d_shape multiple times test does break alloc cache gh- _ range x = np empty x resize assert_equal x shape assert_equal x size x = np empty x resize assert_equal x shape assert_equal x size test_invalid_arguments assert_raises TypeError np eye resize hi assert_raises ValueError np eye resize - assert_raises TypeError np eye resize order= assert_raises NotImplementedError TypeError np eye resize refcheck= hi _no_tracing test_freeform_shape x = np eye IS_PYPY x resize refcheck=False x resize assert_ x shape == _no_tracing test_zeros_appended x = np eye IS_PYPY x resize refcheck=False x resize assert_array_equal x np eye assert_array_equal x np zeros test_empty_view check sizes containing zero don t trigger reallocate already empty arrays x = np zeros int x_view = x x_view resize x_view resize skip reason= ignore weakrefs ndarray resize test_check_weakref x = np array xref = weakref ref x assert_raises ValueError x resize del xref avoid pyflakes unused variable warning _mean args mean args _var args var args _std args std args instantiate_parametrized_tests TestStats TestCase funcs = _mean _var _std setUp np random seed rmat = np random random cmat = rmat + j rmat test_python_type x np float + j assert_equal np mean x assert_equal np std x assert_equal np var x test_keepdims mat = np eye f funcs axis res = f mat axis=axis keepdims=True assert_ res ndim == mat ndim assert_ res shape axis == axis None res = f mat axis=axis keepdims=True assert_ res shape == test_out mat = np eye f funcs out = np zeros tgt = f mat axis= res = f mat axis= out=out assert_almost_equal res out assert_almost_equal res tgt out = np empty assert_raises ValueError f mat axis= out=out out = np empty assert_raises ValueError f mat axis= out=out test_dtype_from_input icodes = np typecodes AllInteger fcodes = np typecodes AllFloat integer types f funcs c icodes mat = np eye dtype=c tgt = np float res = f mat axis= dtype type assert_ res tgt scalar case res = f mat axis=None dtype type assert_ res tgt mean float types f _mean c fcodes mat = np eye dtype=c tgt = mat dtype type res = f mat axis= dtype type assert_ res tgt scalar case res = f mat axis=None dtype type assert_ res tgt var std float types f _var _std c fcodes mat = np eye dtype=c deal complex types tgt = mat real dtype type res = f mat axis= dtype type assert_ res tgt scalar case res = f mat axis=None dtype type assert_ res tgt test_dtype_from_dtype mat = np eye stats integer types FIXME needs definition there lots places along line where type casting may take place f funcs c np typecodes AllInteger tgt = np dtype c type res = f mat axis= dtype=c dtype type assert_ res tgt scalar case res = f mat axis=None dtype=c dtype type assert_ res tgt stats float types f funcs c np typecodes AllFloat tgt = np dtype c type res = f mat axis= dtype=c dtype type assert_ res tgt scalar case res = f mat axis=None dtype=c dtype type assert_ res tgt test_ddof f _var ddof range dim = rmat shape tgt = f rmat axis= dim res = f rmat axis= ddof=ddof dim - ddof f _std ddof range dim = rmat shape tgt = f rmat axis= np sqrt dim res = f rmat axis= ddof=ddof np sqrt dim - ddof assert_almost_equal res tgt assert_almost_equal res tgt test_ddof_too_big dim = rmat shape f _var _std ddof range dim dim + warnings catch_warnings record=True w warnings simplefilter always res = f rmat axis= ddof=ddof assert_ res any assert_ len w assert_ issubclass w category RuntimeWarning test_empty A = np zeros f funcs axis None warnings catch_warnings record=True w warnings simplefilter always assert_ np isnan f A axis=axis all assert_ len w assert_ issubclass w category RuntimeWarning axis warnings catch_warnings record=True w warnings simplefilter always assert_equal f A axis=axis np zeros test_mean_values mat rmat cmat axis tgt = mat sum axis=axis res = _mean mat axis=axis mat shape axis assert_almost_equal res tgt axis None tgt = mat sum axis=axis res = _mean mat axis=axis np prod mat shape assert_almost_equal res tgt test_mean_float This fail sum inside mean done float instead float assert_ _mean np ones dtype= float == test_mean_axis_error Ensure AxisError raised instead IndexError when axis out bounds see gh- assert_raises np AxisError np arange mean axis= xpassIfTorchDynamo_np reason= implement mean where= test_mean_where = np arange reshape wh_full = np array False True False True True False True False True True False False False False True True wh_partial = np array False True True False _cases = True wh_full wh_full wh_partial _ax _wh _res _cases assert_allclose mean axis=_ax where=_wh np array _res assert_allclose np mean axis=_ax where=_wh np array _res d = np arange reshape _wh_partial = np array False True True False _res = assert_allclose d mean axis= where=_wh_partial np array _res assert_allclose np mean d axis= where=_wh_partial np array _res pytest warns RuntimeWarning assert_allclose mean axis= where=wh_partial np array np nan np nan pytest warns RuntimeWarning assert_equal mean where=False np nan pytest warns RuntimeWarning assert_equal np mean where=False np nan test_var_values mat rmat cmat axis None msqr = _mean mat mat conj axis=axis mean = _mean mat axis=axis tgt = msqr - mean mean conjugate res = _var mat axis=axis assert_almost_equal res tgt parametrize complex_dtype ndec complex complex test_var_complex_values complex_dtype ndec Test fast-paths every builtin complex type axis None mat = cmat copy astype complex_dtype msqr = _mean mat mat conj axis=axis mean = _mean mat axis=axis tgt = msqr - mean mean conjugate res = _var mat axis=axis assert_almost_equal res tgt decimal=ndec test_var_dimensions _var paths complex number introduce additions views increase dimensions Ensure generalizes higher dims mat = np stack cmat axis - None msqr = _mean mat mat conj axis=axis mean = _mean mat axis=axis tgt = msqr - mean mean conjugate res = _var mat axis=axis assert_almost_equal res tgt skip reason= endianness test_var_complex_byteorder Test var fast-path does cause failures complex arrays non-native byteorder cmat = cmat copy astype complex cmat_swapped = cmat astype cmat dtype newbyteorder assert_almost_equal cmat var cmat_swapped var test_var_axis_error Ensure AxisError raised instead IndexError when axis out bounds see gh- assert_raises np AxisError np arange var axis= xpassIfTorchDynamo_np reason= implement var where= test_var_where = np arange reshape wh_full = np array False True False True True True False True True False True True False False True False True True False True True False True True False wh_partial = np array False True True False True _cases = True True _ax _wh _res _cases assert_allclose var axis=_ax where=_wh np array _res assert_allclose np var axis=_ax where=_wh np array _res d = np arange reshape _wh_partial = np array False True True False _res = assert_allclose d var axis= where=_wh_partial np array _res assert_allclose np var d axis= where=_wh_partial np array _res assert_allclose np var axis= where=wh_full np var wh_full reshape axis= assert_allclose np var axis= where=wh_partial np var wh_partial axis= pytest warns RuntimeWarning assert_equal var where=False np nan pytest warns RuntimeWarning assert_equal np var where=False np nan test_std_values mat rmat cmat axis None tgt = np sqrt _var mat axis=axis res = _std mat axis=axis assert_almost_equal res tgt xpassIfTorchDynamo_np reason= implement std where= test_std_where = np arange reshape - whf = np array False True False True True True False True False True True True False True False True False True True False False True False True True whp = np array False False True True False _cases = True np ones True np ones whf np array whp np ones _ax _wh _res _cases assert_allclose std axis=_ax where=_wh _res assert_allclose np std axis=_ax where=_wh _res d = np arange reshape _wh_partial = np array False True True False _res = assert_allclose d std axis= where=_wh_partial np array _res assert_allclose np std d axis= where=_wh_partial np array _res assert_allclose std axis= where=whf np std whf reshape axis= assert_allclose np std axis= where=whf whf reshape std axis= assert_allclose std axis= where=whp np std whp axis= assert_allclose np std axis= where=whp whp std axis= pytest warns RuntimeWarning assert_equal std where=False np nan pytest warns RuntimeWarning assert_equal np std where=False np nan TestVdot TestCase test_basic dt_numeric = np typecodes AllFloat + np typecodes AllInteger dt_complex = np typecodes Complex test real = np eye dt dt_numeric b = astype dt res = np vdot b b assert_ np isscalar res assert_equal np vdot b b test complex = np eye j dt dt_complex b = astype dt res = np vdot b b assert_ np isscalar res assert_equal np vdot b b test boolean b = np eye dtype=bool res = np vdot b b assert_ np isscalar res assert_equal np vdot b b True xpassIfTorchDynamo_np reason= implement order= F test_vdot_array_order = np array order= C b = np array order= F res = np vdot integer arrays exact assert_equal np vdot b res assert_equal np vdot b res assert_equal np vdot b b res test_vdot_uncontiguous size Different sizes match different branches vdot = np zeros size b = np zeros size = np arange size b = np arange size + Make b uncontiguous = b = b assert_equal np vdot b np vdot flatten b flatten assert_equal np vdot b copy np vdot flatten b flatten assert_equal np vdot copy b np vdot flatten b flatten xpassIfTorchDynamo_np reason= implement order= F test_vdot_uncontiguous_ test order= F separately size Different sizes match different branches vdot = np zeros size b = np zeros size = np arange size b = np arange size + Make b uncontiguous = b = b assert_equal np vdot copy F b np vdot flatten b flatten assert_equal np vdot b copy F np vdot flatten b flatten instantiate_parametrized_tests TestDot TestCase setUp np random seed Numpy pytorch random streams differ so inline values numpy A = np random rand A = np array b = np random rand b = np array b = np random rand b = np array b = np random rand b = np array b = np random rand b = np array N = test_dotmatmat A = A res = np dot A transpose A tgt = np array assert_almost_equal res tgt decimal=self N test_dotmatvec A b = A b res = np dot A b tgt = np array assert_almost_equal res tgt decimal=self N test_dotmatvec A b = A b res = np dot A b tgt = np array assert_almost_equal res tgt decimal=self N test_dotvecmat A b = A b res = np dot b A tgt = np array assert_almost_equal res tgt decimal=self N test_dotvecmat b A = b A res = np dot b A transpose tgt = np array assert_almost_equal res tgt decimal=self N test_dotvecmat A b = A b res = np dot A transpose b tgt = np array assert_almost_equal res tgt decimal=self N test_dotvecvecouter b b = b b res = np dot b b tgt = np array assert_almost_equal res tgt decimal=self N test_dotvecvecinner b b = b b res = np dot b b tgt = np array assert_almost_equal res tgt decimal=self N test_dotcolumnvect b = np ones b = res = np dot b b tgt = np array assert_almost_equal res tgt decimal=self N test_dotcolumnvect b = np ones transpose b = res = np dot b b tgt = np array assert_almost_equal res tgt decimal=self N test_dotvecscalar np random seed Numpy guarantees random stream we don t So inline values numpy b = np random rand b = np array b = np random rand b = np array res = np dot b b tgt = np array assert_almost_equal res tgt decimal=self N test_dotvecscalar np random seed b = np random rand b = np array b = np random rand b = np array res = np dot b b tgt = np array assert_almost_equal res tgt decimal=self N test_all dims = dout = dim dim dim zip dout itertools product dims dims b = np zeros dim b = np zeros dim res = np dot b b tgt = np zeros dim assert_ res shape == tgt shape assert_almost_equal res tgt decimal=self N skip reason= numpy internals test_dot_ args numpy core multiarray dot = np array dtype=float b = np array dtype=float c = np array dtype=float d = dot b assert_allclose c d skip reason= numpy internals test_dot_ args numpy core multiarray dot np random seed f = np random random_sample v = np random random_sample r = np empty _ range dot f v r HAS_REFCOUNT assert_equal sys getrefcount r r = dot f v out=None assert_array_equal r r assert_ r dot f v out=r v = v copy v shape == r = r copy r shape == r = dot f v assert_ r dot f v r assert_array_equal r r skip reason= numpy internals test_dot_ args_errors numpy core multiarray dot np random seed f = np random random_sample v = np random random_sample r = np empty assert_raises ValueError dot f v r r = np empty assert_raises ValueError dot f v r r = np empty assert_raises ValueError dot f v r r = np empty assert_raises ValueError dot f v r assert_raises ValueError dot f v r T r = np empty assert_raises ValueError dot f v r assert_raises ValueError dot f v r r = np empty dtype=np float assert_raises ValueError dot f v r r = np empty dtype=int assert_raises ValueError dot f v r xpassIfTorchDynamo_np reason= TODO order= F test_dot_array_order = np array order= C b = np array order= F res = np dot integer arrays exact assert_equal np dot b res assert_equal np dot b res assert_equal np dot b b res skip reason= TODO nbytes view __array_interface__ test_accelerate_framework_sgemv_fix aligned_array shape align dtype order= C d = dtype N = np prod shape tmp = np zeros N d nbytes + align dtype=np uint address = tmp __array_interface__ data offset range align address + offset align == break tmp = tmp offset offset + N d nbytes view dtype=dtype tmp reshape shape order=order as_aligned arr align dtype order= C aligned = aligned_array arr shape align dtype order aligned = arr aligned assert_dot_close A X desired assert_allclose np dot A X desired rtol= e- atol= e- m = aligned_array np float s = aligned_array np float np dot s m will always segfault bug present testdata = itertools product C F align m n a_order testdata Calculation double precision A_d = np random rand m n X_d = np random rand n desired = np dot A_d X_d Calculation aligned single precision A_f = as_aligned A_d align np float order=a_order X_f = as_aligned X_d align np float assert_dot_close A_f X_f desired Strided A rows A_d_ = A_d desired = np dot A_d_ X_d A_f_ = A_f assert_dot_close A_f_ X_f desired Strided A columns strided X vector A_d_ = A_d_ X_d_ = X_d desired = np dot A_d_ X_d_ A_f_ = A_f_ X_f_ = X_f assert_dot_close A_f_ X_f_ desired Check strides expected a_order == F assert_equal A_f_ strides m assert_equal A_f_ strides n assert_equal X_f_ strides Strides A rows + cols only X_f_ c = as_aligned X_f_ align np float assert_dot_close A_f_ X_f_ c desired Strides just A cols A_d_ = A_d desired = np dot A_d_ X_d_ A_f_ = A_f assert_dot_close A_f_ X_f_ c desired Strides A cols X assert_dot_close A_f_ X_f_ desired slow parametrize dtype np float np complex requires_memory free_bytes= e complex case needs GiB+ test_huge_vectordot dtype Large vector multiplications chunked bit BLAS Test chunking does right thing see also gh- data = np ones + dtype=dtype res = np dot data data assert res == + MatmulCommon Common tests operator numpy matmul Should work these types Will want add O some point types = bhilBefdFD test_exceptions dims = mismatched vector vector mismatched matrix vector mismatched vector matrix mismatched matrix matrix vector scalar scalar vector matrix scalar scalar matrix cannot broadcast dt dm dm itertools product types dims = np ones dm dtype=dt b = np ones dm dtype=dt assert_raises RuntimeError ValueError matmul b test_shapes dims = broadcast first argument broadcast second argument matrix stack sizes match dt dm dm itertools product types dims = np ones dm dtype=dt b = np ones dm dtype=dt res = matmul b assert_ res shape == vector vector returns scalars dt types = np ones dtype=dt b = np ones dtype=dt c = matmul b assert_ np array c shape == test_result_types mat = np ones vec = np ones dt types m = mat astype dt v = vec astype dt arg m v v m m m res = matmul arg assert_ res dtype == dt xpassIfTorchDynamo_np reason= no scalars test_result_types_ numpy vector vector returns scalars we D array instead dt types v = np ones astype dt dt = O res = matmul v v assert_ type res np dtype dt type test_scalar_output vec = np array vec = np array reshape - tgt = np array dt types v = vec astype dt v = vec astype dt res = matmul v v assert_equal res tgt res = matmul v T v assert_equal res tgt boolean type vec = np array True True dtype= reshape - res = matmul vec vec assert_equal res True test_vector_vector_values vec = np array vec = np array reshape - tgt = np array tgt = np array dt types v = vec astype dt v = vec astype dt res = matmul v v assert_equal res tgt no broadcast we must make v into d ndarray res = matmul v v reshape - assert_equal res tgt boolean type vec = np array True True dtype= res = matmul vec vec assert_equal res True test_vector_matrix_values vec = np array mat = np array mat = np stack mat axis= tgt = np array tgt = np stack tgt axis= dt types v = vec astype dt m = mat astype dt m = mat astype dt res = matmul v m assert_equal res tgt res = matmul v m assert_equal res tgt boolean type vec = np array True False mat = np array True False False True mat = np stack mat axis= tgt = np array True False tgt = np stack tgt axis= res = matmul vec mat assert_equal res tgt res = matmul vec mat assert_equal res tgt test_matrix_vector_values vec = np array mat = np array mat = np stack mat axis= tgt = np array tgt = np stack tgt axis= dt types v = vec astype dt m = mat astype dt m = mat astype dt res = matmul m v assert_equal res tgt res = matmul m v assert_equal res tgt boolean type vec = np array True False mat = np array True False False True mat = np stack mat axis= tgt = np array True False tgt = np stack tgt axis= res = matmul vec mat assert_equal res tgt res = matmul vec mat assert_equal res tgt test_matrix_matrix_values mat = np array mat = np array mat = np stack mat mat axis= mat = np stack mat mat axis= tgt = np array tgt = np array tgt = np array tgt _ = np stack tgt tgt axis= tgt _ = np stack tgt tgt axis= tgt _ = np stack tgt tgt axis= dt types m = mat astype dt m = mat astype dt m = mat astype dt m = mat astype dt matrix matrix res = matmul m m assert_equal res tgt res = matmul m m assert_equal res tgt stacked matrix res = matmul m m assert_equal res tgt _ matrix stacked res = matmul m m assert_equal res tgt _ stacked stacked res = matmul m m assert_equal res tgt _ boolean type m = np array dtype=np bool_ m = np array dtype=np bool_ m = np stack m m axis= m = np stack m m axis= tgt = m tgt = m tgt = np array dtype=np bool_ tgt _ = np stack tgt tgt axis= tgt _ = np stack tgt tgt axis= tgt _ = np stack tgt tgt axis= matrix matrix res = matmul m m assert_equal res tgt res = matmul m m assert_equal res tgt stacked matrix res = matmul m m assert_equal res tgt _ matrix stacked res = matmul m m assert_equal res tgt _ stacked stacked res = matmul m m assert_equal res tgt _ instantiate_parametrized_tests TestMatmul MatmulCommon TestCase setUp matmul = np matmul test_out_arg = np ones dtype=float b = np array dtype=float tgt = np dot b test positional argument msg = out positional argument out = np zeros dtype=float matmul b out assert_array_equal out tgt err_msg=msg test keyword argument msg = out keyword argument out = np zeros dtype=float matmul b out=out assert_array_equal out tgt err_msg=msg test out allowed type cast safe casting msg = Cannot cast out = np zeros dtype=np int assert_raises_regex TypeError msg matmul b out=out test out type upcast complex out = np zeros dtype=np complex c = matmul b out=out assert_ c out c = c astype tgt dtype assert_array_equal c tgt test_empty_out Check output cannot broadcast so cannot size zero when outer dimensions iterator size has size zero arr = np ones out = np ones assert matmul arr arr shape == pytest raises RuntimeError ValueError matmul arr arr out=out test_out_contiguous = np ones dtype=float b = np array dtype=float v = np array dtype=float tgt = np dot b tgt_mv = np dot v test out non-contiguous out = np ones dtype=float c = matmul b out=out assert_array_equal c tgt c = matmul v out=out assert_array_equal c tgt_mv c = matmul v T out=out assert_array_equal c tgt_mv test out contiguous only last dim out = np ones dtype=float c = matmul b out=out assert_array_equal c tgt test transposes out args out = np ones dtype=float c = matmul b T T out=out T assert_array_equal out tgt xfailIfTorchDynamo test_out_contiguous_ = np ones dtype=float b = np array dtype=float test out non-contiguous out = np ones dtype=float c = matmul b out=out assert c tensor _base out tensor m = np arange reshape m = np arange reshape m = np arange reshape non-contiguous vc = np arange vr = np arange m = np zeros parametrize args matrix-matrix subtest m m name= mm subtest m T m T name= mm subtest m T copy m T name= mm subtest m T m T copy name= mm matrix-matrix-transpose contiguous non subtest m m T name= mmT subtest m T m name= mmT subtest m m T name= mmT subtest m m T name= mmT subtest m m T name= mmT subtest m T m name= mmT matrix-matrix non-contiguous subtest m m name= mmN subtest m T m T name= mmN subtest m T copy m T name= mmN vector-matrix matrix-vector contiguous subtest m vr name= vm subtest vc m name= vm subtest m T vc name= vm subtest vr m T name= vm vector-matrix matrix-vector vector non-contiguous subtest m vr name= mvN subtest vc m name= mvN subtest m T vc name= mvN subtest vr m T name= mvN vector-matrix matrix-vector matrix non-contiguous subtest m vr name= mvN subtest vc m name= mvN subtest m T vc name= mvN subtest vr m T name= mvN vector-matrix matrix-vector both non-contiguous subtest m vr name= mvN subtest vc m name= mvn subtest m T vc name= mv subtest vr m T name= mv size == subtest m m T name= s _ subtest m T m name= s _ subtest m m name= s _ subtest m T m T name= s _ test_dot_equivalent args r = np matmul args r = np dot args assert_equal r r r = np matmul args copy args copy assert_equal r r skip reason= object arrays test_matmul_exception_multiply test matmul fails ` __mul__ ` missing add_not_multiply __add__ other = np full add_not_multiply assert_raises TypeError np matmul skip reason= object arrays test_matmul_exception_add test matmul fails ` __add__ ` missing multiply_not_add __mul__ other = np full multiply_not_add assert_raises TypeError np matmul test_matmul_bool gh- = np array dtype=bool assert np max view np uint == b = np matmul matmul boolean output should always assert np max b view np uint == rg = np random default_rng np random PCG d = rg integers size= dtype=np int d = d reshape np random seed d = np random randint size= out = np matmul d d reshape out = np dot d d reshape assert_equal out out c = np matmul np zeros dtype=bool np zeros dtype=bool assert np any c TestMatmulOperator MatmulCommon TestCase operator matmul = operator matmul skip reason= no __array_priority__ test_array_priority_override A __array_priority__ = __matmul__ other A __rmatmul__ other A = A b = np ones assert_equal matmul b A assert_equal matmul b A test_matmul_raises assert_raises RuntimeError TypeError ValueError matmul np int np int xpassIfTorchDynamo_np reason= torch supports inplace matmul so do we skipif numpy __version__ = reason= This fixed numpy test_matmul_inplace It would nice support in-place matmul eventually now we don t have working implementation so better just error out nudge people writing = b = np eye b = np eye assert_raises TypeError __imatmul__ b xfail XXX what s up exec under Dynamo test_matmul_inplace_ = np eye b = np eye assert_raises TypeError operator imatmul b assert_raises TypeError exec = b globals locals xpassIfTorchDynamo_np reason= matmul_axes test_matmul_axes = np arange reshape c = np matmul axes= - - - - assert c shape == d = np matmul axes= - - - - assert d shape == e = np swapaxes d assert_array_equal e c f = np matmul np arange axes= assert f shape == TestInner TestCase test_inner_scalar_and_vector dt np typecodes AllInteger + np typecodes AllFloat + sca = np array dtype=dt vec = np array dtype=dt desired = np array dtype=dt assert_equal np inner vec sca desired assert_equal np inner sca vec desired test_vecself Ticket Inner product vector itself segfaults give meaningless result = np zeros shape= dtype=np float p = np inner assert_almost_equal p decimal= test_inner_product_with_various_contiguities github issue dt np typecodes AllInteger + np typecodes AllFloat + check inner product involving matrix transpose A = np array dtype=dt B = np array dtype=dt C = np array dtype=dt desired = np array dtype=dt assert_equal np inner A T C desired assert_equal np inner C A T desired assert_equal np inner B C desired assert_equal np inner C B desired check matrix product desired = np array dtype=dt assert_equal np inner A B desired check syrk vs gemm paths desired = np array dtype=dt assert_equal np inner A A desired assert_equal np inner A A copy desired skip reason= - supported test_inner_product_reversed_view dt np typecodes AllInteger + np typecodes AllFloat + check inner product involving aliased reversed view = np arange astype dt b = - desired = np array dtype=dt item assert_equal np inner b desired test_ d_tensor dt np typecodes AllInteger + np typecodes AllFloat + = np arange reshape astype dt b = np arange reshape astype dt desired = np array astype dt assert_equal np inner b desired assert_equal np inner b transpose desired instantiate_parametrized_tests TestChoose TestCase setUp x = np ones dtype=int y = np ones dtype=int x = np ones dtype=int y = np ones dtype=int ind = test_basic A = np choose ind x y assert_equal A test_broadcast A = np choose ind x y assert_equal A test_broadcast A = np choose ind x y assert_equal A XXX revisit xfails when NEP lands numpy skip reason= XXX revisit xfails when NEP lands numpy parametrize ops np array dtype=np uint - np array dtype=np uint np float np array dtype=np float test_output_dtype ops expected_dt = np result_type ops assert np choose ops dtype == expected_dt test_docstring_ examples docstring https numpy org doc reference generated numpy choose html choices = A = np choose choices assert_equal A test_docstring_ = choices = - A = np choose choices assert_equal A - - - - test_docstring_ = np array reshape c = np array reshape c = np array - - - - - reshape A = np choose c c result x x res =c res =c expected = np array - - - - - - - - - - - - - - - assert_equal A expected TestRepeat TestCase setUp m = np array m_rect = m reshape test_basic A = np repeat m assert_equal A test_broadcast A = np repeat m assert_equal A test_axis_spec A = np repeat m_rect axis= assert_equal A A = np repeat m_rect axis= assert_equal A test_broadcast A = np repeat m_rect axis= assert_equal A A = np repeat m_rect axis= assert_equal A TODO test multidimensional NEIGH_MODE = zero one constant circular mirror xpassIfTorchDynamo_np reason= TODO TestWarnings TestCase test_complex_warning x = np array y = np array - j + j np ComplexWarning moved np exceptions numpy = np exceptions only available numpy = has_exceptions_ns = hasattr np exceptions ComplexWarning = np exceptions ComplexWarning has_exceptions_ns np ComplexWarning warnings catch_warnings warnings simplefilter error ComplexWarning assert_raises ComplexWarning x __setitem__ slice None y assert_equal x TestMinScalarType TestCase test_usigned_shortshort dt = np min_scalar_type - wanted = np dtype uint assert_equal wanted dt three tests below added based what numpy does test_complex dt = np min_scalar_type + j assert dt == np dtype complex test_float dt = np min_scalar_type assert dt == np dtype float test_nonscalar dt = np min_scalar_type assert dt == np dtype int numpy core _internal _dtype_from_pep skip reason= dont worry about buffer protocol TestPEP Dtype TestCase _check spec wanted dt = np dtype wanted actual = _dtype_from_pep spec assert_equal actual dt err_msg=f spec spec r = dtype wanted r test_native_padding align = np dtype i alignment j range j == s = bi s = f b j d xi _check + s f i f i align + j align _check = + s f i f i + j test_native_padding_ Native padding should work also structs sub-arrays _check x T xi f f i _check ^x T xi f f i test_trailing_padding Trailing padding should included item size should match alignment aligned mode align = np dtype i alignment size = np dtype i itemsize aligned n align + n - align base = dict formats= i names= f _check ix dict itemsize=aligned size + base _check ixx dict itemsize=aligned size + base _check ixxx dict itemsize=aligned size + base _check ixxxx dict itemsize=aligned size + base _check i x dict itemsize=aligned size + base _check ^ix dict itemsize=size + base _check ^ixx dict itemsize=size + base _check ^ixxx dict itemsize=size + base _check ^ixxxx dict itemsize=size + base _check ^i x dict itemsize=size + base test_native_padding_ dt = np dtype b b i sub np dtype b i c i align=True _check T b xxxi b T b f =i f sub xxxi c dt dt = np dtype b b i c b d b e b sub np dtype b i align=True _check T b =i b b c b d b e T b f xxxi f sub dt test_padding_with_array_inside_struct dt = np dtype b b i c b d i align=True _check T b xxxi b b c xi d dt test_byteorder_inside_struct The byte order after T =i should = Check noting absence native alignment _check T ^i xi f f i f i test_intra_padding Natively aligned sub-arrays may require some internal padding align = np dtype i alignment size = np dtype i itemsize aligned n align + n - align _check T ix dict names= f formats= i offsets= itemsize=aligned size + test_char_vs_string dt = np dtype c _check c dt dt = np dtype f S f S _check c s dt test_field_order gh- - previously we relied dictionary key order _check I f b I b f _check I b f b I f test_unnamed_fields _check ii f i f i _check ii f f i f i _check i i _check i f f i NOTE xpassIfTorchDynamo_np below TODO torch _numpy does handle model _CopyMode order= keyword supported probably won t Under TEST_WITH_TORCHDYNAMO many these make through due graph break leaving _CopyMode only handled numpy skipif numpy __version__ reason= CopyMode new NumPy xpassIfTorchDynamo_np instantiate_parametrized_tests TestArrayCreationCopyArgument TestCase RaiseOnBool __bool__ raise ValueError true_vals = True np _CopyMode ALWAYS np True_ false_vals = False np _CopyMode IF_NEEDED np False_ true_vals = True np True_ false_vals = False np False_ test_scalars Test both numpy python scalars dtype np typecodes All arr = np zeros dtype=dtype scalar = arr pyscalar = arr item Test never-copy raises error assert_raises ValueError np array scalar copy=np _CopyMode NEVER assert_raises ValueError np array pyscalar copy=np _CopyMode NEVER assert_raises ValueError np array pyscalar copy=self RaiseOnBool Casting dtype unsigned integers can special pytest raises ValueError np array pyscalar dtype=np int copy=np _CopyMode NEVER xfail TODO handle ` _CopyMode ` properly torch _numpy test_compatible_cast Some types compatible even though they different no copy necessary them This mostly true some integers int_types byteswap=False int_types = np typecodes Integer + np typecodes UnsignedInteger int_type int_types yield np dtype int_type byteswap yield np dtype int_type newbyteorder int int_types int int_types True arr = np arange dtype=int copy true_vals res = np array arr copy=copy dtype=int assert res arr res flags owndata assert_array_equal res arr int == int Casting necessary base check sufficient here copy false_vals res = np array arr copy=copy dtype=int assert res arr res base arr res = np array arr copy=np _CopyMode NEVER dtype=int assert res arr res base arr Casting necessary assert copy works copy false_vals res = np array arr copy=copy dtype=int assert res arr res flags owndata assert_array_equal res arr assert_raises ValueError np array arr copy=np _CopyMode NEVER dtype=int assert_raises ValueError np array arr copy=None dtype=int test_buffer_interface Buffer interface gives direct memory access no copy arr = np arange view = memoryview arr Checking bases bit tricky since numpy creates another memoryview so use may_share_memory copy true_vals res = np array view copy=copy assert np may_share_memory arr res copy false_vals res = np array view copy=copy assert np may_share_memory arr res res = np array view copy=np _CopyMode NEVER assert np may_share_memory arr res test_array_interfaces Array interface gives direct memory access much like memoryview base_arr = np arange ArrayLike __array_interface__ = base_arr __array_interface__ arr = ArrayLike copy val True None np _CopyMode ALWAYS None False arr np _CopyMode IF_NEEDED arr np _CopyMode NEVER arr res = np array arr copy=copy assert res base val test___array__ base_arr = np arange ArrayLike __array__ __array__ should copy numpy cannot know however base_arr arr = ArrayLike copy true_vals res = np array arr copy=copy assert_array_equal res base_arr An additional copy currently forced numpy case you could argue numpy does trust ArrayLike This may open change assert res base_arr copy false_vals res = np array arr copy=copy assert_array_equal res base_arr assert res base_arr numpy trusts ArrayLike pytest raises ValueError np array arr copy=np _CopyMode NEVER parametrize arr np ones np arange reshape parametrize order C F None parametrize order C F A K test_order_mismatch arr order order The order main python side reason can cause never-copy fail Prepare C-order F-order non-contiguous arrays arr = arr copy order order == C assert arr flags c_contiguous order == F assert arr flags f_contiguous arr ndim = Make array non-contiguous arr = arr assert arr flags forc Whether copy necessary depends order arr order == C no_copy_necessary = arr flags c_contiguous order == F no_copy_necessary = arr flags f_contiguous Keeporder Anyorder OK non-contiguous output This consistent ` astype ` behaviour which enforces contiguity A It probably historic when K did exist no_copy_necessary = True Test both array memoryview view arr memoryview arr copy true_vals res = np array view copy=copy order=order assert res arr res flags owndata assert_array_equal arr res no_copy_necessary copy false_vals res = np array view copy=copy order=order res base obj refers memoryview IS_PYPY assert res arr res base obj arr res = np array view copy=np _CopyMode NEVER order=order IS_PYPY assert res arr res base obj arr copy false_vals res = np array arr copy=copy order=order assert_array_equal arr res assert_raises ValueError np array view copy=np _CopyMode NEVER order=order assert_raises ValueError np array view copy=None order=order test_striding_not_ok arr = np array assert_raises ValueError np array arr T copy=np _CopyMode NEVER order= C assert_raises ValueError np array arr T copy=np _CopyMode NEVER order= C dtype=np int assert_raises ValueError np array arr copy=np _CopyMode NEVER order= F assert_raises ValueError np array arr copy=np _CopyMode NEVER order= F dtype=np int TestArrayAttributeDeletion TestCase test_multiarray_writable_attributes_deletion ticket should seqfault raise AttributeError = np ones attr = shape strides data dtype real imag flat suppress_warnings sup sup filter DeprecationWarning Assigning data attribute s attr assert_raises AttributeError delattr s test_multiarray_not_writable_attributes_deletion = np ones attr = ndim flags itemsize size nbytes base ctypes T __array_interface__ __array_struct__ __array_priority__ __array_finalize__ s attr assert_raises AttributeError delattr s test_multiarray_flags_writable_attribute_deletion = np ones flags attr = writebackifcopy updateifcopy aligned writeable s attr assert_raises AttributeError delattr s test_multiarray_flags_not_writable_attribute_deletion = np ones flags attr = contiguous c_contiguous f_contiguous fortran owndata fnc forc behaved carray farray num s attr assert_raises AttributeError delattr s skip supported too brittle too annoying instantiate_parametrized_tests TestArrayInterface TestCase Foo __init__ value value = value iface = typestr f __float__ float value property __array_interface__ iface f = Foo parametrize val iface expected f f f f f shape f shape None TypeError f shape f shape ValueError f strides f strides ValueError f strides TypeError test_scalar_interface val iface expected Test scalar coercion within array interface f iface = typestr f f iface update iface HAS_REFCOUNT pre_cnt = sys getrefcount np dtype f isinstance expected type assert_raises expected np array val result = np array val assert_equal np array val expected assert result dtype == f del result HAS_REFCOUNT post_cnt = sys getrefcount np dtype f assert_equal pre_cnt post_cnt TestDelMisc TestCase xpassIfTorchDynamo_np reason= TODO test_flat_element_deletion = np ones flat try del del except TypeError pass except Exception raise AssertionError None TestConversion TestCase test_array_scalar_relational_operation All integer dt np typecodes AllInteger assert_ np array dtype=dt f type dt failed assert_ np array dtype=dt f type dt failed dt np typecodes AllInteger assert_ np array dtype=dt np array dtype=dt f type dt dt failed assert_ np array dtype=dt np array dtype=dt f type dt dt failed Unsigned integers dt B assert_ - np array dtype=dt f type dt failed assert_ - np array dtype=dt f type dt failed assert_ - = np array dtype=dt f type dt failed Unsigned vs signed dt bhil assert_ np array dtype=dt np array - dtype=dt f type dt dt failed assert_ np array dtype=dt np array - dtype=dt f type dt dt failed assert_ np array dtype=dt = np array - dtype=dt f type dt dt failed Signed integers floats dt bhl + np typecodes Float assert_ np array - dtype=dt f type dt failed assert_ np array - dtype=dt f type dt failed assert_ - == np array - dtype=dt f type dt failed dt bhl + np typecodes Float assert_ np array dtype=dt np array - dtype=dt f type dt dt failed assert_ np array dtype=dt np array - dtype=dt f type dt dt failed assert_ np array - dtype=dt == np array - dtype=dt f type dt dt failed skip reason= object arrays test_to_bool_scalar assert_equal bool np array False False assert_equal bool np array True True assert_equal bool np array True assert_raises ValueError bool np array NotConvertible __bool__ raise NotImplementedError assert_raises NotImplementedError bool np array NotConvertible assert_raises NotImplementedError bool np array NotConvertible IS_PYSTON raise SkipTest Pyston disables recursion checking self_containing = np array None self_containing = self_containing Error = RecursionError assert_raises Error bool self_containing previously stack overflow self_containing = None resolve circular reference test_to_int_scalar gh- means these aren t always same int_funcs = int lambda x x __int__ int_func int_funcs assert_equal int_func np array assert_equal int_func np array assert_equal int_func np array assert_raises ValueError TypeError int_func np array skip reason= object arrays test_to_int_scalar_ int_funcs = int lambda x x __int__ int_func int_funcs gh- assert_equal int_func np array assert_equal int_func np bytes_ b assert_equal int_func np str_ The delegation int __trunc__ deprecated Python sys version_info HasTrunc __trunc__ assert_equal int_func np array HasTrunc assert_equal int_func np array HasTrunc pass NotConvertible __int__ raise NotImplementedError assert_raises NotImplementedError int_func np array NotConvertible assert_raises NotImplementedError int_func np array NotConvertible TestWhere TestCase test_basic dts = bool np int np int np int np double np complex dt dts c = np ones dtype=bool assert_equal np where c dt dt dt assert_equal np where ~c dt dt dt assert_equal np where True dt dt dt assert_equal np where False dt dt dt d = np ones_like c astype dt e = np zeros_like d r = d astype dt c = False r = e assert_equal np where c e e e assert_equal np where c d e r assert_equal np where c d e r assert_equal np where c d e r assert_equal np where c d e r assert_equal np where c d e r assert_equal np where c d e r assert_equal np where c d e r assert_equal np where c - d - e - r - assert_equal np where c - d - e - r - assert_equal np where c - d - e - r - test_exotic zero sized m = np array dtype=bool reshape b = np array dtype=np float reshape assert_array_equal np where m b np array reshape skip reason= object arrays test_exotic_ object cast d = np array - - - - - - - - nan = float NaN e = np array z l nan Wz nan nan Xq cs nan nan QN nan nan Fd nan nan kp nan i dtype=object m = np array dtype=bool r = e r np where m = d np where m assert_array_equal np where m d e r r = e r np where ~m = d np where ~m assert_array_equal np where m e d r assert_array_equal np where m e e e minimal dtype result NaN scalar e g required pandas d = np array dtype=np float e = float NaN assert_equal np where True d e dtype np float e = float Infinity assert_equal np where True d e dtype np float e = float -Infinity assert_equal np where True d e dtype np float also check upcast e = e assert_equal np where True d e dtype np float test_ndim c = True False = np zeros b = np ones r = np where np array c np newaxis b assert_array_equal r assert_array_equal r b = T b = b T r = np where c b assert_array_equal r assert_array_equal r b test_dtype_mix c = np array False True False False False False True False False False True False = np uint b = np array - - - dtype=np float r = np array - - - dtype=np float assert_equal np where c b r = astype np float b = b astype np int assert_equal np where c b r non bool mask c = c astype int c c = = assert_equal np where c b r invert tmpmask = c = c c == = c tmpmask = assert_equal np where c b r skip reason= endianness test_foreign c = np array False True False False False False True False False False True False r = np array - - - dtype=np float = np ones dtype= i b = np array - - - dtype=np float assert_equal np where c b r b = b astype f assert_equal np where c b r = astype i assert_equal np where c b r c = c astype i assert_equal np where c b r test_error c = True True = np ones b = np ones assert_raises RuntimeError ValueError np where c assert_raises RuntimeError ValueError np where c b test_empty_result pass empty where result through assignment which reads data empty arrays error detectable valgrind see gh- x = np zeros ibad = np vstack np where x == assert_array_equal ibad np atleast_ d np array dtype=np intp test_largedim invalid read regression gh- shape = np random seed array = np random rand shape _ range benchmark = array nonzero result = array nonzero assert_array_equal benchmark result test_kwargs = np zeros assert_raises TypeError np where x=a y=a TestHashing TestCase test_arrays_not_hashable x = np ones assert_raises TypeError hash x test_collections_hashable x = np array assert_ isinstance x collections abc Hashable TestFormat TestCase xpassIfTorchDynamo_np reason= TODO test_ d = np array np pi assert_equal f g assert_equal f g test_ d_no_format = np array np pi assert_equal f str test_ d_format until gh- ensure behaviour matches what used = np array np pi assert_raises TypeError format numpy testing IS_PYPY TestWritebackIfCopy TestCase all these tests use WRITEBACKIFCOPY mechanism test_argmax_with_out mat = np eye out = np empty dtype= i res = np argmax mat out=out assert_equal res range test_argmin_with_out mat = -np eye out = np empty dtype= i res = np argmin mat out=out assert_equal res range xpassIfTorchDynamo_np reason= XXX place test_insert_noncontiguous = np arange reshape T force non-c-contiguous uses arr_insert np place assert_equal np array hit one failing paths assert_raises ValueError np place test_put_noncontiguous = np arange reshape T force non-c-contiguous assert flags C_CONTIGUOUS sanity check np put assert_equal np array xpassIfTorchDynamo_np reason= XXX putmask test_putmask_noncontiguous = np arange reshape T force non-c-contiguous uses arr_putmask np putmask assert_equal np array test_take_mode_raise = np arange dtype= int out = np empty dtype= int np take out=out mode= raise assert_equal out np array test_choose_mod_raise = np array out = np empty dtype= int choices = - np choose choices out=out mode= raise assert_equal out np array - - - - xpassIfTorchDynamo_np reason= XXX ndarray flat test_flatiter__array__ = np arange reshape b = T flat c = b __array__ triggers WRITEBACKIFCOPY resolution assuming refcount semantics del c test_dot_out HAVE_CBLAS will use WRITEBACKIFCOPY = np arange dtype=float reshape b = np dot out=a assert_equal b np array instantiate_parametrized_tests TestArange TestCase test_infinite assert_raises RuntimeError ValueError np arange np inf unsupported range test_nan_step assert_raises RuntimeError ValueError cannot compute length np arange np nan test_zero_step assert_raises ZeroDivisionError np arange assert_raises ZeroDivisionError np arange empty range assert_raises ZeroDivisionError np arange assert_raises ZeroDivisionError np arange test_require_range assert_raises TypeError np arange assert_raises TypeError np arange step= assert_raises TypeError np arange dtype= int xpassIfTorchDynamo_np reason= weird arange signature optionals before required args test_require_range_ assert_raises TypeError np arange start= test_start_stop_kwarg keyword_stop = np arange stop= keyword_zerotostop = np arange start= stop= keyword_start_stop = np arange start= stop= assert len keyword_stop == assert len keyword_zerotostop == assert len keyword_start_stop == assert_array_equal keyword_stop keyword_zerotostop skip reason= arange booleans numpy maybe deprecates test_arange_booleans Arange makes some sense booleans works up length But weird since ` arange dtype=bool ` works Arguably much all could deprecated removed res = np arange False dtype=bool assert_array_equal res np array dtype= bool res = np arange True dtype= bool assert_array_equal res False res = np arange dtype= bool assert_array_equal res False True This case especially weird drops out without special case res = np arange dtype= bool assert_array_equal res True True pytest raises TypeError np arange dtype= bool parametrize which test_error_paths_and_promotion which args = start stop step args which = np float should ensure float output assert np arange args dtype == np float repeat non-empty ranges args = args which = np float assert np arange args dtype == np float parametrize dt np float np uint complex test_explicit_dtype dt assert np arange dtype=dt dtype == dt TestRichcompareScalar TestCase skip XXX brittle fails passes under dynamo depending NumPy version test_richcompare_scalar_boolean_singleton_return These currently guaranteed boolean singletons maybe returning NumPy booleans would also OK assert np array == False assert np array = True assert np int == False assert np int = True skip reason= implement views dtypes TestViewDtype TestCase Verify making view non-contiguous array works expected test_smaller_dtype_multiple x non-contiguous x = np arange dtype= i pytest raises ValueError match= last axis must contiguous x view i expected = assert_array_equal x np newaxis view i expected test_smaller_dtype_not_multiple x non-contiguous x = np arange dtype= i pytest raises ValueError match= last axis must contiguous x view S pytest raises ValueError match= When changing smaller dtype x np newaxis view S Make sure problem because dtype size expected = b b \x b \x assert_array_equal x np newaxis view S expected test_larger_dtype_multiple x non-contiguous first dimension contiguous last x = np arange dtype= i reshape expected = np array dtype= i assert_array_equal x view i expected test_larger_dtype_not_multiple x non-contiguous first dimension contiguous last x = np arange dtype= i reshape pytest raises ValueError match= When changing larger dtype x view S Make sure problem because dtype size expected = b \x \x \x b \x \x \x b \x \x \t b \x c\x \r b \x \x \x assert_array_equal x view S expected test_f_contiguous x F-contiguous x = np arange dtype= i reshape T pytest raises ValueError match= last axis must contiguous x view i test_non_c_contiguous x contiguous axis=- C-contiguous other axes x = np arange dtype= i reshape transpose expected = assert_array_equal x view i expected instantiate_parametrized_tests TestSortFloatMisc TestCase Test various array sizes hit different code paths quicksort-avx parametrize N test_sort_float N Regular data nan sprinkled np random seed arr = - + np random sample N astype f arr np random choice arr shape = np nan assert_equal np sort arr kind= quick np sort arr kind= heap +INF infarr = np inf np ones N dtype= f infarr np random choice infarr shape = - assert_equal np sort infarr kind= quick np sort infarr kind= heap -INF neginfarr = -np inf np ones N dtype= f neginfarr np random choice neginfarr shape = assert_equal np sort neginfarr kind= quick np sort neginfarr kind= heap + -INF infarr = np inf np ones N dtype= f infarr np random choice infarr shape int N = -np inf assert_equal np sort infarr kind= quick np sort infarr kind= heap test_sort_int Random data NPY_MAX_INT NPY_MIN_INT sprinkled rng = np random default_rng np random seed N = minv = np iinfo np int min maxv = np iinfo np int max arr = np random randint low=minv high=maxv size=N astype int arr np random choice arr shape = minv arr np random choice arr shape = maxv assert_equal np sort arr kind= quick np sort arr kind= heap __name__ == __main__ run_tests