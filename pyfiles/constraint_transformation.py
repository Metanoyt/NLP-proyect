mypy ignore-errors copy itertools collections abc Callable torch fx experimental migrate_gradual_types constraint ApplyBroadcasting BinConstraintD CalcConv CalcMaxPool CalcProduct CanReshape Conj Constraint DGreatestUpperBound Disj DVar F GetItem GetItemTensor IndexSelect Prod T TGreatestUpperBound Transpose TVar torch fx experimental migrate_gradual_types constraint_generator BinConstraintT MAX_TENSOR_RANK torch fx experimental migrate_gradual_types operation op_add op_consistency op_div op_eq op_leq op_matching op_mod op_mul op_neq op_precision op_sub torch fx experimental migrate_gradual_types util gen_dvar gen_nat_constraints gen_tensor_dims torch fx tensor_type Dyn TensorType _TRANSFORMATION_RULES dict Constraint Callable = register_transformation_rule call_target register fn call_target _TRANSFORMATION_RULES raise RuntimeError f Transformation rule already registered call_target _TRANSFORMATION_RULES call_target = fn fn register valid_index index dims Given list dimensions checks index valid list try dims index T except IndexError F register_transformation_rule Transpose transform_transpose constraint counter Similar sequence two index-selects dims counter = gen_tensor_dims constraint tensor_size counter is_valid_index = valid_index constraint index dims is_valid_index = valid_index constraint index dims new_dims = copy deepcopy dims nat_constraints = gen_nat_constraints dims is_valid_index == T is_valid_index == T new_dims constraint index = dims constraint index new_dims constraint index = dims constraint index transformed_constraint = Conj BinConstraintT constraint input_var TensorType dims op_eq nat_constraints is_valid_index is_valid_index BinConstraintT constraint output TensorType new_dims op_eq transformed_constraint counter register_transformation_rule IndexSelect transform_index_select constraint counter The constraints consider given tensor size checks index valid so generates constraint replacing input dimension required dimension dims counter = gen_tensor_dims constraint tensor_size counter is_valid_index = valid_index constraint index dims nat_constraints = gen_nat_constraints dims index valid then replace input dimension new dimension otherwise dimension will replaced clause will contain False is_valid_index == T new_dims = copy deepcopy dims new_dims constraint index = constraint dim_replace transformed_constraint = Conj BinConstraintT constraint input_var TensorType dims op_eq nat_constraints is_valid_index BinConstraintT constraint output TensorType new_dims op_eq print constraints transformed_constraint counter register_transformation_rule GetItem transform_get_item constraint counter generate equality form t = then generate constraints check given index valid given particular tensor size If index valid generate constraint get item Note we already handled Dyn input case previous step Args constraint GetItem which assumes we getting item tensor Dyn counter variable tracking Returns simplified constraints GetItem dims counter = gen_tensor_dims constraint tensor_size counter nat_constraints = gen_nat_constraints dims is_valid_index = valid_index constraint index dims all_constraints = BinConstraintT constraint input_var TensorType dims op_eq nat_constraints is_valid_index index valid we generate constraint getting item otherwise clause will have been UNSAT due wrong index is_valid_index == T all_constraints append BinConstraintD constraint res dims constraint index op_eq Conj all_constraints counter valid_index_tensor index dims slice instances exceed length dimensions then type error so we False slice_count = s index isinstance s slice slice_count += slice_count len dims F T register_transformation_rule GetItemTensor transform_get_item_tensor constraint counter When index tuple then output will tensor TODO we have check case all HF models The cases we covering here tuple one - slice default argument - None None appends input tensor dimensions so each occurrence None increases rank slice default arguments does change rank assert isinstance constraint index_tuple tuple generate result tensor expected size dims counter = gen_tensor_dims constraint tensor_size counter nat_constraints = gen_nat_constraints dims generate place-holder list right rank where slice does contribute rank None does none_c = constraint index_tuple count None resulting_tensor_dims = none_c + len dims None dim_index = i range len constraint index_tuple append right location resulting tensor constraint index_tuple i None resulting_tensor_dims i = constraint index_tuple i == slice None None None pass raise NotImplementedError Method yet implemented append remaining dimensions right location dim_index = i range len resulting_tensor_dims resulting_tensor_dims i None resulting_tensor_dims i = dims dim_index dim_index += check index valid is_valid_index = valid_index_tensor constraint index_tuple dims check resulting tensor within bounds len resulting_tensor_dims F counter constraints = BinConstraintT constraint input_var TensorType dims op_eq BinConstraintT constraint res TensorType resulting_tensor_dims op_eq nat_constraints is_valid_index Conj constraints counter register_transformation_rule BinConstraintT generate_binconstraint_t constraint counter Transform binary constraints tensors precision constraints constraint op == op_precision constraint lhs == Dyn T counter isinstance constraint lhs TensorType is_fully_static = all d = Dyn d constraint lhs __args__ is_fully_static BinConstraintT constraint lhs constraint rhs op_eq counter new_dims = _ range len constraint lhs __args__ dim counter = gen_dvar counter new_dims append dim new_dim_constraints = BinConstraintD old_dim new_dim op_precision new_dim old_dim zip new_dims constraint lhs __args__ + BinConstraintT constraint rhs TensorType new_dims op_eq + BinConstraintD new_dim op_leq new_dim new_dims Conj new_dim_constraints counter matching constraint op == op_matching assert isinstance constraint rhs TensorType d = constraint rhs __args__ d = constraint rhs __args__ d = constraint rhs __args__ d = constraint rhs __args__ conj = BinConstraintT constraint lhs Dyn op_eq BinConstraintD d Dyn op_eq BinConstraintD d Dyn op_eq BinConstraintD d Dyn op_eq BinConstraintD d Dyn op_eq Disj Conj conj BinConstraintT constraint lhs TensorType d d d d op_eq counter constraint op == op_consistency c_dyn = Disj BinConstraintT constraint lhs Dyn op_eq BinConstraintT constraint rhs Dyn op_eq c_tensor_ c_tensor_ c_tensor_ c_tensor_ counter = gen_consistency_constraints constraint counter Disj c_dyn c_tensor_ c_tensor_ c_tensor_ c_tensor_ counter constraint op == op_leq assert isinstance constraint rhs int disj = BinConstraintT constraint lhs Dyn op_eq i range constraint rhs + dims = _ range i + dim_var counter = gen_dvar counter dims append dim_var disj append BinConstraintT constraint lhs TensorType dims op_eq Disj disj counter constraint counter register_transformation_rule BinConstraintD generate_binconstraint_d constraint counter Transform binary constraints dimensions constraint op == op_precision isinstance constraint lhs int BinConstraintD constraint lhs constraint rhs op_eq counter constraint lhs == Dyn T counter constraint op == op_consistency Disj BinConstraintD constraint lhs constraint rhs op_eq BinConstraintD constraint rhs Dyn op_eq BinConstraintD constraint lhs Dyn op_eq counter constraint counter register_transformation_rule Conj generate_conj constraint counter Transform conjunctions new = c constraint conjucts new_c counter = transform_constraint c counter new append new_c Conj new counter register_transformation_rule Disj generate_disj constraint counter Transform disjunctions new = c constraint disjuncts new_c counter = transform_constraint c counter new append new_c Disj new counter register_transformation_rule TGreatestUpperBound generate_gub constraint counter Transform greatest upper bound tensors Results equality Greatest Upper Bound dimensions c = Conj Disj BinConstraintT constraint rhs Dyn op_eq BinConstraintT constraint rhs Dyn op_eq BinConstraintT constraint res Dyn op_eq c c c c counter = gen_greatest_upper_bound constraint counter Disj c c c c c counter register_transformation_rule DGreatestUpperBound generate_d_gub constraint counter Transform greatest upper bound dimensions into equality constraints c = Conj BinConstraintD constraint rhs Dyn op_eq BinConstraintD constraint res constraint rhs op_eq c = Conj BinConstraintD constraint rhs Dyn op_eq BinConstraintD constraint res constraint rhs op_eq c = Conj BinConstraintD constraint rhs constraint rhs op_eq BinConstraintD constraint res constraint rhs op_eq Disj c c c counter register_transformation_rule CalcConv generate_calc_conv constraint counter d counter = gen_tensor_dims counter conv_result = TensorType d d d d convolution result tensor size c = BinConstraintT constraint conv_result conv_result op_eq second dimension output equal output channels c = Conj BinConstraintD d constraint c_out op_eq BinConstraintD d Dyn op_neq input corresponds output first dimension convolution c = BinConstraintD constraint matching_constraint d op_eq c c = calc_last_two_dims constraint d leq_constraints = Conj BinConstraintD d op_leq BinConstraintD d op_leq BinConstraintD d op_leq BinConstraintD d op_leq Conj c c c c c leq_constraints counter register_transformation_rule CalcMaxPool generate_calc_maxpool constraint counter Transform maxpool constraints d counter = gen_tensor_dims counter maxpool_result = TensorType d d d d maxpool result tensor size c = BinConstraintT constraint maxpool_result maxpool_result op_eq input corresponds output first second dimension maxpool c = BinConstraintD constraint matching_constraint d op_eq c = BinConstraintD constraint matching_constraint d op_eq c c = calc_last_two_dims constraint d leq_constraints = Conj BinConstraintD d op_leq BinConstraintD d op_leq BinConstraintD d op_leq BinConstraintD d op_leq Conj c c c c c leq_constraints counter register_transformation_rule CalcProduct generate_calc_product constraint counter Transform flatten constraints start = constraint start end = constraint end dims = constraint dims_to_flatten flattened = constraint flattened n = len constraint dims_to_flatten will evaluated right here boundary_check = = start start end end = n c_boundary = T boundary_check F lhs = dims start rhs = dims end mid = dims start end all_possibilities = generate_all_int_dyn_dim_possibilities mid all_constraints = p all_possibilities p = list p tells us there dynamic variable contains_dyn = all constraint op == op_neq constraint p contains_dyn mid_var = Dyn total_constraints = lhs + mid_var + rhs len total_constraints all_constraints append F all_constraints append Conj BinConstraintT flattened TensorType lhs + mid_var + rhs op_eq + p new_var counter = gen_dvar counter mid_eq_prod = Conj BinConstraintD new_var Prod mid op_eq BinConstraintD new_var Dyn op_neq mid_var = new_var total_constraints = lhs + mid_var + rhs len total_constraints all_constraints append F all_constraints append Conj BinConstraintT flattened TensorType lhs + mid_var + rhs op_eq mid_eq_prod + p Conj Disj all_constraints c_boundary counter register_transformation_rule CanReshape generate_reshape constraint counter Transform reshape constraints d counter = gen_tensor_dims counter d = d d = d d = d d = d target = constraint target __args__ is_fully_static = all d = Dyn d target dynamic tensor c _dyn = BinConstraintT constraint src Dyn op_eq c _tensor = BinConstraintT constraint src TensorType d op_eq c _tensor = BinConstraintT constraint src TensorType d d op_eq c _tensor = BinConstraintT constraint src TensorType d d d op_eq c _tensor = BinConstraintT constraint src TensorType d d d d op_eq d _eq_dyn = BinConstraintD d Dyn op_eq d _neq_dyn = BinConstraintD d Dyn op_neq d _eq_dyn = BinConstraintD d Dyn op_eq d _neq_dyn = BinConstraintD d Dyn op_neq d _eq_dyn = BinConstraintD d Dyn op_eq d _neq_dyn = BinConstraintD d Dyn op_neq d _eq_dyn = BinConstraintD d Dyn op_eq d _neq_dyn = BinConstraintD d Dyn op_neq nat_d = BinConstraintD d op_leq nat_d = BinConstraintD d op_leq nat_d = BinConstraintD d op_leq nat_d = BinConstraintD d op_leq is_fully_static size tensor c _tensor = Disj d _eq_dyn Conj d _neq_dyn BinConstraintD d Prod target op_eq all_tensor_ = Conj c _tensor c _tensor size tensor all_tensor_ = Conj c _tensor gen_all_reshape_possibilities d d target size tensor all_tensor_ = Conj c _tensor gen_all_reshape_possibilities d d d target size tensor all_tensor_ = Conj c _tensor gen_all_reshape_possibilities d d d d target Conj Disj c _dyn all_tensor_ all_tensor_ all_tensor_ all_tensor_ nat_d nat_d nat_d nat_d counter then there must exactly one occurrence dyn new_target = n n target n = Dyn tensor c _tensor = Disj d _eq_dyn Conj d _neq_dyn is_dim_div_by_target new_target d all_tensor_ = Conj c _tensor c _tensor tensor c = Disj d _eq_dyn d _eq_dyn c = Conj d _neq_dyn d _neq_dyn is_dim_div_by_target new_target Prod d d all_tensor_ = Conj c _tensor Disj c c tensor c = Disj d _eq_dyn d _eq_dyn d _eq_dyn c = Conj d _neq_dyn d _neq_dyn d _neq_dyn is_dim_div_by_target new_target Prod d d d all_tensor_ = Conj c _tensor Disj c c tensor c = Disj d _eq_dyn d _eq_dyn d _eq_dyn d _eq_dyn c = Conj d _neq_dyn d _neq_dyn d _neq_dyn d _neq_dyn is_dim_div_by_target new_target Prod d d d d all_tensor_ = Conj c _tensor Disj c c Conj Disj c _dyn all_tensor_ all_tensor_ all_tensor_ all_tensor_ nat_d nat_d nat_d nat_d counter register_transformation_rule ApplyBroadcasting generate_broadcasting constraint counter Transform broadcasting constraints e e = constraint res constraint res e e = constraint input constraint input e _dyn = BinConstraintT e Dyn op_eq e _dyn = BinConstraintT e Dyn op_eq Introduce dimensions e _equal_e = BinConstraintT e e op_eq e _equal_e = BinConstraintT e e op_eq dyn possibility e _dyn_constraint = Conj e _dyn e _equal_e e _equal_e e _dyn_constraint = Conj e _dyn e _equal_e e _equal_e tensor possibility generate dimensions create tensors size final_tensor_ _constraint _ _ nat_dims_ counter = gen_broadcasting_constraints e e e e counter generate dimensions create tensors size final_tensor_ _constraint_no_padding final_tensor_ _constraint_padding_arg final_tensor_ _constraint_padding_arg nat_dims_ counter = gen_broadcasting_constraints e e e e counter generate dimensions create tensors size final_tensor_ _constraint_no_padding final_tensor_ _constraint_padding_arg final_tensor_ _constraint_padding_arg nat_dims_ counter = gen_broadcasting_constraints e e e e counter generate dimensions create tensors size final_tensor_ _constraint_no_padding final_tensor_ _constraint_padding_arg final_tensor_ _constraint_padding_arg nat_dims_ counter = gen_broadcasting_constraints e e e e counter final_result = Disj e _dyn_constraint e _dyn_constraint final_tensor_ _constraint final_tensor_ _constraint_no_padding final_tensor_ _constraint_padding_arg final_tensor_ _constraint_padding_arg final_tensor_ _constraint_no_padding final_tensor_ _constraint_padding_arg final_tensor_ _constraint_padding_arg final_tensor_ _constraint_no_padding final_tensor_ _constraint_padding_arg final_tensor_ _constraint_padding_arg Conj final_result nat_dims_ nat_dims_ nat_dims_ nat_dims_ counter transform_constraint constraint Constraint counter int Transforms constraint into simpler constraint Ex precision consistency transformed equality Args constraint constraint transformed counter variable tracking Returns Constraint type constraint _TRANSFORMATION_RULES _TRANSFORMATION_RULES type constraint constraint counter constraint counter calc_last_two_dims constraint d list DVar Generates constraints last two dimensions convolution maxpool output Args constraint CalcConv CalcMaxPool d The list output dimensions Returns Constraints calculating last two dimensions output assert isinstance constraint CalcConv CalcMaxPool b = constraint matching_constraint b = constraint matching_constraint b _dyn = Conj BinConstraintD d Dyn op_eq BinConstraintD b Dyn op_eq b _dyn = Conj BinConstraintD d Dyn op_eq BinConstraintD b Dyn op_eq d _not_dyn = Conj BinConstraintD d Dyn op_neq BinConstraintD b Dyn op_neq d _not_dyn = Conj BinConstraintD d Dyn op_neq BinConstraintD b Dyn op_neq transform parameters into tuples case they already padding = constraint padding constraint padding isinstance constraint padding int constraint padding kernel = constraint kernel constraint kernel isinstance constraint kernel int constraint kernel stride = constraint stride constraint stride isinstance constraint stride int constraint stride dilation = constraint dilation constraint dilation isinstance constraint dilation int constraint dilation f = BinConstraintD b BinConstraintD padding op_mul op_add f = BinConstraintD dilation BinConstraintD kernel op_sub op_mul f = BinConstraintD BinConstraintD BinConstraintD f f op_sub op_sub stride op_div f = BinConstraintD f op_add c = Disj b _dyn Conj d _not_dyn BinConstraintD d f op_eq f = BinConstraintD b BinConstraintD padding op_mul op_add f = BinConstraintD dilation BinConstraintD kernel op_sub op_mul f = BinConstraintD BinConstraintD BinConstraintD f f op_sub op_sub stride op_div f = BinConstraintD f op_add c = Disj b _dyn Conj d _not_dyn BinConstraintD d f op_eq c c generate_all_int_dyn_dim_possibilities my_list list DVar Generate all possibilities being equal equal dyn my_list Args my_list List tensor dimensions Returns A list list constraints Each list constraints corresponds one possibility about values dimension variables generate all possibilities being equal equal dyn my_list eq_possibilities = BinConstraintD my_list i Dyn op_eq i range len my_list neq_possibilities = BinConstraintD my_list i Dyn op_neq i range len my_list d_possibilities = list i i zip eq_possibilities neq_possibilities all_possibilities = list itertools product d_possibilities all_possibilities is_target_div_by_dim target list int dim list DVar Generate constraints check target dimensions divisible input dimensions Args target Target dimensions dim Input dimensions Returns Constraints check divisibility BinConstraintD BinConstraintD Prod target dim op_mod op_eq is_dim_div_by_target target list int dim list DVar Generate constraints check input dimensions divisible target dimensions Args target Target dimensions dim Input dimensions Returns Constraints check divisibility BinConstraintD BinConstraintD dim Prod target op_mod op_eq gen_all_reshape_possibilities list_of_dims target Consider all possibilities what input dimensions could number dynamic Then generate appropriate constraints using multiplication mod depending possibility The possibilities we consider here cross product being equal dyn equal dyn input Target fixed because most one dimension could dyn We have different cases Args list_of_dims The input list dimensions target The tensor we want reshape Returns A disjunction transformed reshape constraints all_possibilities = generate_all_int_dyn_dim_possibilities list_of_dims all_constraints = p all_possibilities to_multiply = p = list p constraint p assert isinstance constraint BinConstraintD constraint op == op_neq to_multiply append constraint lhs to_multiply all_constraints append Conj p len to_multiply len list_of_dims all_constraints append Conj p + is_target_div_by_dim target Prod to_multiply all_constraints append Conj p + BinConstraintD Prod list_of_dims Prod target op_eq Disj all_constraints broadcast_dim tensor_input tensor_input res res index padding=False Apply broadcasting index dimension tensor_input Args tensor_input should represent d d_index where d_index = tensor_input represents second input res broadcasted result res broadcasted result index index broadcast padding If padding used then tensor_input index does exist Returns tensor_input index None assert padding padding then inputs same length so they all have dimensions index Conj BinConstraintD tensor_input index op_eq BinConstraintD res index res index op_eq BinConstraintD res index tensor_input index op_eq we don t set input dimension since doesn t exist Conj BinConstraintD res index res index op_eq BinConstraintD res index tensor_input index op_eq apply_padding e _var TVar e BinConstraintT e BinConstraintT e BinConstraintT d list DVar d list DVar d list DVar counter int We considering possibility where one input has less dimensions than another input so we apply padding broadcasted results Args e _var Variable representing first input where padding will e constraint form e = Tensortype d dn e constraint form e = Tensortype d dn e constraint form e = Tensortype d dn d Tensor variables second input d Tensor variables broadcasted first input d Tensor variables broadcasted second input counter variable tracking Returns A new constraint whose goal apply padding broadcasted result res = pad shorter input None so we can pass broadcasting helper function i range len d d counter = gen_tensor_dims i counter nat_constraints = gen_nat_constraints d + d + d + d e = BinConstraintT e _var TensorType d op_eq simulate_padding = None len d - i assert len simulate_padding + d == len d every padding size we also consider broadcasting broadcast_padding = broadcast_dim simulate_padding d d d j True j range len d - i we consider possibilities broadcasting every dimension Since we already padded d we do consider while broadcasting all_broadcasting_possibilities = generate_all_broadcasting_possibilities_no_padding d d len d - i d len d - i d len d - i combine all constraints into conjunction c = Conj e e e e broadcast_padding all_broadcasting_possibilities nat_constraints res append c Disj res counter no_broadcast_dim_with_index d list DVar d list DVar d list DVar d list DVar i int Args d input d input d simulated broadcasting input d simulated broadcasting input i rank resulting tensor addition Returns Constraints when no broadcasting occurs Conj Disj Conj BinConstraintD d i op_eq BinConstraintD d i op_eq Conj BinConstraintD d i op_neq BinConstraintD d i op_neq BinConstraintD d i d i op_eq BinConstraintD d i d i op_eq gen_lists_of_dims num_tensors int dim_size int counter int Generate lists DVar represent tensor dimensions Args num_tensors required number tensors dim_size number dimensions each tensor counter variable tracking Returns A list list tensor dimensions res = _ range num_tensors dims counter = gen_tensor_dims dim_size counter res append dims res counter create_equality_constraints_for_broadcasting e TVar e TVar e TVar e TVar d list DVar d list DVar d list DVar d list DVar Create equality constraints when no broadcasting occurs Args e Input e Input e Broadcasted input e Broadcasted input d Variables store dimensions e d Variables store dimensions e d Variables store dimensions e d Variables store dimensions e Returns Four equality constraints e _tensor = BinConstraintT e TensorType d op_eq e _tensor = BinConstraintT e TensorType d op_eq e _tensor = BinConstraintT e TensorType d op_eq e _tensor = BinConstraintT e TensorType d op_eq e _tensor e _tensor e _tensor e _tensor gen_consistency_constraints constraint Constraint counter int Args constraint Consistency constraint tensors counter variable tracking Returns Equality consistency constraints dimensions all_constraints = i range MAX_TENSOR_RANK + new_dims_rhs_ counter = gen_tensor_dims i counter new_dims_rhs_ counter = gen_tensor_dims i counter nat_constraints = gen_nat_constraints new_dims_rhs_ + new_dims_rhs_ c_tensor_i = Conj BinConstraintT constraint lhs TensorType new_dims_rhs_ op_eq BinConstraintT constraint rhs TensorType new_dims_rhs_ op_eq + BinConstraintD d d op_consistency d d zip new_dims_rhs_ new_dims_rhs_ + nat_constraints all_constraints append c_tensor_i all_constraints counter gen_greatest_upper_bound constraint TGreatestUpperBound counter int Args constraint Greatest upper bound tensors counter variable tracking Returns A set equality constraints DGreatestUpperBound constraints all_constraints = i range MAX_TENSOR_RANK + c = dims counter = gen_tensor_dims i counter c tensor = TensorType dims dims counter = gen_tensor_dims i counter c tensor = TensorType dims dims counter = gen_tensor_dims i counter c tensor = TensorType dims c += BinConstraintT constraint rhs c tensor op_eq BinConstraintT constraint rhs c tensor op_eq BinConstraintT constraint res c tensor op_eq + gen_nat_constraints dims + dims + dims assert len c tensor __args__ == len c tensor __args__ == len c tensor __args__ i range len c tensor __args__ c append DGreatestUpperBound c tensor __args__ i c tensor __args__ i c tensor __args__ i all_constraints append Conj c all_constraints counter generate_all_broadcasting_possibilities_no_padding d list DVar d list DVar d list DVar d list DVar Generate broadcasting constraints assuming no padding Broadcasting can happen any dimension We look all combinations all dimensions d d Args d input dimensions d input dimensions d broadcasted input dimensions d broadcasted input dimensions Returns broadcasting constraints relating input dimensions broadcasted dimensions size = len d res = i range size t = broadcast_dim d d d d i t = broadcast_dim d d d d i t = no_broadcast_dim_with_index d d d d i res append Disj t t t Conj res gen_broadcasting_constraints e TVar e TVar e TVar e TVar i int counter int Simulates broadcasting e e returns results respectively e e Because gradual types e e may equal Similarly e e may equal e e should guaranteed consistent they represent shapes tensors added after broadcasting Args e TVar representing type input e TVar representing type input e TVar representing representing broadcasted input e TVar representing representing broadcasted input i The rank resulting type addition counter variable tracking Returns Simplified broadcasting constraints dims counter = gen_lists_of_dims i counter d d d d = dims nat_dims_i = gen_nat_constraints list itertools chain from_iterable dims initialize_tensors_constraints = create_equality_constraints_for_broadcasting e e e e d d d d e _tensor e _tensor e _tensor e _tensor = initialize_tensors_constraints without padding broadcast all possibilities tensors size i final_tensor_constraint_no_padding = Conj initialize_tensors_constraints generate_all_broadcasting_possibilities_no_padding d d d d padding broadcast all possibilities tensors size i final_tensor_constraint_padding_arg counter = apply_padding e e _tensor e _tensor e _tensor d d d counter final_tensor_constraint_padding_arg counter = apply_padding e e _tensor e _tensor e _tensor d d d counter final_tensor_constraint_no_padding final_tensor_constraint_padding_arg final_tensor_constraint_padding_arg nat_dims_i counter