mypy ignore-errors This module implements variable tracking PyTorch nn Module instances during Dynamo tracing It provides specialized handling different types nn Module instances through several key classes - NNModuleVariable Handles instance-specific module tracing specializing module id placing parameters directly torch fx GraphModule This creates one graph per module instance - UnspecializedNNModuleVariable Provides class-level module tracing treating nn Modules like other user-defined objects passing parameters inputs FX graph This creates one graph per module - UnspecializedBuiltinNNModuleVariable Specifically handles built-in PyTorch modules e g nn Linear appropriate optimizations - FSDPManagedNNModuleVariable Special handling FSDP-wrapped modules modified guarding behavior parameter handling The module integrates Dynamo s broader tracing functionality handle module method calls parameter access hooks other nn Module behaviors while maintaining proper scoping guarding module state functools inspect itertools re types contextlib contextmanager nullcontext typing TYPE_CHECKING torch nn graph_break_hints trace_rules variables exc raise_observed_exception unimplemented_v UnspecializeRestartAnalysis Unsupported guards GuardBuilder install_guard mutation_guard GenerationTracker source AttrSource ConstDictKeySource DictGetItemSource FSDPNNModuleSource GetItemSource NNModuleSource UnspecializedNNModuleSource utils get_custom_getattr get_fake_value is_lazy_module is_namedtuple is_safe_constant istensor istype nnmodule_has_hooks object_has_getattribute proxy_args_kwargs raise_args_mismatch set_example_value unpatched_nn_module_call unpatched_nn_module_call_impl base raise_type_error_exc typestr ValueMutationNew VariableTracker functions invoke_and_store_as_constant lazy LazyVariableTracker lists SliceVariable user_defined UserDefinedObjectVariable TYPE_CHECKING torch _dynamo symbolic_convert InstructionTranslator initialize_lazy_module tx InstructionTranslator mod args kwargs Fairly coupled helper used NNModuleVariable UnspecializedNNModuleVariable Used cause lazy module initialized delete its init hook before tracing Especially useful now allowed modules graph-break hooks calling first ensures there no hook time we trace __call__ thus no graph-break lazy allowed modules hasattr mod _initialize_hook convert_to_fake x is_namedtuple x type x convert_to_fake elem elem x isinstance x dict k convert_to_fake v k v x items isinstance x list tuple set type x convert_to_fake elem elem x isinstance x torch fx Proxy get_fake_value x node tx x proxy_args proxy_kwargs = proxy_args_kwargs args kwargs fake_args = convert_to_fake arg arg proxy_args fake_kwargs = k convert_to_fake v k v proxy_kwargs items try mod _infer_parameters mod fake_args fake_kwargs except AttributeError e Re-raise original error message AttributeError raise_observed_exception AttributeError tx msg=str e str e AttributeError during lazy module initialization contextmanager record_nn_module_stack module_key str source tx mod torch nn Module fully_qualified_name = source name Remove redundant namings fully_qualified_name = re sub r \ _ modules &#124; parameters &#124; buffers \ \ ^ \ \ + \ \ r \ fully_qualified_name num_calls = tx num_calls get fully_qualified_name module_key = f module_key num_calls num_calls module_key try tx nn_module_stack module_key = fully_qualified_name mod __class__ tx num_calls fully_qualified_name = num_calls + yield finally del tx nn_module_stack module_key guard_to_detect_forward_monkeypatching source mod Users sometimes patch forward method nn module instance perform optimizations like quantization Though good software practice python allows Dynamo needs detect patching One way do add ID_MATCH guard every function getting inlined https github com pytorch pytorch pull But increased guard overhead around To keep guard overhead down we just guard ` forward ` being present mod __dict__ The common case patching forward method adds ` forward ` instance __dict__ whereas unpatched ` forward ` sits type mod __dict__ source forward mod __dict__ callable mod __dict__ forward Monkeypatched forward method add ID_MATCH guard forward function fwd = mod __dict__ forward forward_source = AttrSource source forward type fwd types MethodType forward_source = AttrSource forward_source __func__ install_guard forward_source make_guard GuardBuilder CLOSURE_MATCH Common case - check forward key absent mod __dict__ install_guard source make_guard functools partial GuardBuilder NOT_PRESENT_IN_GENERIC_DICT attr= forward NNModuleVariable VariableTracker _nonvar_fields = module_type module_key value nn_module_stack_source VariableTracker _nonvar_fields __init__ module_type type module_key str value torch nn Module kwargs - None super __init__ kwargs module_type = module_type module_key = module_key value = value assert source nn_module_stack_source = source get_nn_module_stack_source nn_module_stack_source source set_nn_module_stack_source source nn_module_stack_source = source python_type module_type _wrap_submodule tx InstructionTranslator source submod key_extra options unpack_var_sequence tx implement list iter tuple etc calls base = tx output get_submodule module_key isinstance base torch nn ModuleDict result = name submod base items name_var = variables ConstantVariable create name tx output register_attr_or_module submod module_key name source=NNModuleSource GetItemSource source name result append name_var result assert isinstance base torch nn ModuleList torch nn ParameterList torch nn Sequential typestr base assert source result = idx submod enumerate base result append tx output register_attr_or_module submod module_key idx source=NNModuleSource GetItemSource source idx result call_obj_hasattr tx InstructionTranslator name str - VariableTracker mod = tx output get_submodule module_key result = hasattr mod name install_guard NNModuleSource AttrSource source name make_guard GuardBuilder HASATTR variables ConstantVariable create result is_training tx mod = tx output get_submodule module_key getattr mod training False convert_to_unspecialized tx Restart analysis treating module UnspecializedNNModuleVariable mod = tx output get_submodule module_key GenerationTracker tag mod Mark dynamic unless its module initialization tx f_code co_name = __init__ GenerationTracker mark_class_dynamic type mod raise UnspecializeRestartAnalysis has_key_in_generic_dict tx InstructionTranslator key base = tx output get_submodule module_key object_has_getattribute base unimplemented_v gb_type= Custom __getattribute__ nn Module dict key check context=f has_key_in_generic_dict key explanation= Dynamo does support checking key existence ` nn Module ` instances have custom ` __getattribute__ ` method defined hints= Avoid defining ` __getattribute__ ` your module graph_break_hints SUPPORTABLE tx output side_effects has_pending_mutation_of_attr key mutated_attr = tx output side_effects load_attr key deleted_ok=True isinstance mutated_attr variables DeletedVariable base_dict = object __getattribute__ base __dict__ key base_dict _custom_getattr_fallback base tx name obj_source Check __getattr__ handle specially implemented object_has_getattribute base unimplemented_v gb_type= Custom __getattribute__ nn Module attribute access context=f var_getattr name explanation= Dynamo does support checking key existence ` nn Module ` instances have custom ` __getattribute__ ` method defined hints= Avoid defining ` __getattribute__ ` your module graph_break_hints SUPPORTABLE getattr_fn = get_custom_getattr base ignore_nn_module_getattr=True getattr_fn None None isinstance getattr_fn types FunctionType unimplemented_v gb_type= torch nn Module non-function custom __getattr__ context=f var_getattr name explanation= Dynamo detected nn Module object custom ` __getattr__ ` method method standard Python function e g might implemented C C++ Dynamo cannot currently trace into such non-standard ` __getattr__ ` methods hints= Avoid using objects non-standard __getattr__ methods within compiled region If possible implement __getattr__ standard Python function graph_break_hints SUPPORTABLE options = source AttrSource obj_source __getattr__ variables UserMethodVariable getattr_fn options call_function tx variables ConstantVariable create name var_getattr tx InstructionTranslator name source = source AttrSource source name base = tx output get_submodule module_key base_dict = object __getattribute__ base __dict__ object_member = True all_class_attribute_names = set x inspect getmro base __class__ all_class_attribute_names update x __dict__ keys source unimplemented_v gb_type= getattr no source context=f var_getattr name explanation= Dynamo does know how access attribute ` nn Module ` instance lacks source This usually internal error Dynamo hints= graph_break_hints DYNAMO_BUG name == __dict__ variables GetAttrVariable name source=source name base_dict subobj = base_dict name _modules base_dict name base_dict _modules name all_class_attribute_names subobj = base_dict _modules name _parameters base_dict name base_dict _parameters subobj = base_dict _parameters name _buffers base_dict name base_dict _buffers subobj = base_dict _buffers name try subobj = inspect getattr_static base name object_member = False except AttributeError see we can fallback __getattr__ which checked getattr_static result = _custom_getattr_fallback base=base tx=tx name=name obj_source=self source result None result we can t find __getattr__ we can t parse raise attribute error raise_observed_exception AttributeError tx msg=f type base __name__ object has no attribute name name == forward guard_to_detect_forward_monkeypatching source base name == __class__ object_member variables UserDefinedClassVariable base __class__ source=source object_member out = VariableTracker build tx subobj NNModuleSource source isinstance out NNModuleVariable UnspecializedNNModuleVariable nn_module_stack source BC surface area Ensure mod _modules linear reflected mod linear nn_module_stack out set_nn_module_stack_source AttrSource get_nn_module_stack_source name out istype subobj property source Read attribute reach property source = AttrSource AttrSource source __class__ name Get getter function source = AttrSource source fget variables UserFunctionVariable subobj fget source=source call_function tx istype subobj classmethod variables UserMethodVariable subobj __func__ variables UserDefinedObjectVariable type base source=source istype subobj staticmethod variables UserFunctionVariable subobj __get__ base source=source istype subobj types FunctionType variables UserMethodVariable subobj source=source is_safe_constant subobj istensor subobj Support possibly common cases members VariableTracker build tx subobj NNModuleSource source unimplemented_v gb_type= Unsupported nn Module attribute type context=f nn Module subclass typestr base name name attribute type typestr subobj explanation=f Dynamo does support tracing nn Module attributes type ` typestr subobj ` hints= f Refactor your code so ` name ` type ` typestr subobj ` attribute ` typestr base ` Currently supported attribute types methods classmethods staticmethods properties constants tensors graph_break_hints SUPPORTABLE variables GetAttrVariable name source=source call_function tx args list VariableTracker kwargs dict str VariableTracker - VariableTracker mod = tx output get_submodule module_key record_nn_module_stack module_key get_nn_module_stack_source tx mod is_lazy = is_lazy_module mod isinstance mod torch nn Sequential mod __class__ forward torch nn Sequential forward nnmodule_has_hooks mod We do want unroll sequential has hooks since evaporating will cause hooks fire This terminates restart tracing process convert_to_unspecialized tx Unroll sequential assert is_lazy Expected lazy sequential isn t valid combination kwargs raise_args_mismatch tx torch nn Module Sequential kwargs f len kwargs kwargs arg = args TODO Use named_children when supports remove_duplicate=False child_name submod mod _modules items tx call_function tx output register_attr_or_module submod module_key child_name source=NNModuleSource AttrSource source child_name arg arg = tx pop arg is_lazy The module type will change after called mod cls_to_become None module_type = mod cls_to_become The pre-hook runs initialize module shapes then deletes itself After module more less lazy can treated normal module regardless is_allowed other variations initialize_lazy_module tx mod args kwargs If we tracing higher order op we want Dynamo step inside module call so Dynamo can see underlying parameters buffers raise them inputs graph NB torch nn utils parametrize changes type parametrized module such its __module__ points torch nn utils parametrize tx output is_root_tracer mod __module__ startswith torch nn torch ao mod __module__ = torch nn utils parametrize basically means we using new strict export tracer which wraps user callable so we shouldn t directly proxy fx graph isinstance mod torch ao quantization pt e export_utils _WrapperModule nnmodule_has_hooks mod check_forward_hooks=True check_backward_hooks=True End fn bubbles up restarts tracing convert_to_unspecialized tx builder wrap_fx_proxy wrap_fx_proxy tx=tx proxy=tx output create_proxy call_module module_key proxy_args_kwargs args kwargs assert source Must provide valid source order inline since inlined function may have default args which must guarded isinstance mod torch fx GraphModule TODO do we want support __call__ GM s If so least some changes needed we don t allow inlining call_wrapped currently maybe other issues too fn = mod forward fn_source = AttrSource source forward fn = mod _call_impl fn_source = AttrSource source _call_impl istype fn types MethodType fn = fn __func__ fn_source = AttrSource fn_source __func__ args = + args assert istype fn types FunctionType tx inline_user_function_return variables UserFunctionVariable fn source=fn_source args kwargs call_method tx name args list VariableTracker kwargs dict str VariableTracker constant=False - VariableTracker ConstantVariable ListIteratorVariable TupleVariable key = module_key module = tx output get_submodule key generic_call_method_helper name Helper function put ` call_method ` node FX graph nn Module first arg mod_proxy = tx output create_proxy get_attr module_key set_example_value mod_proxy node module proxy_args proxy_kwargs = proxy_args_kwargs args kwargs builder wrap_fx_proxy wrap_fx_proxy tx=tx proxy=tx output create_proxy call_method name args= mod_proxy proxy_args kwargs=proxy_kwargs name _call_impl _wrapped_call_impl Example ` layer __call__ x ` This used explicit calling ` __call__ ` forward function Dynamo inlines ` __call__ ` includes hooks call_function tx args kwargs name == forward Example ` layer forward x ` This used explicit calling ` forward ` forward function Dynamo puts ` call_method ` node FX doesn t trigger hooks record_nn_module_stack module_key get_nn_module_stack_source tx module generic_call_method_helper name name == _check_input_dim trace_rules is_torch_inline_allowed inspect getfile module __class__ _check_input_dim ConstantVariable create True name == _get_item_by_idx args is_python_constant raise_type_error_exc tx f ` ` nn Module ` ` module s call method name requires constant index argument isinstance args TupleVariable raise_type_error_exc tx f ` ` nn Module ` ` module s call method name requires tuple first argument mod_var = args items args value isinstance mod_var UnspecializedNNModuleVariable mod_var key = mod_var module_key submod = tx output get_submodule key tx output register_attr_or_module submod key key source=NNModuleSource GetItemSource source key constant fn = getattr module name name = f module __class__ __name__ _ name _result invoke_and_store_as_constant tx fn name args kwargs assert_all_args_kwargs_const all x is_python_constant x itertools chain args kwargs values unimplemented_v gb_type= non-const argument nn Module method context=f call_method name args kwargs explanation= Dynamo does support calling f method ` name ` ` ` nn Module ` ` module non-constant arguments hints= get_kwargs names assert_all_args_kwargs_const fn = getattr module name bound_args = inspect signature fn bind x as_python_constant x args k v as_python_constant k v kwargs items bound_args apply_defaults bound_args = bound_args arguments k bound_args k k names wrap_values items result = name submod items result append tx output register_attr_or_module submod key name source=NNModuleSource gen_source source name ListIteratorVariable result mutation_type=ValueMutationNew named_embed name obj TupleVariable ConstantVariable create name tx output register_attr_or_module obj key name source=NNModuleSource gen_source source name gen_source source name name_split = name split name_split == source while len name_split x = name_split pop source = AttrSource source x source name == named_children tx output guard_on_key_order add AttrSource source _modules args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs result = name submod module named_children result append named_embed name submod ListIteratorVariable result mutation_type=ValueMutationNew name == named_parameters tx output guard_on_key_order add AttrSource source _parameters result = name param module named_parameters get_kwargs prefix recurse result append named_embed name param ListIteratorVariable result mutation_type=ValueMutationNew name == named_buffers tx output guard_on_key_order add AttrSource source _buffers result = name buffer module named_buffers get_kwargs prefix recurse remove_duplicate result append named_embed name buffer ListIteratorVariable result mutation_type=ValueMutationNew name == named_modules tx output guard_on_key_order add AttrSource source _modules result = name submod module named_modules get_kwargs memo prefix remove_duplicate result append named_embed name submod ListIteratorVariable result mutation_type=ValueMutationNew name == children tx output guard_on_key_order add AttrSource source _modules args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs wrap_values module named_children name == modules tx output guard_on_key_order add AttrSource source _modules wrap_values module named_modules name == parameters tx output guard_on_key_order add AttrSource source _parameters wrap_values module named_parameters get_kwargs recurse name == buffers tx output guard_on_key_order add AttrSource source _buffers wrap_values module named_buffers get_kwargs recurse name == keys args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs result = name module keys result append ConstantVariable create name ListIteratorVariable result mutation_type=ValueMutationNew name == values args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs wrap_values module items name == items args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs result = name submod module items result append named_embed name submod ListIteratorVariable result mutation_type=ValueMutationNew name == __len__ args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs ConstantVariable create len module name == __iter__ ListIteratorVariable unpack_var_sequence tx mutation_type=ValueMutationNew name == __contains__ isinstance module torch nn ModuleDict torch nn ParameterDict args args is_python_constant ConstantVariable create args as_python_constant module _modules name == __getitem__ kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs builtin_supported = torch nn ModuleDict __getitem__ torch nn ModuleList __getitem__ torch nn ParameterDict __getitem__ torch nn ParameterList __getitem__ torch nn Sequential __getitem__ type module __getitem__ builtin_supported isinstance args variables ConstantVariable isinstance args as_python_constant str int unimplemented_v gb_type= Invalid non-const argument nn Module __getitem__ context=f call_method name args kwargs explanation= Dynamo does support calling f method ` name ` ` ` nn Module ` ` module non-constant non- str int key hints= Use constant arguments type str int __getitem__ fn = getattr module name __func__ assert isinstance fn types FunctionType src = AttrSource AttrSource source name __func__ tx inline_user_function_return variables UserFunctionVariable fn source=src + list args kwargs assert source isinstance args SliceVariable TODO anijain export-team - Remove condition when inlining inbuilt nn modules enabled export tx output export Build TupleVariable NNModules result = Turn slice into list integers keys = list range len module args as_python_constant idx submod enumerate module args as_python_constant key = keys idx src = NNModuleSource GetItemSource source key result append tx output register_attr_or_module submod key source=src new_module = module args as_python_constant new_module_variable = tx output register_attr_or_module new_module f __getitem__ slice source=NNModuleSource GetItemSource source args as_python_constant new_module_variable slice nn module results creation new module instance so we need make sourceless Convert unspecialized so UnspecializedNNModule variable can take care convert_to_unspecialized tx tensor SymNodeVariable isinstance args SymNodeVariable key = args evaluate_expr tx output args is_python_constant key = args as_python_constant unimplemented_v gb_type= Unsupported key type nn Module __getitem__ context=f call_method name args kwargs explanation= Dynamo does support getitem ` nn Module ` non-constant key hints= submod = module key tx output register_attr_or_module submod module_key key source=NNModuleSource GetItemSource source key name == _get_abs_string_index isinstance module torch nn modules conv _ConvNd name == _conv_forward isinstance module torch nn modules conv _ConvTransposeNd name == _output_padding Inline function fn = getattr module name __func__ fn_source = AttrSource AttrSource source name __func__ tx inline_user_function_return variables UserFunctionVariable fn source=fn_source + args kwargs A loose heuristic seems generally good before we drop into manual handling inputs name module __class__ __dict__ callable module __class__ __dict__ name all isinstance x variables TensorVariable x itertools chain args kwargs values generic_call_method_helper name super call_method tx name args kwargs UnspecializedNNModuleVariable UserDefinedObjectVariable _nonvar_fields = value_type is_state_mutated nn_module_stack_source UserDefinedObjectVariable _nonvar_fields The above will specialize id module place parameters torch fx GraphModule Giving one graph per module instance This version treats nn Modules like other user defined objects will pass parameters into FX graph inputs Giving one graph per module __init__ value kwargs - None type value torch jit _script RecursiveScriptModule raise Unsupported ScriptModules aren t supported UnspecializedNNModuleVariable because their forward function isn t static member their type value_type kwargs lazy_value_to_become = getattr kwargs value_type cls_to_become None type value lazy_value_to_become We may have cloned variabletracker LazyModule earlier e g tracking side-effects then later we called mutated LazyModule into MaterializedModule We do do mutation upon first seeing LazyModule since we preserve eager semantics only mutate upon first call requires we update multiple copies VariableTracker post-mutation kwargs value_type = type value super __init__ value=value kwargs is_state_mutated = False nn_module_stack_source used ensure BC nn_module_stack Downstream users prefer mod linear instead mod _modules linear module stack When Dynamo inlines __getattr__ method we cannot use source nn_module_stack because will similar mod _modules linear In these cases we set nn_module_stack_source appropriately resemble mod linear nn_module_stack_source = source _wrap_source attr_source vt already wrapped UnspecializedNNModuleSource attr_source get_nn_module_stack_source nn_module_stack_source source set_nn_module_stack_source source nn_module_stack_source = source staticmethod functools cache _nn_module_method_ids Allow __setattr__ fall through base handler supported = torch nn Module __setattr__ torch nn Module __init__ torch nn Module __delattr__ id x __code__ x torch nn Module __dict__ values hasattr x __code__ x supported unpack_var_sequence tx try fn = inspect getattr_static value_type __iter__ except AttributeError e raise NotImplementedError e fn torch nn ModuleList __iter__ torch nn ParameterList __iter__ torch nn Sequential __iter__ The program can mutate nn module object saved ` value ` will reflect mutations So trace through ` __iter__ ` function reflect any tracked mutations tx inline_user_function_return VariableTracker build tx fn unpack_var_sequence tx super unpack_var_sequence tx call_function tx InstructionTranslator args list VariableTracker kwargs dict str VariableTracker - VariableTracker mod = value see comment lazy module handling NNModuleVariable call_function context is_lazy_module mod mod cls_to_become None value_type = mod cls_to_become initialize_lazy_module tx mod args kwargs isinstance mod torch fx GraphModule name = __call__ fn = getattr value_type name name = _call_impl fn = getattr value_type name Check we can short circuit nn Module _call_impl forward method NB - This done reduce compile time Dynamo istype mod __call__ types MethodType istype mod _call_impl types MethodType mod __call__ __func__ unpatched_nn_module_call mod _call_impl __func__ unpatched_nn_module_call_impl forward mod __dict__ forward_method = inspect getattr_static mod forward isinstance forward_method types FunctionType globals_vt = tx nn_modules_globals_vt var_getattr tx _backward_hooks realize len var_getattr tx _backward_pre_hooks realize len var_getattr tx _forward_hooks realize len var_getattr tx _forward_pre_hooks realize len globals_vt var_getattr tx _global_backward_pre_hooks len globals_vt var_getattr tx _global_backward_hooks len globals_vt var_getattr tx _global_forward_hooks len globals_vt var_getattr tx _global_forward_pre_hooks len name = forward fn = value_type forward source source = get_source_by_walking_mro name source = None guard_to_detect_forward_monkeypatching source mod ctx = record_nn_module_stack str id mod get_nn_module_stack_source tx mod source nullcontext ctx isinstance fn types FunctionType torch jit ScriptFunction fn_vt = VariableTracker build tx fn source=source fn_vt call_function tx + list args kwargs Ideally we would have just used VariableTracker build tx fn source=source introduces guard ` forward __code__ ` object Given we already guard forward present generic dict we dont need guard variables UserFunctionVariable fn source=source call_function tx + list args kwargs call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name _call_impl _wrapped_call_impl fn = getattr value_type name source source = get_source_by_walking_mro name source = None fn_vt = VariableTracker build tx fn source=source fn_vt call_function tx + list args kwargs name getattr value __dict__ try method = inspect getattr_static type value name except AttributeError method = None isinstance method staticmethod source = AttrSource get_source_by_walking_mro name __func__ fn_vt = VariableTracker build tx method __func__ source=source fn_vt call_function tx args kwargs hasattr method __code__ id method __code__ _nn_module_method_ids unimplemented_v gb_type= UnspecializedNNModuleVariable missing method context=f call_method name args kwargs explanation=f Dynamo does support tracing method name nn Module value hints= Dynamo does really define unspecialized nn Module very well graph_break_hints DIFFICULT _parameters value __dict__ checks module initialized name == __setattr__ _parameters value __dict__ Record mutations happens parameters buffers modules The mutations these tracked base UserDefinedObject vt This will used later graph break seeing parameters family calls TODO anijain - This might needed we let Dynamo inline both getattr setattr In case should see lowest level dicts - _parameters family automatically track mutations those Investigate can done attr_name = args as_python_constant value = args This reverse engineered looking nn module __setattr__ logic isinstance value variables TensorVariable value python_type torch nn Parameter attr_name value __dict__ _parameters Handle parameters is_state_mutated = True attr_name value __dict__ _buffers Handle buffers is_state_mutated = True isinstance value variables NNModuleVariable variables UnspecializedNNModuleVariable attr_name value __dict__ _modules Handle submodules is_state_mutated = True method torch nn Module __setattr__ isinstance args variables DeletedVariable method torch nn Module __delattr__ Trace through __delattr__ track mutations module members like ` _modules ` ` fn_vt = VariableTracker build tx torch nn Module __delattr__ fn_vt call_function tx args kwargs super call_method tx name args kwargs getattr_helper tx InstructionTranslator field name_vt dict_vt = var_getattr tx field isinstance dict_vt variables ConstDictVariable dict_vt maybe_getitem_const name_vt None var_getattr tx InstructionTranslator name Allow skipping empty hook dict guards inbuilt nn modules name _backward_hooks _backward_pre_hooks _forward_hooks _forward_pre_hooks For empty hooks make EMPTY_NN_MODULE_HOOKS_DICT This allows us control installation empty hooks guard via skip_nnmodule_hook_guards tx output side_effects has_pending_mutation_of_attr name hooks_dict = getattr value name isinstance hooks_dict dict len hooks_dict == source hooks_source = AttrSource source name install_guard hooks_source make_guard GuardBuilder EMPTY_NN_MODULE_HOOKS_DICT variables ConstDictVariable For non-empty hook dicts one way just fallback VariableTracker build create ConstDictVariable However ConstDictVariable guards keys This can cause recompiles when same hook installed different nn module instances because key keeps changing look more into RemovableHandle understand why key changes - also related https github com pytorch pytorch issues Here we carefully craft NNModuleHooksDictVariable subclass ConstDictVariable avoid any guard keys source name _forward_pre_hooks _forward_hooks tx output side_effects has_pending_mutation_of_attr name hooks_dict = getattr value name hooks_dict_source = AttrSource source name install_guard hooks_dict_source make_guard GuardBuilder SEQUENCE_LENGTH tx output guard_on_key_order add hooks_dict_source build_key_value i k v Make key sourceless avoid any guard key = variables ConstantVariable create k Instead using dict key access value use dict dict keys index access value This removes reliance actual key value source_key = ConstDictKeySource hooks_dict_source i source_value = DictGetItemSource hooks_dict_source source_key value = LazyVariableTracker create v source_value key value result = dict build_key_value i k v i k v enumerate hooks_dict items variables NNModuleHooksDictVariable result type hooks_dict source=hooks_dict_source super var_getattr tx name manually_trace_nn_module_getattr tx InstructionTranslator name Dynamo tracing nn Module __getattr__ can expensive model has deep submodule hierarchy Since __getattr__ stable we can directly look into underlying datastructures This saves lot compilation time name_vt = variables ConstantVariable name out = getattr_helper tx _parameters name_vt out None out = getattr_helper tx _modules name_vt out None out = getattr_helper tx _buffers name_vt out None raise_observed_exception AttributeError tx msg=f type value __name__ object has no attribute name out UnspecializedBuiltinNNModuleVariable UnspecializedNNModuleVariable Differentiates between builtin nn modules e g torch nn Linear user defined nn modules _wrap_source attr_source vt already wrapped UnspecializedBuiltinNNModuleSource attr_source FSDPManagedNNModuleVariable UnspecializedNNModuleVariable Tracing behavior trace into submodules treat them Unspecialized do register parameters top-level treat them function inputs Guards behavior skip_fsdp_guards many guards would installed vanilla UnspecializedNNModuleVariable simply dropped basis user wrapping their model FSDP model already opting into requirement modify internal model state which would already break FSDP without compilation __init__ value kwargs - None source = kwargs get source assert source None FSDPManagedNNModule depends having accurate source control guarding super __init__ value=value kwargs source = source _wrap_source attr_source isinstance attr_source FSDPNNModuleSource UnspecializedNNModuleSource torch _dynamo config skip_fsdp_guards FSDPNNModuleSource attr_source UnspecializedNNModuleSource attr_source attr_source