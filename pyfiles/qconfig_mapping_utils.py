mypy allow-untyped-defs re collections defaultdict OrderedDict collections abc Callable typing Any Union torch torch ao nn intrinsic _FusedModule torch ao quantization QConfig torch ao quantization backend_config BackendConfig DTypeConfig torch ao quantization backend_config utils get_module_to_qat_module torch ao quantization observer _is_activation_post_process torch ao quantization qconfig _add_module_to_qconfig_obs_ctr qconfig_equals QConfigAny torch ao quantization qconfig_mapping _MODULE_NAME_DICT_KEY _MODULE_NAME_REGEX_DICT_KEY _OBJECT_TYPE_DICT_KEY QConfigMapping torch ao quantization utils _parent_name get_qconfig_dtypes torch fx GraphModule torch fx graph Graph __all__ list str = _maybe_adjust_qconfig_for_module_name_object_type_order qconfig_mapping QConfigMapping cur_module_path str cur_object_type Callable cur_object_type_idx int fallback_qconfig QConfigAny - QConfigAny module_name object_type index qconfig qconfig_mapping module_name_object_type_order_qconfigs items module_name == cur_module_path object_type == cur_object_type index == cur_object_type_idx qconfig fallback_qconfig _update_qconfig_for_fusion model GraphModule qconfig_mapping QConfigMapping Update QConfigMapping account fused modules such LinearReLU This assumes QConfigMapping s attributes have already been converted OrderedDicts object_type_dict = qconfig_mapping object_type_qconfigs len object_type_dict == qconfig_mapping modules = dict model named_modules node model graph nodes node op == call_module node target modules maybe_fused_module = modules str node target isinstance maybe_fused_module _FusedModule continue ops = list maybe_fused_module _modules values fused_qconfig = object_type_dict get type ops None Raise error modules fused module have different qconfigs specified qconfig_dict TODO currently only works modules need make work torch nn functional relu TODO currently only works object_type configurations ideally should work different types configurations maybe we want redesign part op ops qconfig_equals object_type_dict get type op None fused_qconfig raise LookupError During fusion we need specify same + f qconfigs all module types type maybe_fused_module + f offending type type op fused_qconfig None object_type_dict type maybe_fused_module = fused_qconfig _generate_node_name_to_qconfig root torch nn Module modules dict str torch nn Module input_graph Graph qconfig_mapping QConfigMapping node_name_to_scope dict str tuple str type - dict str QConfigAny global_qconfig = qconfig_mapping global_qconfig node_name_to_qconfig = example foo bar F linear F conv d meaning submodule foo bar we have seen F linear F conv d invocations so far submodule_to_object_type_to_cur_idx dict str dict Callable int = defaultdict lambda defaultdict int node input_graph nodes qconfig = None node op == get_attr module_name _ = _parent_name node target qconfig = _maybe_adjust_qconfig_for_module_type_or_name qconfig_mapping type modules module_name module_name global_qconfig qconfig_with_device_check = _add_module_to_qconfig_obs_ctr qconfig modules get node target None node op == call_function precedence module_name_qconfig function_qconfig global_qconfig module_name takes precedence over function qconfig function_qconfig = _get_object_type_qconfig qconfig_mapping node target global_qconfig module_path module_type = node_name_to_scope node name qconfig = _maybe_adjust_qconfig_for_module_type_or_name qconfig_mapping module_type module_path function_qconfig cur_object_type_idx = submodule_to_object_type_to_cur_idx module_path node target submodule_to_object_type_to_cur_idx module_path node target += qconfig = _maybe_adjust_qconfig_for_module_name_object_type_order qconfig_mapping module_path node target cur_object_type_idx qconfig qconfig_with_device_check = _add_module_to_qconfig_obs_ctr qconfig modules get node target None node op == call_method module_path module_type = node_name_to_scope node name first use node target string get qconfig support configs like object_type reshape qconfig qconfig = _maybe_adjust_qconfig_for_module_type_or_name qconfig_mapping node target module_path global_qconfig there no special config method we ll fall back config module contains call_method node qconfig = _maybe_adjust_qconfig_for_module_type_or_name qconfig_mapping module_type module_path qconfig currently call_method does support modifying qconfig order we can add later needed qconfig_with_device_check = _add_module_to_qconfig_obs_ctr qconfig modules get node target None node op == call_module node observer just continue - don t add qconfig_map _is_activation_post_process modules node target continue qconfig = _maybe_adjust_qconfig_for_module_type_or_name qconfig_mapping type modules node target node target global_qconfig module_path module_type = node_name_to_scope node name Note call_module module_path current module s name meaningfully count invocations we need count them parent module parent_name _ = _parent_name module_path cur_object_type_idx = submodule_to_object_type_to_cur_idx parent_name module_type submodule_to_object_type_to_cur_idx parent_name module_type += qconfig = _maybe_adjust_qconfig_for_module_name_object_type_order qconfig_mapping parent_name module_type cur_object_type_idx qconfig qconfig_with_device_check = _add_module_to_qconfig_obs_ctr qconfig modules get node target None regex supported eager mode propagate_qconfig_ we ll need set qconfig explicitly here case regex used modules node target qconfig = qconfig_with_device_check qconfig_with_device_check = None node_name_to_qconfig node name = qconfig_with_device_check node_name_to_qconfig _check_is_valid_config_dict config_dict Any allowed_keys set str dict_name str - None r Checks given config_dict has correct keys Args ` config_dict ` dictionary whose keys we want check k config_dict keys k allowed_keys raise ValueError Expected + dict_name + have following keys + str allowed_keys + But found + k + instead _compare_prepare_convert_qconfig_mappings prepare_qconfig_mapping QConfigMapping convert_qconfig_mapping QConfigMapping r Compare qconfig_mapping passed convert one prepare check values Args ` prepare_qconfig_mapping ` configuration prepare quantization step ` convert_qconfig_mapping ` configuration convert quantization step qconfig_equals prepare_qconfig_mapping global_qconfig convert_qconfig_mapping global_qconfig raise AssertionError Expected global qconfigs same prepare convert quantization configs prepare_dicts list OrderedDict = prepare_qconfig_mapping object_type_qconfigs prepare_qconfig_mapping module_name_qconfigs prepare_qconfig_mapping module_name_regex_qconfigs convert_dicts list OrderedDict = convert_qconfig_mapping object_type_qconfigs convert_qconfig_mapping module_name_qconfigs convert_qconfig_mapping module_name_regex_qconfigs dict_names = _OBJECT_TYPE_DICT_KEY _MODULE_NAME_DICT_KEY _MODULE_NAME_REGEX_DICT_KEY i range len prepare_dicts name prepare_dicts i keys name convert_dicts i raise AssertionError f Missing key dict_names i name convert QConfigMapping when present prepare convert_dicts i name None qconfig_equals prepare_dicts i name convert_dicts i name raise AssertionError Expected convert QConfigMapping have same qconfig prepare key f dict_names i name prepare prepare_dicts i name convert convert_dicts i name _is_qconfig_supported_by_dtype_configs qconfig QConfig dtype_configs list DTypeConfig dtype_config dtype_configs is_dynamic = dtype_config is_dynamic is_dynamic None is_dynamic = False input_dtype = dtype_config input_dtype torch float weight_dtype = dtype_config weight_dtype torch float bias_dtype = dtype_config bias_dtype torch float output_dtype = dtype_config output_dtype torch float qconfig_activation_dtype qconfig_weight_dtype qconfig_input_act_is_dynamic = get_qconfig_dtypes qconfig qconfig_bias_dtype = torch float qconfig_activation_dtype == torch float qconfig_weight_dtype == torch float is_dynamic torch float is_dynamic is_match = qconfig_input_act_is_dynamic input_dtype == qconfig_activation_dtype output_dtype == torch float weight_dtype == qconfig_weight_dtype is_match = input_dtype == qconfig_activation_dtype output_dtype == qconfig_activation_dtype weight_dtype == qconfig_weight_dtype bias_dtype == qconfig_bias_dtype is_match True False _get_object_type_qconfig qconfig_mapping QConfigMapping object_type Union Callable str fallback_qconfig QConfigAny - QConfigAny qconfig_mapping object_type_qconfigs get object_type fallback_qconfig _get_module_name_regex_qconfig qconfig_mapping module_name fallback_qconfig regex_pattern qconfig qconfig_mapping module_name_regex_qconfigs items re match regex_pattern module_name first match wins qconfig fallback_qconfig _get_module_name_qconfig qconfig_mapping module_name fallback_qconfig module_name == module name qconfig found fallback_qconfig module_name qconfig_mapping module_name_qconfigs qconfig_mapping module_name_qconfigs module_name parent _ = _parent_name module_name _get_module_name_qconfig qconfig_mapping parent fallback_qconfig _maybe_adjust_qconfig_for_module_type_or_name qconfig_mapping module_type module_name global_qconfig get qconfig module_name fallback module_name_regex_qconfig module_type_qconfig global_qconfig necessary module_type_qconfig = _get_object_type_qconfig qconfig_mapping module_type global_qconfig module_name_regex_qconfig = _get_module_name_regex_qconfig qconfig_mapping module_name module_type_qconfig module_name_qconfig = _get_module_name_qconfig qconfig_mapping module_name module_name_regex_qconfig module_name_qconfig _get_flattened_qconfig_dict qconfig_mapping QConfigMapping - dict Union Callable str QConfigAny flatten global object_type module_name qconfig same qconfig_dict so can used propagate_qconfig_ function module_name_regex ignored now since s supported propagate_qconfig_ can fixed later For example Input qconfig object_type torch add qconfig module_name conv qconfig Output qconfig torch add qconfig conv qconfig flattened dict Union Callable str QConfigAny = qconfig_mapping global_qconfig flattened update qconfig_mapping object_type_qconfigs flattened update qconfig_mapping module_name_qconfigs type ignore arg-type flattened _update_qconfig_for_qat qconfig_mapping QConfigMapping backend_config BackendConfig Update qconfig_mapping account module swaps during QAT During QAT we perform module swap nn Module types corresponding nn qat modules types module_to_qat_module_class = get_module_to_qat_module backend_config object_type_dict = qconfig_mapping object_type_qconfigs new_object_type_dict = object_type_dict copy k v new_object_type_dict items k module_to_qat_module_class object_type_dict module_to_qat_module_class k = v