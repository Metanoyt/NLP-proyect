copy collections OrderedDict typing cast TypedDict numpy np torch torch distributed _tools mem_tracker _MemRefType _ModMemStats _ModState MemTracker torch distributed _tools runtime_estimator RuntimeEstimator torch distributed _tools sac_estimator SACEstimator SACTradeOffStats ModOrder TypedDict fw_pre_order list str bw_pre_order list str fw_post_order list str bw_post_order list str ModRuntime TypedDict fw float bw float ModStats TypedDict fqn str per-module params param_per_module int per-module grads grad_per_module int total accumulated gradients up including module grad_total int per module fw activation size excluding input output act_fw_per_module int per module bw activation size during peak_bw act_bw_per_module int per module activation grad size during peak_bw act_grad_per_module int total activation size up excluding current module includes input current module i e output previous module act_total int Inputs module input_per_module int Outputs module output_per_module int Total fw run-time module fw_runtime_per_module float Total bw run-time module bw_runtime_per_module float Is module leaf module is_leaf bool Total ac run-time module sac_runtime float Total ac_memory module sac_memory int Number piecewise-linear functions used approximating ac tradeoff curve n_segments int Slopes piecewise-linear functions slopes list float Intercepts piecewise-linear functions intercepts list float X breakpoints piecewise-linear functions breakpoints list float Original trade-off curves tradeoff_curve OrderedDict float float ModuleInfo TypedDict mod_order ModOrder mod_stats list ModStats aggregate_stats model torch nn Module mem_tracker MemTracker runtime_estimator RuntimeEstimator sac_estimator SACEstimator dev torch device - ModuleInfo Collect modulewise stats given model including memory runtime AC tradeoff stats Args model nn Module object runtime_estimator RuntimeEstimator object runtime stats mem_tracker MemTracker object memory stats sac_estimator SACEstimator object AC tradeoff stats dev device model run used extract memory stats MemTracker Returns ModuleInfo A dictionary module order module stats Memory stats mod_mem_stats dict torch nn Module _ModMemStats = dict copy deepcopy mem_tracker memory_tracking Runtime stats mod_runtime_stats dict str ModRuntime = fqn fw v fw bw v bw fqn v runtime_estimator mod_runtimes items Module order mod_order ModOrder = fw_pre_order list runtime_estimator mod_fw_pre_order bw_pre_order list runtime_estimator mod_bw_pre_order fw_post_order list runtime_estimator mod_fw_post_order bw_post_order list runtime_estimator mod_bw_post_order Selective Activation Checkpointing stats sac_estimator pwlf_sac_tradeoff_curve mod_sac_tradeoff_stats dict str SACTradeOffStats = copy deepcopy sac_estimator sac_mod_tradeoff_stats module_info ModuleInfo = mod_order mod_order mod_stats mod model modules mod_mem_stat = mod_mem_stats get mod tradeoff_stats = mod_sac_tradeoff_stats get mod_mem_stat mod_fqn None sac_runtime = tradeoff_stats sac_runtime sac_memory = tradeoff_stats sac_memory n_segments = tradeoff_stats n_segments slopes = tradeoff_stats slopes intercepts = tradeoff_stats intercepts breakpoints = tradeoff_stats fit_breaks tradeoff_curve = tradeoff_stats tradeoff_curve is_leaf = False sac_runtime = sac_memory = n_segments = slopes = intercepts = breakpoints = tradeoff_curve OrderedDict float float = OrderedDict type ignore no-redef is_leaf = True mod_stat ModStats = fqn mod_mem_stat mod_fqn param_per_module mod_mem_stat parameter_mem grad_per_module mod_mem_stat parameter_mem grad_total mod_mem_stat snapshots _ModState PRE_BW - dev _MemRefType GRAD act_fw_per_module max mod_mem_stat snapshots _ModState POST_FW - dev _MemRefType ACT - mod_mem_stat snapshots _ModState PRE_FW - dev _MemRefType ACT - mod_mem_stat output_mem act_bw_per_module max mod_mem_stat snapshots _ModState PEAK_BW - dev _MemRefType ACT act_grad_per_module mod_mem_stat snapshots _ModState PEAK_BW - dev _MemRefType TEMP - mod_mem_stat snapshots _ModState PRE_BW - dev _MemRefType TEMP act_total mod_mem_stat snapshots _ModState POST_FW - dev _MemRefType ACT input_per_module mod_mem_stat input_mem output_per_module mod_mem_stat output_mem fw_runtime_per_module mod_runtime_stats mod_mem_stat mod_fqn fw bw_runtime_per_module mod_runtime_stats mod_mem_stat mod_fqn bw is_leaf is_leaf sac_runtime sac_runtime sac_memory sac_memory n_segments n_segments slopes slopes intercepts intercepts breakpoints breakpoints tradeoff_curve tradeoff_curve module_info mod_stats append mod_stat module_info Node ModStats index int index according forward pre-order pos_fw_post_order int index according forward post-order Graph __init__ n int - None nodes list Node = name node dict str Node = ad_matrix = np zeros n n fw_post_order list str = add_node node Node - None nodes append node name node node fqn = node parse_module_info module_info ModuleInfo - Graph Parse module info create graph tree modules The graph will used MILP solver find optimal SAC FSDP configurations mod_stats = module_info mod_stats fw_pre_order = module_info mod_order fw_pre_order assertion number nodes assert len mod_stats == len fw_pre_order n_nodes = len mod_stats create graph g = Graph n_nodes g fw_post_order = module_info mod_order fw_post_order sort modules pre-order add them graph module_info mod_stats = sorted mod_stats key=lambda x fw_pre_order index x fqn i one_mod_stats enumerate mod_stats node Node = cast Node one_mod_stats node index = i node pos_fw_post_order = g fw_post_order index node fqn g add_node node set up ancestor-descendant matrix i range n_nodes j range i n_nodes is_self_or_submodule g nodes j fqn g nodes i fqn g ad_matrix i j = break g is_self_or_submodule name_descendant str name_ancestor str - bool check name_descendant submodule name_ancestor they same name_descendant == name_ancestor name_ancestor + name_descendant is_submodule name_descendant str name_ancestor str - bool name_descendant submodule name_ancestor same name_ancestor + name_descendant display_bytes b int unit str = MiB - str string represent number bytes desired unit unit == KiB f b f KiB unit == MiB f b f MiB unit == GiB f b f GiB f b f bytes get_peak_memory_runtime_baseline graph Graph - tuple int float Get baseline peak memory runtime Baseline here means there no FSDP AC Memory includes parameters gradients activations activation gradients Memory does include e g optimizer states embedding tables etc Returns int peak memory bytes float compute time ms P_ = graph nodes param_per_module num_nodes = len graph nodes peak_mem = i range num_nodes TG_i = graph nodes i grad_total AG_i = graph nodes i act_grad_per_module TA_i = graph nodes i act_total peak_mem = max peak_mem P_ + TG_i + AG_i + TA_i compute_time = graph nodes fw_runtime_per_module + graph nodes bw_runtime_per_module peak_mem compute_time