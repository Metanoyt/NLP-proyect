utils GetterReturnType torch torch distributions dist torch Tensor get_simple_regression device torch device - GetterReturnType N = K = loc_beta = scale_beta = beta_prior = dist Normal loc_beta scale_beta X = torch rand N K + device=device Y = torch rand N device=device X shape N K + Y shape N beta_value shape K + beta_value = beta_prior sample K + beta_value requires_grad_ True forward beta_value Tensor - Tensor mu = X mm beta_value We need compute first second gradient score respect beta_value We disable Bernoulli validation because Y relaxed value score = dist Bernoulli logits=mu validate_args=False log_prob Y sum + beta_prior log_prob beta_value sum score forward beta_value device get_robust_regression device torch device - GetterReturnType N = K = X shape N K + Y shape N X = torch rand N K + device=device Y = torch rand N device=device Predefined nu_alpha nu_beta nu_alpha shape nu_beta shape nu_alpha = torch rand device=device nu_beta = torch rand device=device nu = dist Gamma nu_alpha nu_beta Predefined sigma_rate sigma_rate shape N sigma_rate = torch rand N device=device sigma = dist Exponential sigma_rate Predefined beta_mean beta_sigma beta_mean shape K + beta_sigma shape K + beta_mean = torch rand K + device=device beta_sigma = torch rand K + device=device beta = dist Normal beta_mean beta_sigma nu_value = nu sample nu_value requires_grad_ True sigma_value = sigma sample sigma_unconstrained_value = sigma_value log sigma_unconstrained_value requires_grad_ True beta_value = beta sample beta_value requires_grad_ True forward nu_value Tensor sigma_unconstrained_value Tensor beta_value Tensor - Tensor sigma_constrained_value = sigma_unconstrained_value exp mu = X mm beta_value For model we need compute following three scores We need compute first second gradient score respect nu_value nu_score = dist StudentT nu_value mu sigma_constrained_value log_prob Y sum + nu log_prob nu_value We need compute first second gradient score respect sigma_unconstrained_value sigma_score = dist StudentT nu_value mu sigma_constrained_value log_prob Y sum + sigma log_prob sigma_constrained_value + sigma_unconstrained_value We need compute first second gradient score respect beta_value beta_score = dist StudentT nu_value mu sigma_constrained_value log_prob Y sum + beta log_prob beta_value nu_score sum + sigma_score sum + beta_score sum forward nu_value device sigma_unconstrained_value device beta_value device