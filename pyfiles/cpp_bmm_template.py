mypy allow-untyped-defs contextlib itertools typing Any Callable Optional unittest mock patch sympy ir select_algorithm PartialRender virtualized V common ArgName cpp_gemm_template CppGemmTemplate GEMM_TEMPLATE cpp_micro_gemm LayoutType cpp_template_kernel CppTemplateKernel cpp_utils DTYPE_TO_CPP GemmBlocking We pass all sizevars present BY GEMM templates so variables renamed BMM definition GEMM_SINGLE_THREAD_MM_STUB = r kernel def_kernel inputs= X X W W outputs= Y Y_ d aliases=aliases function_name=kernel_name+ _single_thread_mm extra_sizevars=BY_sizevars + b_index placeholder= SINGLE_THREAD_MM_DEF_FOR_BMM GEMM_THREADED_MM_STUB = r kernel def_kernel inputs= X X W W outputs= Y Y_ d aliases=aliases function_name=kernel_name+ _threaded_mm extra_sizevars=BY_sizevars + b_index placeholder= THREADED_MM_DEF_FOR_BMM BMM_TEMPLATE = r template codegen_microkernel_def template codegen_single_thread_gemm template codegen_multi_thread_gemm extern C kernel def_kernel inputs= X BX W BW outputs= Y BY aliases=aliases const int _t B = kernel size BY_ d - num_threads constexpr int _t num_threads = num_threads int _t B_single_thread_block = B num_threads num_threads #pragma omp parallel num_threads num_threads - int _t B_single_thread_block = B - endif int _t b_start = b_start B_single_thread_block ++b_start template get_gemm_function_call kernel kernel_name+ _single_thread_mm SINGLE_THREAD_CALL_FOR_BMM b_index= b_start int _t b_start = B_single_thread_block b_start B ++b_start template get_gemm_function_call kernel kernel_name+ _threaded_mm THREADED_MM_CALL_FOR_BMM b_index= b_start CppBmmTemplate CppGemmTemplate __init__ input_nodes layout ir Layout num_threads int register_blocking GemmBlocking beta= alpha= has_bias=False epilogue_creator Optional Callable ir Buffer ir Pointwise = None should_block_weights bool = False name= bmm In order simplify implementation increase code reuse BMM template implements two versions GEMM kernel single-threaded version multi-threaded version GEMM kernels called loop over batch dimension single-threaded GEMM calls all last B num_threads which handled multi-threaded GEMM kernel We use extra sizevar ` b_index ` index batch dimension which we pass into GEMM template sympy Symbol This allows us slice D batch tensors GEMM template without any changes GEMM template itself super __init__ input_nodes layout num_threads register_blocking beta=beta alpha=alpha has_bias=has_bias epilogue_creator=epilogue_creator should_block_weights=should_block_weights name=name b_index = sympy Symbol s_b_index integer=True nonnegative=True staticmethod get_padded_size n block_n k should_block_weight should_block_weight Tensor constant contiguous so we will pad block new_size padded_n = CppGemmTemplate get_padded_size n block_n k should_block_weight Add new batch dimension new_size insert - new_size padded_n new_size = - k n new_size n staticmethod check_if_block_weight W micro_gemm assert isinstance W ir IRNode _ n = W get_size - result = W get_layout is_contiguous W get_name V graph constants n micro_gemm register_blocking block_n = micro_gemm get_b_layout = LayoutType NORMAL result get_gemm_function_call kernel CppTemplateKernel function_name str placeholder str b_index str - str Similar def_kernel cpp_template_kernel instead generating function definition generate function call GEMM kernel Args placeholder The string replace function call b_index The index slicing D batch tensors hook arg_defs call_args _ _ = kernel args python_argdefs i buf enumerate call_args buf == b_index arg_defs i = ArgName b_index call = f function_name join x full_name x arg_defs call assert placeholder kernel render_hooks kernel render_hooks placeholder = hook placeholder get_default_reindexers epilogue_nodes reindexer args epilogue nodes exist they have D ranges args D so add index b_index + args reindexer len epilogue_nodes get_options kernel CppTemplateKernel template_buffer_node Optional ir CppTemplateBuffer = None flag_template_buffer_has_other_users Optional bool = None epilogue_nodes Optional list ir IRNode = None kwargs - dict str Any options = super get_options kernel=kernel template_buffer_node=template_buffer_node flag_template_buffer_has_other_users=flag_template_buffer_has_other_users epilogue_nodes=epilogue_nodes kwargs BX BW BY = options X options W options Y options BX options BW options BY = BX BW BY options BY_ d = options Y_ d kword X W GemmOut Y_ d options kword = kernel select options kword b_index kword X W Y_ d options kword + _dtype = DTYPE_TO_CPP options kword dtype options b_index = b_index options BY_sizevars = s sym itertools chain BY get_size BY get_stride isinstance sym sympy Expr s sym free_symbols options kernel_name = kernel kernel_name options render type ignore override kernel CppTemplateKernel template_buffer_node Optional ir CppTemplateBuffer = None flag_template_buffer_has_other_users Optional bool = None epilogue_nodes Optional list ir IRNode = None kwargs - str options = get_options kernel=kernel template_buffer_node=template_buffer_node flag_template_buffer_has_other_users=flag_template_buffer_has_other_users epilogue_nodes=epilogue_nodes kwargs render_options = options contextlib ExitStack stack buf options fake_buffers stack enter_context patch object V graph get_dtype _fake_get_dtype buf result = _template_from_string BMM_TEMPLATE render options Finalize function definitions gemm routines sub_mm_hooks = name hook name hook kernel render_hooks items FOR_BMM name result = PartialRender result sub_mm_hooks finalize_all name sub_mm_hooks del kernel render_hooks name del kernel args sizevars options b_index result codegen_single_thread_gemm stub = _template_from_string GEMM_SINGLE_THREAD_MM_STUB render render_options stub + _template_from_string GEMM_TEMPLATE render render_options num_threads codegen_multi_thread_gemm stub = _template_from_string GEMM_THREADED_MM_STUB render render_options stub + _template_from_string GEMM_TEMPLATE render render_options codegen_gemm_stub_def