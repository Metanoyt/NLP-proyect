mypy allow-untyped-defs ast copy dataclasses inspect re string collections namedtuple textwrap dedent torch torch jit annotations torch _jit_internal torch _C _jit_tree_views Apply Assert Assign Attribute AugAssign BinOp Break ClassDef Const Continue Decl Def Delete DictComp DictLiteral Dots EmptyTypeAnnotation ExprStmt FalseLiteral For Ident If ListComp ListLiteral NoneLiteral Param Pass Property Raise Return Select SliceExpr Starred Stmt StringLiteral Subscript TernaryIf TrueLiteral TupleLiteral UnaryOp Var While With WithItem torch _jit_internal noqa F _is_drop_fn FunctionModifiers is_static_fn should_drop torch _sources get_source_lines_and_file make_source_context parse_def ParsedDef _ParsedDef torch jit _dataclass_impls DATACLASS_MAGIC_METHODS torch jit _monkeytype_config get_qualified_name monkeytype_trace Borrowed cPython implementation https github com python cpython blob d cfab c b b bd b Lib textwrap py#L _reserved_prefix = __jit _reserved_names = print _identifier_chars = set string ascii_lowercase + string ascii_uppercase + string digits is_reserved_name name name startswith _reserved_prefix name _reserved_names pretty_node_names = ast FunctionDef function definitions ast For loops ast Delete del statements ast ClassDef definitions ast With statements ast Raise raise statements ast Assert assertions ast Import statements ast ImportFrom statements ast Global global variables ast Break break statements ast Continue continue statements node_start_tokens = ast FunctionDef ast For ast Delete del ast ClassDef ast With ast Raise raise ast Assert assert ast Import ast ImportFrom ast Global global ast Break break ast Continue continue pyrefly ignore no-matching-overload pretty_node_names update ast AsyncFunctionDef async function definitions ast AsyncFor async loops ast AsyncWith async statements ast Try try blocks ast Nonlocal nonlocal variables pyrefly ignore no-matching-overload node_start_tokens update ast AsyncFunctionDef async ast AsyncFor async ast AsyncWith async ast Try try ast Nonlocal nonlocal pyrefly ignore no-matching-overload pretty_node_names update ast AnnAssign annotated assignments NB no specific token AnnAssign FrontendError Exception __init__ source_range msg source_range = source_range msg = msg This has instantiated here so ErrorReport accurate call stack when FrontendError raised error_report = torch _C ErrorReport source_range __str__ msg + error_report what lstrip NotSupportedError FrontendError pass UnsupportedNodeError NotSupportedError __init__ ctx offending_node reason= If we don t have specific token we default length node_type = type offending_node range_len = len node_start_tokens get node_type source_range = ctx make_range offending_node lineno offending_node col_offset offending_node col_offset + range_len feature_name = pretty_node_names get node_type node_type __name__ msg = f feature_name reason + reason aren t supported super __init__ source_range msg FrontendTypeError FrontendError pass build_withitems ctx items items = build_withitem ctx i i items list items build_stmts ctx stmts stmts = build_stmt ctx s s stmts list filter None stmts get_class_properties cls self_name Get list Property objects representing properties Args cls The get properties self_name The name properties should belong Returns A list Property objects corresponding properties cls Property here refers subclass TreeView props = inspect getmembers cls predicate=lambda m isinstance m property Any property should compiled must list Module unused_properties = getattr cls __jit_unused_properties__ Create Property TreeView objects inspected property objects properties = prop props prop unused_properties should_drop prop fget getter = get_jit_def prop fget f __ prop _getter self_name=self_name setter = get_jit_def prop fset f __ prop _setter self_name=self_name prop fset None properties append Property getter range Ident getter range prop getter setter properties get_class_assigns ctx cls_ast assigns = maybe_build_assign builder entry nonlocal assigns try assigns append builder ctx entry except NotSupportedError pass entry cls_ast body isinstance entry ast Assign maybe_build_assign StmtBuilder build_Assign entry isinstance entry ast AnnAssign maybe_build_assign StmtBuilder build_AnnAssign entry assigns get_jit_class_def cls self_name Get definitions each method within current independently Args cls The get definition self_name The name properties should belong Returns torch _C _jit_tree_views ClassDef A representation methods their definition tree TODO proper overriding analysis when implementing inheritance methods = inspect getmembers cls predicate=lambda m inspect ismethod m inspect isfunction m is_static_fn cls m __name__ m __name__ cls __dict__ _is_drop_fn m is_classmethod fn inspect ismethod fn getattr fn __self__ None == cls Get parse source code sourcelines file_lineno filename = get_source_lines_and_file cls torch _C ErrorReport call_stack source = join sourcelines dedent_src = dedent source py_ast = ast parse dedent_src class_ast = py_ast body assert isinstance class_ast ast ClassDef Special case dataclasses In general we need access source code object order JIT compile But dataclasses module dynamically synthesizes magic methods classes we can t get source code these methods As workaround we synthesize TorchScript-friendly implementations ourselves dataclasses is_dataclass cls Detect whether user manually implemented any magic methods If they did we don t want synthesize override them overrides = method name method class_ast body isinstance method ast FunctionDef method name DATACLASS_MAGIC_METHODS i name _ enumerate methods Is magic method we can synthesize synthesizer_fn = DATACLASS_MAGIC_METHODS get name synthesizer_fn name overrides parsed_def = synthesizer_fn cls methods i = name parsed_def func = getattr cls name _jit_internal loader cache func parsed_def source method_defs = get_jit_def obj name self_name=self_name is_classmethod=is_classmethod obj name obj methods properties = get_class_properties cls self_name leading_whitespace_len = len source split \n - len dedent_src split \n ctx = make_source_context source filename file_lineno leading_whitespace_len False assigns = get_class_assigns ctx class_ast build_class_def ctx class_ast method_defs properties self_name assigns get_jit_def fn def_name self_name=None is_classmethod=False Build JIT AST TreeView given function Args fn A function object compile pre-parsed ParsedDef object def_name The name give resulting AST object This always same ` fn __name__ ` example _forward forward = _forward In case ` __name__ ` attribute function object _forward we want result AST have name forward self_name If function method what type name ` ` parsed_def = parse_def fn isinstance fn _ParsedDef fn type_line = torch jit annotations get_type_line parsed_def source fn_def = parsed_def ast body is_classmethod arg_name = fn_def args args arg type ignore union-attr Insert statement assigns first argument assign_stmt = ast parse f arg_name = self_name body fn_def body insert assign_stmt type ignore union-attr Swap out function signature body unused should_drop fn unused_fn_def = ast parse unused_fn Any \n\traise RuntimeError Cannot call unused methods len unused_fn_def body = isinstance unused_fn_def body ast FunctionDef raise RuntimeError f Expected single top-level function parsed_def filename parsed_def file_lineno unused_def = unused_fn_def body fn_def body = unused_def body type ignore union-attr kwarg vararg supported ` build_def ` fn_def args kwarg = fn_def args vararg = None type ignore union-attr arg fn_def args args + fn_def args kwonlyargs type ignore union-attr Replace potentially unsupported type annotations Any arg annotation = unused_def args args annotation _is_drop_fn fn Dropping potentially unsupported type annotation jit _drop fn_def returns = None type ignore union-attr fn_def type_comment = None type ignore union-attr If MonkeyType installed get all consolidated type traces arguments type_trace_db type_trace_db = torch jit _script _get_type_trace_db pdt_arg_types = None monkeytype_trace isinstance fn _ParsedDef type ignore truthy-function qualname = get_qualified_name fn pdt_arg_types = type_trace_db get_args_types qualname build_def parsed_def ctx fn_def type_line def_name self_name=self_name pdt_arg_types=pdt_arg_types TODO more robust handling recognizing ignore context manager is_torch_jit_ignore_context_manager stmt checks statement torch jit ignore context manager isinstance stmt items context_expr ast Call extract torch part function = stmt items context_expr func isinstance function ast Attribute attr_name = function attr attr_value = function value attr_name == _IgnoreContextManager isinstance attr_value ast Attribute there should most two nested attributes e g torch jit _IgnoreContextManager attr_value attr == jit isinstance attr_value value ast Name attr_value value id == torch True False Builder __call__ ctx node method = getattr build_ + node __class__ __name__ None method None raise UnsupportedNodeError ctx node method ctx node build_class_def ctx py_def methods properties self_name assigns r = ctx make_range py_def lineno py_def col_offset py_def col_offset + len ClassDef Ident r self_name Stmt method method methods properties assigns build_def ctx py_def type_line def_name self_name=None pdt_arg_types=None body = py_def body r = ctx make_range py_def lineno py_def col_offset py_def col_offset + len param_list = build_param_list ctx py_def args self_name pdt_arg_types return_type = None getattr py_def returns None None return_type = build_expr ctx py_def returns decl = Decl r param_list return_type is_method = self_name None type_line None type_comment_decl = torch _C parse_type_comment type_line decl = torch _C merge_type_from_type_comment decl type ignore arg-type type_comment_decl is_method type ignore assignment Def Ident r def_name decl build_stmts ctx body _vararg_kwarg_err = Compiled functions can t take variable number arguments use keyword-only arguments defaults build_param_list ctx py_args self_name pdt_arg_types=None py_args kwarg None expr = py_args kwarg ctx_range = ctx make_range expr lineno expr col_offset - expr col_offset + len expr arg raise NotSupportedError ctx_range _vararg_kwarg_err py_args vararg None expr = py_args vararg ctx_range = ctx make_range expr lineno expr col_offset - expr col_offset + len expr arg raise NotSupportedError ctx_range _vararg_kwarg_err len py_args kw_defaults kw_defaults list values kwargs which default None so they don t actually have line numbers arg py_args kw_defaults arg None ctx_range = build_expr ctx arg range raise NotSupportedError ctx_range _vararg_kwarg_err List Tuple args type inferred profile directed typing arg_and_types = arg pdt_arg_types arg arg pdt_arg_types bool pdt_arg_types arg arg None arg py_args args arg_and_types_kwonlyargs = arg pdt_arg_types arg arg pdt_arg_types bool pdt_arg_types arg arg None arg py_args kwonlyargs result = build_param ctx arg self_name kwarg_only=False pdt_arg_type=arg_type arg arg_type arg_and_types result += build_param ctx arg self_name kwarg_only=True pdt_arg_type=arg_type arg arg_type arg_and_types_kwonlyargs result build_param ctx py_arg self_name kwarg_only pdt_arg_type=None NB In Python py_arg pair str arg expr annotation name = py_arg arg r = ctx make_range py_arg lineno py_arg col_offset py_arg col_offset + len name getattr py_arg annotation None None annotation_expr = build_expr ctx py_arg annotation pdt_arg_type annotation_expr = Var Ident r pdt_arg_type self_name None name == annotation_expr = Var Ident r self_name annotation_expr = EmptyTypeAnnotation r Param annotation_expr Ident r name kwarg_only build_ignore_context_manager ctx stmt InputType = namedtuple InputType name ann OutputType = namedtuple OutputType name ann process_ins_outs args parse context manager figure out inputs outputs their annotated types TODO add input output validator inputs = outputs = arg args var_name = arg arg var_ann = arg value value var_decl_type var_ann = var_ann split var_decl_type == inp inputs append InputType var_name var_ann var_decl_type == out outputs append OutputType var_name var_ann inputs outputs create_unique_name_ext ctx stmt extension will based full path filename plus line number original context manager fn = re sub r ^a-zA-Z - _ _ ctx filename f fn _ stmt lineno build_return_ann_stmt outputs return_type_ann = return_statement_str = len outputs == return_type_ann += - None len outputs == return_type_ann = - + outputs ann return_statement_str += outputs name len outputs return_type_ann = - tuple return_type_ann += + join var ann var outputs + return_statement_str += join var name var outputs return_type_ann return_statement_str build_args args join arg name arg args inputs outputs = process_ins_outs stmt items context_expr keywords build replacement function str given inputs outputs ignore_function_name = func_ignore_ + create_unique_name_ext ctx stmt ignore_function_str = \ndef + ignore_function_name ignore_function_str += + join var name + + var ann var inputs + return_ann return_stmt = build_return_ann_stmt outputs ignore_function_str += return_ann + pass first create functionDef object just declaration ignore_function = ast parse ignore_function_str body dump body context manager dummy function ignore_function body = stmt body type ignore attr-defined insert statement function return_stmt = ast parse return_stmt body ignore_function body append return_stmt type ignore attr-defined ignore_func_str = f \ Backward compat These used imported into outer global scope so some code may still expect them typing List Dict Tuple torch jit ignore ast unparse ignore_function g = copy copy globals exec ignore_func_str g noqa P registers custom function global context globals ignore_function_name = g ignore_function_name build statements out_ out_ = torch jit frontend func in_ in_ assign_str_lhs = build_args outputs function will registered torch jit frontend module default assign_str_rhs = f torch jit frontend ignore_function_name + build_args inputs + len outputs assign_str = assign_str_lhs + = + assign_str_rhs assign_str = assign_str_rhs assign_ast = ast parse assign_str body assign_ast get_default_args fn Get dictionary default arguments function Args fn Callable - The function inspect default arguments Returns Dict str Any mapping argument names their default values attr ` fn ` None empty dictionary fn None signature = inspect signature fn k v default k v signature parameters items v default inspect Parameter empty get_default_args_for_class cls Get default arguments all methods except static methods Args cls type - The type inspect default arguments Returns A Dict str Dict str Any which maps each method name Dict str Any maps each argument name its default value Get methods except static methods because those compiled separately they independent script functions methods = inspect getmembers cls predicate=lambda m inspect ismethod m inspect isfunction m is_static_fn cls m __name__ m __name__ cls __dict__ Get method defaults Property defaults do need considered because setters cannot invoked without value defaults = method_name get_default_args method_impl method_name method_impl methods defaults WithItemBuilder Builder staticmethod build_withitem ctx item lineno = item context_expr lineno start = item context_expr col_offset end = start + len pretty_node_names ast With op_vars = item optional_vars r = ctx make_range lineno start end WithItem r build_expr ctx item context_expr build_expr ctx op_vars op_vars None StmtBuilder Builder augassign_map = ast Add + ast Sub - ast Mult ast Div ast Mod ast BitOr &#124; ast BitAnd ast BitXor ^ ast LShift ast RShift ast Pow staticmethod build_Expr ctx stmt value = stmt value value __class__ __name__ == Str If statement string literal expression then docstring Just ignore None ExprStmt build_expr ctx value staticmethod build_Assign ctx stmt rhs = build_expr ctx stmt value lhs = build_expr ctx x x stmt targets Assign lhs rhs staticmethod build_AnnAssign ctx stmt stmt value None raise UnsupportedNodeError ctx stmt reason= without assigned value Disallow type annotations instance attributes outside __init__ type stmt target ast Attribute stmt target value id == type ignore attr-defined ctx funcname = __init__ start = stmt col_offset end = start + len f stmt target attr hasattr stmt annotation id end += len f stmt annotation id sr = ctx make_range stmt lineno start end raise ValueError Type annotations instance attributes must declared f __init__ ctx funcname sr rhs = build_expr ctx stmt value lhs = build_expr ctx stmt target the_type = build_expr ctx stmt annotation Assign lhs rhs the_type staticmethod build_Delete ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len del Delete r build_expr ctx target target stmt targets staticmethod build_Return ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len Return r None stmt value None build_expr ctx stmt value staticmethod build_Raise ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len raise expr = build_expr ctx stmt exc Raise r expr staticmethod build_Assert ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len assert test = build_expr ctx stmt test msg = build_expr ctx stmt msg stmt msg None None Assert r test msg staticmethod build_AugAssign ctx stmt lhs = build_expr ctx stmt target rhs = build_expr ctx stmt value op = type stmt op op StmtBuilder augassign_map op_token = StmtBuilder augassign_map op raise NotSupportedError find_before ctx rhs range start = offsets= - unsupported kind augmented assignment + op __name__ AugAssign lhs op_token rhs staticmethod build_While ctx stmt stmt orelse TODO try recover location Python doesn t give us useful annotations case raise NotSupportedError None branches while loops aren t supported r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len while While r build_expr ctx stmt test build_stmts ctx stmt body staticmethod build_For ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len stmt orelse raise NotSupportedError r branches loops aren t supported For r build_expr ctx stmt target build_expr ctx stmt iter build_stmts ctx stmt body staticmethod build_If ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len If r build_expr ctx stmt test build_stmts ctx stmt body build_stmts ctx stmt orelse staticmethod build_Print ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len print stmt dest raise NotSupportedError r print statements non-default destinations aren t supported args = build_expr ctx val val stmt values ExprStmt Apply Var Ident r print args staticmethod build_Pass ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len pass Pass r staticmethod build_Break ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len break Break r staticmethod build_Continue ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len continue Continue r staticmethod build_With ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset + len Handle ignore context manager is_torch_jit_ignore_context_manager stmt assign_ast = build_ignore_context_manager ctx stmt build_stmt ctx assign_ast With r build_withitems ctx stmt items build_stmts ctx stmt body ExprBuilder Builder binop_map = ast Add + ast Sub - ast Mult ast Div ast Pow ast Mod ast FloorDiv ast BitAnd ast BitXor ^ ast BitOr &#124; ast LShift ast RShift pyrefly ignore unsupported-operation binop_map ast MatMult = unop_map = ast Not ast USub - ast Invert ~ boolop_map = ast And ast Or cmpop_map = ast Eq == ast NotEq = ast LtE = ast Lt ast GtE = ast Gt ast Is ast IsNot ast In ast NotIn staticmethod build_Attribute ctx expr base = build_expr ctx expr value expr attr just string so s annotated any way so we have build range manually source = ctx source encode utf- get_char index chr source index start_pos = base range end + while get_char start_pos string whitespace Skip whitespace start_pos += end_pos = start_pos + len expr attr name_range = ctx make_raw_range start_pos end_pos Select base Ident name_range expr attr staticmethod build_Call ctx expr func = build_expr ctx expr func args = build_expr ctx py_arg py_arg expr args hasattr expr starargs expr starargs stararg_expr = build_expr ctx expr starargs args += Starred stararg_expr range stararg_expr kwargs = kw expr keywords kw_expr = build_expr ctx kw value XXX we could do better job figuring out range name here kw arg raise NotSupportedError kw_expr range keyword-arg expansion supported kwargs append Attribute Ident kw_expr range kw arg kw_expr Apply func args kwargs staticmethod build_Ellipsis ctx expr r = ctx make_range expr lineno expr col_offset expr col_offset + len == Dots r staticmethod build_Name ctx expr r = ctx make_range expr lineno expr col_offset expr col_offset + len expr id expr id startswith _reserved_prefix raise NotSupportedError r names variables used JIT-ed functions can t start + _reserved_prefix expr id == True TrueLiteral r expr id == False FalseLiteral r expr id == None NoneLiteral r expr id == Ellipsis Dots r Var Ident r expr id staticmethod build_NameConstant ctx expr r = ctx make_range expr lineno expr col_offset expr col_offset + len str expr value expr value True TrueLiteral r expr value False FalseLiteral r expr value None NoneLiteral r expr value == Ellipsis Dots r raise ValueError Name constant value unsupported + str expr value staticmethod build_BinOp ctx expr lhs = build_expr ctx expr left rhs = build_expr ctx expr right op = type expr op op == ast Div ctx uses_true_division err_range = ctx make_raw_range lhs range end rhs range start raise FrontendError err_range Division ints TorchScript uses Python true division semantics Please put ` __future__ division ` top your file op_token = ExprBuilder binop_map get op op_token None err_range = ctx make_raw_range lhs range end rhs range start raise NotSupportedError err_range unsupported binary operator + op __name__ BinOp op_token lhs rhs staticmethod build_UnaryOp ctx expr sub_expr = build_expr ctx expr operand op = type expr op op_token = ExprBuilder unop_map get op op_token None raise NotSupportedError expr range unsupported unary operator + op __name__ r = ctx make_range expr lineno expr col_offset expr col_offset + len op_token UnaryOp r op_token sub_expr staticmethod build_BoolOp ctx expr len expr values raise AssertionError expected least values BoolOp got + str len expr values sub_exprs = build_expr ctx sub_expr sub_expr expr values op = type expr op op_token = ExprBuilder boolop_map get op op_token None err_range = ctx make_raw_range sub_exprs range end sub_exprs range start raise NotSupportedError err_range unsupported boolean operator + op __name__ lhs = sub_exprs rhs sub_exprs lhs = BinOp op_token lhs rhs lhs staticmethod build_IfExp ctx expr TernaryIf build_expr ctx expr test build_expr ctx expr body build_expr ctx expr orelse staticmethod build_Compare ctx expr operands = build_expr ctx e e expr left + list expr comparators result = None lhs op_ rhs zip operands expr ops operands op = type op_ op_token = ExprBuilder cmpop_map get op r = ctx make_raw_range lhs range end rhs range start op_token None raise NotSupportedError r unsupported comparison operator + op __name__ op == ast NotIn NB ` ` just ` ` so we don t introduce new tree view just make nested call our tree view structure in_expr = BinOp lhs rhs cmp_expr = UnaryOp r in_expr cmp_expr = BinOp op_token lhs rhs type ignore assignment result None result = cmp_expr result = BinOp result cmp_expr type ignore assignment result staticmethod build_Subscript ctx expr build_SliceExpr ctx base slice_expr lower = build_expr ctx slice_expr lower slice_expr lower None None upper = build_expr ctx slice_expr upper slice_expr upper None None step = build_expr ctx slice_expr step slice_expr step None None SliceExpr base range lower upper step build_Index ctx base index_expr isinstance index_expr value ast Tuple raise NotSupportedError base range slicing multiple dimensions tuples supported yet build_expr ctx index_expr value build_ExtSlice ctx base extslice sub_exprs = expr extslice dims sub_type = type expr sub_type ast Index sub_exprs append build_Index ctx base expr sub_type ast Slice sub_exprs append build_SliceExpr ctx base expr sub_type ast Constant expr value Ellipsis sub_exprs append Dots base range raise NotSupportedError base range f slicing multiple dimensions sub_type supported sub_exprs base = build_expr ctx expr value sub_type = type expr slice sub_type ast Index isinstance expr slice value ast Tuple N-dimensional indexing using Tuple x i j k equivalent x i j k XXX Indexing using list different It triggers advanced indexing indices = build_expr ctx index_expr index_expr expr slice value elts indices ` col_offset ` int ` end_col_offset ` ` Optional int ` The magic number here make sure we can parse ` ` any machine r = ctx make_range expr lineno expr slice value col_offset expr slice value col_offset + tup = TupleLiteral r indices append tup Subscript base indices Subscript base build_expr ctx expr slice value sub_type ast Slice Subscript base build_SliceExpr ctx base expr slice sub_type ast ExtSlice Subscript base build_ExtSlice ctx base expr slice In Python array indices wrapped ast Index sub_type ast Tuple N-dimensional indexing using Tuple x i j k equivalent x i j k indices = index_expr expr slice elts isinstance index_expr ast Slice indices append build_SliceExpr ctx base index_expr indices append build_expr ctx index_expr Special-case logic ` typing Tuple ` indices See note above r e magic number r = ctx make_range expr lineno expr slice col_offset expr slice col_offset + tup = TupleLiteral r indices append tup Subscript base indices Subscript base build_expr ctx expr slice staticmethod build_List ctx expr ListLiteral ctx make_range expr lineno expr col_offset expr col_offset + build_expr ctx e e expr elts staticmethod build_Tuple ctx expr TupleLiteral ctx make_range expr lineno expr col_offset expr col_offset + build_expr ctx e e expr elts staticmethod build_Dict ctx expr range = ctx make_range expr lineno expr col_offset expr col_offset + expr keys expr keys raise NotSupportedError range Dict expansion e g ` dict ` supported DictLiteral range build_expr ctx e e expr keys build_expr ctx e e expr values staticmethod build_Num ctx expr value = str expr value r = ctx make_range expr lineno expr col_offset expr col_offset + len value Const r value staticmethod build_Constant ctx expr value = expr value value None isinstance value bool NB check has happen before int check because bool subclass int ExprBuilder build_NameConstant ctx expr isinstance value int float complex ExprBuilder build_Num ctx expr isinstance value str ExprBuilder build_Str ctx expr isinstance value type Ellipsis ExprBuilder build_Ellipsis ctx expr error_range = ctx make_range expr lineno expr col_offset expr col_offset + len str value raise FrontendError error_range Unknown Constant expression type staticmethod build_Str ctx expr value = str expr value r = ctx make_range expr lineno expr col_offset expr col_offset + len value + StringLiteral r value staticmethod build_JoinedStr ctx expr s = args = value expr values r = ctx make_range value lineno value col_offset value col_offset + isinstance value ast FormattedValue value conversion = - raise NotSupportedError r Don t support conversion JoinedStr value format_spec None raise NotSupportedError r Don t support formatting JoinedStr s += args append build_expr ctx value value isinstance value ast Constant pyrefly ignore unsupported-operation s += value value raise NotSupportedError r Unsupported value JoinedStr r = ctx make_range expr lineno expr col_offset expr col_offset + Apply Select StringLiteral r s Ident r format args staticmethod build_ListComp ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset len stmt generators = raise NotSupportedError r Only single generator currently supported len stmt generators ifs = raise NotSupportedError r Comprehension ifs supported yet elt_expr = build_expr ctx stmt elt target_expr = build_expr ctx stmt generators target iter_expr = build_expr ctx stmt generators iter ListComp r elt_expr target_expr iter_expr staticmethod build_GeneratorExp ctx stmt Convert Generator expression ListComp ExprBuilder build_ListComp ctx stmt staticmethod build_DictComp ctx stmt r = ctx make_range stmt lineno stmt col_offset stmt col_offset len stmt generators = raise NotSupportedError r Only single generator currently supported len stmt generators ifs = raise NotSupportedError r Comprehension ifs supported yet key_expr = build_expr ctx stmt key value_expr = build_expr ctx stmt value target_expr = build_expr ctx stmt generators target iter_expr = build_expr ctx stmt generators iter DictComp r key_expr value_expr target_expr iter_expr staticmethod build_Starred ctx expr r = ctx make_range expr lineno expr col_offset expr col_offset + Starred r build_expr ctx expr value build_expr = ExprBuilder build_stmt = StmtBuilder build_withitem = WithItemBuilder find_before ctx pos substr offsets= new_pos = ctx source pos rindex substr ctx make_raw_range new_pos + offsets new_pos + len substr + offsets