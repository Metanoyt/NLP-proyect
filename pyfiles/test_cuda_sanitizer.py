Owner s module cuda sys textwrap traceback typing Optional torch torch cuda _sanitizer csan torch cuda _sanitizer DataPtr EventId StreamId torch testing _internal common_utils NoTest run_tests TEST_CUDA TestCase torch testing _internal two_tensor TwoTensor TEST_CUDA print CUDA available skipping tests file=sys stderr TestCase = NoTest noqa F TestArgumentHandler TestCase test_add add_func = torch ops aten add Tensor = torch ones device= cuda b = torch randn device= cuda argument_handler = csan ArgumentHandler argument_handler parse_inputs add_func _schema b is_factory=False c = torch add b argument_handler parse_outputs add_func _schema c is_factory=False assertEqual data_ptr b data_ptr argument_handler dataptrs_read assertEqual c data_ptr argument_handler dataptrs_written test_cat cat_func = torch ops aten cat default = torch ones device= cuda b = torch zeros device= cuda c = torch rand device= cuda argument_handler = csan ArgumentHandler argument_handler parse_inputs cat_func _schema b c is_factory=False d = torch cat b c dim= argument_handler parse_outputs cat_func _schema d is_factory=False assertEqual data_ptr b data_ptr c data_ptr argument_handler dataptrs_read assertEqual d data_ptr argument_handler dataptrs_written test_split split_func = torch ops aten split Tensor = torch arange device= cuda reshape argument_handler = csan ArgumentHandler argument_handler parse_inputs split_func _schema is_factory=False out = torch split argument_handler parse_outputs split_func _schema out is_factory=False Split view op no data read written assertEqual len argument_handler dataptrs_read assertEqual len argument_handler dataptrs_written test_inplace add_inplace_func = torch ops aten add_ Tensor = torch rand device= cuda argument_handler = csan ArgumentHandler argument_handler parse_inputs add_inplace_func _schema is_factory=False add_ argument_handler parse_outputs add_inplace_func _schema is_factory=False assertEqual set argument_handler dataptrs_read assertEqual data_ptr argument_handler dataptrs_written test_out mul_out_func = torch ops aten mul out = torch arange device= cuda b = torch empty device= cuda argument_handler = csan ArgumentHandler argument_handler parse_inputs mul_out_func _schema out b is_factory=False torch mul out=b argument_handler parse_outputs mul_out_func _schema b is_factory=False assertEqual data_ptr argument_handler dataptrs_read assertEqual b data_ptr argument_handler dataptrs_written test_nonzero nonzero_func = torch ops aten nonzero default = torch ones device= cuda argument_handler = csan ArgumentHandler argument_handler parse_inputs nonzero_func _schema as_tuple True is_factory=False out = torch nonzero as_tuple=True argument_handler parse_outputs nonzero_func _schema out is_factory=False outputs = out data_ptr out data_ptr out data_ptr assertEqual data_ptr argument_handler dataptrs_read assertEqual outputs argument_handler dataptrs_written test_tensor_names addr_func = torch ops aten addr default vec = torch arange device= cuda M = torch zeros device= cuda argument_handler = csan ArgumentHandler argument_handler parse_inputs addr_func _schema M vec vec is_factory=False out = torch addr M vec vec argument_handler parse_outputs addr_func _schema out is_factory=False assertEqual argument_handler tensor_aliases M data_ptr vec data_ptr vec vec out data_ptr assertEqual out data_ptr argument_handler outputs tensor_id i int - DataPtr i stream_id i int - StreamId + i event_id i int - EventId + i TestEventHandler TestCase setUp handler = csan EventHandler kernel_launch stream StreamId read_only Optional list DataPtr = None read_write Optional list DataPtr = None - list csan SynchronizationError read_only None read_only = read_write None read_write = handler _handle_kernel_launch stream read_only read_write k k read_only + read_write assert_good_kernel_launch stream StreamId read_only Optional list DataPtr = None read_write Optional list DataPtr = None - None assertEqual kernel_launch stream read_only read_write assert_bad_kernel_launch number_of_errors int stream StreamId read_only Optional list DataPtr = None read_write Optional list DataPtr = None - None errors = kernel_launch stream read_only read_write assertEqual len errors number_of_errors test_empty_kernel_launch assert_good_kernel_launch stream_id test_simple_passing assert_good_kernel_launch stream_id read_only= tensor_id assert_good_kernel_launch stream_id read_only= tensor_id test_simple_error assert_good_kernel_launch stream_id read_only= tensor_id assert_bad_kernel_launch stream_id read_write= tensor_id test_simple_sync assert_good_kernel_launch stream_id read_only= tensor_id handler _handle_event_record event_id stream_id handler _handle_event_wait event_id stream_id assert_good_kernel_launch stream_id read_write= tensor_id test_reads_check_last_write Tests only first read operation checks conflict last write operation all read operations do assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_event_record event_id stream_id handler _handle_event_wait event_id stream_id assert_good_kernel_launch stream_id read_only= tensor_id assert_bad_kernel_launch stream_id read_only= tensor_id test_branch_sync Tests two streams can read after both waiting third they cannot write without further synchronization assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_event_record event_id stream_id handler _handle_event_wait event_id stream_id handler _handle_event_wait event_id stream_id assert_good_kernel_launch stream_id read_only= tensor_id assert_good_kernel_launch stream_id read_only= tensor_id assert_bad_kernel_launch stream_id read_write= tensor_id test_chain_sync iterations = assert_good_kernel_launch stream_id read_only= tensor_id i range iterations handler _handle_event_record event_id i stream_id i handler _handle_event_wait event_id i stream_id i + assert_good_kernel_launch stream_id iterations read_write= tensor_id test_expired_record assert_good_kernel_launch stream_id read_only= tensor_id handler _handle_event_record event_id stream_id assert_good_kernel_launch stream_id read_only= tensor_id handler _handle_event_wait event_id stream_id assert_bad_kernel_launch stream_id read_write= tensor_id test_deleted_record should_delete should_create True True True False False True setUp subTest should_delete=should_delete should_create=should_create assert_good_kernel_launch stream_id read_only= tensor_id handler _handle_event_record event_id stream_id should_delete handler _handle_event_deletion event_id should_create handler _handle_event_creation event_id handler _handle_event_wait event_id stream_id assert_bad_kernel_launch stream_id read_write= tensor_id test_all_reads_checked_failing iterations = i range iterations assert_good_kernel_launch stream_id i read_only= tensor_id handler _handle_event_record event_id i stream_id i i range iterations handler _handle_event_wait event_id i stream_id assert_good_kernel_launch stream_id iterations read_only= tensor_id handler _handle_event_record event_id iterations stream_id i Does synchronize last read assert_bad_kernel_launch stream_id read_write= tensor_id test_all_reads_checked_passing iterations = i range iterations assert_good_kernel_launch stream_id i read_only= tensor_id handler _handle_event_record event_id i stream_id i i range iterations handler _handle_event_wait event_id i stream_id assert_good_kernel_launch stream_id read_write= tensor_id test_multiple_errors iterations = assert_good_kernel_launch stream_id read_write= tensor_id i i range iterations assert_bad_kernel_launch iterations stream_id read_write= tensor_id i i range iterations test_correct_state_merging Tests after waiting event stream s state indeed set pointwise maximum its old state recorded state assert_good_kernel_launch stream_id read_write= tensor_id assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_event_record event_id stream_id handler _handle_event_record event_id stream_id assert_good_kernel_launch stream_id read_write= tensor_id assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_event_wait event_id stream_id handler _handle_event_wait event_id stream_id handler _handle_event_record event_id stream_id handler _handle_event_wait event_id stream_id assert_good_kernel_launch stream_id read_write= tensor_id tensor_id test_record_override assert_good_kernel_launch stream_id read_only= tensor_id assert_good_kernel_launch stream_id read_only= tensor_id handler _handle_event_record event_id stream_id handler _handle_event_record event_id stream_id handler _handle_event_wait event_id stream_id assert_bad_kernel_launch stream_id read_write= tensor_id test_multiple_wait Tests wait operation can performed multiple times same event different streams assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_event_record event_id stream_id handler _handle_event_wait event_id stream_id handler _handle_event_wait event_id stream_id assert_good_kernel_launch stream_id read_only= tensor_id assert_good_kernel_launch stream_id read_only= tensor_id test_device_synchronize Tests device synchronization does correctly cause all streams synchronize each other iterations = i range iterations assert_good_kernel_launch stream_id i read_write= tensor_id i handler _handle_device_synchronization assert_good_kernel_launch stream_id read_write= tensor_id i i range iterations test_device_synchronization_expired Tests device synchronization one-time synchronization assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_device_synchronization assert_good_kernel_launch stream_id read_write= tensor_id assert_bad_kernel_launch stream_id read_write= tensor_id test_new_stream_is_synchronized Tests after synchronizing operations host any newly created stream guaranteed synchronized them well assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_device_synchronization handler _handle_stream_creation stream_id assert_good_kernel_launch stream_id read_write= tensor_id test_stream_synchronize Tests stream synchronization does correctly cause all streams wait one specific stream does synchronize all streams each other assert_good_kernel_launch stream_id read_write= tensor_id assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_stream_synchronization stream_id assert_good_kernel_launch stream_id read_only= tensor_id assert_good_kernel_launch stream_id read_only= tensor_id assert_bad_kernel_launch stream_id read_only= tensor_id test_event_synchronize Tests event synchronization does correctly cause all streams wait recorded event does guarantee synchronization current state stream recorded event assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_event_record event_id stream_id assert_good_kernel_launch stream_id read_write= tensor_id handler _handle_event_synchronization event_id assert_good_kernel_launch stream_id read_write= tensor_id assert_bad_kernel_launch stream_id read_write= tensor_id TestMessages TestCase setUp handler = csan EventHandler test_ensure_exists ARG = func out handler _handle_event_deletion f Found Event id ARG no matching event creation trace Backfilling trace now Perhaps sanitizer enabled after some torch operations handler _handle_memory_deallocation f Found tensor pointer ARG no matching tensor allocation trace Backfilling trace now Perhaps sanitizer enabled after some torch operations subTest func=func out=out assertLogs captured func ARG assertEqual captured records getMessage out test_ensure_does_not_exist ARG = handler _handle_event_creation ARG handler _handle_stream_creation ARG func out handler _handle_event_creation Found duplicate event creation trace event f id ARG Assuming trace event deletion wasn t caught backfilling now Perhaps sanitizer enabled after some torch operations handler _handle_stream_creation Found duplicate Stream creation trace Stream f id ARG PyTorch Streams only created once so trace entry ignored subTest func=func out=out assertLogs captured func ARG assertEqual captured records getMessage out test_error_message current_access = csan Access type=csan AccessType WRITE seq_num= stream=stream_id operator= schema aliases= b is_output=True stack_trace=traceback StackSummary from_list file name trace previous_access = csan Access type=csan AccessType READ seq_num= stream=stream_id operator= schema aliases= is_output=False stack_trace=traceback StackSummary from_list file name trace b error = csan UnsynchronizedAccessError data_ptr=tensor_id allocation_stack_trace=traceback StackSummary from_list file name alloc current_access=current_access previous_access=previous_access assertEqual str error textwrap dedent \ ============================ CSAN detected possible data race tensor data pointer Access stream during kernel schema writing argument s b output With stack trace File file line name trace Previous access stream during kernel schema reading argument s With stack trace File file line name trace b Tensor allocated stack trace File file line name alloc test_subclass MyT torch Tensor __new__ cls data new_data = data clone new_data as_subclass cls try csan enable_cuda_sanitizer These two tests ensure subclass creation happens smoothly under mode used csan TwoTensor torch rand torch rand MyT torch rand finally csan cuda_sanitizer disable __name__ == __main__ run_tests