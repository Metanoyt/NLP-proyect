mypy allow-untyped-defs copy logging typing Any Optional Protocol Union torch torch _library utils parse_namespace torch utils _python_dispatch _disable_current_modes log = logging getLogger __name__ FakeScriptObject __init__ wrapped_obj Any script_class_name str x torch ScriptObject wrapped_obj = wrapped_obj The fully qualified name original script object script_class_name = script_class_name try _disable_current_modes real_obj = copy deepcopy x except RuntimeError e log warning noqa G Unable deepcopy custom object s due s Defaulting user given object This might dangerous side effects may directly applied object script_class_name str e real_obj = x FakeScriptMethod __init__ self_fake_obj FakeScriptObject method_name str schema Optional torch FunctionSchema self_fake_obj = self_fake_obj method_name = method_name schema = schema __call__ args kwargs torch _higher_order_ops torchbind call_torchbind call_torchbind self_fake_obj method_name args kwargs HasStaticMethodFromReal Protocol classmethod from_real cls real_obj torch ScriptObject pass FakeClassRegistry __init__ - None _registered_class dict str Any = has_impl full_qualname str - bool full_qualname _registered_class get_impl full_qualname str - Any _check_registered full_qualname _registered_class full_qualname register full_qualname str fake_class=None - None has_impl full_qualname log warning s already registered Previous fake overridden s full_qualname fake_class _registered_class full_qualname = fake_class deregister full_qualname str - Any has_impl full_qualname log warning Cannot deregister s Please use register_fake_class register first Or do you dereigster twice full_qualname _registered_class pop full_qualname clear - None _registered_class clear _check_registered full_qualname str - None full_qualname _registered_class raise RuntimeError f full_qualname registered Please use register_fake_class register first global_fake_class_registry = FakeClassRegistry TODO add check compile time __obj_flatten__ _check_valid_flat_script_obj flat_x isinstance flat_x tuple raise RuntimeError Expect flat x tuple tp flat_x isinstance tp tuple raise RuntimeError Expect flat x tuple tuples len tp == isinstance tp str raise RuntimeError Expect element flat x tuple two elements first element being string tracing_with_real x torch ScriptObject - bool hasattr x tracing_mode False assert x tracing_mode real fake f tracing_mode can either real fake got x tracing_mode x tracing_mode == real maybe_to_fake_obj fake_mode x torch ScriptObject - Union FakeScriptObject torch ScriptObject torch utils _pytree pytree torch utils _python_dispatch _disable_current_modes When tracing real mode people should implement meta kernels can handle case real script object + fake tensor inputs tracing_with_real x x torch _library opaque_object FakeOpaqueObject OpaqueTypeStr str x _type == OpaqueTypeStr In order make OpaqueObjects truly opaque fake kernel should depend contents OpaqueObject all fake_x = FakeOpaqueObject x __obj_flatten__ could calling some tensor operations inside we don t want call these ops surrounding dispatch modes when executing Otherwise example fake tensor modes will error out when tensors inside script object execute some operations like clone allow_non_fake_input flag set _disable_current_modes flat_x = x __obj_flatten__ type ignore attr-defined _check_valid_flat_script_obj flat_x fake_mode torch _higher_order_ops utils _tensor_storage storage_map = _tensor_storage inp i i inp enumerate flat_x isinstance inp torch Tensor alias_map = i storage_map _tensor_storage inp i inp enumerate flat_x isinstance inp torch Tensor storage_map _tensor_storage inp = i len alias_map log warning Detected script object s has aliasing relationship among its tensors Flattened obj s Aliasing tensor indices s This supported may cause unexpected behavior x flat_x alias_map This breaks aliasing relationship among tensors inside torchbind object This bad since we don t need preserve aliasing relationship anyway we state clearly aliasing relationship preserved doc so might OK fake_flattened = pytree tree_map_only torch Tensor lambda t torch empty_strided t size t stride device=t device dtype=t dtype requires_grad=t requires_grad layout=t layout flat_x fake_x = _find_fake_class_for_script_object x __obj_unflatten__ fake_flattened fake_x_wrapped = FakeScriptObject fake_x x _type qualified_name x type ignore attr-defined name x _method_names type ignore attr-defined attr = getattr fake_x name None attr None callable attr raise RuntimeError f Expect name callable got attr real_attr = getattr x name type ignore attr-defined real attr sometimes torch ScriptMethod thus doesn t have schema e g __init___ __eq__ method_schema Optional torch FunctionSchema = None isinstance real_attr torch ScriptMethod method_schema = real_attr schema type ignore attr-defined setattr fake_x_wrapped name FakeScriptMethod fake_x_wrapped name method_schema override_skip_list = __obj_flatten__ __getstate__ __setstate__ name override_skip_list log warning fake object s doesn t implement method s x name fake_x_wrapped register_fake_class qualname fake_class Optional HasStaticMethodFromReal = None r Register fake implementation It s same spirit registering fake implementation operator difference associates fake original torch bind registered torch class_ In way torch compile can handle them properly components such Dynamo AOTAutograd This API may used decorator see example For fake users required provide from_real classmethod takes real object returns instance fake All tensors fake object should also properly fakified to_fake_tensor from_real Examples For custom Foo defined test_custom_class_registration cpp TORCH_LIBRARY _TorchScriptTesting m m class_ TensorQueue _TensorQueue torch init Tensor push TensorQueue push pop TensorQueue pop top TensorQueue top size TensorQueue size clone_queue TensorQueue clone_queue __obj_flatten__ TensorQueue __obj_flatten__ def_pickle __getstate__ const c intrusive_ptr TensorQueue - c Dict std string Tensor self- serialize __setstate__ c Dict std string Tensor data - c intrusive_ptr TensorQueue c make_intrusive TensorQueue std move data We could register fake FakeTensorQueue Python follows torch torch _library register_fake_class _TorchScriptTesting _TensorQueue FakeTensorQueue __init__ queue queue = queue classmethod __obj_unflatten__ cls flattened_ctx cls dict ctx push x queue append x pop queue pop size len queue In example original TensorQeue need add __obj_flatten__ method TensorQueue flattened result passed into FakeTensorQueue s __obj_unflatten__ inputs create fake This protocol allows pytorch look contents script object properly handle them subsystems like dynamo aot_aotugrad more inner fake_class HasStaticMethodFromReal ns name = parse_namespace qualname This also checks whether referred torch class_ exists torch _C _get_custom_class_python_wrapper ns name from_method = getattr fake_class _CONVERT_FROM_REAL_NAME None from_method raise RuntimeError f fake_class doesn t define classmethod _CONVERT_FROM_REAL_NAME isinstance fake_class __dict__ _CONVERT_FROM_REAL_NAME classmethod raise RuntimeError f _CONVERT_FROM_REAL_NAME method classmethod global_fake_class_registry register _full_qual_class_name qualname fake_class fake_class fake_class None inner inner fake_class deregister_fake_class qualname global_fake_class_registry deregister _full_qual_class_name qualname has_fake_class full_qualname - bool global_fake_class_registry has_impl full_qualname find_fake_class full_qualname - Optional Any has_fake_class full_qualname None global_fake_class_registry get_impl full_qualname _full_qual_class_name qualname str - str ns name = parse_namespace qualname __torch__ torch classes + ns + + name _is_script_object obj Any - bool isinstance obj torch ScriptObject obj _type qualified_name startswith type ignore attr-defined __torch__ torch classes Return namespace name fully qualified name _ns_and_class_name full_qualname str - tuple str str splits = full_qualname split assert len splits == f Could split full_qualname= _torch _torch_ns _classes ns class_name = splits ns class_name _find_fake_class_for_script_object x torch ScriptObject - Any full_qualname = x _type qualified_name type ignore attr-defined ns class_name = _ns_and_class_name full_qualname fake_class = find_fake_class full_qualname fake_class None raise RuntimeError f ScriptObject s full_qualname haven t registered fake f Please use register_fake_class ns class_name annotate fake script obj f Specifically create python implements fake version all methods f re used program put annotated program e g after loading library f The fake methods can written same way meta kernel operator need additionally f simulate object s states Be sure add _CONVERT_FROM_REAL_NAME classmethod f enable creating fake obj real one fake_class _CONVERT_FROM_REAL_NAME = __obj_unflatten__ _fake_obj_from_real fake_mode x - Any fake_class = _find_fake_class_for_script_object x from_real_method = getattr fake_class _CONVERT_FROM_REAL_NAME None from_real_method raise RuntimeError f fake_class must define classmethod _CONVERT_FROM_REAL_NAME f converts real object fake object from_real defined user need ctx fakify tensor states ctx = torch _library fake_impl FakeImplCtx fake_mode None torch _library fake_impl set_ctx_getter lambda ctx fake_class from_real x