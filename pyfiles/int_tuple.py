################################################################################################# Copyright c - NVIDIA CORPORATION AFFILIATES All rights reserved SPDX-License-Identifier BSD- -Clause Redistribution use source binary forms without modification permitted provided following conditions met Redistributions source code must retain above copyright notice list conditions following disclaimer Redistributions binary form must reproduce above copyright notice list conditions following disclaimer documentation other materials provided distribution Neither name copyright holder nor names its contributors may used endorse promote products derived software without specific prior written permission THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE ################################################################################################# Functions manipulating IntTuples functools reduce itertools chain typing Optional TypeAlias Union typing_extensions TypeIs typing Integer Type aliases better readability IntTuple TypeAlias = Union int tuple IntTuple is_int x object - TypeIs int isinstance x Integer is_tuple x object - TypeIs tuple isinstance x tuple as_tuple x IntTuple - tuple IntTuple is_int x x x match_structure IntTuple b IntTuple - bool is_int is_int b True is_tuple is_tuple b len == len b all match_structure x y x y zip b False flatten t IntTuple - tuple int is_tuple t len t == tuple i t i flatten t signum int - int bool - bool product IntTuple - int is_tuple reduce lambda val elem val product elem inner_product IntTuple b IntTuple - int is_tuple is_tuple b tuple tuple assert len == len b sum inner_product x y x y zip b int int assert is_tuple is_tuple b b tuple_max IntTuple - int is_tuple max tuple_max x x elem_scale IntTuple b IntTuple - IntTuple is_tuple is_tuple b tuple tuple assert len == len b tuple elem_scale x y x y zip b tuple int raise AssertionError Invalid combination tuple int is_tuple b int tuple elem_scale product b int int b Inclusive prefix ceil div output congruent input shape_div IntTuple b IntTuple - IntTuple is_tuple is_tuple b tuple tuple assert len == len b tuple shape_div x y x y zip b tuple int r = shape_div b + shape_div i b = shape_div b product i- i range len r = v r append shape_div v b b = shape_div b product v tuple r is_tuple b int tuple shape_div product b int int assert b == b == + b - b Exclusive suffix product output congruent input lexicographic suffix_product IntTuple init IntTuple = - IntTuple TODO With all these length asserts may want create zip_strict wrapper is_tuple is_tuple init tuple tuple assert len == len init tuple suffix_product x i x i zip init tuple int Process right left lexicographic ordering r = prefix_product len - init + prefix_product i init = init product i+ i range len - reverse r = Calculate products right left appending list i range len - - - r append suffix_product i init init = init product i Reverse get correct lexicographic order r reverse tuple r is_tuple init int tuple raise AssertionError Invalid combination int tuple init int int init idx crd idx IntTuple shape IntTuple stride Optional IntTuple = None - IntTuple stride None stride = suffix_product shape is_tuple idx is_tuple shape is_tuple stride tuple tuple tuple assert len idx == len shape len stride == len shape tuple idx crd i s d i s d zip idx shape stride tuple int int raise AssertionError Invalid combination tuple int stride is_tuple shape is_tuple stride int tuple tuple assert len shape == len stride tuple idx crd idx s d s d zip shape stride int int int assert is_tuple shape is_tuple stride idx stride shape all ints after type checks crd idx crd Optional IntTuple shape IntTuple stride Optional IntTuple = None - int stride None stride = suffix_product shape is_tuple crd is_tuple shape is_tuple stride tuple tuple tuple assert len crd == len shape len stride == len shape sum crd idx c s d c s d zip crd shape stride tuple int int raise AssertionError f Invalid combination crd= crd shape= shape crd None crd = is_tuple shape is_tuple stride int tuple tuple assert len shape == len stride result = Process right left lexicographic ordering i range len shape - - result += crd idx crd product shape i shape i stride i crd = crd product shape i len shape result += crd idx crd shape stride result int int int assert is_tuple shape is_tuple stride crd stride all ints after type checks Transform crd into dst_shape s iteration space crd crd crd IntTuple dst_shape IntTuple src_shape Optional IntTuple = None - IntTuple is_tuple crd is_tuple dst_shape tuple tuple assert len crd == len dst_shape tuple crd crd x y x y zip crd dst_shape tuple int Ambiguous unless we have src_shape assert src_shape None crd idx crd src_shape is_tuple dst_shape int tuple idx crd crd dst_shape int int assert crd dst_shape crd Filter trg according crd keep only elements trg paired None slice_ crd Union None tuple int trg Union tuple int - Union tuple int is_tuple crd is_tuple trg tuple tuple assert len crd == len trg match C++ behavior ` filter_tuple ` using ` tuple_cat ` tuple chain filter type ignore arg-type filter returns Iterator which compatible lambda x x = slice_ c s c s zip crd trg raise AssertionError Invalid combination tuple crd int trg crd None match C++ behavior ` cute tuple B b ` trg Determine None appears any int_tuples terminals has_none Union None tuple int - bool is_tuple any has_none v v None