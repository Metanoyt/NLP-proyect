mypy ignore-errors __future__ annotations functools math typing TYPE_CHECKING torch _dtypes_impl _util _normalizations ArrayLike KeepDims normalizer TYPE_CHECKING collections abc Sequence LinAlgError Exception pass _atleast_float_ dtype is_floating_point dtype is_complex = _dtypes_impl default_dtypes float_dtype _atleast_float_ b dtyp = _dtypes_impl result_type_impl b dtyp is_floating_point dtyp is_complex dtyp = _dtypes_impl default_dtypes float_dtype = _util cast_if_needed dtyp b = _util cast_if_needed b dtyp b linalg_errors func functools wraps func wrapped args kwds try func args kwds except torch _C _LinAlgError e raise LinAlgError e args noqa B wrapped ### Matrix vector products ### normalizer linalg_errors matrix_power ArrayLike n = _atleast_float_ torch linalg matrix_power n normalizer linalg_errors multi_dot inputs Sequence ArrayLike out=None torch linalg multi_dot inputs ### Solving equations inverting matrices ### normalizer linalg_errors solve ArrayLike b ArrayLike b = _atleast_float_ b torch linalg solve b normalizer linalg_errors lstsq ArrayLike b ArrayLike rcond=None b = _atleast_float_ b NumPy using gelsd https github com numpy numpy blob v numpy linalg umath_linalg cpp#L CUDA only ` gels ` available though so use instead driver = gels is_cuda b is_cuda gelsd torch linalg lstsq b rcond=rcond driver=driver normalizer linalg_errors inv ArrayLike = _atleast_float_ result = torch linalg inv result normalizer linalg_errors pinv ArrayLike rcond= e- hermitian=False = _atleast_float_ torch linalg pinv rtol=rcond hermitian=hermitian normalizer linalg_errors tensorsolve ArrayLike b ArrayLike axes=None b = _atleast_float_ b torch linalg tensorsolve b dims=axes normalizer linalg_errors tensorinv ArrayLike ind= = _atleast_float_ torch linalg tensorinv ind=ind ### Norms other numbers ### normalizer linalg_errors det ArrayLike = _atleast_float_ torch linalg det normalizer linalg_errors slogdet ArrayLike = _atleast_float_ torch linalg slogdet normalizer linalg_errors cond x ArrayLike p=None x = _atleast_float_ x check empty cf https github com numpy numpy blob v numpy linalg linalg py#L x numel == math prod x shape - == raise LinAlgError cond defined empty arrays result = torch linalg cond x p=p Convert nans infs numpy does data-dependent way depending whether input array has nans XXX NumPy does https github com numpy numpy blob v numpy linalg linalg py#L torch where torch isnan result float inf result normalizer linalg_errors matrix_rank ArrayLike tol=None hermitian=False = _atleast_float_ ndim int = any tol None follow https github com numpy numpy blob v numpy linalg linalg py#L atol = rtol = max shape - torch finfo dtype eps atol rtol = tol torch linalg matrix_rank atol=atol rtol=rtol hermitian=hermitian normalizer linalg_errors norm x ArrayLike ord=None axis=None keepdims KeepDims = False x = _atleast_float_ x torch linalg norm x ord=ord dim=axis ### Decompositions ### normalizer linalg_errors cholesky ArrayLike = _atleast_float_ torch linalg cholesky normalizer linalg_errors qr ArrayLike mode= reduced = _atleast_float_ result = torch linalg qr mode=mode mode == r match NumPy result = result R result normalizer linalg_errors svd ArrayLike full_matrices=True compute_uv=True hermitian=False = _atleast_float_ compute_uv torch linalg svdvals NB ignore hermitian= argument no pytorch equivalent result = torch linalg svd full_matrices=full_matrices result ### Eigenvalues eigenvectors ### normalizer linalg_errors eig ArrayLike = _atleast_float_ w vt = torch linalg eig is_complex w is_complex w imag == all w = w real vt = vt real w vt normalizer linalg_errors eigh ArrayLike UPLO= L = _atleast_float_ torch linalg eigh UPLO=UPLO normalizer linalg_errors eigvals ArrayLike = _atleast_float_ result = torch linalg eigvals is_complex result is_complex result imag == all result = result real result normalizer linalg_errors eigvalsh ArrayLike UPLO= L = _atleast_float_ torch linalg eigvalsh UPLO=UPLO