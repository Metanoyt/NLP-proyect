Owner s oncall fx contextlib pickle io BytesIO unittest mock patch torch torch _export torch fx torch fx _lazy_graph_module _LazyGraphModule _make_graph_module _use_lazy_graph_module torch fx experimental proxy_tensor make_fx torch package PackageExporter PackageImporter torch testing _internal common_utils TestCase TestLazyGraphModule TestCase exit_stack = None classmethod setUpClass cls cls exit_stack = contextlib ExitStack cls exit_stack enter_context _use_lazy_graph_module True classmethod tearDownClass cls cls exit_stack close staticmethod replace_sin_with_cos gm n gm graph nodes n target == sin n target = cos test_replace_sin_with_cos f x x sin x = torch randn gm = fx symbolic_trace f replace_sin_with_cos gm gm recompile expected = x cos actual = gm x assertTrue torch allclose expected actual code = gm print_readable False assertTrue cos code assertTrue isinstance gm _LazyGraphModule test_call_forward_directly f x x sin x = torch randn gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule replace_sin_with_cos gm gm recompile expected = x cos actual = gm forward x assertTrue torch allclose expected actual test_needs_recompile Make sure needs_recompile correct state f x x sin gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule assertTrue gm _needs_recompile gm torch randn assertFalse gm _needs_recompile test_multi_recompile Cover case multiple recompilation happens f x x sin gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule assertTrue gm _needs_recompile x = torch randn trigger first recompilation assertTrue torch allclose x sin gm x assertFalse gm _needs_recompile replace_sin_with_cos gm assertFalse gm _needs_recompile gm recompile assertTrue gm _needs_recompile trigger second recompilation assertTrue torch allclose x cos gm x assertFalse gm _needs_recompile test_accessing_code_cause_recompiling Make sure we recompile we have done yet when we access code property GraphModule f x x sin gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule assertTrue gm _needs_recompile should trigger recompilation code = gm code assertTrue sin code assertFalse gm _needs_recompile test_graph_module_str f x x sin gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule assertTrue sin str gm test_recapture_with_make_fx f x x sin gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule assertTrue gm _needs_recompile gm = make_fx gm torch randn assertTrue isinstance gm _LazyGraphModule assertTrue gm _needs_recompile make_fx will cal forward method gm That clears _needs_recompile flag assertFalse gm _needs_recompile test_recapture_with_symbolic_trace f x x sin gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule assertTrue gm _needs_recompile gm = fx symbolic_trace gm lazy recompilcation already realized We realize recompilation beginning symbolic_trace since symbolic_trace can handle tracing lazy recompilation assertFalse gm _needs_recompile assertTrue gm _needs_recompile test_recapture_with_dynamo f x x sin gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule assertTrue gm _needs_recompile torch compile gm torch rand dynamo calls gm forward eval hook installed That will trigger real recompilation assertFalse gm _needs_recompile test_save_lazy_foward Save lazy forward method call repeatedly Make sure we don t recompile each such call f x x sin orig_gm_recompile = fx GraphModule recompile recompile_count = mock_gm_recompile nonlocal recompile_count recompile_count += orig_gm_recompile patch object fx GraphModule recompile mock_gm_recompile gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule saved_fwd = gm forward x = torch rand _ range saved_fwd x assertEqual recompile_count test_pickle Fx graph cache need ability pickle GraphModule _LazyGraphModule f x x sin gm = fx symbolic_trace f assertTrue isinstance gm _LazyGraphModule serialized = pickle dumps gm gm = pickle loads serialized assertTrue isinstance gm _LazyGraphModule assertTrue sin gm code test_make_graph_module gm = fx symbolic_trace lambda x x sin assertTrue isinstance gm _LazyGraphModule gm = _make_graph_module gm gm graph class_name= MyGraphModule graph_module_cls=fx GraphModule assertFalse isinstance gm _LazyGraphModule assertTrue gm __class__ __name__ == MyGraphModule gm = _make_graph_module gm gm graph assertTrue isinstance gm _LazyGraphModule assertTrue gm __class__ __name__ == GraphModule test_package_fx_simple Copied test package test_package_fx py make sure LazyGraphModule works torch package SimpleTest torch nn Module forward x torch relu x + st = SimpleTest traced = fx symbolic_trace st f = BytesIO PackageExporter f pe pe save_pickle model model pkl traced f seek pi = PackageImporter f loaded_traced = pi load_pickle model model pkl input = torch rand assertEqual loaded_traced input traced input test_dynamo_innermost_fn Repro https github com pytorch pytorch issues f x x gm = torch fx symbolic_trace f lazy_gm = torch fx _lazy_graph_module _LazyGraphModule from_graphmodule gm wrapped_forward = torch _dynamo disable gm forward got_inner_forward = torch _dynamo eval_frame innermost_fn wrapped_forward assert hasattr got_inner_forward __self__ wrapped_lazy_forward = torch _dynamo disable lazy_gm forward got_lazy_inner_forward = torch _dynamo eval_frame innermost_fn wrapped_lazy_forward assert hasattr got_lazy_inner_forward __self__ __name__ == __main__ raise RuntimeError This test currently used should enabled discover_tests py required