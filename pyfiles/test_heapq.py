======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_collections py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests __TestCase = CPythonTestCase ======= END DYNAMO PATCH ======= Unittests heapq random unittest doctest test support import_helper unittest TestCase skipUnless operator itemgetter py_heapq = import_helper import_fresh_module heapq blocked= _heapq c_heapq = import_helper import_fresh_module heapq fresh= _heapq _heapq nlargest nsmallest saved heapq _nlargest _smallest when _heapq imported so check them there func_names = heapify heappop heappush heappushpop heapreplace _heappop_max _heapreplace_max _heapify_max TestModules __TestCase test_py_functions fname func_names assertEqual getattr py_heapq fname __module__ heapq skipUnless c_heapq requires _heapq test_c_functions fname func_names assertEqual getattr c_heapq fname __module__ _heapq _TestHeap test_push_pop Push random numbers pop them off verifying all s OK heap = data = check_invariant heap i range item = random random data append item module heappush heap item check_invariant heap results = while heap item = module heappop heap check_invariant heap results append item data_sorted = data data_sorted sort assertEqual data_sorted results Check invariant holds sorted array check_invariant results assertRaises TypeError module heappush try assertRaises TypeError module heappush None None assertRaises TypeError module heappop None except AttributeError pass check_invariant heap Check heap invariant pos item enumerate heap pos pos has no parent parentpos = pos- assertTrue heap parentpos = item test_heapify size list range + heap = random random dummy range size module heapify heap check_invariant heap assertRaises TypeError module heapify None test_naive_nbest data = random randrange i range heap = item data module heappush heap item len heap module heappop heap heap sort assertEqual heap sorted data - heapiter heap An iterator returning heap s elements smallest-first try while yield module heappop heap except IndexError pass test_nbest Less-naive N-best algorithm much faster len data big enough wink than sorting all data However we had max heap instead min heap could go faster still via heapify ing all data linear time then doing heappops log-time steps data = random randrange i range heap = data module heapify heap item data item heap gets rarer longer we run module heapreplace heap item assertEqual list heapiter heap sorted data - assertRaises TypeError module heapreplace None assertRaises TypeError module heapreplace None None assertRaises IndexError module heapreplace None test_nbest_with_pushpop data = random randrange i range heap = data module heapify heap item data module heappushpop heap item assertEqual list heapiter heap sorted data - assertEqual module heappushpop x x test_heappushpop h = x = module heappushpop h assertEqual h x h = x = module heappushpop h assertEqual h x assertEqual type h int assertEqual type x float h = x = module heappushpop h assertEqual h x h = x = module heappushpop h assertEqual h x test_heappop_max _heapop_max has optimization one-item lists which isn t covered other tests so test case explicitly here h = assertEqual module _heappop_max h assertEqual module _heappop_max h test_heapsort Exercise everything repeated heapsort checks trial range size = random randrange data = random randrange i range size trial Half time use heapify heap = data module heapify heap The rest time use heappush heap = item data module heappush heap item heap_sorted = module heappop heap i range size assertEqual heap_sorted sorted data test_merge inputs = i range random randrange row = j range random randrange tup = random choice ABC random randrange - row append tup inputs append row key None itemgetter itemgetter itemgetter reverse False True seqs = seq inputs seqs append sorted seq key=key reverse=reverse assertEqual sorted chain inputs key=key reverse=reverse list module merge seqs key=key reverse=reverse assertEqual list module merge test_empty_merges Merging two empty lists without key should produce another empty list assertEqual list module merge assertEqual list module merge key=lambda test_merge_does_not_suppress_index_error Issue Heapq merge suppresses IndexError user generator iterable s = list range i range yield s i IndexError when i assertRaises IndexError list module merge iterable iterable test_merge_stability Int int pass inputs = i range stream = random randrange x = random randrange obj = Int x obj pair = x stream inputs stream append obj stream inputs stream sort result = i pair i module merge inputs assertEqual result sorted result test_nsmallest data = random randrange i i range f None lambda x x n assertEqual list module nsmallest n data sorted data n assertEqual list module nsmallest n data key=f sorted data key=f n test_nlargest data = random randrange i i range f None lambda x x n assertEqual list module nlargest n data sorted data reverse=True n assertEqual list module nlargest n data key=f sorted data key=f reverse=True n test_comparison_operator Issue Make sure heapq works both __lt__ For python __le__ alone enough hsort data comp data = comp x x data module heapify data module heappop data x i range len data LT __init__ x x = x __lt__ other x other x LE __init__ x x = x __le__ other x = other x data = random random i range target = sorted data reverse=True assertEqual hsort data LT target assertRaises TypeError data LE TestHeapPython _TestHeap __TestCase module = py_heapq skipUnless c_heapq requires _heapq TestHeapC _TestHeap __TestCase module = c_heapq #============================================================================== LenOnly Dummy sequence defining __len__ __getitem__ __len__ CmpErr Dummy element always raises error during comparison __eq__ other raise ZeroDivisionError __ne__ = __lt__ = __le__ = __gt__ = __ge__ = __eq__ R seqn Regular generator i seqn yield i G Sequence using __getitem__ __init__ seqn seqn = seqn __getitem__ i seqn i I Sequence using iterator protocol __init__ seqn seqn = seqn i = __iter__ __next__ i = len seqn raise StopIteration v = seqn i i += v Ig Sequence using iterator protocol defined generator __init__ seqn seqn = seqn i = __iter__ val seqn yield val X Missing __getitem__ __iter__ __init__ seqn seqn = seqn i = __next__ i = len seqn raise StopIteration v = seqn i i += v N Iterator missing __next__ __init__ seqn seqn = seqn i = __iter__ E Test propagation exceptions __init__ seqn seqn = seqn i = __iter__ __next__ S Test immediate stop __init__ seqn pass __iter__ __next__ raise StopIteration itertools chain L seqn Test multiple tiers iterators chain map lambda x x R Ig G seqn SideEffectLT __init__ value heap value = value heap = heap __lt__ other heap = value other value _TestErrorHandling test_non_sequence f module heapify module heappop assertRaises TypeError AttributeError f f module heappush module heapreplace module nlargest module nsmallest assertRaises TypeError AttributeError f test_len_only f module heapify module heappop assertRaises TypeError AttributeError f LenOnly f module heappush module heapreplace assertRaises TypeError AttributeError f LenOnly f module nlargest module nsmallest assertRaises TypeError f LenOnly test_cmp_err seq = CmpErr CmpErr CmpErr f module heapify module heappop assertRaises ZeroDivisionError f seq f module heappush module heapreplace assertRaises ZeroDivisionError f seq f module nlargest module nsmallest assertRaises ZeroDivisionError f seq test_arg_parsing f module heapify module heappop module heappush module heapreplace module nlargest module nsmallest assertRaises TypeError AttributeError f test_iterable_args f module nlargest module nsmallest s range range g G I Ig L R assertEqual list f g s list f s assertEqual list f S s assertRaises TypeError f X s assertRaises TypeError f N s assertRaises ZeroDivisionError f E s Issue heap may change size while s being walked test_heappush_mutating_heap heap = heap extend SideEffectLT i heap i range Python version raises IndexError C version RuntimeError assertRaises IndexError RuntimeError module heappush heap SideEffectLT heap test_heappop_mutating_heap heap = heap extend SideEffectLT i heap i range Python version raises IndexError C version RuntimeError assertRaises IndexError RuntimeError module heappop heap test_comparison_operator_modifiying_heap See bpo- Strong references need taken when comparing objects they can alter heap EvilClass int __lt__ o heap clear NotImplemented heap = module heappush heap EvilClass assertRaises IndexError module heappushpop heap test_comparison_operator_modifiying_heap_two_heaps h int __lt__ o list clear NotImplemented g int __lt__ o list clear NotImplemented list list = module heappush list h module heappush list g assertRaises IndexError RuntimeError module heappush list g assertRaises IndexError RuntimeError module heappush list h TestErrorHandlingPython _TestErrorHandling __TestCase module = py_heapq skipUnless c_heapq requires _heapq TestErrorHandlingC _TestErrorHandling __TestCase module = c_heapq __name__ == __main__ run_tests