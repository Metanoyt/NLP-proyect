usr bin env python A set primitive functions performing collective ops Each should also handle single rank scenario __future__ annotations importlib logging collections defaultdict dataclasses dataclass typing Any cast Generic Optional TYPE_CHECKING TypeVar Union TYPE_CHECKING collections abc Callable Iterable torch torch distributed dist __all__ list str = SyncPayload broadcast all_gather all_gather_object_enforce_type logger = logging getLogger __name__ T = TypeVar T dataclass SyncPayload Generic T stage_name Optional str success bool payload T exception Optional Exception = None broadcast data_or_fn Union T Callable T success bool = True stage_name Optional str = None rank int = pg Optional dist ProcessGroup = None - T Broadcasts data payload rank all other ranks Or function passed execute rank broadcast result all other ranks Can used broadcast failure signal stop all ranks If function raises exception all ranks will raise Args data_or_fn data broadcast function execute broadcast result success False stop all ranks stage_name name logical stage synchronization debugging rank rank broadcast data execute function broadcast results pg process group sync Throws RuntimeError original exception trace Returns value after synchronization Example usage id = broadcast data_or_fn=allocate_id rank= pg=ext_pg my_pg success data_or_fn None raise AssertionError Data Function expected None successful payload Optional T = None exception Optional Exception = None no pg passed then execute rank pg None rank == pg None pg rank == rank determine executable function data payload only callable data_or_fn try payload = data_or_fn except Exception e success = False exception = e payload = data_or_fn broadcast exception type any all ranks failure categorization sync_obj = SyncPayload stage_name=stage_name success=success payload=payload exception=exception pg None broadcast_list = sync_obj dist broadcast_object_list broadcast_list src=rank group=pg assert len broadcast_list == sync_obj = broadcast_list failure any rank will trigger throw every rank sync_obj success error_msg = f Rank rank failed stage_name None error_msg += f stage sync_obj stage_name sync_obj exception None error_msg += f exception sync_obj exception pyrefly ignore invalid-inheritance raise RuntimeError error_msg sync_obj exception cast T sync_obj payload all_gather data_or_fn Union T Callable T stage_name Optional str = None pg Optional dist ProcessGroup = None - list T A simple all_gather primitive basic synchronization guard logic checking payload all ranks has same stage name Args data_or_fn data all gathered across ranks function executed stage_name sync stage name out-of-sync protection pg process group sync Throws RuntimeError original exception trace Returns list synced data all ranks Example usage all_ids = all_gather data_or_fn=allocate_id pg=ext_pg my_pg payload Optional T = None exception Optional Exception = None success = True determine executable function data payload only callable data_or_fn try payload = data_or_fn except Exception e success = False exception = e payload = data_or_fn sync_obj = SyncPayload stage_name=stage_name success=success payload=payload exception=exception pg None List success failure across all ranks total_list = None dist get_world_size pg all_gather_object_enforce_type pg total_list sync_obj Each rank will throw RuntimeError case failure any rank stage_name = cast SyncPayload T total_list stage_name exception_list list tuple int Exception = ret_list list T = error_msg str = i sp enumerate cast list SyncPayload T total_list sp stage_name = stage_name error_msg += f Unexpected stage name received rank i sp stage_name continue sp success sp exception None exception_list append i sp exception continue ret_list append sp payload len exception_list raise RuntimeError type ignore misc error_msg exception_list pyrefly ignore invalid-inheritance exception_list ret_list sync_obj success raise RuntimeError f all_gather failed exception sync_obj exception pyrefly ignore invalid-inheritance sync_obj exception sync_obj payload type ignore list-item Note use Any typing now so users can pass either list None target type placeholders otherwise pyre would complain all_gather_object_enforce_type pg dist ProcessGroup pyre-fixme Parameter must have type does contain ` Any ` object_list list Any pyre-fixme Parameter must have type other than ` Any ` obj Any pyre-fixme Parameter must have type does contain ` Any ` type_checker Callable Any Any bool = lambda x y type x type y - None Similar plain all_gather_object additional type checking AFTER gather done ensure basic consistency If check does pass all ranks will fail exception This generally prevent conditional logic leading unexpected messages being received This considered fatal code error due logic stacks might happen implicitly practice The default check does check sub type considered different covariance considered same users can pass custom checker more complicated check needed dist all_gather_object object_list obj group=pg conservative check list_len = len object_list list_len == first_obj = object_list i range list_len type_checker first_obj object_list i raise TypeError f Object type index i type object_list i f while first object type type first_obj _summarize_ranks ranks Iterable int - str ranks = sorted ranks assert min ranks = ranks should all positive assert len set ranks == len ranks ranks should contain duplicates curr Optional Union int range = None ranges = while ranks x = ranks pop curr None curr = x isinstance curr int x == curr + curr = range curr x + step = x - curr curr = range curr x + step step assert isinstance curr range x == curr stop curr = range curr start curr stop + curr step curr step ranges append curr curr = x isinstance curr int ranges append range curr curr + isinstance curr range ranges append curr result = r ranges len r == pyrefly ignore bad-argument-type result append f r start r step == pyrefly ignore bad-argument-type result append f r start r stop pyrefly ignore bad-argument-type result append f r start r stop r step join result _check_philox_rng_sync generator torch Generator group dist ProcessGroup - tuple dict Any set str local_state = generator get_state all_states = torch empty_like local_state _ range group size torch distributed all_gather all_states local_state seeds_offsets = state view torch uint item state view torch uint item state all_states seed_offset_ranks = defaultdict set rank seed offset enumerate seeds_offsets seed_offset_ranks seed offset add rank seed_offset_ranks Seed Offset _check_cpu_rng_sync generator torch Generator group dist ProcessGroup - tuple dict Any set str seed returned uint _t C impl so may fit torch int tensor directly state_tensor = generator get_state all_state_tensors = torch empty_like state_tensor _ range group size torch distributed all_gather all_state_tensors state_tensor state_ranks = defaultdict set rank state_tensor enumerate all_state_tensors Summarize state vector CPU rng The properties matter most its different there state difference its printable see desync table- viable print whole state vector size k state_ranks torch hash_tensor state_tensor item add rank state_ranks Generator state hash _check_rng_sync_internal generator torch Generator group dist ProcessGroup - tuple dict Any set str generator device type == cuda _check_philox_rng_sync generator group generator device type == cpu _check_cpu_rng_sync generator group raise NotImplementedError f Unsupported generator device generator device type _desync_table_str tag str value_ranks dict Any set int - str headers = Ranks f tag values rank_values = _summarize_ranks ranks str value value ranks value_ranks items importlib util find_spec tabulate tabulate tabulate tabulate rank_values headers=headers row_str = \n join str row row rank_values str f headers \n row_str _check_rng_sync generator torch Generator group dist ProcessGroup - Optional str value_ranks value_header = _check_rng_sync_internal generator group log_str = None len value_ranks log_str = f Generator desync detected \n _desync_table_str value_header value_ranks logger error log_str log_str