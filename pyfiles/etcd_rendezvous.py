usr bin env python mypy allow-untyped-defs Copyright c Facebook Inc its affiliates All rights reserved This source code licensed under BSD-style license found LICENSE file root directory source tree json logging sys threading time typing Optional try etcd type ignore except ModuleNotFoundError _etcd_stub etcd torch distributed elastic rendezvous RendezvousClosedError RendezvousError RendezvousHandler RendezvousInfo RendezvousParameters RendezvousStoreInfo RendezvousTimeoutError etcd_store cas_delay EtcdStore utils parse_rendezvous_endpoint __all__ = EtcdRendezvousRetryableFailure EtcdRendezvousRetryImmediately EtcdRendezvousHandler EtcdRendezvous create_rdzv_handler _log_fmt = logging Formatter levelname s asctime s message s _log_handler = logging StreamHandler sys stderr _log_handler setFormatter _log_fmt logger = logging getLogger __name__ logger propagate = False logger setLevel logging INFO logger addHandler _log_handler Retryable failure exception means we too late make desired state transition e g because race condition should now restart beginning A small delay recommended avoid spamming Etcd EtcdRendezvousRetryableFailure Exception pass Similar retryable failure new state we observed suggests we can re-try immediately i e without need safety delay EtcdRendezvousRetryImmediately Exception pass Default timeout rendezvous _DEFAULT_TIMEOUT int = minutes Additional waiting time after reaching minimum number nodes case rendezvous elastic min = max _DEFAULT_LAST_CALL_TIMEOUT int = seconds Various constants used internally EtcdRendezvous CONST_ETCD_SETUP_TTL = CONST_ETCD_FROZEN_TTL = CONST_ETCD_JOINABLE_EPHEMERAL_TTL = Ephemeral node TTL worker s keep-alive key CONST_WORKER_KEEPALIVE_TTL = TTL ephemeral run_id-specific directory All rendezvous state data specific run_id job instance contained within directory Its only role clean-up rendezvous data old runs case when etcd server persistent has no affect correctness should larger than any timeouts worker process expected survive CONST_RUNID_SUBROOT_TTL = hours EtcdRendezvousHandler RendezvousHandler Implements py ` torch distributed elastic rendezvous RendezvousHandler ` interface backed py ` torch distributed elastic rendezvous etcd_rendezvous EtcdRendezvous ` ` ` EtcdRendezvousHandler ` ` uses URL configure type rendezvous use pass implementation specific configurations rendezvous module The basic etcd rendezvous configuration URL looks like following etcd etcd_address port job_id min_workers= min_workers max_workers= max_workers noqa W -- example -- etcd localhost min_workers= max_workers= The URL above interpreted follows Use rendezvous handler registered ` ` etcd ` ` scheme The ` ` etcd ` ` endpoint use ` ` localhost ` ` ` ` job_id == ` ` used prefix etcd allows one share common etcd server multiple jobs so long ` ` job_ids ` ` guaranteed unique Note job id can any string e g does need number long unique ` ` min_workers= ` ` ` ` max_workers= ` ` specifies range membership size - Torch Distributed Elastic starts running job long cluster size greater than equal ` ` min_workers ` ` admits up ` ` max_workers ` ` into cluster Below full list parameters can passed etcd rendezvous + -------------------------------------------- + -------------------------- + &#124; Parameter &#124; Description &#124; +============================================+==========================+ &#124; min_workers &#124; minimum number &#124; &#124; &#124; workers &#124; &#124; &#124; rendezvous valid &#124; + -------------------------------------------- + -------------------------- + &#124; max_workers &#124; maximum number &#124; &#124; &#124; workers admit &#124; + -------------------------------------------- + -------------------------- + &#124; timeout &#124; total timeout within &#124; &#124; &#124; which next_rendezvous &#124; &#124; &#124; expected succeed &#124; &#124; &#124; default s &#124; + -------------------------------------------- + -------------------------- + &#124; last_call_timeout &#124; additional wait amount &#124; &#124; &#124; last call after min &#124; &#124; &#124; number workers has &#124; &#124; &#124; been reached defaults &#124; &#124; &#124; s &#124; + -------------------------------------------- + -------------------------- + &#124; etcd_prefix &#124; path prefix etcd &#124; &#124; &#124; root inside which all &#124; &#124; &#124; etcd nodes will &#124; &#124; &#124; created defaults &#124; &#124; &#124; ` ` torchelastic p p ` ` &#124; + -------------------------------------------- + -------------------------- + __init__ rdzv_impl EtcdRendezvous local_addr Optional str Args rdzv_impl implementation rendezvous local_addr local address current node _rdzv_impl = rdzv_impl _local_addr = local_addr __del__ TODO look into using weakref here instead del _rdzv_impl get_backend - str etcd next_rendezvous rdzv_version rank world_size = _rdzv_impl rendezvous_barrier logger info Creating EtcdStore c d Store implementation store = _rdzv_impl setup_kv_store rdzv_version bootstrap_store_info = RendezvousStoreInfo build rank store local_addr=self _local_addr RendezvousInfo store rank world_size bootstrap_store_info is_closed try _ state = _rdzv_impl get_rdzv_state state status == closed except etcd EtcdKeyNotFound No rendezvous state so cannot closed False set_closed _rdzv_impl set_closed num_nodes_waiting try _ state = _rdzv_impl get_rdzv_state state status == final state num_workers_waiting except etcd EtcdKeyNotFound pass get_run_id - str _rdzv_impl _run_id shutdown - bool try set_closed True except BaseException noqa B logger warning Shutdown failed exc_info=True False TODO we should probably handle few additional errors like EtcdLeaderElectionInProgress EtcdWatcherCleared These only relevant multi-node Etcd ensemble A simple retry would work verbose add everywhere Consider wrapping client calls into auto-retry these errors EtcdRendezvous A rendezvous implementation uses ` etcd https etcd io ` __ backend store __init__ client prefix run_id num_min_workers num_max_workers timeout last_call_timeout client = client logger info Etcd machines s client machines _prefix = prefix _run_id = run_id _num_min_workers = num_min_workers _num_max_workers = num_max_workers _timeout = timeout _last_call_timeout = last_call_timeout For cleaning up TTL refresher threads ephemeral keys _lease_run_id_stop = None _lease_this_rank_stop = None _prefix endswith _prefix += Setup permanent prefix dir didn t exist _prefix = create_path_if_not_exists _prefix Lease sub-root node specific job instance run_id create_path_if_not_exists get_path ttl=CONST_RUNID_SUBROOT_TTL _lease_run_id_stop = setup_lease_renewal get_path ttl=CONST_RUNID_SUBROOT_TTL Subdir all rendezvous work create_path_if_not_exists get_path rdzv Create rendezvous version counter doesn t exist try client write key=self get_path rdzv version_counter value= prevExist=False except etcd EtcdAlreadyExist pass __del__ TODO look into using weakref here instead _lease_run_id_stop None _lease_run_id_stop set _lease_this_rank_stop None _lease_this_rank_stop set rendezvous_barrier Main entry point next rendezvous This method blocking until rendezvous succeeds timeout occurs Returns ` ` rdzv_version rank world_size ` ` Raises RendezvousTimeoutError - timeout waiting rendezvous RendezvousClosedError - rendezvous closed while waiting RendezvousError - other persistent errors render rendezvous non-retryable _rendezvous_deadline = time time + _timeout while True time time _rendezvous_deadline raise RendezvousTimeoutError logger info Attempting join next rendezvous try Dis-own our lease previous rendezvous exists _lease_this_rank_stop None _lease_this_rank_stop set init_phase except EtcdRendezvousRetryImmediately The type failure suggests we can retry without delay pass except EtcdRendezvousRetryableFailure In case retryable failure wait small delay avoid spamming etcd time sleep except RendezvousTimeoutError logger info Rendezvous timeout occurred EtcdRendezvousHandler raise except RendezvousClosedError logger info Rendezvous run_id= s observed closed _run_id raise except RendezvousError raise except Exception e In case general exception wait small delay avoid spamming etcd FIXME there few things fall under like etcd EtcdKeyNotFound etc which could handled more explicitly logger info Rendezvous attempt failed will retry Reason s e noqa G time sleep init_phase Initially rendezvous state expected one empty non-existent - case we try create new one joinable - we try join final - we announce ourselves waiting go into monitoring mode Any other state considered transitional will retried after short delay Returns ` ` rdzv_version rank world_size ` ` Raises RendezvousClosedError - current rendezvous closed EtcdRendezvousRetryableFailure - observed some intermediate state which best handled retrying later try active_version = try_create_rendezvous state = json loads active_version value logger info New rendezvous state created s state except etcd EtcdAlreadyExist active_version state = get_rdzv_state Note possible above query fail etcd EtcdKeyNotFound ok us - just means we ll restart beginning logger info Observed existing rendezvous state s state state status == closed raise RendezvousClosedError state status == joinable join_phase state version state status == final handle_existing_rendezvous state version raise EtcdRendezvousRetryImmediately try_wait_for_state_change etcd_index=active_version etcd_index + raise EtcdRendezvousRetryableFailure join_phase expected_version We observed rendezvous state joinable state attempt join particular version then wait all other peers join Failure join will propagate exception causing re-entry active_version this_rank = join_rendezvous expected_version state = json loads active_version value logger info Joined rendezvous version s rank s Full state s state version this_rank state If worker first reach num_min_workers requirement rendezvous still joinable therefore elastic then worker will responsible waiting out last call timeout closing i e transitioning frozen rendezvous afterwards As safety against potential failure worker during last call timeout rendezvous state made ephemeral when min_num_workers reached this_rank == _num_min_workers - state status == joinable logger info Rank s responsible join last call this_rank last_call_deadline = time time + _last_call_timeout handle_join_last_call expected_version last_call_deadline logger info Rank s finished join last call this_rank Wait rendezvous state frozen which means fixed set peers logger info Waiting remaining peers active_version = wait_for_peers expected_version state = json loads active_version value assert state version == expected_version Logic error failed observe version mismatch confirm_phase expected_version this_rank confirm_phase expected_version this_rank Once rendezvous state transitions joinable frozen we have every participant confirm their membership setup per-member keep-alive TTL keys then wait all other participants confirm which would then successfully conclude rendezvous logger info All peers arrived Confirming membership confirm_membership expected_version this_rank logger info Waiting confirmations all peers active_version = wait_for_final expected_version state = json loads active_version value logger info Rendezvous version s complete Final state s state version state Rendezvous version number our rank world size state version this_rank len state participants handle_existing_rendezvous expected_version Handle case when there s existing state final rendezvous already place we have announce ourselves waiting wait until next rendezvous opportunity If state final - increment num_workers_waiting Then observe state changes s no longer final - bail out re-try keep alives missing destroy bail out active_state = announce_self_waiting expected_version logger info Added waiting list Rendezvous full state s active_state value wait_for_rendezvous_to_free expected_version logger info Previously existing rendezvous state changed Will re-try joining try_create_rendezvous Create new rendezvous state raise exception indicates unexpected state e g already exists Raises RendezvousError - unexpected state Initially active_version ephemeral - handle possibility might fail complete setup transaction i e transition setup - joinable active_version = client write key=self get_path rdzv active_version value=json dumps status setup prevExist=False ttl=CONST_ETCD_SETUP_TTL try version_counter = client get get_path rdzv version_counter version_counter value = str int version_counter value + client update version_counter except etcd EtcdKeyNotFound etcd EtcdCompareFailed e raise RendezvousError Unexpected state EtcdRendezvousHandler worker needs die e Any failure below results declaring retryable rendezvous failure The ephemeral rdzv active_version will expire someone can then re-try setup process Create directory node participant data client write key=self get_path f rdzv v_ version_counter value value=None dir=True prevExist=False Publish rendezvous version signal ready-to-be-joined If rendezvous set closed just before retry will happen where closed condition will handled client test_and_set key=self get_path rdzv active_version value=json dumps status joinable version version_counter value participants prev_value=active_version value join_rendezvous expected_version Helper method join phase Use compare-and-swap add rendezvous state while True cas_delay active_version state = get_rdzv_state state status = joinable raise EtcdRendezvousRetryableFailure Rendezvous state became non-joinable before we could join Must join next one state version = expected_version raise EtcdRendezvousRetryImmediately Rendezvous version changed Must try join new one assert len state participants _num_max_workers Logic error joinable rendezvous should always have space left this_rank = len state participants state participants append this_rank When reaching min workers changing state frozen we ll set active_version node ephemeral set_ttl Optional int = None len state participants == _num_max_workers state status = frozen state keep_alives = set_ttl = CONST_ETCD_FROZEN_TTL len state participants = _num_min_workers set_ttl = CONST_ETCD_JOINABLE_EPHEMERAL_TTL try Compare-and-swap active_version = client test_and_set key=self get_path rdzv active_version value=json dumps state prev_value=active_version value ttl=set_ttl We succeeded joining active_version this_rank except etcd EtcdCompareFailed logger info Join rendezvous CAS unsuccessful retrying wait_for_peers expected_version Helper method join phase active_version state = get_rdzv_state while True state status == frozen state version == expected_version Success all peers arrived active_version state status == joinable state version == expected_version Continue waiting any interesting events active_version state = try_wait_for_state_change etcd_index=active_version etcd_index + No valid transition possible point raise EtcdRendezvousRetryableFailure Rendezvous state transition no longer possible Must re-enter confirm_membership expected_version this_rank Helper method confirm phase Compare-and-swap loop while True cas_delay active_version state = get_rdzv_state state status = frozen raise EtcdRendezvousRetryImmediately Rendezvous no longer frozen before we confirmed Must join next one state version = expected_version raise EtcdRendezvousRetryImmediately Rendezvous version changed Must try join new one this_lease_key = get_path f rdzv v_ expected_version rank_ this_rank client set this_lease_key value=None ttl=CONST_WORKER_KEEPALIVE_TTL state keep_alives append this_lease_key len state keep_alives == len state participants Everyone confirmed rank last do so state status = final state num_workers_waiting = finalize = True finalize = False try Compare-and-swap If new state still frozen keep ephemeral active_version = client test_and_set key=self get_path rdzv active_version value=json dumps state prev_value=active_version value ttl=None finalize CONST_ETCD_FROZEN_TTL _lease_this_rank_stop = setup_lease_renewal this_lease_key ttl=CONST_WORKER_KEEPALIVE_TTL active_version except etcd EtcdCompareFailed logger info Confirm membership CAS unsuccessful retrying wait_for_final expected_version Helper method confirm phase active_version state = get_rdzv_state while True state status == final state version == expected_version Success This rendezvous final we accept active_version state status == frozen state version == expected_version Continue waiting any interesting events active_version state = try_wait_for_state_change etcd_index=active_version etcd_index + No valid transition possible point raise EtcdRendezvousRetryableFailure Rendezvous state transition no longer possible Must re-enter announce_self_waiting expected_version Announce worker waiting via num_workers_waiting counter join next rendezvous only state version match while True cas_delay active_version state = get_rdzv_state state status = final state version = expected_version raise EtcdRendezvousRetryImmediately Increment counter signal additional waiting worker state num_workers_waiting += try active_version = client test_and_set key=self get_path rdzv active_version value=json dumps state prev_value=active_version value active_version except etcd EtcdCompareFailed logger info Announce waiting CAS unsuccessful retrying wait_for_rendezvous_to_free expected_version When there s existing valid rendezvous state final we have wait until next opportunity join Such opportunity may come rendezvous state changed someone which case we unblock retry rendezvous becomes invalid because least one member failed renew their leased keep_alive node We detect destroy rendezvous active_version state = get_rdzv_state while True state status = final state version = expected_version Check current rendezvous state valid sense all its members alive renewing their lease If try destroy rendezvous so new one can created alive_members = client get get_path f rdzv v_ expected_version keep_alive_keys = ch key ch alive_members children key state keep_alives key keep_alive_keys This participant didn t renew their lease We ll declare rendezvous version dead only hadn t changed logger info Keep-alive key s renewed key logger info Rendezvous version s incomplete expected_version logger info Attempting destroy Compare-and-delete operation Throws compare failed which means rendezvous already destroyed re-created closed we can try re-enter barrier client delete key=self get_path rdzv active_version prevValue=active_version value logger info Destroyed rendezvous version s successfully expected_version We can retry immediately Existing rendezvous seems valid no reason destroy We just have wait until something changes re-check try overall_timeout = max _rendezvous_deadline - time time + client watch key=self get_path rdzv index=active_version etcd_index + recursive=True timeout=overall_timeout except etcd EtcdEventIndexCleared etcd EtcdWatchTimedOut pass time time _rendezvous_deadline raise RendezvousTimeoutError active_version state = get_rdzv_state handle_join_last_call expected_version deadline After we reach min number workers one particular worker takes responsibility waiting additional timeout before closing join window If worker responsible fails rendezvous will destroyed due expiring TTL other participants will re-rendezvous Here we expect see state joinable expected_version Exit gracefully either state becomes frozen expected_version timeout happens reaching deadline which case we try transition frozen expected_version Exit exception otherwise active_version state = get_rdzv_state while True state status == frozen state version == expected_version Worker set became frozen before last-call timeout This possible when num_max_workers reached before timeout state status = joinable state version = expected_version raise EtcdRendezvousRetryableFailure Rendezvous state transition no longer possible Must re-enter If timeout occurred attempt state transition joinable - frozen time time = deadline state status = frozen state keep_alives = try active_version = client test_and_set key=self get_path rdzv active_version value=json dumps state prev_value=active_version value ttl=CONST_ETCD_FROZEN_TTL We successfully made rendezvous frozen except etcd EtcdCompareFailed logger info Join last-call transition CAS unsuccessful Will retry cas_delay active_version state = get_rdzv_state continue Timeout did occur so we must refresh TTL wait further changes Note we only want TTL refreshed state still joinable hence we use CAS here even though we don t change any data try active_version = client test_and_set key=self get_path rdzv active_version value=active_version value prev_value=active_version value ttl=CONST_ETCD_JOINABLE_EPHEMERAL_TTL Minimize oversleeping timeout = min CONST_ETCD_JOINABLE_EPHEMERAL_TTL deadline - time time + Oversleeping s ok active_version state = try_wait_for_state_change etcd_index=active_version etcd_index + timeout=timeout except etcd EtcdCompareFailed logger info Join last-call TTL refresh CAS unsuccessful will retry cas_delay active_version state = get_rdzv_state set_closed Mark rendezvous closed current run_id which used signal other participants attempt perform re- rendezvous This useful when one workers decides job complete while True active_version state = get_rdzv_state state status == closed Already closed someone state status = closed try client test_and_set key=self get_path rdzv active_version value=json dumps state prev_value=active_version value except etcd EtcdCompareFailed logger info Set closed CAS unsuccessful retrying cas_delay get_rdzv_state active_version = client get key=self get_path rdzv active_version active_version json loads active_version value try_wait_for_state_change etcd_index timeout=None Don t sleep past overall deadline least more than s overall_timeout = max _rendezvous_deadline - time time + timeout = overall_timeout timeout None min timeout overall_timeout try client watch get_path rdzv active_version index=etcd_index timeout=timeout except etcd EtcdEventIndexCleared etcd EtcdWatchTimedOut pass time time _rendezvous_deadline raise RendezvousTimeoutError Unfortunately we have do another fetch order get last etcd_index get_rdzv_state get_path path path startswith path = + path f _prefix run_ _run_id path create_path_if_not_exists full_path ttl=None try client write key=full_path value=None dir=True prevExist=False ttl=ttl except etcd EtcdAlreadyExist pass setup_lease_renewal full_path ttl NOTE For ephemeral key TTL renewal ~lease work correctly make sure you don t call any long-blocking methods do release Python s GIL An example calling pybind extension function blocking long-running doing scoped release GIL lease_worker client path ttl stop_event while True try client refresh path ttl=ttl except etcd EtcdKeyNotFound break except ConnectionRefusedError This error usually occurs during test when server already got terminated python garbage collector have yet invoked __del__ method break stop_event wait timeout=ttl break lease_stop_event = threading Event lease_thread = threading Thread target=lease_worker args= client full_path ttl lease_stop_event lease_thread daemon = True lease_thread start lease_stop_event store_extra_data rdzv_version key value node = get_path f rdzv v_ rdzv_version extra_data try If first time we storing anything extra_data = client write key=node value=json dumps key value prevExist=False except etcd EtcdAlreadyExist pass CAS loop make sure we don t lose concurrent stores while True We never delete extra_data Failure here should fatal no special handling extra_data = client get node new_extra_data_value = json loads extra_data value new_extra_data_value key = value try extra_data = client test_and_set key=node value=json dumps new_extra_data_value prev_value=extra_data value except etcd EtcdCompareFailed logger info Store extra_data CAS unsuccessful retrying time sleep load_extra_data rdzv_version key timeout=None extra_data node itself directory located node = get_path f rdzv v_ rdzv_version extra_data node_dir = get_path f rdzv v_ rdzv_version TODO implement timeout https github com pytorch elastic issues while True Combined wait node itself key inside root = client get node_dir Find extra_data node exists extra_data = n n root children n key == node assert len extra_data = Node extra_data exists check desired key inside len extra_data == extra_data_dict = json loads extra_data value key extra_data_dict extra_data_dict key The extra_data node doesn t exist they key isn t published yet Wait interesting events extra_data node retry try client watch node index=root etcd_index + except etcd EtcdEventIndexCleared etcd EtcdWatchTimedOut pass setup_kv_store rdzv_version store_path = get_path f rdzv v_ rdzv_version kv create_path_if_not_exists store_path EtcdStore etcd_client=self client etcd_store_prefix=store_path _create_etcd_client params RendezvousParameters - etcd Client Create new ` ` etcd Client ` ` specified ` ` RendezvousParameters ` ` hostname port = parse_rendezvous_endpoint params endpoint The communication protocol protocol = params config get protocol protocol None protocol = http protocol = http protocol = https raise ValueError The etcd protocol must HTTP HTTPS The SSL client certificate ssl_cert = params config get cert ssl_cert None cert_key = params config get key cert_key None The etcd client expects certificate key second element ` cert ` tuple ssl_cert = ssl_cert cert_key The root certificate ca_cert = params config get cacert etcd Client hostname port protocol=protocol cert=ssl_cert ca_cert=ca_cert allow_reconnect=True Handler torch distributed static registration create_rdzv_handler params RendezvousParameters - RendezvousHandler Usage rdzv_params = RendezvousParameters backend= etcd endpoint= run_id= min_nodes= max_nodes= timeout= last_call_timeout= etcd_prefix= custom_prefix protocol= https cacert= etc kubernetes certs ca crt cert= etc kubernetes certs client crt key= etc kubernetes certs client key -- -- rdzv_params = RendezvousParameters backend= etcd endpoint= run_id= min_nodes= max_nodes= etcd_rdzv_handler = create_etcd_rendezvous_handler rdzv_params Where run_id - unique id training job instance min_nodes - min number workers expected join rendezvous max_nodes - max number workers allowed join rendezvous defaults min_workers specified timeout - total timeout within which next_rendezvous expected succeed RendezvousTimeoutError raised otherwise Defaults minutes last_call_timeout - additional wait amount last call after min number workers has been reached Defaults seconds etcd_prefix - path prefix etcd root inside which all etcd nodes will created Default torchelastic p p protocol - http default https access etcd cacert - CA cert access etcd only makes sense https cert - client cert access etcd only makes sense https key - client key access etcd only makes sense https client = _create_etcd_client params etcd_prefix = params get etcd_prefix torchelastic p p rdzv = EtcdRendezvous client=client prefix=etcd_prefix run_id=params run_id num_min_workers=params min_nodes num_max_workers=params max_nodes timeout=params get_as_int timeout _DEFAULT_TIMEOUT last_call_timeout=params get_as_int last_call_timeout _DEFAULT_LAST_CALL_TIMEOUT EtcdRendezvousHandler rdzv_impl=rdzv local_addr=params local_addr