__future__ annotations contextlib functools hashlib os re sys textwrap dataclasses is_dataclass enum auto Enum pathlib Path pprint pformat typing Any Generic TYPE_CHECKING TypeVar typing_extensions assert_never Self torchgen code_template CodeTemplate TYPE_CHECKING argparse Namespace collections abc Callable Iterable Iterator Sequence TORCHGEN_ROOT = Path __file__ absolute parent REPO_ROOT = TORCHGEN_ROOT parent Many these functions share logic defining both definition declaration example function signature same so we organize them into one function takes Target say which code we want This OPEN enum we may add more cases future so sure explicitly specify Literal Target XXX Literal Target XXX Target YYY what targets valid your use Target Enum top level namespace including DEFINITION = auto DECLARATION = auto TORCH_LIBRARY REGISTRATION = auto namespace ANONYMOUS_DEFINITION = auto namespace cpu NAMESPACED_DEFINITION = auto NAMESPACED_DECLARATION = auto Matches foo foo bar foobar Used search occurrence parameter derivative formula IDENT_REGEX = r ^ &#124; \W $ &#124; \W TODO Use real parser here will get bamboozled split_name_params schema str - tuple str list str m = re match r \w+ \ \w+ \ \ schema m None raise RuntimeError f Unsupported function schema schema name _ params = m groups name params split T = TypeVar T S = TypeVar S These two functions purposely generators analogy map so you don t mix up when you need list them Map over function may None omit Nones output sequence mapMaybe func Callable T S &#124; None xs Iterable T - Iterator S x xs r = func x r None yield r Map over function returns sequences cat them all together concatMap func Callable T Sequence S xs Iterable T - Iterator S x xs yield func x Conveniently add error context exceptions raised Lets us easily say error occurred while processing specific context contextlib contextmanager context msg_fn Callable str - Iterator None try yield except Exception e TODO does wrong thing KeyError msg = msg_fn msg = textwrap indent msg msg = f e args \n msg e args msg e args = msg + e args raise functools cache _read_template template_fn str - CodeTemplate CodeTemplate from_file template_fn String hash s stable across different executions unlike builtin hash string_stable_hash s str - int sha = hashlib sha s encode latin usedforsecurity=False digest int from_bytes sha byteorder= little A small abstraction writing out generated files keeping track what files have been written so you can write out list output files FileManager __init__ install_dir str &#124; Path template_dir str &#124; Path dry_run bool - None install_dir = Path install_dir template_dir = Path template_dir files set Path = set dry_run = dry_run property filenames - frozenset str frozenset file as_posix file files _write_if_changed filename str &#124; Path contents str - None file = Path filename old_contents str &#124; None = None try old_contents = file read_text encoding= utf- except OSError pass contents = old_contents Create output directory doesn t exist file parent mkdir parents=True exist_ok=True file write_text contents encoding= utf- Read template file replace pattern callable type could dict str substitute_with_template template_fn str &#124; Path env_callable Callable str &#124; dict str Any - str assert Path template_fn is_absolute f template_fn must relative template_fn template_path = template_dir template_fn env = env_callable isinstance env dict generated_comment env generator_default = TORCHGEN_ROOT gen py try generator = Path sys modules __main__ __file__ generator_default absolute except KeyError AttributeError generator = generator_default absolute try generator_path = generator relative_to REPO_ROOT as_posix except ValueError generator_path = generator name env = env copy original dict instead mutating generated_comment + f generated generator_path template_fn template = _read_template template_path substitute_out = template substitute env Ensure extra blank line between function definition docstring previous function definition NB It generally recommended have docstrings pyi stub files But there any we need ensure file properly formatted re sub r \n+ match triple quotes \s +\n match decorators any \s &#124; match function definition r \g \n\n\g substitute_out flags=re VERBOSE isinstance env str env assert_never env write_with_template filename str &#124; Path template_fn str &#124; Path env_callable Callable str &#124; dict str Any - None filename = Path filename assert filename is_absolute f filename must relative filename file = install_dir filename assert file files f duplicate file write file files add file dry_run substitute_out = substitute_with_template template_fn=template_fn env_callable=env_callable _write_if_changed filename=file contents=substitute_out write filename str &#124; Path env_callable Callable str &#124; dict str Any - None write_with_template filename filename env_callable write_sharded filename str &#124; Path items Iterable T key_fn Callable T str env_callable Callable T dict str list str num_shards int base_env dict str Any &#124; None = None sharded_keys set str - None write_sharded_with_template filename filename items key_fn=key_fn env_callable=env_callable num_shards=num_shards base_env=base_env sharded_keys=sharded_keys write_sharded_with_template filename str &#124; Path template_fn str &#124; Path items Iterable T key_fn Callable T str env_callable Callable T dict str list str num_shards int base_env dict str Any &#124; None = None sharded_keys set str - None file = Path filename assert file is_absolute f filename must relative filename everything dict str Any = shard_id Everything shards list dict str Any = shard_id f _ i i range num_shards all_shards = everything + shards base_env None shard all_shards shard update base_env key sharded_keys shard all_shards key shard assert isinstance shard key list sharded keys base_env must list shard key = shard key copy shard key = merge_env into dict str list str from_ dict str list str - None k v from_ items assert k sharded_keys f undeclared sharded key k into k += v dry_run Dry runs don t write any templates so incomplete environments fine items = item items key = key_fn item sid = string_stable_hash key num_shards env = env_callable item merge_env shards sid env merge_env everything env shard all_shards shard_id = shard shard_id write_with_template file with_stem f file stem shard_id template_fn lambda shard filenames used track compiled files FooEverything cpp isn t meant compiled files discard install_dir file with_stem f file stem Everything write_outputs variable_name str filename str &#124; Path - None Write file containing list all outputs which generated script content = \n join set variable_name Use POSIX paths avoid invalid escape sequences Windows f file as_posix file sorted files _write_if_changed filename content template_dir_for_comments - str This needs deterministic The template dir absolute path varies across builds So just use path relative file which will point codegen source will stable os path relpath template_dir os path dirname __file__ Helper function generate file manager make_file_manager options Namespace install_dir str &#124; Path &#124; None = None - FileManager template_dir = os path join options source_path templates install_dir = install_dir install_dir options install_dir FileManager install_dir=install_dir template_dir=template_dir dry_run=options dry_run Helper function create pretty representation dataclasses dataclass_repr obj Any indent int = width int = - str pformat obj indent width _format_dict attr dict Any Any indent int width int curr_indent int - str curr_indent += indent + dict_repr = k v attr items k_repr = repr k v_str = pformat v indent width curr_indent + len k_repr is_dataclass v repr v dict_repr append f k_repr v_str _format dict_repr indent width curr_indent _format_list attr list Any &#124; set Any &#124; tuple Any indent int width int curr_indent int - str curr_indent += indent + list_repr = pformat l indent width curr_indent is_dataclass l repr l l attr start end = isinstance attr list _format list_repr indent width curr_indent start end _format fields_str list str indent int width int curr_indent int start str end str - str delimiter curr_indent_str = exceed max width then we place one element per line len repr fields_str = width delimiter = \n curr_indent_str = curr_indent indent_str = indent body = f delimiter curr_indent_str join fields_str f start indent_str body end NamespaceHelper A helper constructing namespace open close strings nested set namespaces e g namespace_str torch lazy prologue namespace torch namespace lazy epilogue namespace lazy namespace torch __init__ namespace_str str entity_name str = max_level int = - None cpp_namespace can colon joined string such torch lazy cpp_namespaces = namespace_str split assert len cpp_namespaces = max_level f Codegen doesn t support more than max_level level s custom namespace Got namespace_str cpp_namespace_ = namespace_str prologue_ = \n join f namespace n n cpp_namespaces epilogue_ = \n join f namespace n n reversed cpp_namespaces namespaces_ = cpp_namespaces entity_name_ = entity_name staticmethod from_namespaced_entity namespaced_entity str max_level int = - NamespaceHelper Generate helper nested namespaces long function name E g torch lazy add names = namespaced_entity split entity_name = names - namespace_str = join names - NamespaceHelper namespace_str=namespace_str entity_name=entity_name max_level=max_level property prologue - str prologue_ property epilogue - str epilogue_ property entity_name - str entity_name_ Only allow certain level namespaces get_cpp_namespace default str = - str Return namespace string joining all namespaces hence no leading Return default namespace string empty cpp_namespace_ cpp_namespace_ default OrderedSet Generic T storage dict T None __init__ iterable Iterable T &#124; None = None - None iterable None storage = storage = dict fromkeys iterable __contains__ item T - bool item storage __iter__ - Iterator T iter storage keys update items OrderedSet T - None storage update items storage add item T - None storage item = None copy - OrderedSet T ret OrderedSet T = OrderedSet ret storage = storage copy ret staticmethod union args OrderedSet T - OrderedSet T ret = args copy s args ret update s ret __or__ other OrderedSet T - OrderedSet T OrderedSet union other __ior__ other OrderedSet T - Self update other __eq__ other object - bool isinstance other OrderedSet storage == other storage set storage keys == other