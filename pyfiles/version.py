This file dual licensed under terms Apache License Version BSD License See LICENSE file root repository complete details testsetup packaging version parse Version itertools re typing Any Callable NamedTuple Optional SupportsInt Tuple Union _structures Infinity InfinityType NegativeInfinity NegativeInfinityType __all__ = VERSION_PATTERN parse Version InvalidVersion LocalType = Tuple Union int str CmpPrePostDevType = Union InfinityType NegativeInfinityType Tuple str int CmpLocalType = Union NegativeInfinityType Tuple Union Tuple int str Tuple NegativeInfinityType Union int str CmpKey = Tuple int Tuple int CmpPrePostDevType CmpPrePostDevType CmpPrePostDevType CmpLocalType VersionComparisonMethod = Callable CmpKey CmpKey bool _Version NamedTuple epoch int release Tuple int dev Optional Tuple str int pre Optional Tuple str int post Optional Tuple str int local Optional LocalType parse version str - Version Parse given version string parse dev Version dev param version The version string parse raises InvalidVersion When version string valid version Version version InvalidVersion ValueError Raised when version string valid version Version invalid Traceback most recent call last packaging version InvalidVersion Invalid version invalid _BaseVersion _key Tuple Any __hash__ - int hash _key Please keep duplicated ` isinstance ` check six comparisons hereunder unless you find way avoid adding overhead function calls __lt__ other _BaseVersion - bool isinstance other _BaseVersion NotImplemented _key other _key __le__ other _BaseVersion - bool isinstance other _BaseVersion NotImplemented _key = other _key __eq__ other object - bool isinstance other _BaseVersion NotImplemented _key == other _key __ge__ other _BaseVersion - bool isinstance other _BaseVersion NotImplemented _key = other _key __gt__ other _BaseVersion - bool isinstance other _BaseVersion NotImplemented _key other _key __ne__ other object - bool isinstance other _BaseVersion NotImplemented _key = other _key Deliberately anchored start end string make easier rd party code reuse _VERSION_PATTERN = r v P epoch - + epoch P release - + \ - + release segment P pre pre-release -_\ P pre_l alpha &#124; &#124; beta &#124; b &#124; preview &#124; pre &#124; c &#124; rc -_\ P pre_n - + P post post release - P post_n - + &#124; -_\ P post_l post &#124; rev &#124; r -_\ P post_n - + P dev dev release -_\ P dev_l dev -_\ P dev_n - + \+ P local a-z - + -_\ a-z - + local version VERSION_PATTERN = _VERSION_PATTERN A string containing regular expression used match valid version The pattern anchored either end intended embedding larger expressions example matching version number part file name The regular expression should compiled ` ` re VERBOSE ` ` ` ` re IGNORECASE ` ` flags set meta hide-value Version _BaseVersion This abstracts handling project s versions A ` Version ` instance comparison aware can compared sorted using standard Python interfaces v = Version v = Version v Version v Version v v True v == v False v v False v = v False v = v True _regex = re compile r ^\s + VERSION_PATTERN + r \s $ re VERBOSE &#124; re IGNORECASE _key CmpKey __init__ version str - None Initialize Version object param version The string representation version which will parsed normalized before use raises InvalidVersion If ` ` version ` ` does conform PEP any way then exception will raised Validate version parse into pieces match = _regex search version match raise InvalidVersion f Invalid version version Store parsed out pieces version _version = _Version epoch=int match group epoch match group epoch release=tuple int i i match group release split pre=_parse_letter_version match group pre_l match group pre_n post=_parse_letter_version match group post_l match group post_n match group post_n dev=_parse_letter_version match group dev_l match group dev_n local=_parse_local_version match group local Generate key which will used sorting _key = _cmpkey _version epoch _version release _version pre _version post _version dev _version local __repr__ - str A representation Version shows all internal state Version Version f Version __str__ - str A string representation version can rounded-tripped str Version parts = Epoch epoch = parts append f epoch Release segment parts append join str x x release Pre-release pre None parts append join str x x pre Post-release post None parts append f post post Development release dev None parts append f dev dev Local version segment local None parts append f + local join parts property epoch - int The epoch version Version epoch Version epoch _version epoch property release - Tuple int The components release segment version Version release Version release Version post release Includes trailing zeroes epoch any pre-release development post-release suffixes _version release property pre - Optional Tuple str int The pre-release segment version print Version pre None Version pre Version b pre b Version rc pre rc _version pre property post - Optional int The post-release number version print Version post None Version post post _version post _version post None property dev - Optional int The development number version print Version dev None Version dev dev _version dev _version dev None property local - Optional str The local version segment version print Version local None Version +abc local abc _version local join str x x _version local None property public - str The public portion version Version public Version +abc public Version +abc dev public str split + property base_version - str The base version version Version base_version Version +abc base_version Version +abc dev base_version The base version public version project without any pre post release markers parts = Epoch epoch = parts append f epoch Release segment parts append join str x x release join parts property is_prerelease - bool Whether version pre-release Version is_prerelease False Version is_prerelease True Version b is_prerelease True Version rc is_prerelease True Version dev is_prerelease True dev None pre None property is_postrelease - bool Whether version post-release Version is_postrelease False Version post is_postrelease True post None property is_devrelease - bool Whether version development release Version is_devrelease False Version dev is_devrelease True dev None property major - int The first item attr ` release ` ` ` ` ` unavailable Version major release len release = property minor - int The second item attr ` release ` ` ` ` ` unavailable Version minor Version minor release len release = property micro - int The third item attr ` release ` ` ` ` ` unavailable Version micro Version micro release len release = _parse_letter_version letter Optional str number Union str bytes SupportsInt None - Optional Tuple str int letter We consider there implicit pre-release there numeral associated number None number = We normalize any letters their lower case form letter = letter lower We consider some words alternate spellings other words those cases we want normalize spellings our preferred spelling letter == alpha letter = letter == beta letter = b letter c pre preview letter = rc letter rev r letter = post letter int number letter number We assume we given number we given letter then using implicit post release syntax e g - letter = post letter int number None _local_version_separators = re compile r \ _- _parse_local_version local Optional str - Optional LocalType Takes string like abc twelve turns into abc twelve local None tuple part lower part isdigit int part part _local_version_separators split local None _cmpkey epoch int release Tuple int pre Optional Tuple str int post Optional Tuple str int dev Optional Tuple str int local Optional LocalType - CmpKey When we compare release version we want compare all trailing zeros removed So we ll use reverse list drop all now leading zeros until we come something non zero then take rest re-reverse back into correct order make tuple use our sorting key _release = tuple reversed list itertools dropwhile lambda x x == reversed release We need trick sorting algorithm put dev before We ll do abusing pre segment we _only_ want do there pre post segment If we have one those then normal sorting rules will handle case correctly pre None post None dev None _pre CmpPrePostDevType = NegativeInfinity Versions without pre-release except noted above should sort after those one pre None _pre = Infinity _pre = pre Versions without post segment should sort before those one post None _post CmpPrePostDevType = NegativeInfinity _post = post Versions without development segment should sort after those one dev None _dev CmpPrePostDevType = Infinity _dev = dev local None Versions without local segment should sort before those one _local CmpLocalType = NegativeInfinity Versions local segment need segment parsed implement sorting rules PEP - Alpha numeric segments sort before numeric segments - Alpha numeric segments sort lexicographically - Numeric segments sort numerically - Shorter versions sort before longer versions when prefixes match exactly _local = tuple i isinstance i int NegativeInfinity i i local epoch _release _pre _post _dev _local