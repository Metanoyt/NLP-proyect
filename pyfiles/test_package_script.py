Owner s oncall package deploy io BytesIO textwrap dedent unittest skipIf torch torch package PackageExporter PackageImporter torch testing _internal common_utils IS_FBCODE IS_SANDCASTLE run_tests skipIfTorchDynamo try common PackageTestCase except ImportError Support case where we run file directly common PackageTestCase try torchvision models resnet HAS_TORCHVISION = True except ImportError HAS_TORCHVISION = False skipIfNoTorchVision = skipIf HAS_TORCHVISION no torchvision TestPackageScript PackageTestCase Tests compatibility TorchScript test_package_interface Packaging interface should work correctly package_a fake_interface fake uses_interface = fake UsesInterface scripted = torch jit script uses_interface scripted proxy_mod = torch jit script fake NewModule buffer = BytesIO PackageExporter buffer pe pe intern pe save_pickle model model pkl uses_interface buffer seek package_importer = PackageImporter buffer loaded = package_importer load_pickle model model pkl scripted_loaded = torch jit script loaded scripted_loaded proxy_mod = torch jit script fake NewModule input = torch tensor assertEqual scripted input scripted_loaded input test_different_package_interface Test case where interface defined package different than one defined loading environment make sure TorchScript can distinguish between two Import one version interface package_a fake_interface fake Simulate package contains different version interface exact same name buffer = BytesIO PackageExporter buffer pe pe save_source_string fake __name__ dedent \ torch torch Tensor torch jit interface ModuleInterface torch nn Module one inp Tensor - Tensor pass ImplementsInterface torch nn Module one inp Tensor - Tensor inp + UsesInterface torch nn Module proxy_mod ModuleInterface __init__ - None super __init__ proxy_mod = ImplementsInterface forward input Tensor - Tensor proxy_mod one input buffer seek package_importer = PackageImporter buffer diff_fake = package_importer import_module fake __name__ We should able script successfully torch jit script diff_fake UsesInterface test_package_script_class package_a fake_script_class fake buffer = BytesIO PackageExporter buffer pe pe save_module fake __name__ buffer seek package_importer = PackageImporter buffer loaded = package_importer import_module fake __name__ input = torch tensor assertTrue torch allclose fake uses_script_class input loaded uses_script_class input test_package_script_class_referencing_self package_a fake_script_class fake obj = fake UsesIdListFeature intentionally script here fill compilation cache make sure there no false sharing between scripted types coming package vs outside environment torch jit script obj buffer = BytesIO PackageExporter buffer exporter exporter intern exporter save_pickle obj obj pkl obj buffer seek importer = PackageImporter buffer obj_loaded = importer load_pickle obj obj pkl scripted_obj_loaded = torch jit script obj_loaded Make sure scripted object can serialized without error buffer = scripted_obj_loaded save_to_buffer torch jit load BytesIO buffer test_different_package_script_class Test case where script defined package different than one defined loading environment make sure TorchScript can distinguish between two package_a fake_script_class fake Simulate package contains different version script attribute ` bar ` instead ` foo ` buffer = BytesIO PackageExporter buffer pe pe save_source_string fake __name__ dedent \ torch torch jit script MyScriptClass __init__ x bar = x buffer seek package_importer = PackageImporter buffer diff_fake = package_importer import_module fake __name__ input = torch rand loaded_script_class = diff_fake MyScriptClass input orig_script_class = fake MyScriptClass input assertEqual loaded_script_class bar orig_script_class foo test_save_scriptmodule Test basic saving ScriptModule package_a test_module ModWithTensor scripted_mod = torch jit script ModWithTensor torch rand buffer = BytesIO PackageExporter buffer e e save_pickle res mod pkl scripted_mod buffer seek importer = PackageImporter buffer loaded_mod = importer load_pickle res mod pkl map_location= cpu input = torch rand assertEqual loaded_mod input scripted_mod input skipIf IS_FBCODE IS_SANDCASTLE Tests use temporary files disabled fbcode test_save_scriptmodule_file Test basic saving ScriptModule file package_a test_module ModWithTensor scripted_mod = torch jit script ModWithTensor torch rand filename = temp PackageExporter filename e e save_pickle res mod pkl scripted_mod importer = PackageImporter filename loaded_mod = importer load_pickle res mod pkl input = torch rand assertEqual loaded_mod input scripted_mod input test_save_scriptmodule_with_submods Test basic saving ScriptModule submodule package_a test_module ModWithSubmod ModWithTensor scripted_mod = torch jit script ModWithSubmod ModWithTensor torch rand buffer = BytesIO PackageExporter buffer e e save_pickle res mod pkl scripted_mod buffer seek importer = PackageImporter buffer loaded_mod = importer load_pickle res mod pkl map_location= cpu input = torch rand assertEqual loaded_mod input scripted_mod input test_save_scriptmodules_submod_redefinition Test verify saving multiple ScriptModules same top module different submodules works Submodule redefined between defintion top module check different concrete types modules thoroughly recognized serializaiton code Submod torch nn Module forward input str input = input + _submod input TopMod torch nn Module __init__ - None super __init__ modB = Submod forward input str modB input scripted_mod_ = torch jit script TopMod redefinition intentional change single inner string string attribute should trigger new module type Submod torch nn Module noqa F forward input str input = input + _submod changed input scripted_mod_ = torch jit script TopMod buffer = BytesIO PackageExporter buffer e e save_pickle res mod pkl scripted_mod_ e save_pickle res mod pkl scripted_mod_ buffer seek importer = PackageImporter buffer loaded_mod_ = importer load_pickle res mod pkl loaded_mod_ = importer load_pickle res mod pkl assertEqual loaded_mod_ input scripted_mod_ input assertEqual loaded_mod_ input scripted_mod_ input assertNotEqual loaded_mod_ input loaded_mod_ input test_save_independent_scriptmodules Test verify saving multiple ScriptModules completely separate code works package_a test_module ModWithTensor SimpleTest scripted_mod_ = torch jit script SimpleTest scripted_mod_ = torch jit script ModWithTensor torch rand buffer = BytesIO PackageExporter buffer e e save_pickle res mod pkl scripted_mod_ e save_pickle res mod pkl scripted_mod_ buffer seek importer = PackageImporter buffer loaded_mod_ = importer load_pickle res mod pkl loaded_mod_ = importer load_pickle res mod pkl input = torch rand assertEqual loaded_mod_ input scripted_mod_ input assertEqual loaded_mod_ input scripted_mod_ input test_save_repeat_scriptmodules Test verify saving multiple different modules repeats same scriptmodule package works Also tests PyTorchStreamReader isn t having code hidden PyTorchStreamWriter writing ScriptModule code files multiple times package_a test_module ModWithSubmodAndTensor ModWithTensor SimpleTest scripted_mod_ = torch jit script SimpleTest scripted_mod_ = torch jit script ModWithTensor torch rand scripted_mod_ = torch jit script ModWithSubmodAndTensor torch rand ModWithTensor torch rand buffer = BytesIO PackageExporter buffer e e save_pickle res mod pkl scripted_mod_ e save_pickle res mod pkl scripted_mod_ e save_pickle res mod pkl scripted_mod_ e save_pickle res mod pkl scripted_mod_ e save_pickle res mod pkl scripted_mod_ buffer seek importer = PackageImporter buffer loaded_mod_ = importer load_pickle res mod pkl loaded_mod_ = importer load_pickle res mod pkl loaded_mod_ = importer load_pickle res mod pkl input = torch rand assertEqual loaded_mod_ input scripted_mod_ input assertEqual loaded_mod_ input scripted_mod_ input assertEqual loaded_mod_ input scripted_mod_ input test_scriptmodules_repeat_save Test verify saving loading same ScriptModule object works across multiple packages package_a test_module ModWithSubmodAndTensor ModWithTensor scripted_mod_ = torch jit script ModWithTensor torch rand scripted_mod_ = torch jit script ModWithSubmodAndTensor torch rand ModWithTensor torch rand buffer_ = BytesIO PackageExporter buffer_ e e save_pickle res mod pkl scripted_mod_ buffer_ seek importer_ = PackageImporter buffer_ loaded_module_ = importer_ load_pickle res mod pkl buffer_ = BytesIO PackageExporter buffer_ e e save_pickle res mod pkl scripted_mod_ e save_pickle res mod pkl loaded_module_ buffer_ seek importer_ = PackageImporter buffer_ loaded_module_ = importer_ load_pickle res mod pkl reloaded_module_ = importer_ load_pickle res mod pkl input = torch rand assertEqual loaded_module_ input scripted_mod_ input assertEqual loaded_module_ input reloaded_module_ input assertEqual loaded_module_ input scripted_mod_ input skipIfNoTorchVision test_save_scriptmodule_only_necessary_code Test verify when saving multiple packages same CU packages don t include unnecessary torchscript code files The TorchVision code should only saved package relies package_a test_module ModWithTensor ModWithTorchVision torch nn Module __init__ name str super __init__ tvmod = resnet forward input input scripted_mod_ = torch jit script ModWithTorchVision foo scripted_mod_ = torch jit script ModWithTensor torch rand buffer_ = BytesIO PackageExporter buffer_ e e save_pickle res mod pkl scripted_mod_ buffer_ seek importer_ = PackageImporter buffer_ buffer_ = BytesIO PackageExporter buffer_ e e save_pickle res mod pkl scripted_mod_ buffer_ seek importer_ = PackageImporter buffer_ assertTrue torchvision str importer_ file_structure assertFalse torchvision str importer_ file_structure test_save_scriptmodules_in_container Test saving ScriptModules inside container Checks relations between shared modules upheld package_a test_module ModWithSubmodAndTensor ModWithTensor scripted_mod_a = torch jit script ModWithTensor torch rand scripted_mod_b = torch jit script ModWithSubmodAndTensor torch rand scripted_mod_a script_mods_list = scripted_mod_a scripted_mod_b buffer = BytesIO PackageExporter buffer e e save_pickle res list pkl script_mods_list buffer seek importer = PackageImporter buffer loaded_mod_list = importer load_pickle res list pkl input = torch rand assertEqual loaded_mod_list input scripted_mod_a input assertEqual loaded_mod_list input scripted_mod_b input test_save_eager_mods_sharing_scriptmodule Test saving single ScriptModule shared multiple eager modules ScriptModule should saved just once even though contained multiple pickles package_a test_module ModWithSubmod SimpleTest scripted_mod = torch jit script SimpleTest mod = ModWithSubmod scripted_mod mod = ModWithSubmod scripted_mod buffer = BytesIO PackageExporter buffer e e intern e save_pickle res mod pkl mod e save_pickle res mod pkl mod buffer seek importer = PackageImporter buffer file_structure = importer file_structure assertTrue file_structure has_file data ts_code assertFalse file_structure has_file data ts_code test_load_shared_scriptmodules Test loading single ScriptModule shared multiple eager modules single pickle ScriptModule objects should same package_a test_module ModWithMultipleSubmods ModWithSubmod SimpleTest scripted_mod = torch jit script SimpleTest mod = ModWithSubmod scripted_mod mod = ModWithSubmod scripted_mod mod_parent = ModWithMultipleSubmods mod mod buffer = BytesIO PackageExporter buffer e e intern e save_pickle res mod pkl mod_parent buffer seek importer = PackageImporter buffer loaded_mod = importer load_pickle res mod pkl assertTrue id loaded_mod mod script_mod == id loaded_mod mod script_mod skipIfTorchDynamo unexplained failure Can t pickle Tensor object test_save_shared_tensors Test tensors shared across eager ScriptModules serialized once package_a test_module ModWithSubmodAndTensor ModWithTensor shared_tensor = torch rand scripted_mod = torch jit script ModWithTensor shared_tensor mod = ModWithSubmodAndTensor shared_tensor scripted_mod mod = ModWithSubmodAndTensor shared_tensor scripted_mod buffer = BytesIO PackageExporter buffer e e intern e save_pickle res tensor shared_tensor e save_pickle res mod pkl mod e save_pickle res mod pkl mod buffer seek importer = PackageImporter buffer loaded_mod_ = importer load_pickle res mod pkl assert there only one storage stored package file_structure = importer file_structure include= data storage assertTrue len file_structure children data children == input = torch rand assertEqual loaded_mod_ input mod input test_load_shared_tensors Test tensors shared across eager ScriptModules load same package_a test_module ModWithTensor ModWithTwoSubmodsAndTensor shared_tensor = torch ones scripted_mod_ = torch jit script ModWithTensor shared_tensor scripted_mod_ = torch jit script ModWithTensor shared_tensor mod = ModWithTwoSubmodsAndTensor shared_tensor scripted_mod_ scripted_mod_ assertEqual shared_tensor storage _cdata scripted_mod_ tensor storage _cdata assertEqual shared_tensor storage _cdata scripted_mod_ tensor storage _cdata buffer = BytesIO PackageExporter buffer e e intern e save_pickle res mod pkl mod buffer seek importer = PackageImporter buffer loaded_mod_ = importer load_pickle res mod pkl assertEqual loaded_mod_ tensor storage _cdata loaded_mod_ sub_mod_ tensor storage _cdata assertEqual loaded_mod_ tensor storage _cdata loaded_mod_ sub_mod_ tensor storage _cdata loaded_mod_ tensor add_ torch ones assertTrue torch allclose loaded_mod_ tensor loaded_mod_ sub_mod_ tensor assertTrue torch allclose loaded_mod_ tensor loaded_mod_ sub_mod_ tensor test_load_shared_tensors_repackaged Test tensors shared across eager ScriptModules load same across multiple package saves loads This important test because all tensor information restored python between packages The python identity maintained backing cpp TensorImpl We load save storages based off cpp TensorImpl python identity package_a test_module ModWithTensor ModWithTwoSubmodsAndTensor shared_tensor = torch ones scripted_mod_ = torch jit script ModWithTensor shared_tensor scripted_mod_ = torch jit script ModWithTensor shared_tensor mod = ModWithTwoSubmodsAndTensor shared_tensor scripted_mod_ scripted_mod_ buffer_ = BytesIO PackageExporter buffer_ e e intern e save_pickle res mod pkl mod buffer_ seek importer_ = PackageImporter buffer_ loaded_mod_ = importer_ load_pickle res mod pkl buffer_ = BytesIO PackageExporter buffer_ importer=importer_ e e intern e save_pickle res mod pkl loaded_mod_ buffer_ seek importer = PackageImporter buffer_ loaded_mod_ = importer load_pickle res mod pkl assertEqual loaded_mod_ tensor storage _cdata loaded_mod_ sub_mod_ tensor storage _cdata assertEqual loaded_mod_ tensor storage _cdata loaded_mod_ sub_mod_ tensor storage _cdata loaded_mod_ tensor add_ torch ones all tensors should reflect change assertTrue torch allclose loaded_mod_ tensor loaded_mod_ sub_mod_ tensor assertTrue torch allclose loaded_mod_ tensor loaded_mod_ sub_mod_ tensor test_saving_and_scripting_packaged_mod Test scripting module loaded package saving new package script object package_a test_module SimpleTest orig_mod = SimpleTest buffer_ = BytesIO PackageExporter buffer_ e e intern e save_pickle model model pkl orig_mod buffer_ seek importer_ = PackageImporter buffer_ loaded_mod = importer_ load_pickle model model pkl input = torch rand assertEqual loaded_mod input orig_mod input scripted_mod = torch jit script loaded_mod buffer_ = BytesIO PackageExporter buffer_ importer=importer_ e e intern e save_pickle res scripted_mod pkl scripted_mod buffer_ seek importer_ = PackageImporter buffer_ loaded_mod_scripted = importer_ load_pickle res scripted_mod pkl assertEqual loaded_mod_scripted input orig_mod input test_mixing_packaged_and_inline_modules Test saving inline imported modules same package independent code InlineMod torch nn Module __init__ name str super __init__ name = name tensor = torch rand forward input str input = input + _modInline + name input tensor inline_mod = InlineMod inline scripted_inline = torch jit script inline_mod package_a test_module SimpleTest imported_mod = SimpleTest scripted_imported = torch jit script imported_mod buffer = BytesIO PackageExporter buffer e e save_pickle model inline pkl scripted_inline e save_pickle model imported pkl scripted_imported buffer seek importer = PackageImporter buffer loaded_inline = importer load_pickle model inline pkl loaded_imported = importer load_pickle model imported pkl input = torch rand assertEqual loaded_imported input imported_mod input assertEqual loaded_inline input inline_mod input skipIfNoTorchVision test_mixing_packaged_and_inline_modules_shared_code Test saving inline imported modules same package share code TorchVisionTestInline torch nn Module __init__ - None super __init__ tvmod = resnet forward x x = a_non_torch_leaf x x torch relu x + a_non_torch_leaf b + b inline_mod = TorchVisionTestInline scripted_inline = torch jit script inline_mod package_c test_module TorchVisionTest imported_mod = TorchVisionTest scripted_imported = torch jit script imported_mod buffer = BytesIO PackageExporter buffer e e save_pickle model inline pkl scripted_inline e save_pickle model imported pkl scripted_imported buffer seek importer = PackageImporter buffer loaded_inline = importer load_pickle model inline pkl loaded_imported = importer load_pickle model imported pkl input = torch rand assertEqual loaded_imported input imported_mod input assertEqual loaded_inline input inline_mod input test_tensor_sharing_pickle Test saving ScriptModule separately saving tensor object causes no issues M torch nn Module __init__ - None super __init__ foo = torch ones forward foo scripted_m = torch jit script M original_tensor = torch ones f = BytesIO torch package PackageExporter f exporter exporter save_pickle model model pkl scripted_m exporter save_pickle model input pkl original_tensor f seek Should able load correctly importer = PackageImporter f loaded_m = importer load_pickle model model pkl loaded_tensor = importer load_pickle model input pkl assertEqual scripted_m foo loaded_m foo assertEqual original_tensor loaded_tensor __name__ == __main__ run_tests