usr bin env python NB following functions used Meta-internal workflows github_first_try_merge my_handler py thus have functionality limitations no ` git ` command access no network access besides strict allow list find_matching_merge_rule read_merge_rules Also any signature changes these functions well changes ` GitHubPR ` will likely require corresponding changes internal workflows base json os re time urllib parse collections defaultdict collections abc Iterable dataclasses dataclass functools cache pathlib Path re Pattern typing Any Callable cast NamedTuple Optional warnings warn yaml github_utils gh_close_pr gh_fetch_json_list gh_fetch_merge_base gh_fetch_url gh_graphql gh_post_commit_comment gh_post_pr_comment gh_update_pr_state GitHubComment gitutils are_ghstack_branches_in_sync get_git_remote_name get_git_repo_dir GitRepo patterns_to_regex retries_decorator label_utils gh_add_labels gh_remove_label has_required_labels LABEL_ERR_MSG trymerge_explainer get_revert_message TryMergeExplainer labels MERGE_IN_PROGRESS_LABEL = merging MERGE_COMPLETE_LABEL = merged JobCheckState NamedTuple name str url str status Optional str classification Optional str job_id Optional int title Optional str summary Optional str JobNameToStateDict = dict str JobCheckState WorkflowCheckState __init__ name str url str run_id int status Optional str name str = name url str = url run_id int = run_id status Optional str = status jobs JobNameToStateDict = GH_PR_REVIEWS_FRAGMENT = fragment PRReviews PullRequestReviewConnection nodes author login bodyText createdAt authorAssociation editor login databaseId url state pageInfo startCursor hasPreviousPage GH_CHECKSUITES_FRAGMENT = fragment PRCheckSuites CheckSuiteConnection edges node workflowRun workflow name databaseId databaseId url checkRuns first nodes name conclusion detailsUrl databaseId title summary pageInfo endCursor hasNextPage conclusion cursor pageInfo hasNextPage GH_COMMIT_AUTHORS_FRAGMENT = fragment CommitAuthors PullRequestCommitConnection nodes commit authors first nodes user login email name oid pageInfo endCursor hasNextPage GH_GET_PR_INFO_QUERY = GH_PR_REVIEWS_FRAGMENT + GH_CHECKSUITES_FRAGMENT + GH_COMMIT_AUTHORS_FRAGMENT + query $ owner String $ name String $ number Int repository owner $ owner name $ name pullRequest number $ number closed isCrossRepository author login title body headRefName headRepository nameWithOwner baseRefName baseRefOid baseRepository nameWithOwner isPrivate defaultBranchRef name mergeCommit oid commits_with_authors commits first CommitAuthors totalCount commits last nodes commit checkSuites first PRCheckSuites status contexts context state targetUrl oid changedFiles files first nodes path pageInfo endCursor hasNextPage reviews last PRReviews comments last nodes bodyText createdAt author login url authorAssociation editor login databaseId url pageInfo startCursor hasPreviousPage labels first edges node name GH_GET_PR_NEXT_FILES_QUERY = query $ owner String $ name String $ number Int $ cursor String repository name $ name owner $ owner pullRequest number $ number files first after $ cursor nodes path pageInfo endCursor hasNextPage GH_GET_PR_NEXT_CHECKSUITES = GH_CHECKSUITES_FRAGMENT + query $ owner String $ name String $ number Int $ cursor String repository name $ name owner $ owner pullRequest number $ number commits last nodes commit oid checkSuites first after $ cursor PRCheckSuites GH_GET_PR_NEXT_CHECK_RUNS = query $ owner String $ name String $ number Int $ cs_cursor String $ cr_cursor String repository name $ name owner $ owner pullRequest number $ number commits last nodes commit oid checkSuites first after $ cs_cursor nodes checkRuns first after $ cr_cursor nodes name conclusion detailsUrl databaseId title summary pageInfo endCursor hasNextPage GH_GET_PR_PREV_COMMENTS = query $ owner String $ name String $ number Int $ cursor String repository name $ name owner $ owner pullRequest number $ number comments last before $ cursor nodes bodyText createdAt author login authorAssociation editor login databaseId url pageInfo startCursor hasPreviousPage This query needs read-org permission GH_GET_TEAM_MEMBERS_QUERY = query $ org String $ name String $ cursor String organization login $ org team slug $ name members first after $ cursor nodes login pageInfo hasNextPage endCursor GH_GET_PR_NEXT_AUTHORS_QUERY = GH_COMMIT_AUTHORS_FRAGMENT + query $ owner String $ name String $ number Int $ cursor String repository name $ name owner $ owner pullRequest number $ number commits_with_authors commits first after $ cursor CommitAuthors GH_GET_PR_PREV_REVIEWS_QUERY = GH_PR_REVIEWS_FRAGMENT + query $ owner String $ name String $ number Int $ cursor String repository name $ name owner $ owner pullRequest number $ number reviews last before $ cursor PRReviews GH_GET_REPO_SUBMODULES = query $ owner String $ name String repository owner $ owner name $ name submodules first nodes path pageInfo endCursor hasNextPage RE_GHSTACK_HEAD_REF = re compile r ^ gh ^ + - + head$ RE_GHSTACK_DESC = re compile r Stack \r \n \ ^\r\n +\r \n + re MULTILINE RE_PULL_REQUEST_RESOLVED = re compile r Pull Request resolved &#124; Pull-Request-resolved &#124; Pull-Request r https github com P owner ^ + P repo ^ + pull P number - + re MULTILINE RE_PR_CC_LINE = re compile r ^cc \w+ \r \n $ re MULTILINE RE_DIFF_REV = re compile r ^Differential Revision + D - + re MULTILINE CIFLOW_LABEL = re compile r ^ciflow + CIFLOW_TRUNK_LABEL = re compile r ^ciflow trunk MERGE_RULE_PATH = Path github merge_rules yaml REMOTE_MAIN_BRANCH = origin main DRCI_CHECKRUN_NAME = Dr CI INTERNAL_CHANGES_CHECKRUN_NAME = Meta Internal-Only Changes Check HAS_NO_CONNECTED_DIFF_TITLE = There no internal Diff connected can merged now This could set - ignore all flaky broken trunk failures On other hand using large value like here might useful sev situation IGNORABLE_FAILED_CHECKS_THESHOLD = iter_issue_timeline_until_comment org str repo str issue_number int target_comment_id int max_pages int = - Any Yield timeline entries order until including entry whose id == target_comment_id commented event Stops once target comment encountered page = while page = max_pages url = f https api github com repos org repo issues issue_number timeline params = per_page page page batch = gh_fetch_json_list url params batch ev batch The target issue comment row event == commented id == issue_comment_id ev get event == commented ev get id == target_comment_id yield ev nothing timeline after matters so stop early yield ev len batch page += If we got here without finding comment then we either hit bug some github PR has _really_ long timeline The max pages found any pytorch pytorch PR time change raise RuntimeError f Could find merge commit first max_pages pages timeline url url f This most likely bug please report pytorch pytorch-dev-infra team sha_from_committed_event ev dict str Any - Optional str Extract SHA committed event timeline ev get sha sha_from_force_push_after ev dict str Any - Optional str Extract SHA force push event timeline The current GitHub API format commit_id = ev get commit_id commit_id str commit_id Legacy format after = ev get after ev get after_commit isinstance after dict after get sha after get oid ev get after_sha ev get head_sha gh_get_pr_info org str proj str pr_no int - Any rc = gh_graphql GH_GET_PR_INFO_QUERY name=proj owner=org number=pr_no rc data repository pullRequest cache gh_get_team_members org str name str - list str rc list str = team_members dict str Any = pageInfo hasNextPage true endCursor None while bool team_members pageInfo hasNextPage query = gh_graphql GH_GET_TEAM_MEMBERS_QUERY org=org name=name cursor=team_members pageInfo endCursor team = query data organization team team None warn f Requested non-existing team org name team_members = team members rc += member login member team_members nodes rc get_check_run_name_prefix workflow_run Any - str workflow_run None f workflow_run workflow name is_passing_status status Optional str - bool status None status upper SUCCESS SKIPPED NEUTRAL add_workflow_conclusions checksuites Any get_next_checkruns_page Callable list dict str dict str Any int Any Any get_next_checksuites Callable Any Any - JobNameToStateDict graphql seems favor most recent workflow run so theory we shouldn t need account reruns do just case workflow - job - job info workflows dict str WorkflowCheckState = jobs don t have workflow no_workflow_obj WorkflowCheckState = WorkflowCheckState None add_conclusions edges Any - None edge_idx edge enumerate edges node = edge node workflow_run = node workflowRun checkruns = node checkRuns workflow_obj WorkflowCheckState = no_workflow_obj workflow_run None This usual workflow run ID we see GitHub workflow_run_id = workflow_run databaseId While metadata name ID workflow itself workflow_name = workflow_run workflow name workflow_id = workflow_run workflow databaseId workflow_conclusion = node conclusion Do override existing status cancelled workflow_conclusion == CANCELLED workflow_name workflows continue Only keep latest workflow run each workflow heuristically s run largest run ID workflow_id workflows workflows workflow_id run_id workflow_run_id workflows workflow_id = WorkflowCheckState name=workflow_name status=workflow_conclusion url=workflow_run url run_id=workflow_run_id workflow_obj = workflows workflow_id while checkruns None checkrun_node checkruns nodes isinstance checkrun_node dict warn f Expected dictionary got type checkrun_node continue checkrun_name = f get_check_run_name_prefix workflow_run checkrun_node name existing_checkrun = workflow_obj jobs get checkrun_name existing_checkrun None is_passing_status existing_checkrun status workflow_obj jobs checkrun_name = JobCheckState checkrun_name checkrun_node detailsUrl checkrun_node conclusion classification=None job_id=checkrun_node databaseId title=checkrun_node title summary=checkrun_node summary bool checkruns pageInfo hasNextPage checkruns = get_next_checkruns_page edges edge_idx checkruns checkruns = None all_edges = checksuites edges copy while bool checksuites pageInfo hasNextPage checksuites = get_next_checksuites checksuites all_edges extend checksuites edges add_conclusions all_edges Flatten dictionaries If there exists jobs workflow run put jobs don t put workflow We care more about jobs workflow ran than container workflow res JobNameToStateDict = workflow workflows values len workflow jobs job_name job workflow jobs items res job_name = job res workflow name = JobCheckState workflow name workflow url workflow status classification=None job_id=None title=None summary=None job_name job no_workflow_obj jobs items res job_name = job res parse_args - Any argparse ArgumentParser parser = ArgumentParser Merge PR into default branch parser add_argument -- dry-run action= store_true parser add_argument -- revert action= store_true parser add_argument -- force action= store_true parser add_argument -- ignore-current action= store_true parser add_argument -- check-mergeability action= store_true parser add_argument -- comment-id type=int parser add_argument -- reason type=str parser add_argument pr_num type=int parser parse_args can_skip_internal_checks pr GitHubPR comment_id Optional int = None - bool comment_id None False comment = pr get_comment_by_id comment_id comment editor_login None False comment author_login == facebook-github-bot _revlist_to_prs repo GitRepo pr GitHubPR rev_list Iterable str should_skip Optional Callable int GitHubPR bool = None - list tuple GitHubPR str rc list tuple GitHubPR str = idx rev enumerate rev_list msg = repo commit_message rev findall doesn t named captures so we need use finditer all_matches = list RE_PULL_REQUEST_RESOLVED finditer msg len all_matches = raise RuntimeError f Found unexpected number PRs mentioned commit rev f len all_matches This probably because you using old version ghstack Please update ghstack resubmit your PRs m = all_matches pr org = m group owner pr project = m group repo raise RuntimeError f PR m group number resolved wrong owner repo pair pr_num = int m group number candidate = GitHubPR pr org pr project pr_num pr_num = pr pr_num pr should_skip None should_skip idx candidate continue rc append candidate rev rc get_ghstack_prs repo GitRepo pr GitHubPR open_only bool = True - list tuple GitHubPR str Get PRs stack below PR inclusive Throws error any open PRs out sync param open_only Only open PRs For ghstack cherry-pick commits based origin orig_ref = f repo remote pr get_ghstack_orig_ref rev_list = repo revlist f pr default_branch orig_ref skip_func idx int candidate GitHubPR - bool open_only candidate is_closed False print f Skipping idx + len rev_list PR candidate pr_num its already been merged True assert pr is_ghstack_pr entire_stack = _revlist_to_prs repo pr reversed rev_list skip_func print f Found len entire_stack PRs stack pr pr_num x pr_num x entire_stack stacked_pr rev entire_stack stacked_pr is_closed continue base_ref = stacked_pr base_ref base_ref == pr default_branch base_ref = repo get_merge_base f repo remote base_ref f repo remote stacked_pr head_ref are_ghstack_branches_in_sync repo stacked_pr head_ref base_ref raise RuntimeError f PR stacked_pr pr_num out sync corresponding revision rev + f branch stacked_pr get_ghstack_orig_ref would merged into stacked_pr default_branch + This usually happens because there non ghstack change PR + f Please sync them try again ex make changes orig_ref run ghstack entire_stack GitHubPR __init__ org str project str pr_num int - None assert isinstance pr_num int org = org project = project pr_num = pr_num info = gh_get_pr_info org project pr_num changed_files Optional list str = None labels Optional list str = None conclusions Optional JobNameToStateDict = None comments Optional list GitHubComment = None _authors Optional list tuple str str = None _reviews Optional list tuple str str = None merge_base Optional str = None submodules Optional list str = None is_closed - bool bool info closed is_cross_repo - bool bool info isCrossRepository base_ref - str cast str info baseRefName default_branch - str cast str info baseRepository defaultBranchRef name head_ref - str cast str info headRefName is_ghstack_pr - bool RE_GHSTACK_HEAD_REF match head_ref None get_ghstack_orig_ref - str assert is_ghstack_pr re sub r head$ orig head_ref is_base_repo_private - bool bool info baseRepository isPrivate get_changed_files_count - int int info changedFiles last_commit - Any info commits nodes - commit last_commit_sha default Optional str = None - str commits oid sha default None str last_commit oid str last_commit get oid default get_merge_base - str merge_base merge_base last_commit_sha = last_commit_sha NB We could use base_ref here regular PR however doesn t work ghstack where base custom branch i e gh USER ID base so let s just use main instead merge_base = gh_fetch_merge_base org project last_commit_sha default_branch Fallback baseRefOid API call fails i e rate limit Note baseRefOid points base ref associated PR other words head main when PR created rebased This necessarily merge base commit could serve fallback most cases s readily available part PR info merge_base merge_base = cast str info baseRefOid merge_base get_changed_files - list str changed_files None info = info unique_changed_files = set Do try fetch more than K files _ range unique_changed_files update x path x info files nodes info files pageInfo hasNextPage break rc = gh_graphql GH_GET_PR_NEXT_FILES_QUERY name=self project owner=self org number=self pr_num cursor=info files pageInfo endCursor info = rc data repository pullRequest changed_files = list unique_changed_files len changed_files = get_changed_files_count raise RuntimeError Changed file count mismatch changed_files get_submodules - list str submodules None rc = gh_graphql GH_GET_REPO_SUBMODULES name=self project owner=self org info = rc data repository submodules submodules = s path s info nodes submodules get_changed_submodules - list str submodules = get_submodules f f get_changed_files f submodules has_invalid_submodule_updates - bool Submodule updates PR invalid submodule keyword mentioned neither title nor body description nor any labels len get_changed_submodules submodule get_title lower submodule get_body lower all submodule label label get_labels _get_reviews - list tuple str str _reviews None _reviews = info = info _ range nodes = info reviews nodes _reviews = node author login node state node nodes + _reviews info reviews pageInfo hasPreviousPage break rc = gh_graphql GH_GET_PR_PREV_REVIEWS_QUERY name=self project owner=self org number=self pr_num cursor=info reviews pageInfo startCursor info = rc data repository pullRequest reviews = author state author state _reviews state = COMMENTED list reviews items get_approved_by - list str login login state _get_reviews state == APPROVED get_commit_count - int int info commits_with_authors totalCount get_commit_sha_at_comment comment_id int - Optional str Get PR head commit SHA present when specific comment posted This ensures we only merge state PR time merge command issued any subsequent commits may have been pushed after Returns None no head-changing events found before comment comment found head = None try event iter_issue_timeline_until_comment org project pr_num comment_id etype = event get event etype == committed sha = sha_from_committed_event event sha head = sha print f Timeline Found commit event SHA sha etype == head_ref_force_pushed sha = sha_from_force_push_after event sha head = sha print f Timeline Found force push event SHA sha etype == commented event get id == comment_id print f Timeline Found final comment sha sha head except Exception e print f Warning Failed reconstruct timeline comment comment_id e None print f Did find comment id comment_id PR timeline None get_pr_creator_login - str cast str info author login _fetch_authors - list tuple str str _authors None _authors authors list tuple str str = add_authors info dict str Any - None node info commits_with_authors nodes author_node node commit authors nodes user_node = author_node user author = f author_node name author_node email user_node None If author github user user node will null authors append author authors append cast str user_node login author info = info _ range add_authors info info commits_with_authors pageInfo hasNextPage break rc = gh_graphql GH_GET_PR_NEXT_AUTHORS_QUERY name=self project owner=self org number=self pr_num cursor=info commits_with_authors pageInfo endCursor info = rc data repository pullRequest _authors = authors authors get_committer_login num int = - str _fetch_authors num get_committer_author num int = - str _fetch_authors num get_labels - list str labels None labels labels = node node name node info labels edges labels info labels = labels labels get_checkrun_conclusions - JobNameToStateDict Returns dict checkrun - conclusion url conclusions None conclusions orig_last_commit = last_commit get_pr_next_check_runs edges list dict str dict str Any edge_idx int checkruns Any - Any rc = gh_graphql GH_GET_PR_NEXT_CHECK_RUNS name=self project owner=self org number=self pr_num cs_cursor=edges edge_idx - cursor edge_idx None cr_cursor=checkruns pageInfo endCursor last_commit = rc data repository pullRequest commits nodes - commit checkruns = last_commit checkSuites nodes - checkRuns checkruns get_pr_next_checksuites checksuites Any - Any rc = gh_graphql GH_GET_PR_NEXT_CHECKSUITES name=self project owner=self org number=self pr_num cursor=checksuites edges - cursor info = rc data repository pullRequest last_commit = info commits nodes - commit last_commit oid = orig_last_commit oid raise RuntimeError Last commit changed PR last_commit checkSuites checksuites = orig_last_commit checkSuites conclusions = add_workflow_conclusions checksuites get_pr_next_check_runs get_pr_next_checksuites Append old style statuses like ones populated CircleCI EasyCLA conclusions orig_last_commit status orig_last_commit status contexts status orig_last_commit status contexts name = status context conclusions name = JobCheckState name status targetUrl status state classification=None job_id=None title=None summary=None Making exception Apply lint auggestions autoformat because bot adds merged label - triggers workflow - sometimes needs approval - read failure which results blocked merge workflow doesn t provide mergability info conclusions pop Apply lint suggestions None conclusions get_authors - dict str str rc = idx range len _fetch_authors rc get_committer_login idx = get_committer_author idx rc get_author - str authors = get_authors len authors == next iter authors values creator = get_pr_creator_login If PR creator among authors Assume authored first commit author creator authors get_committer_author authors creator get_title - str cast str info title get_body - str cast str info body get_merge_commit - Optional str mc = info mergeCommit mc oid mc None None get_pr_url - str f https github com org project pull pr_num staticmethod _comment_from_node node Any - GitHubComment editor = node editor GitHubComment body_text=node bodyText created_at=node get createdAt author_login=node author login author_url=node author get url None author_association=node authorAssociation editor_login=editor login editor None database_id=node databaseId url=node url get_comments - list GitHubComment comments None comments comments = info = info comments Do try fetch more than K comments _ range comments = _comment_from_node node node info nodes + comments info pageInfo hasPreviousPage break rc = gh_graphql GH_GET_PR_PREV_COMMENTS name=self project owner=self org number=self pr_num cursor=info pageInfo startCursor info = rc data repository pullRequest comments comments get_last_comment - GitHubComment _comment_from_node info comments nodes - get_comment_by_id database_id int - GitHubComment comments None Fastpath - try searching partial prefetched comments node info comments nodes comment = _comment_from_node node comment database_id == database_id comment comment get_comments comment database_id == database_id comment The comment could have actually been review left PR message written alongside review This generally done trigger merge right when comment left Check those review comments see one those comment question node info reviews nodes These review comments contain all fields regular comments need comment = _comment_from_node node comment database_id == database_id comment raise RuntimeError f Comment id database_id found get_diff_revision - Optional str rc = RE_DIFF_REV search get_body rc group rc None None has_internal_changes - bool checkrun_name = INTERNAL_CHANGES_CHECKRUN_NAME get_diff_revision None False checks = get_checkrun_conclusions checks None checkrun_name checks False checks checkrun_name status = SUCCESS has_no_connected_diff - bool checkrun_name = INTERNAL_CHANGES_CHECKRUN_NAME checks = get_checkrun_conclusions checks None checkrun_name checks False checks checkrun_name title == HAS_NO_CONNECTED_DIFF_TITLE merge_ghstack_into repo GitRepo skip_mandatory_checks bool comment_id Optional int = None skip_all_rule_checks bool = False - list GitHubPR assert is_ghstack_pr ghstack_prs = get_ghstack_prs repo open_only=False raises error out sync pr_dependencies = pr rev ghstack_prs pr is_closed pr_dependencies append pr continue commit_msg = pr gen_commit_message filter_ghstack=True ghstack_deps=pr_dependencies pr pr_num = pr_num skip_all_rule_checks Raises exception matching rule found find_matching_merge_rule pr repo skip_mandatory_checks=skip_mandatory_checks skip_internal_checks=can_skip_internal_checks comment_id repo cherry_pick rev repo amend_commit_message commit_msg pr_dependencies append pr x x _ ghstack_prs x is_closed gen_commit_message filter_ghstack bool = False ghstack_deps Optional list GitHubPR = None - str Fetches title body PR description adds reviewed pull request resolved optionally filters out ghstack info Adding url here makes clickable within Github UI approved_by_urls = join prefix_with_github_url login login get_approved_by Remove cc line message body msg_body = re sub RE_PR_CC_LINE get_body filter_ghstack msg_body = re sub RE_GHSTACK_DESC msg_body msg = get_title + f pr_num \n\n msg += msg_body msg += f \nPull Request resolved get_pr_url \n msg += f Approved approved_by_urls \n ghstack_deps msg += f ghstack dependencies join f pr pr_num pr ghstack_deps \n Mention PR co-authors which should end message And separated body two newlines first_coauthor = True author_login author_name get_authors items author_login = get_pr_creator_login first_coauthor msg first_coauthor = msg + \n False msg += f \nCo-authored-by author_name msg add_numbered_label label_base str dry_run bool - None labels = get_labels labels None full_label = label_base count = label labels label_base label count += full_label = f label_base X count add_label full_label dry_run add_label label str dry_run bool - None gh_add_labels org project pr_num label dry_run merge_into repo GitRepo skip_mandatory_checks bool = False dry_run bool = False comment_id int ignore_current_checks Optional list str = None - None Raises exception matching rule found merge_rule pending_checks failed_checks ignorable_checks = find_matching_merge_rule repo skip_mandatory_checks=skip_mandatory_checks skip_internal_checks=can_skip_internal_checks comment_id ignore_current_checks=ignore_current_checks additional_merged_prs = merge_changes_locally repo skip_mandatory_checks comment_id repo push default_branch dry_run dry_run add_numbered_label MERGE_COMPLETE_LABEL dry_run pr additional_merged_prs pr add_numbered_label MERGE_COMPLETE_LABEL dry_run When merge process reaches part we can assume commit has been successfully pushed trunk merge_commit_sha = repo rev_parse name=self default_branch comment_id pr_num Finally upload record s The list pending failed checks time merge save_merge_record comment_id=comment_id pr_num=self pr_num owner=self org project=self project author=self get_author pending_checks=pending_checks failed_checks=failed_checks ignore_current_checks=ignorable_checks get IGNORE_CURRENT_CHECK broken_trunk_checks=ignorable_checks get BROKEN_TRUNK flaky_checks=ignorable_checks get FLAKY unstable_checks=ignorable_checks get UNSTABLE last_commit_sha=self last_commit_sha default= merge_base_sha=self get_merge_base merge_commit_sha=merge_commit_sha is_failed=False skip_mandatory_checks=skip_mandatory_checks ignore_current=bool ignore_current_checks print Missing comment ID PR number couldn t upload s Usually Github will see commit has resolves pr_num commit message close PR sometimes doesn t leading confusion When doesn t we close manually time sleep Give Github some time close PR manually_close_merged_pr pr=self additional_merged_prs=additional_merged_prs merge_commit_sha=merge_commit_sha dry_run=dry_run merge_changes_locally repo GitRepo skip_mandatory_checks bool = False comment_id Optional int = None branch Optional str = None skip_all_rule_checks bool = False - list GitHubPR param skip_all_rule_checks If true skips all rule checks ghstack PRs useful dry-running merge locally branch_to_merge_into = default_branch branch None branch repo current_branch = branch_to_merge_into repo checkout branch_to_merge_into It s okay skip commit SHA check ghstack PRs since authoring requires write access repo is_ghstack_pr merge_ghstack_into repo skip_mandatory_checks comment_id=comment_id skip_all_rule_checks=skip_all_rule_checks msg = gen_commit_message pr_branch_name = f __pull-request- pr_num __init__ Determine which commit SHA merge commit_to_merge = None comment_id raise ValueError Must provide -- comment-id when merging regular PRs Get commit SHA present when comment made commit_to_merge = get_commit_sha_at_comment comment_id commit_to_merge raise RuntimeError f Could find commit pushed before comment comment_id Validate commit latest commit PR latest_commit = last_commit_sha commit_to_merge = latest_commit raise RuntimeError f Commit commit_to_merge HEAD when comment comment_id posted f now latest commit PR latest_commit f Please re-issue merge command merge latest commit print f Merging commit commit_to_merge locally repo fetch commit_to_merge pr_branch_name repo _run_git merge -- squash pr_branch_name repo _run_git commit f -- author= get_author -m msg Did PR change since we started merge pulled_sha = repo show_ref pr_branch_name latest_pr_status = GitHubPR org project pr_num pulled_sha = latest_pr_status last_commit_sha pulled_sha = commit_to_merge raise RuntimeError PR has been updated since CI checks last passed Please rerun merge command MergeRuleFailedError RuntimeError __init__ message str rule Optional MergeRule = None - None super __init__ message rule = rule MandatoryChecksMissingError MergeRuleFailedError pass PostCommentError Exception pass dataclass MergeRule name str patterns list str approved_by list str mandatory_checks_name Optional list str ignore_flaky_failures bool = True gen_new_issue_link org str project str labels list str template str = bug-report yml - str labels_str = join labels f https github com org project issues new f labels= urllib parse quote labels_str f template= urllib parse quote template read_merge_rules repo Optional GitRepo org str project str - list MergeRule Returns list all merge rules repo project NB function used Meta-internal workflows see comment top file details repo_relative_rules_path = MERGE_RULE_PATH repo None json_data = gh_fetch_url f https api github com repos org project contents repo_relative_rules_path headers= Accept application vnd github v +json reader=json load content = base b decode json_data content MergeRule x x yaml safe_load content rules_path = Path repo repo_dir repo_relative_rules_path rules_path exists print f rules_path does exist returning empty rules open rules_path fp rc = yaml safe_load fp MergeRule x x rc find_matching_merge_rule pr GitHubPR repo Optional GitRepo = None skip_mandatory_checks bool = False skip_internal_checks bool = False ignore_current_checks Optional list str = None - tuple MergeRule list tuple str Optional str Optional int list tuple str Optional str Optional int dict str list Any Returns merge rule matching pr together list associated pending failing jobs OR raises exception NB function used Meta-internal workflows see comment top file details changed_files = pr get_changed_files approved_by = set pr get_approved_by issue_link = gen_new_issue_link org=pr org project=pr project labels= module ci reject_reason = f No rule found match PR Please report issue_link issue DevX team rules = read_merge_rules repo pr org pr project rules reject_reason = f Rejecting merge no rules defined repository MERGE_RULE_PATH raise RuntimeError reject_reason checks = pr get_checkrun_conclusions checks = get_classifications pr pr_num pr project checks ignore_current_checks=ignore_current_checks This keeps list all approvers could stamp change all_rule_approvers = PRs can fail multiple merge rules only needs pass one rule approved If fails all rules we need find rule came closest passing report dev reject_reason_score ranks rules relevancy The higher score more relevant rule rejection reason we only care about most relevant rule reason reject_reason_score intrepretation Score K - how many files rule matched Score K - matched all files no overlapping approvers Score K - matched all files approvers mandatory checks pending Score k - Matched all files approvers mandatory checks failed reject_reason_score = rule rules rule_name = rule name patterns_re = patterns_to_regex rule patterns non_matching_files = Does rule apply all files fname changed_files patterns_re match fname non_matching_files append fname len non_matching_files num_matching_files = len changed_files - len non_matching_files num_matching_files reject_reason_score reject_reason_score = num_matching_files reject_reason = \n join f Not all files match rule ` rule_name ` f num_matching_files files matched there still non-matching files f join non_matching_files len non_matching_files continue If rule needs approvers PR has been reviewed skip len rule approved_by len approved_by == reject_reason_score reject_reason_score = reject_reason = f PR pr pr_num has been reviewed yet continue Does PR have required approvals rule rule_approvers = set approver rule approved_by approver org name = approver split rule_approvers update gh_get_team_members org name rule_approvers add approver approvers_intersection = approved_by intersection rule_approvers If rule requires approvers they aren t ones reviewed PR len approvers_intersection == len rule_approvers Less than equal intentionally used here gather all potential approvers reject_reason_score = reject_reason_score = all_rule_approvers rule name = rule approved_by Prepare reject reason all_rule_approvers_msg = f - name join approved_by len approved_by name approved_by all_rule_approvers items reject_reason = Approvers one following sets needed \n reject_reason += \n join all_rule_approvers_msg continue Does PR pass checks required rule mandatory_checks = rule mandatory_checks_name rule mandatory_checks_name None required_checks = list filter lambda x EasyCLA x Facebook CLA Check x skip_mandatory_checks mandatory_checks pending_checks failed_checks _ = categorize_checks checks required_checks ok_failed_checks_threshold=IGNORABLE_FAILED_CHECKS_THESHOLD rule ignore_flaky_failures categorize_checks assumes all tests required required_checks empty workaround we want keep behavior categorize_checks generally required_checks pending_checks = failed_checks = hud_link = f https hud pytorch org pr org pr project commit pr last_commit_sha len failed_checks reject_reason_score reject_reason_score = reject_reason = \n join f len failed_checks mandatory check s failed The first few checks_to_markdown_bullets failed_checks f Dig deeper viewing failures hud hud_link continue len pending_checks reject_reason_score reject_reason_score = reject_reason = \n join f len pending_checks mandatory check s pending yet run The first few checks_to_markdown_bullets pending_checks f Dig deeper viewing pending checks hud hud_link continue skip_internal_checks pr has_internal_changes raise RuntimeError This PR has internal changes must landed via Phabricator Please try reimporting rexporting PR Categorize all checks when skip_mandatory_checks force merge set Do here where list checks readily available These records will saved into s merge records pending_mandatory_checks failed_mandatory_checks ignorable_checks = categorize_checks checks ok_failed_checks_threshold=IGNORABLE_FAILED_CHECKS_THESHOLD rule pending_mandatory_checks failed_mandatory_checks ignorable_checks reject_reason_score == raise MandatoryChecksMissingError reject_reason rule raise MergeRuleFailedError reject_reason rule checks_to_str checks list tuple str Optional str - str join f c c c None c c checks checks_to_markdown_bullets checks list tuple str Optional str Optional int - list str f - c c c None f - c c checks post_starting_merge_comment repo GitRepo pr GitHubPR explainer TryMergeExplainer dry_run bool ignore_current_checks_info Optional list tuple str Optional str Optional int = None - None Post initial merge starting message PR Also post short message all PRs stack gh_post_pr_comment pr org pr project pr pr_num explainer get_merge_message ignore_current_checks_info dry_run=dry_run pr is_ghstack_pr additional_prs _ get_ghstack_prs repo pr additional_prs pr_num = pr pr_num gh_post_pr_comment additional_prs org additional_prs project additional_prs pr_num f Starting merge part PR stack under pr pr_num dry_run=dry_run manually_close_merged_pr pr GitHubPR additional_merged_prs list GitHubPR merge_commit_sha str dry_run bool - None _comment_and_close pr GitHubPR comment str - None pr = GitHubPR pr org pr project pr pr_num Refresh PR pr is_closed gh_post_pr_comment pr org pr project pr pr_num comment dry_run gh_close_pr pr org pr project pr pr_num dry_run message = f This PR pr pr_num merged merge_commit_sha still open likely due Github bug so mergebot closing manually If you think mistake please feel free reopen contact Dev Infra _comment_and_close pr message additional_pr additional_merged_prs message = f This PR additional_pr pr_num merged part PR pr pr_num stack under merge_commit_sha still open likely due Github bug so mergebot closing manually If you think mistake please feel free reopen contact Dev Infra _comment_and_close additional_pr message print f PR pr pr_num all additional PRs stack have been closed retries_decorator save_merge_record comment_id int pr_num int owner str project str author str pending_checks list tuple str Optional str Optional int failed_checks list tuple str Optional str Optional int ignore_current_checks list tuple str Optional str Optional int broken_trunk_checks list tuple str Optional str Optional int flaky_checks list tuple str Optional str Optional int unstable_checks list tuple str Optional str Optional int last_commit_sha str merge_base_sha str merge_commit_sha str = is_failed bool = False skip_mandatory_checks bool = False ignore_current bool = False error str = - None This saves merge records json which can later uploaded s Prepare record written into s data = comment_id comment_id pr_num pr_num owner owner project project author author pending_checks pending_checks failed_checks failed_checks ignore_current_checks ignore_current_checks broken_trunk_checks broken_trunk_checks flaky_checks flaky_checks unstable_checks unstable_checks last_commit_sha last_commit_sha merge_base_sha merge_base_sha merge_commit_sha merge_commit_sha is_failed is_failed skip_mandatory_checks skip_mandatory_checks ignore_current ignore_current error error This unique identifier record deduping purposes Rockset Any unique string would work This will used after we migrate off Rockset _id f project - pr_num - comment_id - os environ get GITHUB_RUN_ID repo_root = Path __file__ resolve parent parent parent open repo_root merge_record json w f json dump data f retries_decorator get_drci_classifications pr_num int project str = pytorch - Any Query HUD API find similar failures decide they flaky NB This doesn t work internally atm because requires making external API call HUD failures = gh_fetch_url f https hud pytorch org api drci drci prNumber= pr_num data=f repo= project headers= Authorization os getenv DRCI_BOT_KEY Accept application vnd github v +json method= POST reader=json load failures get str pr_num failures REMOVE_JOB_NAME_SUFFIX_REGEX = re compile r - + - + +\ $ remove_job_name_suffix name str replacement str = - str re sub REMOVE_JOB_NAME_SUFFIX_REGEX replacement name is_broken_trunk check JobCheckState drci_classifications Any - bool check drci_classifications False name = check name job_id = check job_id Consult list broken trunk failures Dr CI any name == broken_trunk name job_id job_id == broken_trunk id broken_trunk drci_classifications get BROKEN_TRUNK is_unstable check JobCheckState drci_classifications Any - bool check drci_classifications False name = check name job_id = check job_id The job name has unstable keyword This original way mark job unstable HUD Dr CI trymerge unstable name True Consult list unstable failures Dr CI any name == unstable name job_id job_id == unstable id unstable drci_classifications get UNSTABLE is_flaky check JobCheckState drci_classifications Any - bool check drci_classifications False name = check name job_id = check job_id Consult list flaky failures Dr CI any name == flaky name job_id job_id == flaky id flaky drci_classifications get FLAKY is_invalid_cancel name str conclusion Optional str drci_classifications Any - bool After https github com pytorch test-infra pull invalid cancelled signals have been removed HUD Dr CI The same needs done here consistency name drci_classifications conclusion conclusion upper = CANCELLED False If job cancelled listed failure Dr CI s invalid signal can ignored all name = failure name failure drci_classifications get FAILED get_classifications pr_num int project str checks dict str JobCheckState ignore_current_checks Optional list str - dict str JobCheckState Get failure classification Dr CI which source truth going forward It s preferable try calling Dr CI API directly first get latest results well update Dr CI PR comment drci_classifications = get_drci_classifications pr_num=pr_num project=project get_readable_drci_results drci_classifications Any - str try s = f From Dr CI API pr_num \n classification jobs drci_classifications items s += f classification \n job jobs s += f job id job name \n s except Exception f From Dr CI API json dumps drci_classifications print get_readable_drci_results drci_classifications NB latest results Dr CI available i e when calling SandCastle we fallback any results we can find Dr CI check run summary drci_classifications DRCI_CHECKRUN_NAME checks checks DRCI_CHECKRUN_NAME checks DRCI_CHECKRUN_NAME summary drci_summary = checks DRCI_CHECKRUN_NAME summary try print f From Dr CI checkrun summary drci_summary drci_classifications = json loads str drci_summary except json JSONDecodeError warn Invalid Dr CI checkrun summary drci_classifications = checks_with_classifications = checks copy name check checks items check status == SUCCESS check status == NEUTRAL continue is_unstable check drci_classifications checks_with_classifications name = JobCheckState check name check url check status UNSTABLE check job_id check title check summary continue NB It s important note when comes ghstack broken trunk classification Dr CI uses base whole stack is_broken_trunk check drci_classifications checks_with_classifications name = JobCheckState check name check url check status BROKEN_TRUNK check job_id check title check summary continue is_flaky check drci_classifications checks_with_classifications name = JobCheckState check name check url check status FLAKY check job_id check title check summary continue is_invalid_cancel name check status drci_classifications NB Create new category here invalid cancelled signals because there usually many them when they happen So they shouldn t counted toward ignorable failures threshold checks_with_classifications name = JobCheckState check name check url check status INVALID_CANCEL check job_id check title check summary continue ignore_current_checks None name ignore_current_checks checks_with_classifications name = JobCheckState check name check url check status IGNORE_CURRENT_CHECK check job_id check title check summary checks_with_classifications filter_checks_with_lambda checks JobNameToStateDict status_filter Callable Optional str bool - list JobCheckState check check checks values status_filter check status get_pr_commit_sha repo GitRepo pr GitHubPR - str commit_sha = pr get_merge_commit commit_sha None commit_sha commits = repo commits_resolving_gh_pr pr pr_num len commits == raise PostCommentError Can t find any commits resolving PR commits validate_revert repo GitRepo pr GitHubPR comment_id Optional int = None - tuple str str comment = pr get_last_comment comment_id None pr get_comment_by_id comment_id comment editor_login None raise PostCommentError Halting revert revert comment has been edited author_association = comment author_association author_login = comment author_login allowed_reverters = COLLABORATOR MEMBER OWNER For some reason one can member private repo only CONTRIBUTOR pr is_base_repo_private allowed_reverters append CONTRIBUTOR Special case pytorch-auto-revert app whose does have association But should able issue revert command comment author_url == https github com apps pytorch-auto-revert allowed_reverters append NONE author_association allowed_reverters raise PostCommentError f Will revert author_login one f join allowed_reverters instead author_association commit_sha = get_pr_commit_sha repo pr author_login commit_sha get_ghstack_dependent_prs repo GitRepo pr GitHubPR only_closed bool = True - list tuple str GitHubPR Get PRs stack above PR inclusive Throws error stack have branched original branches gone assert pr is_ghstack_pr orig_ref = f repo remote pr get_ghstack_orig_ref rev_list = repo revlist f pr default_branch orig_ref len rev_list == raise RuntimeError f PR pr pr_num does have any revisions associated skip_len = len rev_list - branch repo branches_containing_ref orig_ref candidate = repo revlist f pr default_branch branch Pick longest candidate len candidate len rev_list candidate rev_list = rev_list candidate Validate candidate always ends rev-list rev_list -len candidate = candidate raise RuntimeError f Branch branch revlist join candidate subset join rev_list Remove commits original PR depends skip_len rev_list = rev_list -skip_len rc list tuple str GitHubPR = pr_ sha _revlist_to_prs repo pr rev_list pr_ is_closed only_closed rc append pr_ continue commit_sha = get_pr_commit_sha repo pr_ rc append commit_sha pr_ rc do_revert_prs repo GitRepo original_pr GitHubPR shas_and_prs list tuple str GitHubPR author_login str extra_msg str = skip_internal_checks bool = False dry_run bool = False - None Prepare push revert commits commit_sha pr shas_and_prs revert_msg = f \nReverted pr get_pr_url behalf prefix_with_github_url author_login revert_msg += extra_msg repo checkout pr default_branch repo revert commit_sha msg = repo commit_message HEAD msg = re sub RE_PULL_REQUEST_RESOLVED msg msg += revert_msg repo amend_commit_message msg repo push shas_and_prs default_branch dry_run Comment reopen PRs commit_sha pr shas_and_prs revert_message = pr pr_num == original_pr pr_num revert_message += f pr get_pr_creator_login your PR has been successfully reverted revert_message += f pr get_pr_creator_login your PR has been reverted part stack under f original_pr pr_num \n pr has_internal_changes pr has_no_connected_diff skip_internal_checks revert_message += \n warning This PR might contain internal changes revert_message += \ncc pytorch pytorch-dev-infra gh_post_pr_comment pr org pr project pr pr_num revert_message dry_run=dry_run pr add_numbered_label reverted dry_run pr add_label ci-no-td dry_run dry_run gh_post_commit_comment pr org pr project commit_sha revert_msg gh_update_pr_state pr org pr project pr pr_num try_revert repo GitRepo pr GitHubPR dry_run bool = False comment_id Optional int = None reason Optional str = None - None try author_login commit_sha = validate_revert repo pr comment_id=comment_id except PostCommentError e gh_post_pr_comment pr org pr project pr pr_num str e dry_run=dry_run extra_msg = f due reason reason None extra_msg += f comment pr get_comment_by_id comment_id url \n comment_id None \n shas_and_prs = commit_sha pr pr is_ghstack_pr try shas_and_prs = get_ghstack_dependent_prs repo pr prs_to_revert = join t get_pr_url t shas_and_prs print f About stack PRs prs_to_revert except Exception e print f Failed fetch dependent PRs str e fall over single revert do_revert_prs repo pr shas_and_prs author_login=author_login extra_msg=extra_msg dry_run=dry_run skip_internal_checks=can_skip_internal_checks pr comment_id prefix_with_github_url suffix_str str - str f https github com suffix_str check_for_sev org str project str skip_mandatory_checks bool - None skip_mandatory_checks response = cast dict str Any gh_fetch_json_list https api github com search issues lint-ignore Having two label queries AND operation params= q f repo org project open issue label ci sev label merge blocking response total_count = raise RuntimeError Not merging any PRs moment because there + merge blocking https github com pytorch pytorch labels ci sev issue open \n + f response items html_url has_label labels list str pattern Pattern str = CIFLOW_LABEL - bool len list filter pattern match labels categorize_checks check_runs JobNameToStateDict required_checks list str ok_failed_checks_threshold Optional int = None - tuple list tuple str Optional str Optional int list tuple str Optional str Optional int dict str list Any Categories all jobs into list pending failing jobs All known flaky failures broken trunk ignored defaults when ok_failed_checks_threshold set unlimited pending_checks list tuple str Optional str Optional int = failed_checks list tuple str Optional str Optional int = failed_checks_categorization used keep track all ignorable failures when saving merge record s failed_checks_categorization dict str list Any = defaultdict list If required_checks set empty consider all names relevant relevant_checknames = name name check_runs keys required_checks any x name x required_checks checkname required_checks all checkname x x check_runs keys pending_checks append checkname None None checkname relevant_checknames status = check_runs checkname status url = check_runs checkname url classification = check_runs checkname classification job_id = check_runs checkname job_id status None classification = UNSTABLE NB No need wait job classification unstable would ignored anyway This useful need wait scarce resources like ROCm which also frequently unstable mode pending_checks append checkname url job_id classification == INVALID_CANCEL continue is_passing_status check_runs checkname status target = failed_checks_categorization classification classification IGNORE_CURRENT_CHECK BROKEN_TRUNK FLAKY UNSTABLE failed_checks target append checkname url job_id flaky_or_broken_trunk = failed_checks_categorization BROKEN_TRUNK + failed_checks_categorization FLAKY flaky_or_broken_trunk warn f The following len flaky_or_broken_trunk checks failed likely due flakiness broken trunk + join x x flaky_or_broken_trunk + f greater than threshold ok_failed_checks_threshold so merge will fail ok_failed_checks_threshold None len flaky_or_broken_trunk ok_failed_checks_threshold ok_failed_checks_threshold None len flaky_or_broken_trunk ok_failed_checks_threshold failed_checks = failed_checks + flaky_or_broken_trunk The list failed_checks_categorization returned so can saved into s merge record pending_checks failed_checks failed_checks_categorization merge pr GitHubPR repo GitRepo comment_id int dry_run bool = False skip_mandatory_checks bool = False timeout_minutes int = stale_pr_days int = ignore_current bool = False - None initial_commit_sha = pr last_commit_sha pr_link = f https github com pr org pr project pull pr pr_num print f Attempting merge initial_commit_sha pr_link MERGE_IN_PROGRESS_LABEL pr get_labels gh_add_labels pr org pr project pr pr_num MERGE_IN_PROGRESS_LABEL dry_run explainer = TryMergeExplainer skip_mandatory_checks pr get_labels pr pr_num pr org pr project ignore_current probably bad name list current checks should ignored toggled -- ignore-current flag ignore_current_checks_info = pr is_ghstack_pr get_ghstack_prs repo pr raises error out sync check_for_sev pr org pr project skip_mandatory_checks skip_mandatory_checks post_starting_merge_comment repo pr explainer dry_run pr merge_into repo dry_run=dry_run skip_mandatory_checks=skip_mandatory_checks comment_id=comment_id Check approvals find_matching_merge_rule pr repo skip_mandatory_checks=True has_required_labels pr raise RuntimeError LABEL_ERR_MSG lstrip ignore_current checks = pr get_checkrun_conclusions _ failing _ = categorize_checks checks list checks keys ok_failed_checks_threshold=IGNORABLE_FAILED_CHECKS_THESHOLD ignore_current_checks_info = failing post_starting_merge_comment repo pr explainer dry_run ignore_current_checks_info=ignore_current_checks_info start_time = time time last_exception = elapsed_time = ignore_current_checks = x x ignore_current_checks_info convert List str convenience while elapsed_time timeout_minutes check_for_sev pr org pr project skip_mandatory_checks current_time = time time elapsed_time = current_time - start_time print f Attempting merge https github com pr org pr project pull pr pr_num elapsed_time minutes elapsed pr = GitHubPR pr org pr project pr pr_num initial_commit_sha = pr last_commit_sha raise RuntimeError New commits pushed while merging Please rerun merge command try required_checks = failed_rule_message = None ignore_flaky_failures = True try find_matching_merge_rule pr repo ignore_current_checks=ignore_current_checks except MandatoryChecksMissingError ex ex rule None ignore_flaky_failures = ex rule ignore_flaky_failures ex rule mandatory_checks_name None required_checks = ex rule mandatory_checks_name failed_rule_message = ex checks = pr get_checkrun_conclusions checks = get_classifications pr pr_num pr project checks ignore_current_checks=ignore_current_checks pending failing _ = categorize_checks checks required_checks + x x checks keys x required_checks ok_failed_checks_threshold=IGNORABLE_FAILED_CHECKS_THESHOLD ignore_flaky_failures HACK until GitHub will better about surfacing those startup_failures = filter_checks_with_lambda checks lambda status status == STARTUP_FAILURE len startup_failures raise RuntimeError f len startup_failures STARTUP failures reported please check workflows syntax + join f x name x url x startup_failures END HACK len failing raise RuntimeError f len failing jobs have failed first few them + join f x x x failing len pending failed_rule_message None raise failed_rule_message raise MandatoryChecksMissingError f Still waiting len pending jobs finish + f first few them join x x pending pr merge_into repo dry_run=dry_run skip_mandatory_checks=skip_mandatory_checks comment_id=comment_id ignore_current_checks=ignore_current_checks except MandatoryChecksMissingError ex last_exception = str ex print f Merge https github com pr org pr project pull pr pr_num failed due ex Retrying min flush=True time sleep Finally report timeout back msg = f Merged timed out after timeout_minutes minutes Please contact pytorch_dev_infra team msg += f The last exception last_exception gh_add_labels pr org pr project pr pr_num land-failed dry_run raise RuntimeError msg main - None args = parse_args repo = GitRepo get_git_repo_dir get_git_remote_name org project = repo gh_owner_and_name pr = GitHubPR org project args pr_num handle_exception e Exception title str = Merge failed - None exception = f Reason e failing_rule = None isinstance e MergeRuleFailedError failing_rule = e rule name e rule None internal_debugging = run_url = os getenv GH_RUN_URL run_url None Hide behind collapsed bullet since s helpful most devs internal_debugging = \n join line line details summary Details Dev Infra team summary f Raised href= run_url workflow job \n f Failing merge rule failing_rule failing_rule details line ignore empty lines during join msg = \n join f ## title f exception f internal_debugging gh_post_pr_comment org project args pr_num msg dry_run=args dry_run traceback traceback print_exc args revert try gh_post_pr_comment org project args pr_num get_revert_message org project pr pr_num args dry_run try_revert repo pr dry_run=args dry_run comment_id=args comment_id reason=args reason except Exception e handle_exception e f Reverting PR args pr_num failed pr is_closed gh_post_pr_comment org project args pr_num f Can t merge closed PR args pr_num dry_run=args dry_run pr is_cross_repo pr is_ghstack_pr gh_post_pr_comment org project args pr_num Cross-repo ghstack merges supported dry_run=args dry_run pr is_ghstack_pr pr base_ref = pr default_branch gh_post_pr_comment org project args pr_num f PR targets pr base_ref rather than pr default_branch refusing merge request dry_run=args dry_run args check_mergeability pr is_ghstack_pr get_ghstack_prs repo pr raises error out sync pr merge_changes_locally repo skip_mandatory_checks=True skip_all_rule_checks=True args force pr has_invalid_submodule_updates message = f This PR updates submodules join pr get_changed_submodules \n message += \nIf those updates intentional please add submodule keyword PR title description gh_post_pr_comment org project args pr_num message dry_run=args dry_run try Ensure comment id set fail args comment_id raise ValueError Comment ID required merging PRs please provide using -- comment-id merge pr repo comment_id=args comment_id dry_run=args dry_run skip_mandatory_checks=args force ignore_current=args ignore_current except Exception e handle_exception e args comment_id args pr_num Finally upload record s we don t have access list pending failed checks here they really needed moment save_merge_record comment_id=args comment_id pr_num=args pr_num owner=org project=project author=pr get_author pending_checks= failed_checks= ignore_current_checks= broken_trunk_checks= flaky_checks= unstable_checks= last_commit_sha=pr last_commit_sha default= merge_base_sha=pr get_merge_base is_failed=True skip_mandatory_checks=args force ignore_current=args ignore_current error=str e print Missing comment ID PR number couldn t upload s finally args check_mergeability gh_remove_label org project args pr_num MERGE_IN_PROGRESS_LABEL args dry_run __name__ == __main__ main