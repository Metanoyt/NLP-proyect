Owner s module named tensor ruff noqa F unittest torch testing _internal common_utils TestCase run_tests TEST_NUMPY torch testing _internal common_utils skipIfTorchDynamo torch testing _internal common_cuda TEST_CUDA torch testing _internal common_device_type get_all_device_types collections namedtuple OrderedDict itertools functools torch torch Tensor torch nn functional F multiprocessing reduction ForkingPickler pickle io sys warnings pass_name_to_python_arg_parser name x = torch empty names= name flatten lst item sublist lst item sublist Function = namedtuple TestCase name lambd parse_compressed_namedshape string This metalanguage describing shape tensor compactly N C - size = names N C None None - size = names None None - size = names=None passed ctor parse_name maybe_name maybe_name = maybe_name strip maybe_name == None None maybe_name string = string strip - size names None len string == None - size = None names string None int size size string split dims = string split tuples = dim split dim dims zip parse_name name int size name size tuples create namedshape factory=torch randn namedshape str names shape = parse_compressed_namedshape namedshape factory shape names=names out_fn operator functools wraps operator fn inputs operator inputs out=inputs fn TestNamedTensor TestCase test_aaa_must_run_first_check_experimental_warning TODO rzou It would nice real python warning Right now error message only prints once doesn t respect warnings simplefilter behavior where python users can control whether display warnings once all time never warnings catch_warnings record=True warns x = torch randn names= N C assertEqual len warns assertTrue str warns message startswith Named tensors all their associated APIs experimental feature test_trivial pass _test_name_inference op args= expected_names= device= cpu maybe_raises_regex=None casted_args = arg device isinstance arg torch Tensor arg arg args maybe_raises_regex None assertRaisesRegex RuntimeError maybe_raises_regex result = op args result = op args assertEqual result names expected_names msg=f Name inference op __name__ device device failed TODO rzou Some form check should added assertEqual Right now I don t know what should look like assertTensorDataAndNamesEqual x y assertEqual x names y names unnamed_x = x rename None unnamed_y = y rename None assertEqual unnamed_x unnamed_y _test_factory factory device x = factory device=device assertEqual x names x = factory device=device assertEqual x names None None None x = factory names=None device=device assertEqual x names None None None x = factory names= N T D device=device assertEqual x names N T D x = factory names= N None D device=device assertEqual x names N None D x = factory names= _ batch BATCH_ device=device assertEqual x names _ batch BATCH_ assertRaisesRegex RuntimeError valid identifier contains only x = factory names= device=device assertRaisesRegex RuntimeError valid identifier contains only x = factory names= device=device assertRaisesRegex RuntimeError Number names x = factory names= N device=device assertRaisesRegex TypeError invalid combination arguments x = factory names= N device=device assertRaisesRegex RuntimeError construct tensor duplicate names x = factory names= N C N device=device names = A i i range x = factory names=names device=device assertEqual x names names assertRaisesRegex RuntimeError only support up dims names = A i i range x = factory names=names device=device skipIfTorchDynamo bug Dynamo causes refcounts different test_none_names_refcount N= scope unnamed = torch empty unnamed names materialize None None prev_none_refcnt = sys getrefcount None Ran N times reduce flakiness scope i range N after_none_refcnt = sys getrefcount None assertTrue after_none_refcnt - prev_none_refcnt N msg= Using tensor names should change refcount Py_None test_has_names unnamed = torch empty none_named = torch empty names= None None partially_named = torch empty names= N None fully_named = torch empty names= N C assertFalse unnamed has_names assertFalse none_named has_names assertTrue partially_named has_names assertTrue fully_named has_names test_py _ellipsis tensor = torch randn output = tensor refine_names N C assertEqual output names N None None C test_refine_names Unnamed tensor - Unnamed tensor _test_name_inference Tensor refine_names create None None None N C H N C H Named tensor - Named tensor _test_name_inference Tensor refine_names create N C H N C H N C H Partially named tensor - named tensor _test_name_inference Tensor refine_names create None C None None C H None C H Too few names _test_name_inference Tensor refine_names create None None N C H maybe_raises_regex= different number dims Cannot change Tensor D Tensor N _test_name_inference Tensor refine_names create D N maybe_raises_regex= different Cannot change Tensor D Tensor None _test_name_inference Tensor refine_names create D None maybe_raises_regex= D more specific than None globbing behavior exists _test_name_inference Tensor refine_names create None None None None C H None None C H test_detach names = N _test_name_inference Tensor detach_ torch randn requires_grad=True names=names names _test_name_inference Tensor detach torch randn requires_grad=True names=names names test_index_fill device get_all_device_types expected_names = N C x = torch randn device=device names=expected_names output = x index_fill_ C torch tensor device=device assertEqual output names expected_names output = x index_fill_ C torch tensor device=device torch tensor assertEqual output names expected_names output = x index_fill C torch tensor device=device assertEqual output names expected_names output = x index_fill C torch tensor device=device torch tensor assertEqual output names expected_names test_equal device get_all_device_types tensor = torch randn device=device other = tensor clone assertTrue torch equal tensor rename N C other rename N C assertFalse torch equal tensor rename M C other rename N C assertFalse torch equal tensor rename None C other rename N C test_squeeze x = create N C H W output = x squeeze C assertEqual output names N H W output = x squeeze assertEqual output names N test_repr named_tensor = torch zeros rename_ N C expected = tensor \n names= N C assertEqual repr named_tensor expected unnamed_tensor = torch zeros expected = tensor \n assertEqual repr unnamed_tensor expected none_named_tensor = torch zeros rename_ None None assertEqual repr none_named_tensor expected test_diagonal named_tensor = torch zeros names=list ABCD assertEqual named_tensor diagonal names C D None assertEqual named_tensor diagonal names A C None assertEqual named_tensor diagonal outdim= E dim = B dim = D names A C E test_empty_names ref_tensor = torch tensor empty_named_tensor = torch tensor names= assertEqual ref_tensor empty_named_tensor test_max_pooling check_tuple_return op inputs expected_names values indices = op inputs assertEqual values names expected_names assertEqual indices names expected_names device get_all_device_types named_tensor_ d = torch zeros device=device names=list ABC named_tensor_ d = torch zeros device=device names=list ABCD named_tensor_ d = torch zeros device=device names=list ABCDE assertEqual F max_pool d named_tensor_ d names named_tensor_ d names assertEqual F max_pool d named_tensor_ d names named_tensor_ d names assertEqual F max_pool d named_tensor_ d names named_tensor_ d names check_tuple_return F max_pool d_with_indices named_tensor_ d named_tensor_ d names check_tuple_return F max_pool d_with_indices named_tensor_ d named_tensor_ d names check_tuple_return F max_pool d_with_indices named_tensor_ d named_tensor_ d names test_max_pooling_without_names_does_not_warn device get_all_device_types tensor_ d = torch zeros device=device requires_grad=True warnings catch_warnings record=True warns warnings simplefilter always result = F max_pool d tensor_ d result sum backward assertEqual len warns test_no_save_support named_tensor = torch zeros names= N C buf = io BytesIO assertRaisesRegex RuntimeError NYI torch save named_tensor buf test_no_pickle_support named_tensor = torch zeros names= N C assertRaisesRegex RuntimeError NYI serialized = pickle dumps named_tensor test_no_multiprocessing_support named_tensor = torch zeros names= N C buf = io BytesIO assertRaisesRegex RuntimeError NYI ForkingPickler buf pickle HIGHEST_PROTOCOL dump named_tensor test_big_tensor_repr_has_names check_repr named_tensor unnamed_tensor = named_tensor rename None names_tag = f names= named_tensor names assertIn names_tag repr named_tensor check_repr torch randn names= N C H W test_noncontig_contiguous This type contiguous special-cased therefore needs its own test device get_all_device_types x = torch randn device=device t rename_ N C assertEqual x contiguous names N C test_copy_transpose This type copy special-cased therefore needs its own test _test self_names other_names expected_names x = torch empty names=self_names y = torch empty t rename_ other_names x copy_ y assertEqual x names expected_names _test N C N C N C _test None N C N C test_rename_ tensor = torch empty names= N C assertEqual tensor rename_ None names None None assertEqual tensor rename_ H W names H W assertRaisesRegex RuntimeError Number names tensor rename_ N C W assertRaisesRegex RuntimeError duplicate names tensor rename_ N N test_rename tensor = torch empty names= N C assertEqual tensor rename None names None None assertEqual tensor rename H W names H W Check we didn t modify tensor names assertEqual tensor names N C assertRaisesRegex RuntimeError Number names tensor rename N C W assertRaisesRegex RuntimeError duplicate names tensor rename N N assertRaisesRegex RuntimeError either positional args keyword args tensor rename None N= batch rename returns view tensor assertEqual tensor rename H W data_ptr tensor data_ptr assertEqual tensor rename None data_ptr tensor data_ptr test_rename_globber scalar = torch randn unnamed_tensor = torch empty named_tensor = torch empty names= N C H W assertEqual scalar rename None names assertEqual scalar rename names Check works unnamed tensors assertEqual unnamed_tensor rename names unnamed_tensor names assertEqual unnamed_tensor rename H W names None None H W assertEqual unnamed_tensor rename N W names N None None W assertEqual unnamed_tensor rename N C names N C None None Check works named tensors assertEqual named_tensor rename names named_tensor names assertEqual named_tensor rename width names N C H width assertEqual named_tensor rename batch channels width names batch channels H width assertEqual named_tensor rename batch names batch C H W Test empty glob assertEqual unnamed_tensor rename None None None None names None None None None assertEqual named_tensor rename N C H W names N C H W Multiple globs throw assertRaisesRegex RuntimeError More than one named_tensor rename channels test_rename_rename_map scalar = torch randn unnamed_tensor = torch empty named_tensor = torch empty names= N C H W assertRaisesRegex RuntimeError dim N does exist scalar rename N= batch assertRaisesRegex RuntimeError dim N does exist unnamed_tensor rename N= batch assertRaisesRegex RuntimeError dim B does exist named_tensor rename B= batch assertRaisesRegex RuntimeError dim B does exist named_tensor rename H= height B= batch assertEqual named_tensor rename N= batch data_ptr named_tensor data_ptr assertEqual named_tensor rename N= batch names batch C H W assertEqual named_tensor rename N= batch H= height names batch C height W test_set_names_property tensor = torch empty names= N C tensor names = None assertEqual tensor names None None tensor names = N W assertEqual tensor names N W assertRaisesRegex RuntimeError Number names tensor names = N C W assertRaisesRegex RuntimeError duplicate names tensor names = N N test_factory_edge_cases device get_all_device_types _test_factory torch empty device test_factory_coverage _test factory device names = N T D torch manual_seed result = factory names=names device=device torch manual_seed expected = factory device=device rename_ names assertTensorDataAndNamesEqual result expected supported = torch ones torch rand torch randn torch zeros op device itertools product supported get_all_device_types _test op device Test torch full device get_all_device_types names = N T D result = torch full names=names device=device expected = torch full device=device rename_ names assertTensorDataAndNamesEqual result expected test_tensor_from_lists names = N C tensor = torch tensor names=names assertEqual tensor names names names = N tensor = torch tensor names=names assertEqual tensor names names assertRaisesRegex RuntimeError Number names names = N C tensor = torch tensor names=names unittest skipIf TEST_NUMPY no numpy test_tensor_from_numpy numpy np arr = np array names = N C tensor = torch tensor names=names assertEqual tensor names names test_tensor_from_tensor x = torch randn names = N C tensor = torch tensor x names=names assertEqual tensor names names test_tensor_from_named_tensor x = torch randn names= N D tensor = torch tensor x assertEqual tensor names N D there s no way distinguish between names=None passing names If user passes names=None they asking trouble x = torch randn names= N D tensor = torch tensor x names=None assertEqual tensor names N D x = torch randn names= N D assertRaisesRegex RuntimeError Name mismatch tensor = torch tensor x names= N C test_size t = torch empty names= N None C assertEqual t size N assertEqual t size C assertRaisesRegex RuntimeError Name \ channels\ found t size channels assertRaisesRegex RuntimeError Name \ N\ found torch empty size N test_stride t = torch empty names= N None C assertEqual t stride N assertEqual t stride C assertRaisesRegex RuntimeError Name \ channels\ found t stride channels assertRaisesRegex RuntimeError Name \ N\ found torch empty stride N test_transpose_variants t = torch randn names= N C H W assertEqual t transpose N C names C N H W assertEqual t transpose names N W H C t = torch randn names= N C assertEqual t t names C N test_resize device get_all_device_types named = torch randn names= N device=device named resize_ assertEqual named names N assertRaisesRegex RuntimeError Cannot resize named tensor named resize_ other_named = torch randn names= N device=device named resize_as_ other_named assertEqual other_named names N unnamed = torch randn device=device assertRaisesRegex RuntimeError r names same computed output names named resize_as_ unnamed unnamed = torch randn device=device unnamed resize_as_ named assertEqual unnamed names N test_cdist device get_all_device_types tensor = torch randn names= M N first_group features device=device other = torch randn names= N second_group features device=device result = torch cdist tensor other assertEqual result names M N first_group second_group test_info_smoke Smoke test info functions methods attributes named tensors tensor = torch empty names= N D tensor device tensor dtype tensor get_device tensor is_complex tensor is_floating_point tensor is_nonzero torch is_same_size tensor tensor torch is_signed tensor tensor layout tensor numel tensor dim tensor element_size tensor is_contiguous tensor is_cuda tensor is_leaf tensor is_pinned tensor is_shared tensor is_sparse tensor ndimension tensor nelement tensor shape tensor size tensor size tensor storage tensor storage_offset tensor storage_type tensor stride tensor stride tensor data tensor data_ptr tensor ndim tensor item tensor type tensor is_shared tensor is_signed test_autograd_smoke x = torch randn names= N D requires_grad=True y = x clone y retain_grad y register_hook lambda x x y sum backward autograd related attributes tensor = torch empty names= N D requires_grad=True tensor = tensor relu tensor output_nr tensor grad_fn tensor requires_grad test_split_fns_propagates_names fns = lambda x x split lambda x x split lambda x x chunk device get_all_device_types orig_tensor = torch empty names= N D device=device fn fns splits = fn orig_tensor split splits assertEqual split names orig_tensor names test_any_all device get_all_device_types x = torch zeros dtype=torch bool device=device names= C assertEqual x any names assertEqual x all names test_addcmul_addcdiv device get_all_device_types names = N = torch rand device=device names=names b = torch rand device=device names=names avoid division c = torch rand device=device names=names clamp_min_ out = torch randn device=device names=names assertEqual torch addcmul b c names names assertEqual torch addcmul b c out=out names names assertEqual addcmul_ b c names names assertEqual torch addcdiv b c names names assertEqual torch addcdiv b c out=out names names assertEqual addcdiv_ b c names names test_binary_ops test_basic op = torch empty names= N C b = torch empty names= C N c = torch empty names= C d = torch empty names= W assertEqual op names N C assertEqual op c names N C TODO dynamo will throw slightly different error message because s adding fake tensors ` must match size ` portion dynamo error assertRaisesRegex RuntimeError do match &#124; must match size op d assertRaisesRegex RuntimeError do match &#124; must match size op b test_wildcard op = torch empty names= N C c = torch empty names= None C assertEqual op c names N C b = torch empty assertEqual op b names N C d = torch empty names= C None assertRaisesRegex RuntimeError Misaligned op d c test_mixed_unnamed_named op is_inplace named = torch randn names= N C unnamed = torch randn unnamed = torch randn unnamed = torch randn compute_expected_names tensor other assert tensor has_names ^ other has_names named = tensor tensor has_names other unnamed = other tensor has_names tensor unnamed_dim = unnamed dim unnamed_dim named dim None unnamed_dim - named dim + list named names named names inputs = itertools chain itertools product named unnamed unnamed unnamed itertools product unnamed unnamed unnamed named is_inplace In-place ops have constraint they must change shape inputs = b b inputs dim = b dim tensor other inputs expected_names = compute_expected_names tensor other assertEqual op tensor other names expected_names method name args kwargs Function name lambda b getattr name b args kwargs function name args kwargs Function name lambda b getattr torch name b args kwargs out_function name args kwargs out_fn = getattr torch name fn b result = torch empty dtype=a dtype device=a device out_fn b args out=result kwargs result Function name fn fn_method_and_inplace name args kwargs method name args kwargs + method name + _ args kwargs + out_function name args kwargs tests = fn_method_and_inplace add fn_method_and_inplace div fn_method_and_inplace mul fn_method_and_inplace sub fn_method_and_inplace pow fn_method_and_inplace atan method copy_ function floor_divide function true_divide tests = flatten tests name op tests test_basic op test_wildcard op test_mixed_unnamed_named op is_inplace=name endswith _ test_logical_ops Implemented via TensorIterator so just check each version out-of-place inplace out= propagates names zeros args kwargs torch zeros args dtype=torch bool kwargs op logical_xor logical_and logical_or _test_name_inference getattr torch op create N C zeros create N C zeros expected_names= N C _test_name_inference getattr Tensor op + _ create N C zeros create N C zeros expected_names= N C _test_name_inference lambda out x y getattr torch op x y out=out create zeros create N C zeros create N C zeros expected_names= N C test_pow_special There few pow cases don t go through TensorIterator Test them here device get_all_device_types named = torch randn names= N C device=device unnamed = torch randn device=device result = torch pow named out=unnamed clone assertEqual result names named names result = torch pow named out=unnamed clone assertEqual result names named names result = torch pow named out=unnamed clone assertEqual result names named names test_out_fn_semantics out_fn = torch abs unnamed_tensor = torch randn none_named_tensor = torch randn names= None None named_tensor = torch randn names= N C partially_named_tensor = torch randn names= N None assertRaisesRegex RuntimeError Name mismatch out_fn partially_named_tensor out=named_tensor assertRaisesRegex RuntimeError Name mismatch out_fn named_tensor out=partially_named_tensor assertRaisesRegex RuntimeError Name mismatch out_fn none_named_tensor out=named_tensor assertRaisesRegex RuntimeError Name mismatch out_fn unnamed_tensor out=named_tensor output = torch randn out_fn unnamed_tensor out=output assertFalse output has_names output = torch randn names= None None out_fn named_tensor out=output assertEqual output names named_tensor names output = torch randn out_fn named_tensor out=output assertEqual output names named_tensor names output = torch randn names= None None out_fn unnamed_tensor out=output assertFalse output has_names test_unary_propagate_names_fns _test testcase names= N D device= cpu sizes = len names tensor = torch empty sizes names=names device=device try out = testcase lambd tensor except RuntimeError err Get better error message catching error asserting raise RuntimeError f testcase name err err assertEqual out names tensor names msg=testcase name fn name args kwargs Function name lambda t getattr torch name t args kwargs method name args kwargs Function name lambda t getattr t name args kwargs out_function name args kwargs out_fn = getattr torch name fn tensor result = torch empty dtype=tensor dtype device=tensor device out_fn tensor args out=result kwargs result Function name + _out fn fn_method_and_inplace name args kwargs method name args kwargs + method name + _ args kwargs + out_function name args kwargs All these operate x tensors tests = unary pointwise fn_method_and_inplace abs fn_method_and_inplace acos fn_method_and_inplace asin fn_method_and_inplace atan fn_method_and_inplace ceil fn_method_and_inplace clamp - fn_method_and_inplace clamp_min - fn_method_and_inplace clamp_max method cauchy_ method clone method contiguous fn_method_and_inplace cos fn_method_and_inplace cosh fn_method_and_inplace digamma fn_method_and_inplace erf fn_method_and_inplace erfc fn_method_and_inplace erfinv fn_method_and_inplace exp fn_method_and_inplace expm method exponential_ fn_method_and_inplace floor fn_method_and_inplace frac method geometric_ p= fn_method_and_inplace lgamma fn_method_and_inplace log fn_method_and_inplace log fn_method_and_inplace log p fn_method_and_inplace log method log_normal_ fn_method_and_inplace neg method normal_ Function polygamma lambda t torch polygamma t method polygamma_ fn_method_and_inplace reciprocal method random_ method random_ method random_ method relu_ method requires_grad_ method relu fn_method_and_inplace round fn_method_and_inplace rsqrt fn_method_and_inplace sigmoid fn_method_and_inplace sign fn_method_and_inplace sin fn_method_and_inplace sinh fn_method_and_inplace sqrt fn_method_and_inplace tan fn_method_and_inplace tanh fn threshold fn threshold_ out_function threshold fn_method_and_inplace trunc method uniform_ method zero_ method fill_ method fill_ torch tensor conversions method dtype=torch long method device= cpu method torch empty method bool method byte method char method cpu method double method float method long method half method int method short method type dtype=torch long cumsum cumprod fn cumsum fn cumsum D out_function cumsum D fn cumprod fn cumprod D out_function cumprod D views method narrow creation functions fn empty_like fn zeros_like fn ones_like fn full_like fn rand_like fn randn_like bernoulli variants method bernoulli_ method bernoulli_ torch tensor method softmax dim= method softmax dim= D method log_softmax dim= method log_softmax dim= D Function F dropout inplace lambda t F dropout t p= inplace=True Function F dropout outplace lambda t F dropout t p= inplace=False tests = flatten tests testcase device itertools product tests get_all_device_types _test testcase device=device test_cummax_cummin test_ops op device get_all_device_types names = N D tensor = torch rand names=names device=device result = op tensor assertEqual result names names assertEqual result names names test_ops torch cummax test_ops torch cummin test_logcumsumexp device get_all_device_types names = N D tensor = torch rand names=names device=device result = torch logcumsumexp tensor D assertEqual result names names test_bitwise_not device get_all_device_types names = N D tensor = torch zeros names=names dtype=torch bool device=device result = torch empty dtype=torch bool device=device assertEqual tensor bitwise_not names names assertEqual torch bitwise_not tensor out=result names names assertEqual tensor bitwise_not_ names names test_logical_not device get_all_device_types names = N D tensor = torch zeros names=names dtype=torch bool device=device result = torch empty dtype=torch bool device=device assertEqual tensor logical_not names names assertEqual torch logical_not tensor out=result names names assertEqual tensor logical_not_ names names test_bernoulli device get_all_device_types names = N D tensor = torch rand names=names device=device result = torch empty device=device assertEqual tensor bernoulli names names torch bernoulli tensor out=result assertEqual result names names test_flatten tensor = torch randn names= N C D H W basic out = tensor flatten D W features assertEqual out names N C features assertEqual out rename None tensor rename None view - int overload out = tensor flatten features assertEqual out names N C features assertEqual out rename None tensor rename None view - list overload out = tensor flatten D H W features assertEqual out names N C features assertEqual out rename None tensor rename None view - Non-contiguous flatten N H adjacent memory sentences = torch randn names= N T H D sentences = sentences transpose T H out = sentences flatten N H N_H assertEqual out names N_H T D assertRaisesRegex RuntimeError Name L found tensor flatten D L features assertRaisesRegex RuntimeError must consecutive tensor flatten D W features assertRaisesRegex RuntimeError must consecutive tensor flatten H D W features test_flatten_nodims tensor = torch empty assertRaisesRegex RuntimeError cannot empty tensor flatten abcd test_flatten_index_error tensor = torch randn assertRaisesRegex IndexError r Dimension out range \ expected range \ - \ got \ tensor flatten assertRaisesRegex IndexError r Dimension out range \ expected range \ - \ got \ tensor flatten N assertRaisesRegex RuntimeError r flatten\ \ has invalid args start_dim cannot come after end_dim tensor flatten assertRaisesRegex RuntimeError r flatten\ \ has invalid args start_dim cannot come after end_dim tensor flatten N test_unflatten test args tensor int namedshape assertTrue torch equal torch ones names= A unflatten A A B torch ones names= A B assertTrue torch equal torch ones names= A unflatten A A B torch ones names= A B assertTrue torch equal torch ones names= A unflatten A A B torch ones names= A B assertTrue torch equal torch ones names= A B unflatten B B - torch ones names= A B assertTrue torch equal torch ones names= A B unflatten B B B B - B torch ones names= A B B B B assertTrue torch equal torch ones names= A B unflatten B B B - B torch ones names= A B B B test args namedtensor str namedshape assertTrue torch equal torch ones names= A B unflatten B B B torch ones names= A B B test invalid args namedtensor str sizes assertRaisesRegex TypeError r unflatten\ \ argument dim \ position \ must int str torch tensor names= A unflatten A test invalid args namedtensor int sizes assertRaisesRegex RuntimeError r input named tensor no names given unflattened sizes torch tensor names= A unflatten assertRaisesRegex RuntimeError r Provided sizes \ - \ don t multiply up r size dim \ B \ Tensor\ A B \ torch ones names= A B unflatten B B B - assertRaisesRegex RuntimeError r unspecified dimension size - can any value ambiguous torch ones names= A B unflatten B B B - tensor = torch randn names= N D K accepts OrderedDict out = tensor unflatten D OrderedDict C H W assertEqual out names N C H W K assertEqual out shape Unflatten left-most out = tensor unflatten N N H assertEqual out names N H D K assertEqual out shape Unflatten right-most out = tensor unflatten K K H assertEqual out names N D K H assertEqual out shape assertRaisesRegex RuntimeError don t multiply up tensor unflatten D H W assertRaisesRegex RuntimeError sizes must non-empty tensor unflatten D None assertRaisesRegex RuntimeError non-empty tensor unflatten D OrderedDict test_unsupported_op_error_msg named = torch randn names= N C assertRaisesRegex RuntimeError r pdist +is yet supported named tensors torch pdist named assertRaisesRegex RuntimeError r as_strided_ +is yet supported named tensors named as_strided_ test_reduction_fns check_output output expected_names isinstance output torch Tensor assertEqual output names expected_names out output assertEqual out names expected_names sum_all_outputs output isinstance output torch Tensor output sum result = out output result = out + result result sum test_simple_reduce op device t = torch empty names= N C L device=device check_output op t N L check_output op t - N C check_output op t C N L ops_support_dim_none = sum mean std var std_mean var_mean nanmean nansum op __name__ ops_support_dim_none check_output op t None assertRaisesRegex RuntimeError Please look up dimensions name op t None assertRaisesRegex RuntimeError Name \ H\ found op t H test_autograd_supports_dimname_overload op device t = torch empty names= N C L device=device requires_grad=True sum_all_outputs op t C backward assertIsNotNone t grad test_complete_reduce op device t = torch empty names= N C L device=device check_output op t test_multidim_reduce op device t = torch empty names= N C L device=device check_output op t N check_output op t - C check_output op t C L N assertRaisesRegex RuntimeError Please look up dimensions name op t None C test_out_variant op output_lambda device t = torch empty names= N C L device=device output_lambda out = output_lambda t out = torch empty device=device op t C out=out check_output out N L test_keepdim op device t = torch empty names= N C L device=device check_output op t C keepdim=True N C L values_and_indices t torch empty device=t device torch empty device=t device dtype=torch long kthvalue_wrapper tensor args kwargs Return -th value torch kthvalue tensor args kwargs Case = namedtuple Case op supports_complete_reduce supports_multidim_reduce supports_out_variant supports_keepdim output_lambda tests = Case torch sum True True True True None Case torch prod True False True True None Case torch mean True True True True None Case torch var True True True True None Case torch std True True True True None Case torch std_mean True True False True None Case torch var_mean True True False True None Case torch min True False True True values_and_indices Case torch max True False True True values_and_indices Case torch unbind False False False False None Case torch logsumexp False True True True None Case torch mode False False True True values_and_indices Case kthvalue_wrapper False False True True values_and_indices Case torch median True False True True values_and_indices Case torch nanmedian True False True True values_and_indices testcase device itertools product tests get_all_device_types op = testcase op test_simple_reduce op device test_autograd_supports_dimname_overload op device testcase supports_keepdim test_keepdim op device testcase supports_out_variant test_out_variant op testcase output_lambda device testcase supports_complete_reduce test_complete_reduce op device testcase supports_multidim_reduce test_multidim_reduce op device test_masked_select simple _test_name_inference torch masked_select create N C create rename N C expected_names= None left broadcast _test_name_inference torch masked_select create C create rename N C expected_names= None right broadcast _test_name_inference torch masked_select create N C create rename C expected_names= None error _test_name_inference torch masked_select create N C create rename D maybe_raises_regex= do match out= _test_name_inference out_fn torch masked_select create create N C create rename N C expected_names= None test_cat simple _test_name_inference torch cat create N C create N C expected_names= N C error zero dim _test_name_inference torch cat create create maybe_raises_regex= zero-dim error names don t match _test_name_inference torch cat create N C create C N maybe_raises_regex= do match error different number dims _test_name_inference torch cat create N C create C maybe_raises_regex= must have same number dimensions out= _test_name_inference out_fn torch cat create create N C create N C expected_names= N C test_masked_fill simple _test_name_inference Tensor masked_fill create N C create rename N C expected_names= N C left broadcast _test_name_inference Tensor masked_fill create C create rename N C maybe_raises_regex= must less than equal right broadcast _test_name_inference Tensor masked_fill create N C create rename C expected_names= N C error _test_name_inference Tensor masked_fill create N C create rename D maybe_raises_regex= do match inplace _test_name_inference Tensor masked_fill_ create N C create rename N C expected_names= N C inplace computed names don t match output tensor names _test_name_inference Tensor masked_fill_ create N None create rename N C maybe_raises_regex= same computed output names test_using_seen_interned_string_doesnt_bump_refcount see_name seen_name = N pass_name_to_python_arg_parser seen_name see_name seen_name = N old_refcnt = sys getrefcount seen_name pass_name_to_python_arg_parser seen_name new_refcnt = sys getrefcount seen_name assertEqual new_refcnt old_refcnt This test failing Python https github com pytorch pytorch issues unittest skipIf sys version_info = Failing python + test_using_unseen_interned_string_bumps_refcount_permanently Please don t use name different test unseen_name = abcdefghi old_refcnt = sys getrefcount unseen_name pass_name_to_python_arg_parser unseen_name new_refcnt = sys getrefcount unseen_name assertEqual new_refcnt old_refcnt + This test failing Python https github com pytorch pytorch issues unittest skipIf sys version_info = Failing python + test_using_unseen_uninterned_string_refcounts Please don t use name different test non-compile-time constants interned unseen_name = join abc ghi jkl interned_unseen_name = abcdefghijkl assertFalse unseen_name interned_unseen_name old_uninterned_refcnt = sys getrefcount unseen_name old_interned_refcnt = sys getrefcount interned_unseen_name pass_name_to_python_arg_parser unseen_name new_uninterned_refcnt = sys getrefcount unseen_name new_interned_refcnt = sys getrefcount interned_unseen_name Internally PyTorch should hold reference uninterned string assertEqual new_uninterned_refcnt old_uninterned_refcnt Instead we should hold new reference interned version assertEqual new_interned_refcnt old_interned_refcnt + _test_select device x = torch empty names= N C H W device=device y = x select assertEqual y names N H W y = x select C assertEqual y names N H W assertRaisesRegex RuntimeError Please look up dimensions name y = x select None test_select _test_select cpu unittest skipIf TEST_CUDA no CUDA test_select_cuda _test_select cuda _test_as_strided device x = torch empty names= N C H W device=device y = x as_strided assertEqual y names None test_as_strided _test_as_strided cpu unittest skipIf TEST_CUDA no CUDA test_as_strided_cuda _test_as_strided cuda test_no_jit_tracer_support foo x torch full x shape names= N assertRaisesRegex RuntimeError supported tracer x = torch randn torch jit trace foo example_inputs=x bar x x select N assertRaisesRegex RuntimeError supported tracer x = torch randn torch jit trace bar example_inputs=x test_no_jit_script_support torch jit script foo x x + assertRaisesRegex RuntimeError NYI foo torch randn names= N C torch jit ignore add_names x x names = N C torch jit script return_named_tensor input add_names input input assertRaisesRegex RuntimeError NYI return_named_tensor torch randn test_align_to trivial tensor = create N output = tensor align_to N assertEqual output names N assertEqual output shape unsqueeze behavior tensor = create N output = tensor align_to N D assertEqual output names N D assertEqual output shape transpose behavior tensor = create N C output = tensor align_to C N assertEqual output names C N assertEqual output shape unsqueeze transpose tensor = create C N H output = tensor align_to N H W C assertEqual output names N H W C assertEqual output shape All input dimensions must named assertRaisesRegex RuntimeError All input dims must named Found unnamed dim index create None C align_to N C enough names assertRaisesRegex RuntimeError Cannot find dim N create N C align_to C names found assertRaisesRegex RuntimeError Cannot find dim C create N C align_to D N test_align_to_ellipsis tensor = create N H W C = N H W C output = tensor align_to assertEqual output names N H W C assertEqual output shape = H C output = tensor align_to W N assertEqual output names H C W N assertEqual output shape = N W output = tensor align_to H C assertEqual output names H C N W assertEqual output shape = H C output = tensor align_to W N assertEqual output names W H C N assertEqual output shape = output = tensor align_to N C D H W assertEqual output names N C D H W assertEqual output shape Input tensor partially named partially_named = create None None None C output = partially_named align_to C assertEqual output names C None None None assertEqual output shape assertRaisesRegex RuntimeError order dimensions cannot contain None partially_named align_to C None Input order partially named assertRaisesRegex RuntimeError cannot contain None name tensor align_to N None Input order duplicate names assertRaisesRegex RuntimeError duplicate names tensor align_to N N test_align_as align_as calls align_to internally align_to has pretty substantial tests so just test some basic things here tensor = create C N H other = create N H W C output = tensor align_as other assertEqual output names N H W C assertEqual output shape unittest skip Not implemented yet test_align_tensors_two_inputs _test tensor_namedshape align_names expected_sizes expected_error tensor_names tensor_sizes = tensor_namedshape tensor = torch empty tensor_sizes names=tensor_names other = torch empty len align_names names=align_names expected_error None assertRaisesRegex RuntimeError expected_error torch align_tensors tensor other output _ = torch align_tensors tensor other assertEqual output shape expected_sizes assertEqual output names align_names Case = namedtuple Case tensor_namedshape align_names expected_sizes expected_error tests = basic tests Case tensor_namedshape= C align_names= C expected_sizes= expected_error=None Case tensor_namedshape= C align_names= D expected_sizes=None expected_error= subsequence single-dim alignment test Case tensor_namedshape= C align_names= N C expected_sizes= expected_error=None Case tensor_namedshape= N align_names= N C expected_sizes= expected_error=None multiple dim alignment test Case tensor_namedshape= N C align_names= N H C W expected_sizes= expected_error=None Case tensor_namedshape= N C align_names= C H N W expected_sizes=None expected_error= subsequence scalar tensor tests Case tensor_namedshape= None align_names= N C expected_sizes= expected_error=None Case tensor_namedshape= align_names= None None expected_sizes= expected_error=None unnamed tensor tests Case tensor_namedshape= None align_names= None None expected_sizes= expected_error=None Case tensor_namedshape= None align_names= None None None expected_sizes= expected_error=None Case tensor_namedshape= None align_names= N expected_sizes=None expected_error= subsequence unnamed dim alignment tests Case tensor_namedshape= None align_names= N None expected_sizes= expected_error=None Case tensor_namedshape= None align_names= N None None None expected_sizes= expected_error=None Case tensor_namedshape= N align_names= N None None None expected_sizes= expected_error=None Case tensor_namedshape= None N None align_names= None None N None expected_sizes= expected_error=None Case tensor_namedshape= None align_names= None N expected_sizes=None expected_error= absolute position right Case tensor_namedshape= None align_names= None N expected_sizes=None expected_error= absolute position right Case tensor_namedshape= None N align_names= None C N expected_sizes=None expected_error= absolute position right test tests _test test unittest skip Not implemented yet test_align_tensors reference_fn tensors longest_names = tensors names tensor tensors len tensor names len longest_names longest_names = tensor names tensor align_to longest_names tensor tensors x = torch empty names= N H y = torch empty names= N C H z = torch empty names= N output = torch align_tensors x y z expected_tensors = reference_fn x y z tensor expected zip output expected_tensors assertTensorDataAndNamesEqual tensor expected test_mm device get_all_device_types _test_name_inference torch mm device=device args= create N C create W H expected_names= N H left arg unnamed _test_name_inference torch mm device=device args= create create W H expected_names= None H right arg unnamed _test_name_inference torch mm device=device args= create N C create expected_names= N None out= _test_name_inference out_fn torch mm device=device args= create create N C create W H expected_names= N H _test_name_inference torch mm device=device args= create N C create W N maybe_raises_regex= duplicate names test_expand device get_all_device_types _test_name_inference Tensor expand device=device args= create D expected_names= D _test_name_inference Tensor expand device=device args= create H W expected_names= None None H W _test_name_inference Tensor expand device=device args= create expected_names= None None None None test_addmm device get_all_device_types full names _test_name_inference torch addmm device=device args= create N H create N C create W H expected_names= N H no name bias _test_name_inference torch addmm device=device args= create create N C create W H expected_names= N H partially named bias _test_name_inference torch addmm device=device args= create N None create N C create W H expected_names= N H out= _test_name_inference out_fn torch addmm device=device args= create create N None create N C create W H expected_names= N H inplace _test_name_inference torch Tensor addmm_ device=device args= create N H create N C create W H expected_names= N H _test_name_inference torch addmm device=device args= create N H create N C create W N maybe_raises_regex= duplicate names test_bmm device get_all_device_types full names _test_name_inference torch bmm device=device args= create N A B create N A B expected_names= N A B no name left tensor _test_name_inference torch bmm device=device args= create create N A B expected_names= N None B no name right tensor _test_name_inference torch bmm device=device args= create N A B create expected_names= N A None out= _test_name_inference out_fn torch bmm device=device args= create create N A B create N A B expected_names= N A B duplicate names after mm _test_name_inference torch bmm device=device args= create N A B create N B A maybe_raises_regex= duplicate names matching error batch dimensions must alignable _test_name_inference torch bmm device=device args= create N A B create M A B maybe_raises_regex= do match misalignment batch dimension getting contracted _test_name_inference torch bmm device=device args= create N A B create None N B maybe_raises_regex= misaligned test_matmul device get_all_device_types input tensors less than D _test_name_inference torch matmul device=device args= create create A maybe_raises_regex= least D _test_name_inference torch matmul device=device args= create A create maybe_raises_regex= least D D D _test_name_inference torch matmul device=device args= create A create B expected_names= ND D _test_name_inference torch matmul device=device args= create A C create B expected_names= A _test_name_inference torch matmul device=device args= create A C D create B expected_names= A C D ND _test_name_inference torch matmul device=device args= create C create A B expected_names= B _test_name_inference torch matmul device=device args= create C create A B D expected_names= A D D D _test_name_inference torch matmul device=device args= create A B create A B expected_names= A B _test_name_inference torch matmul device=device args= create A B create B A maybe_raises_regex= duplicate names ND ND where N = _test_name_inference torch matmul device=device args= create C A B create A B expected_names= C A B _test_name_inference torch matmul device=device args= create C A B create None A B expected_names= C A B _test_name_inference torch matmul device=device args= create C A B create None None A B expected_names= None C A B out= _test_name_inference out_fn torch matmul device=device args= create create N A B create N A B expected_names= N A B duplicate names after mm _test_name_inference torch bmm device=device args= create N A B create N B A maybe_raises_regex= duplicate names misalignment batch dimension getting contracted _test_name_inference torch matmul device=device args= create N A B create A N B maybe_raises_regex= do match test_mv device get_all_device_types _test_name_inference torch mv device=device args= create N C create W expected_names= N left arg unnamed _test_name_inference torch mv device=device args= create create W expected_names= None right arg unnamed _test_name_inference torch mv device=device args= create N C create expected_names= N out= _test_name_inference out_fn torch mv device=device args= create create N C create W expected_names= N test_addmv device get_all_device_types full names _test_name_inference torch addmv device=device args= create N create N C create H expected_names= N no name bias _test_name_inference torch addmv device=device args= create create N C create H expected_names= N out= _test_name_inference out_fn torch addmv device=device args= create create N create N C create H expected_names= N inplace _test_name_inference torch Tensor addmv_ device=device args= create N create N C create H expected_names= N test_autograd_ignores_names sigmoid forward supported named tensors sigmoid_backward see native_functions yaml Test autograd ignores names sigmoid_backward succeeds x = torch randn names= N C requires_grad=True x sigmoid sum backward test_tensor_grad_is_unnamed x = torch randn names= None None requires_grad=True y = torch randn names= N C requires_grad=True x y sum backward Check names weren t propagated assertEqual y grad names None None assertEqual x grad names None None test_autograd_warns_named_grad base = torch randn names= N C named_grad = base clone base requires_grad_ warnings catch_warnings record=True warns Cause all warnings always triggered warnings simplefilter always base clone backward named_grad assertEqual len warns assertTrue str warns message startswith Autograd passed named grad tensor test_nyi_dimname_overload_msg x = torch randn assertRaisesRegex RuntimeError squeeze You passed dimname x squeeze_ N test_dot device get_all_device_types torch dot ignores names both tensors _test_name_inference torch dot device=device args= create C create W expected_names= test_comparison_ops device get_all_device_types = torch randn names= N C device=device b = torch randn names= N C device=device scalar = torch randn device=device assertEqual == b names N C assertEqual = b names N C assertEqual b names N C assertEqual b names N C assertEqual = b names N C assertEqual = b names N C assertEqual == names N C assertEqual = names N C assertEqual names N C assertEqual names N C assertEqual = names N C assertEqual = names N C assertEqual == scalar names N C assertEqual = scalar names N C assertEqual scalar names N C assertEqual scalar names N C assertEqual = scalar names N C assertEqual = scalar names N C res = torch empty dtype=torch bool device=device torch eq b out=res assertEqual res names N C torch ne b out=res assertEqual res names N C torch lt b out=res assertEqual res names N C torch gt b out=res assertEqual res names N C torch le b out=res assertEqual res names N C torch ge b out=res assertEqual res names N C res = torch isnan assertEqual res names N C res = torch isinf assertEqual res names N C test_support_device_named_grad named_tensor = torch randn device= meta assertRaisesRegex RuntimeError NYI named tensors only support CPU CUDA named_tensor rename_ N C named_tensor names = N C named_tensor = torch randn device= meta names= N C __name__ == __main__ run_tests