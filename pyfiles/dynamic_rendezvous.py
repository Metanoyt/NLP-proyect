mypy allow-untyped-defs Copyright c Facebook Inc its affiliates All rights reserved This source code licensed under BSD-style license found LICENSE file root directory source tree inspect logging os pickle socket threading time weakref abc ABC abstractmethod collections abc Callable dataclasses dataclass datetime datetime timedelta timezone enum Enum typing Any Optional torch distributed dist torch distributed Store torch distributed elastic events construct_and_record_rdzv_event NodeState api RendezvousClosedError RendezvousError RendezvousGracefulExitError RendezvousHandler RendezvousInfo RendezvousParameters RendezvousStateError RendezvousStoreInfo RendezvousTimeoutError utils _delay _PeriodicTimer __all__ = RendezvousBackend RendezvousTimeout RendezvousSettings DynamicRendezvousHandler create_handler logger = logging getLogger __name__ get_method_name depth= len inspect stack depth inspect stack depth function no_method_name Token = Any Represent opaque fencing token used rendezvous backend RendezvousBackend ABC Represent backend holds rendezvous state property abstractmethod name - str Get name backend abstractmethod get_state - Optional tuple bytes Token Get rendezvous state Returns A tuple encoded rendezvous state its fencing token ` ` None ` ` no state found backend Raises RendezvousConnectionError The connection backend has failed RendezvousStateError The rendezvous state corrupt abstractmethod set_state state bytes token Optional Token = None - Optional tuple bytes Token bool Set rendezvous state The new rendezvous state set conditionally - If specified ` ` token ` ` matches fencing token stored backend state will updated The new state will returned caller along its fencing token - If specified ` ` token ` ` does match fencing token stored backend state won t updated instead existing state along its fencing token will returned caller - If specified ` ` token ` ` ` ` None ` ` new state will set only there no existing state backend Either new state existing state along its fencing token will returned caller Args state The encoded rendezvous state token An optional fencing token retrieved previous call py meth ` get_state ` ` ` set_state ` ` Returns A tuple serialized rendezvous state its fencing token boolean value indicating whether our set attempt succeeded Raises RendezvousConnectionError The connection backend has failed RendezvousStateError The rendezvous state corrupt RendezvousTimeout Hold timeout configuration rendezvous Args join The time within which rendezvous expected complete last_call An additional wait amount before completing rendezvous once rendezvous has minimum number required participants close The time within which rendezvous expected close after call py meth ` RendezvousHandler set_closed ` py meth ` RendezvousHandler shutdown ` heartbeat The time within which keep-alive heartbeat expected complete _ZERO = timedelta _DEFAULT_TIMEOUTS = join timedelta seconds= last_call timedelta seconds= close timedelta seconds= heartbeat timedelta seconds= _join timedelta _last_call timedelta _close timedelta _heartbeat timedelta __init__ join Optional timedelta = None last_call Optional timedelta = None close Optional timedelta = None heartbeat Optional timedelta = None - None _set_timeouts join=join last_call=last_call close=close heartbeat=heartbeat property join - timedelta Get join timeout _join property last_call - timedelta Get last call timeout _last_call property close - timedelta Get close timeout _close property heartbeat - timedelta Get keep-alive heartbeat timeout _heartbeat _set_timeouts timeouts Optional timedelta name timeout timeouts items timeout None timeout = _DEFAULT_TIMEOUTS name timeout = _ZERO raise ValueError f The name timeout timeout must positive setattr _ + name timeout dataclass repr=False eq=False frozen=True RendezvousSettings Hold settings rendezvous Attributes run_id The run id rendezvous min_nodes The minimum number nodes admit rendezvous max_nodes The maximum number nodes admit rendezvous timeout The timeout configuration rendezvous keep_alive_interval The amount time node waits before sending heartbeat keep alive rendezvous keep_alive_max_attempt The maximum number failed heartbeat attempts after which node considered dead run_id str min_nodes int max_nodes int timeout RendezvousTimeout keep_alive_interval timedelta keep_alive_max_attempt int dataclass eq=True order=True frozen=True _NodeDesc Describe node rendezvous Attributes addr The FQDN node user specified local node address pid The id process which rendezvous handler runs local_id A process-wide unique id addr str pid int local_id int __repr__ - str f addr _ pid _ local_id _NodeDescGenerator Generate node descriptors A node descriptor combination FQDN process id auto- incremented integer uniquely identifies node rendezvous _lock threading Lock _local_id int __init__ - None _lock = threading Lock An integer incremented each call generate _local_id = generate local_addr Optional str = None - _NodeDesc This method can called multiple threads concurrently therefore we must increment integer atomically _lock local_id = _local_id _local_id += _NodeDesc local_addr socket getfqdn os getpid local_id _RendezvousState Hold state rendezvous Attributes round The current round rendezvous complete A boolean value indicating whether current round rendezvous complete deadline The time which current round rendezvous will considered complete still waiting nodes join closed A boolean value indicating whether rendezvous closed participants A dictionary participants their corresponding ranks wait_list A set nodes waiting participate next round rendezvous redundancy_list A set nodes redundant current round can join next rendezvous without triggering re-rendezvous last_heartbeats A dictionary containing each node s last heartbeat time round int complete bool deadline Optional datetime closed bool participants dict _NodeDesc int wait_list set _NodeDesc redundancy_list set _NodeDesc last_heartbeats dict _NodeDesc datetime __init__ - None round = complete = False deadline = None closed = False participants = wait_list = set redundancy_list = set last_heartbeats = _remove_participant_epilogue state _RendezvousState settings RendezvousSettings - None state complete If we do have any participants left move next round state participants msg = No participants left rendezvous marking rendezvous incomplete logger debug msg state complete = False state round += len state participants settings min_nodes msg = f Number participants len state participants less than f min_nodes settings min_nodes clearning deadline state logger debug msg state deadline = None _RendezvousStateHolder ABC Hold shared rendezvous state synced other nodes property abstractmethod state - _RendezvousState Get local state abstractmethod sync - Optional bool Read writes latest state Returns A boolean value indicating whether local state case marked dirty successfully synced other nodes abstractmethod mark_dirty - None Mark local state dirty _BackendRendezvousStateHolder _RendezvousStateHolder Hold rendezvous state synced other nodes via backend Args backend The rendezvous backend use settings The rendezvous settings cache_duration The amount time seconds cache last rendezvous state before requesting backend again _backend RendezvousBackend _state _RendezvousState _settings RendezvousSettings _cache_duration int _token Token _dirty bool _last_sync_time float _dead_nodes list _NodeDesc __init__ backend RendezvousBackend settings RendezvousSettings cache_duration int = - None _backend = backend _state = _RendezvousState _settings = settings _cache_duration = cache_duration _token = None _dirty = False _last_sync_time = - _dead_nodes = _record message str node_state NodeState = NodeState RUNNING construct_and_record_rdzv_event name=f __class__ __name__ get_method_name run_id=self _settings run_id message=message node_state=node_state property state - _RendezvousState See base _state sync - Optional bool See base state_bits Optional bytes = None token = None has_set Optional bool _dirty has_set = False state_bits = pickle dumps _state set_response = _backend set_state state_bits _token set_response None state_bits token has_set = set_response has_set = None _cache_duration Avoid overloading backend we asked retrieve state repeatedly Try serve cached state _last_sync_time = max time monotonic - _cache_duration None get_response = _backend get_state get_response None state_bits token = get_response state_bits None try _state = pickle loads state_bits except pickle PickleError exc raise RendezvousStateError The rendezvous state corrupt See inner exception details exc _state = _RendezvousState has_set _dead_nodes logger isEnabledFor logging DEBUG node_list = join f dead_node dead_node _dead_nodes msg = f As part sync operation node s node_list have been removed f rendezvous _settings run_id since they had no heartbeat _record message=msg logger debug msg _token = token _dirty = False _last_sync_time = time monotonic _sanitize has_set _sanitize - None state = _state expire_time = datetime now timezone utc - _settings keep_alive_interval _settings keep_alive_max_attempt Filter out dead nodes _dead_nodes = node node last_heartbeat state last_heartbeats items last_heartbeat expire_time participant_removed = False dead_node _dead_nodes msg = f Detected dead node dead_node removing rendezvous logger debug msg del state last_heartbeats dead_node try del state participants dead_node participant_removed = True except KeyError pass try state wait_list remove dead_node except KeyError pass try state redundancy_list remove dead_node except KeyError pass participant_removed Common epilogue shared _remove_from_participants function _DistributedRendezvousOpExecutor _remove_participant_epilogue state _settings mark_dirty - None See base If local rendezvous state dirty next sync call will try write changes back backend However attempt might fail another node which had same state also made changes wrote them before us _dirty = True _Action Enum Specifies possible actions based state rendezvous KEEP_ALIVE = ADD_TO_PARTICIPANTS = ADD_TO_WAIT_LIST = ADD_TO_REDUNDANCY_LIST = REMOVE_FROM_PARTICIPANTS = REMOVE_FROM_WAIT_LIST = REMOVE_FROM_REDUNDANCY_LIST = MARK_RENDEZVOUS_COMPLETE = MARK_RENDEZVOUS_CLOSED = SYNC = ERROR_CLOSED = ERROR_TIMEOUT = FINISH = _RendezvousContext Holds context rendezvous Attributes node The node descriptor associated current rendezvous handler instance state The current state rendezvous settings The rendezvous settings node _NodeDesc state _RendezvousState settings RendezvousSettings __init__ node _NodeDesc state _RendezvousState settings RendezvousSettings - None node = node state = state settings = settings _RendezvousOpExecutor ABC Execute rendezvous operations abstractmethod run state_handler Callable _RendezvousContext float _Action deadline float update_deadline Optional Callable timedelta float = None - None Execute rendezvous operation An operation run inside state machine expected transition rendezvous one state another Args state_handler A callable expected next state transition action based current state rendezvous deadline The time seconds which operation will considered timed-out update_deadline Function generate new operation deadline current node may participate next rendezvous _DistributedRendezvousOpExecutor _RendezvousOpExecutor Execute rendezvous operations using shared state Args node The node descriptor associated current rendezvous handler instance state_holder The ` ` RendezvousStateHolder ` ` use sync rendezvous state other nodes settings The rendezvous settings _node _NodeDesc _state _RendezvousState _state_holder _RendezvousStateHolder _settings RendezvousSettings __init__ node _NodeDesc state_holder _RendezvousStateHolder settings RendezvousSettings - None _node = node _state_holder = state_holder _settings = settings _record message str node_state NodeState = NodeState RUNNING - None construct_and_record_rdzv_event name=f __class__ __name__ get_method_name run_id=self _settings run_id message=message node_state=node_state hostname=self _node addr pid=self _node pid local_id=self _node local_id run state_handler Callable _RendezvousContext float _Action deadline float update_deadline Optional Callable timedelta float = None - None See base action = None while action = _Action FINISH Reads writes latest rendezvous state shared all nodes rendezvous Note our local changes might get overridden another node node synced its changes before us has_set = _state_holder sync has_set None has_set msg = f The node _node has successfully synced its local changes f other nodes rendezvous _settings run_id msg = f The node _node has stale state failed sync its local f changes other nodes rendezvous _settings run_id _record message=msg logger debug msg _state = _state_holder state ctx = _RendezvousContext _node _state _settings Determine next action take based current state rendezvous action = state_handler ctx deadline action == _Action FINISH continue action == _Action ERROR_CLOSED raise RendezvousClosedError action == _Action ERROR_TIMEOUT raise RendezvousTimeoutError action == _Action SYNC Delay execution one second avoid overloading backend we asked poll state changes _delay seconds= action == _Action KEEP_ALIVE _keep_alive action == _Action ADD_TO_PARTICIPANTS _add_to_participants action == _Action ADD_TO_WAIT_LIST _add_to_wait_list action == _Action ADD_TO_REDUNDANCY_LIST _add_to_redundancy_list action == _Action REMOVE_FROM_PARTICIPANTS _remove_from_participants action == _Action REMOVE_FROM_WAIT_LIST _remove_from_wait_list action == _Action REMOVE_FROM_REDUNDANCY_LIST _remove_from_redundancy_list update deadline since node may participate rendezvous process update_deadline deadline = update_deadline _settings timeout join action == _Action MARK_RENDEZVOUS_COMPLETE _mark_rendezvous_complete action == _Action MARK_RENDEZVOUS_CLOSED _mark_rendezvous_closed Attempt sync our changes back other nodes _state_holder mark_dirty _keep_alive - None msg = f The node _node updated its keep-alive heartbeat time rendezvous f _settings run_id Pending sync _record message=msg logger debug msg _state last_heartbeats _node = datetime now timezone utc _add_to_participants - None msg = f The node _node added itself participants round f _state round rendezvous _settings run_id Pending sync _record message=msg logger debug msg state = _state try state wait_list remove _node except KeyError pass The ranks participants will set once rendezvous complete state participants _node = _keep_alive len state participants == _settings min_nodes state deadline = datetime now timezone utc + _settings timeout last_call len state participants == _settings max_nodes _mark_rendezvous_complete _add_to_wait_list - None msg = f The node _node added itself wait list round f _state round + rendezvous _settings run_id Pending sync _record message=msg logger debug msg _node _state redundancy_list _state redundancy_list remove _node _state wait_list add _node _keep_alive _add_to_redundancy_list - None msg = f The node _node added itself redundancy list round f _state round + rendezvous _settings run_id Pending sync _record message=msg logger debug msg _state redundancy_list add _node _keep_alive _remove_from_participants - None msg = f The node _node removed itself participants round f _state round rendezvous _settings run_id Pending sync _record message=msg logger debug msg state = _state del state participants _node del state last_heartbeats _node Common epilogue shared sanitizer function _BackendRendezvousStateHolder _remove_participant_epilogue state _settings _remove_from_wait_list - None msg = f The node _node removed itself wait list round f _state round + rendezvous _settings run_id Pending sync _record message=msg logger debug msg _state wait_list remove _node del _state last_heartbeats _node _remove_from_redundancy_list - None msg = f The node _node removed itself redundant list round f _state round + rendezvous _settings run_id Pending sync _record message=msg logger debug msg _state redundancy_list remove _node del _state last_heartbeats _node _mark_rendezvous_complete - None msg = f The node _node marked round _state round rendezvous f _settings run_id complete Pending sync _record message=msg node_state=NodeState SUCCEEDED logger debug msg state = _state state complete = True state deadline = None Assign ranks rank node enumerate sorted state participants state participants node = rank _mark_rendezvous_closed - None msg = f The node _node marked rendezvous _settings run_id closed Pending sync _record message=msg node_state=NodeState SUCCEEDED logger debug msg _state closed = True _should_keep_alive ctx _RendezvousContext - bool Determine whether keep-alive heartbeat should sent try last_heartbeat = ctx state last_heartbeats ctx node except KeyError False last_heartbeat = datetime now timezone utc - ctx settings keep_alive_interval _RendezvousExitOp Represent rendezvous exit operation __call__ ctx _RendezvousContext deadline float - _Action ctx node ctx state participants time monotonic deadline _Action ERROR_TIMEOUT _Action REMOVE_FROM_PARTICIPANTS _Action FINISH _RendezvousJoinOp Represent rendezvous join operation __call__ ctx _RendezvousContext deadline float - _Action state = ctx state A closed rendezvous means no longer accepts new nodes state closed ctx node state redundancy_list msg = f The rendezvous ctx settings run_id closed terminating pending rendezvous raise RendezvousGracefulExitError msg _Action ERROR_CLOSED ctx node state redundancy_list msg = f The node ctx node redundancy list logger debug msg don t apply timeout logic here since we want allow node rejoin len state participants == ctx settings max_nodes _should_keep_alive ctx _Action KEEP_ALIVE _Action SYNC transition waiting state will respect timeouts msg = f The node ctx node removed redundancy list logger debug msg _Action REMOVE_FROM_REDUNDANCY_LIST is_participant = ctx node state participants If we part rendezvous already complete there no further action take state complete is_participant _Action FINISH now = time monotonic now deadline rollback_period = seconds If we still have time rollback short period top operation deadline try remove ourself rendezvous It okay we can t though our keep-alive will eventually expire now = deadline + rollback_period If we part rendezvous means we couldn t find enough participants complete time is_participant _Action REMOVE_FROM_PARTICIPANTS If we wait list means we couldn t wait till next round rendezvous ctx node state wait_list _Action REMOVE_FROM_WAIT_LIST _Action ERROR_TIMEOUT state complete If we here means we part rendezvous In case rendezvous has capacity additional participants add ourself wait list next round len state participants ctx settings max_nodes ctx node state wait_list _Action ADD_TO_WAIT_LIST len state participants = ctx settings max_nodes ctx node state redundancy_list ctx node state wait_list _Action ADD_TO_REDUNDANCY_LIST is_participant If rendezvous has enough number participants including us check whether we have passed rendezvous deadline If yes complete len state participants = ctx settings min_nodes len state participants = ctx settings max_nodes state deadline None state deadline datetime now timezone utc msg = f The node ctx node marking rendezvous complete f quorum established within deadline logger debug msg _Action MARK_RENDEZVOUS_COMPLETE msg = f The node ctx node can t complete rendezvous deadline reached logger debug msg msg = f The node ctx node can t complete rendezvous enough participants logger debug msg The rendezvous complete yet we part Try join _Action ADD_TO_PARTICIPANTS _should_keep_alive ctx _Action KEEP_ALIVE At point either rendezvous complete we part which means we have wait other participants join rendezvous complete we part which means we have wait next round _Action SYNC _RendezvousCloseOp Represent rendezvous close operation __call__ ctx _RendezvousContext deadline float - _Action ctx state closed _Action FINISH time monotonic deadline _Action ERROR_TIMEOUT _Action MARK_RENDEZVOUS_CLOSED _RendezvousKeepAliveOp Represent rendezvous keep-alive update operation __call__ ctx _RendezvousContext deadline float - _Action _should_keep_alive ctx time monotonic deadline _Action ERROR_TIMEOUT _Action KEEP_ALIVE _Action FINISH DynamicRendezvousHandler RendezvousHandler Represent handler sets up rendezvous among set nodes Static _node_desc_generator = _NodeDescGenerator _this_node _NodeDesc _settings RendezvousSettings _backend_name str _store Store _state_holder _RendezvousStateHolder _op_executor _RendezvousOpExecutor _heartbeat_lock threading Lock _keep_alive_timer Optional _PeriodicTimer classmethod from_backend cls run_id str store Store backend RendezvousBackend min_nodes int max_nodes int local_addr Optional str = None timeout Optional RendezvousTimeout = None keep_alive_interval int = keep_alive_max_attempt int = Create new py ` DynamicRendezvousHandler ` Args run_id The run id rendezvous store The C d store part rendezvous backend The backend use hold rendezvous state min_nodes The minimum number nodes admit rendezvous max_nodes The maximum number nodes admit rendezvous local_addr The local node address timeout The timeout configuration rendezvous keep_alive_interval The amount time node waits before sending heartbeat keep alive rendezvous keep_alive_max_attempt The maximum number failed heartbeat attempts after which node considered dead We associate each handler instance unique node descriptor node = cls _node_desc_generator generate local_addr settings = RendezvousSettings run_id min_nodes max_nodes timeout RendezvousTimeout keep_alive_interval=timedelta seconds=keep_alive_interval keep_alive_max_attempt=keep_alive_max_attempt state_holder = _BackendRendezvousStateHolder backend settings cls node settings backend name store state_holder __init__ node _NodeDesc settings RendezvousSettings backend_name str store Store state_holder _RendezvousStateHolder - None settings run_id raise ValueError The run id must non-empty string settings min_nodes raise ValueError f The minimum number nodes settings min_nodes must greater than zero settings max_nodes settings min_nodes raise ValueError f The maximum number nodes settings max_nodes must greater than equal f minimum number nodes settings min_nodes _this_node = node _settings = settings _backend_name = backend_name _store = store _state_holder = state_holder _op_executor = _DistributedRendezvousOpExecutor _this_node _state_holder _settings _heartbeat_lock = threading Lock _keep_alive_timer = None Cached shared store server reference _shared_tcp_store_server Optional dist Store = None _bootstrap_store_info Optional RendezvousStoreInfo = None _record message str node_state NodeState = NodeState RUNNING rank Optional int = None - None construct_and_record_rdzv_event name=f __class__ __name__ get_method_name run_id=self _settings run_id message=message node_state=node_state hostname=self _this_node addr pid=self _this_node pid local_id=self _this_node local_id rank=rank _create_tcp_store_server master_addr master_port - dist TCPStore dist TCPStore host_name=master_addr port=master_port is_master=True multi_tenant=True property settings - RendezvousSettings Get settings rendezvous _settings get_backend - str See base _backend_name property use_agent_store - bool See base os getenv TORCH_DISABLE_SHARE_RDZV_TCP_STORE = next_rendezvous - RendezvousInfo See base msg = f The node _this_node attempts join next round rendezvous f _settings run_id _record message=msg logger info msg try _stop_heartbeats Delay execution small random amount time our first run This will slightly skew rendezvous attempts across nodes reduce load backend _state_holder state round == _delay seconds= exit_op = _RendezvousExitOp join_op = _RendezvousJoinOp deadline = _get_deadline _settings timeout join _op_executor run exit_op deadline _op_executor run join_op deadline _get_deadline _start_heartbeats rank world_size = _get_world store = _get_store except Exception e _record message=f type e __name__ str e node_state=NodeState FAILED raise msg = f The node _this_node has joined round _state_holder state round f rendezvous _settings run_id rank rank world size f world_size _record message=msg rank=rank logger info msg opt-out option TCPStore sharing os getenv TORCH_DISABLE_SHARE_RDZV_TCP_STORE == bootstrap_store_info = RendezvousStoreInfo build rank store local_addr=self _this_node addr RendezvousInfo store rank world_size bootstrap_store_info This will only hit when TCPStore sharing enabled _bootstrap_store_info None To avoid race get_free_port because we release port after call we want create TCPStore server soon afterwards server_port = rank == _shared_tcp_store_server = _create_tcp_store_server _this_node addr server_port server_port = _shared_tcp_store_server port _bootstrap_store_info = RendezvousStoreInfo build rank store local_addr=self _this_node addr server_port=server_port For non- rank no-op assert _bootstrap_store_info None rank == assert _shared_tcp_store_server None RendezvousInfo store rank world_size _bootstrap_store_info type ignore assignment is_closed - bool See base try _heartbeat_lock _state_holder sync _state_holder state closed except Exception e _record message=f type e __name__ str e node_state=NodeState FAILED raise set_closed - None See base try _heartbeat_lock _close except Exception e _record message=f type e __name__ str e node_state=NodeState FAILED raise num_nodes_waiting - int See base try _heartbeat_lock _state_holder sync len _state_holder state wait_list except Exception e _record message=f type e __name__ str e node_state=NodeState FAILED raise get_run_id - str See base _settings run_id shutdown - bool See base _stop_heartbeats try _close True except RendezvousError ex msg = f The node _this_node has failed shutdown rendezvous f _settings run_id due error type type ex __name__ _record message=msg node_state=NodeState FAILED logger warning msg False except Exception e _record message=f type e __name__ str e node_state=NodeState FAILED raise _close - None op = _RendezvousCloseOp deadline = _get_deadline _settings timeout close _op_executor run op deadline msg = f The node _this_node has closed rendezvous _settings run_id _record message=msg node_state=NodeState SUCCEEDED logger info msg staticmethod _keep_alive_weak weak_self - None = weak_self None _keep_alive _keep_alive - None _heartbeat_lock acquire op = _RendezvousKeepAliveOp deadline = _get_deadline _settings timeout heartbeat try _op_executor run op deadline msg = f The node _this_node has sent keep-alive heartbeat rendezvous f _settings run_id _record message=msg logger debug msg except RendezvousError ex msg = f The node _this_node has failed send keep-alive heartbeat f rendezvous _settings run_id due error type type ex __name__ _record message=msg node_state=NodeState FAILED logger warning msg finally _heartbeat_lock release _start_heartbeats - None _keep_alive_timer = _PeriodicTimer _settings keep_alive_interval _keep_alive_weak weakref ref _keep_alive_timer set_name f RendezvousKeepAliveTimer_ _this_node local_id _keep_alive_timer start _stop_heartbeats - None _keep_alive_timer None _keep_alive_timer cancel _get_world - tuple int int state = _state_holder state state participants _this_node len state participants _wrap_store store Store - Store key_prefix = f torch rendezvous _settings run_id _state_holder state round dist PrefixStore key_prefix store _get_store - Store _wrap_store _store _get_deadline timeout timedelta - float time monotonic + timeout total_seconds _get_timeout params RendezvousParameters key str - Optional timedelta timeout = params get_as_int key + _timeout timeout None None timedelta seconds=timeout create_handler store Store backend RendezvousBackend params RendezvousParameters - DynamicRendezvousHandler Create new py ` DynamicRendezvousHandler ` specified parameters Args store The C d store part rendezvous backend The backend use hold rendezvous state + ------------------- + ------------------------------------------------------ + &#124; Parameter &#124; Description &#124; +===================+======================================================+ &#124; join_timeout &#124; The total time seconds within which &#124; &#124; &#124; rendezvous expected complete Defaults &#124; &#124; &#124; seconds &#124; + ------------------- + ------------------------------------------------------ + &#124; last_call_timeout &#124; An additional wait amount seconds before &#124; &#124; &#124; completing rendezvous once minimum number &#124; &#124; &#124; nodes has been reached Defaults seconds &#124; + ------------------- + ------------------------------------------------------ + &#124; close_timeout &#124; The time seconds within which rendezvous &#124; &#124; &#124; expected close after call &#124; &#124; &#124; py meth ` RendezvousHandler set_closed ` &#124; &#124; &#124; py meth ` RendezvousHandler shutdown ` Defaults &#124; &#124; &#124; seconds &#124; + ------------------- + ------------------------------------------------------ + &#124; heartbeat &#124; The time seconds within which keep-alive &#124; &#124; &#124; heartbeat expected complete &#124; + ------------------- + ------------------------------------------------------ + try timeout = RendezvousTimeout _get_timeout params join _get_timeout params last_call _get_timeout params close _get_timeout params heartbeat keep_alive_interval = params get_as_int keep_alive_interval keep_alive_interval None raise TypeError You passed keep_alive_interval=None rendezvous configuration option keep_alive_max_attempt = params get_as_int keep_alive_max_attempt keep_alive_max_attempt None raise TypeError You passed keep_alive_max_attempt=None rendezvous configuration option DynamicRendezvousHandler from_backend params run_id store backend params min_nodes params max_nodes params local_addr timeout keep_alive_interval=keep_alive_interval keep_alive_max_attempt=keep_alive_max_attempt except Exception e construct_and_record_rdzv_event message=f type e __name__ str e run_id=params run_id node_state=NodeState FAILED raise