Owner s module dynamo flake noqa B torch torch _dynamo torch _dynamo test_case torch _dynamo testing torch _dynamo testing CompileCounter CompileCounterWithBackend EagerAndRecordGraphs normalize_gm TestInputAttrTracking torch _dynamo test_case TestCase test_tensor_property_on_tensor fn x x x y x_ = torch randn y_ = torch randn x_ y = y_ eager_result = fn x_ graph = None grab_graph_backend gm inps nonlocal graph graph = gm gm fn = torch compile fn backend=grab_graph_backend fullgraph=True compile_result = fn x_ assertEqual eager_result compile_result placeholder_cnt = node graph graph nodes node op == placeholder placeholder_cnt += We want very sure lifts y inputs assertEqual placeholder_cnt test_tensor_property_assigned_on_tensor fn x y x y = y x x y x_ = torch randn y_ = torch randn eager_result = fn x_ y_ graph = None grab_graph_backend gm inps nonlocal graph graph = gm gm fn = torch compile fn backend=grab_graph_backend fullgraph=True compile_result = fn x_ y_ assertEqual eager_result compile_result placeholder_cnt = node graph graph nodes node op == placeholder placeholder_cnt += y already input assertEqual placeholder_cnt test_const_property_on_tensor fn x x x y x_ = torch randn y_ = x_ y = y_ eager_result = fn x_ graph = None grab_graph_backend gm inps nonlocal graph graph = gm gm fn = torch compile fn backend=grab_graph_backend fullgraph=True compile_result = fn x_ assertEqual eager_result compile_result placeholder_cnt = node graph graph nodes node op == placeholder placeholder_cnt += We want very sure does lifts y inputs its const assertEqual placeholder_cnt test_const_property_assigned_on_tensor fn x y x y = y x x y x_ = torch randn y_ = eager_result = fn x_ y_ fn = torch compile fn backend= eager fullgraph=True compile_result = fn x_ y_ assertEqual eager_result compile_result test_guards_correctly_property_assigned_on_tensor_type_change fn x y x y = y x x y x_ = torch randn fn = torch compile fn backend= eager fullgraph=True compile_result_const = fn x_ assertEqual compile_result_const x_ y = torch randn compile_result_tensor = fn x_ y assertEqual compile_result_tensor x_ y test_guards_correctly_property_assigned_on_tensor_type_change_inductor fn x y x y = y x x y x_ = torch randn fn = torch compile fn backend= inductor fullgraph=True compile_result_const = fn x_ assertEqual compile_result_const x_ y = torch randn compile_result_tensor = fn x_ y assertEqual compile_result_tensor x_ y test_complex_attr_access_without_graph_breaks fn x y z t x t y = y t z = y z new_y = new_z = t x new_y = t y new_y new_z = t z new_z new_y new_z x_ = torch randn x_ = torch randn x_ = torch randn x = x_ x_ x_ y = torch randn z = eager_result = fn x y z counter = CompileCounter fn = torch compile fn backend=counter fullgraph=True compile_result = fn x y z assertEqual compile_result eager_result assertEqual counter frame_count assertEqual counter op_count Graph reference ------------- ------ ----------------------- ------------------------------------ -------- placeholder l_y_ L_y_ call_function mul built-in function mul l_y_ call_function mul_ built-in function mul l_y_ call_function mul_ built-in function mul l_y_ call_function mul_ built-in function mul l_y_ call_function mul_ built-in function mul mul call_function mul_ built-in function mul l_y_ mul_ call_function mul_ built-in function mul mul_ mul_ call_function mul_ built-in function mul l_y_ mul_ call_function mul_ built-in function mul mul_ mul_ output output output mul_ mul_ mul mul_ mul_ test_complex_attr_access_with_graph_breaks fn x y z t x t y = y t z = y z print Break new_y = new_z = t x new_y = t y new_y new_z = t z new_z new_y new_z x_ = torch randn x_ = torch randn x_ = torch randn x = x_ x_ x_ y = torch randn z = eager_result = fn x y z counter = CompileCounter fn = torch compile fn backend=counter fullgraph=False compile_result = fn x y z assertEqual compile_result eager_result assertEqual counter frame_count assertEqual counter op_count Graph reference ------------- ------ ----------------------- ---------------------- -------- placeholder l_y_ L_y_ call_function mul built-in function mul l_y_ call_function mul_ built-in function mul l_y_ call_function mul_ built-in function mul l_y_ output output output mul mul_ mul_ GRAPH BREAK ------------- ------- ----------------------- ----------------- -------- placeholder l_x_ _y L_x_ _y placeholder l_x_ _z L_x_ _z placeholder l_x_ _y L_x_ _y placeholder l_x_ _z L_x_ _z placeholder l_x_ _y L_x_ _y placeholder l_x_ _z L_x_ _z call_function mul built-in function mul l_x_ _y call_function mul_ built-in function mul l_x_ _z call_function mul_ built-in function mul l_x_ _y mul call_function mul_ built-in function mul l_x_ _z mul_ call_function mul_ built-in function mul l_x_ _y mul_ call_function mul_ built-in function mul l_x_ _z mul_ output output output mul_ mul_ test_complex_attr_access_with_inline_reconstruct inline_test_fn x y z print f x + y + z fn x y z x = y = z = mult = inline_test_fn x y z y = y mult x = x mult x y x = torch randn y = torch randn z = torch randn eager_result = fn x y z counter = CompileCounter fn = torch compile fn backend=counter fullgraph=False compile_result = fn x y z assertEqual compile_result eager_result assertEqual counter frame_count assertEqual counter op_count Graph reference __compiled_fn_ eval_with_key opcode name target args kwargs ------------- ------ ----------------------- --------------- -------- placeholder l_x_ L_x_ placeholder l_y_ L_y_ call_function mul built-in function mul l_y_ call_function mul_ built-in function mul l_x_ output output output mul_ mul test_set_data_on_input_tensor fn x y x data = y data x size == y size x y y y x = torch randn y = torch randn eager_result = fn x y eager_and_record = EagerAndRecordGraphs counter = CompileCounterWithBackend eager_and_record fn = torch compile fn backend=counter fullgraph=True compile_result = fn x y graph = eager_and_record graphs actual = normalize_gm graph print_readable False assertEqual compile_result eager_result assertEqual counter frame_count assertEqual counter op_count assertExpectedInline actual \ GraphModule torch nn Module forward L_y_ f L_x_ f l_y_ = L_y_ l_x_ = L_x_ _get_data_attr f = torch _C _autograd _get_data_attr l_y_ _set_grad_enabled = torch _C _set_grad_enabled False _set_grad_enabled = None set_ f = torch_Tensor_set_ l_x_ _get_data_attr _get_data_attr = None _set_grad_enabled_ = torch _C _set_grad_enabled True _set_grad_enabled_ = None _lower_version_count_by_ = torch__dynamo_variables_builtin__lower_version_count_by_ set_ set_ = _lower_version_count_by_ = None mul f = l_x_ l_y_ l_x_ = l_y_ = None mul Note - does actually get captured graph yet The plan record introduce set_data op entirely subsume operation into call_function fx graph let aot_autograd handle test_set_data_on_scoped_tensor fn x z = torch zeros z data = x data x size == z size z x x x = torch randn eager_result = fn x counter = CompileCounter fn = torch compile fn backend=counter fullgraph=False compile_result = fn x assertEqual compile_result eager_result assertEqual counter frame_count assertEqual counter op_count test_set_data_on_user_defined_class_input_tensor MyUserDefinedClass __init__ x y x = x y = y do_some_setattr_stuff z = x y = x + x z x = torch randn y = torch randn mudc_ = MyUserDefinedClass x y eager_result = mudc_ do_some_setattr_stuff counter = CompileCounter mudc_ = MyUserDefinedClass x y do_some_setattr_stuff = torch compile mudc_ do_some_setattr_stuff backend=counter fullgraph=True compile_result = do_some_setattr_stuff assertEqual compile_result eager_result assertEqual counter frame_count assertEqual counter op_count Graph reference __compiled_fn_ eval_with_key opcode name target args kwargs ------------- ------ ----------------------- -------------------- -------- placeholder l_x_ L_x_ placeholder l_y_ L_y_ call_function mul built-in function mul l_x_ l_y_ call_function add built-in function add l_x_ l_x_ call_function mul_ built-in function mul mul add output output output mul_ mul add __name__ == __main__ torch _dynamo test_case run_tests run_tests