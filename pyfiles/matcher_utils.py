mypy allow-untyped-defs copy logging os collections defaultdict dataclasses dataclass field typing Any Union torch torch fx Graph Node torch fx _compatibility compatibility __all__ = SubgraphMatcher InternalMatch Set ` PYTORCH_MATCHER_LOGLEVEL=INFO ` see debug logs _init_logger logger = logging getLogger __name__ level = os environ get PYTORCH_MATCHER_LOGLEVEL WARNING upper logger setLevel level console = logging StreamHandler formatter = logging Formatter filename s message s console setFormatter formatter console setLevel level add handlers logger logger addHandler console logger propagate = False logger logger = _init_logger compatibility is_backward_compatible=False dataclass InternalMatch Nodes which match found anchors list Node Maps nodes pattern subgraph nodes larger graph nodes_map dict Node Node = field default_factory=dict nodes target graph matched placeholder pattern placeholder_nodes list Node = field default_factory=list nodes matched subgraph returned output returning_nodes list Node = field default_factory=list map string name node target graph only available matcher ` SubgraphMatcherWithNameNodesMap ` name_node_map dict str Node = field default_factory=dict __copy__ InternalMatch anchors=self anchors nodes_map=self nodes_map copy placeholder_nodes=self placeholder_nodes copy returning_nodes=self returning_nodes copy compatibility is_backward_compatible=False SubgraphMatcher __init__ pattern Graph match_output bool = False match_placeholder bool = False remove_overlapping_matches bool = True ignore_literals bool = False - None Args pattern targeted matching pattern represented fx Graph match_output If True output node pattern graph will treated part targeted pattern If False output node ignored during match match_placeholder If True placeholder node pattern graph will treated part targeted pattern If False placeholder nodes will used wildcard remove_overlapping_matches If True case overlapping matches only first match will returned ignore_literals If True will check literals equal will instead treat them wildcards pattern = pattern match_output = match_output match_placeholder = match_placeholder remove_overlapping_matches = remove_overlapping_matches ignore_literals = ignore_literals len pattern nodes == raise ValueError SubgraphMatcher cannot initialized empty pattern node pattern nodes node op = output node is_impure assert len node users SubgraphMatcher cannot initialized pattern dead code TODO assert pattern connected graph pattern_placeholder_nodes = n n pattern nodes n op == placeholder output_node = next iter reversed pattern nodes nodes returned outputs pattern_returning_nodes list Node = output_node all_input_nodes pattern_anchors list Node = match_output pattern_anchors = output_node If node has output_node ONLY user then node graph sink should matched against anchor pattern_anchors = n n output_node all_input_nodes len n users == _match_attributes pn Node gn Node - bool Attributes matching complicated Right now we only support matching constant tensor assert isinstance pn target str f pn target pn target must string assert isinstance gn target str f gn target gn target must string pn_value = torch fx graph_module _get_attr pn graph owning_module pn target gn_value = torch fx graph_module _get_attr gn graph owning_module gn target type pn_value type gn_value False Don t require exact match tensor values isinstance pn_value torch Tensor isinstance gn_value torch Tensor raise RuntimeError f Unsupported type pn_value when matching attributes False _nodes_are_equal pn Node gn Node node_name_match str = - bool exact match placeholder required then use placeholder wildcard match_placeholder pn op == placeholder True node_name_match node_name_match gn name True pn op == gn op pn op == placeholder pn op == output True pn op == get_attr _match_attributes pn gn pn target == gn target False _is_contained nodes_map dict Node Node - bool ` lookup ` represents all nodes ` original_graph ` part ` pattern ` Placeholders can used other nodes graphs lookup dict Node Node = gn pn pn gn nodes_map items pn op = placeholder gn pn lookup items nodes returned output allowed used other areas graph pn pattern_returning_nodes continue user gn users If node has users ` lookup ` then must leak out pattern subgraph user lookup False True _remove_overlapping_matches matches list InternalMatch - list InternalMatch non_overlapping_matches list InternalMatch = nodes_matched set Node = set match matches found_overlap = False pn gn match nodes_map items pn op placeholder output gn nodes_matched found_overlap = True break found_overlap non_overlapping_matches append match pn gn match nodes_map items pn op placeholder output nodes_matched add gn non_overlapping_matches _match_literals pn Any gn Any match InternalMatch - bool assert isinstance pn Node isinstance gn Node pn gn cannot both Node isinstance pn Node isinstance gn Node pn op == placeholder Check we ve already matched these nodes current traversal pn match nodes_map match nodes_map pn == gn match nodes_map pn = gn True False isinstance pn Node isinstance gn Node False type gn type pn gn == pn _match_nodes pn Node gn Node match InternalMatch node_name_match str = - bool logger info matching s s pn gn assert isinstance pn Node isinstance gn Node str f pn gn must Node pn pn gn gn Check we ve already matched these nodes current traversal pn match nodes_map match nodes_map pn == gn TODO use more efficient way check gn matched before two-way dict gn match nodes_map values False _nodes_are_equal pn gn node_name_match False Optimistically mark ` pn ` match ` gn ` save local copy match saved_match = copy copy match match nodes_map pn = gn Placeholder wildcard can matched any python object including list tuple pn op == placeholder True Recursively traverse upwards check ` pn ` true match ` gn ` match_found = True _match_args args Union list tuple args Union list tuple - bool len args = len args False zip args args isinstance Node isinstance Node matched = _match_nodes match isinstance list tuple isinstance list tuple matched = _match_args matched = _match_literals match ignore_literals matched False True Flatten all args kwargs into list args pn_args gn_args = None None len pn args = len gn args list pn kwargs keys = list gn kwargs keys pn op == call_function isinstance pn target torch _ops OpOverload args_schema = pn target _schema arguments get_all_arguments orig_args orig_kwargs all_args = i schema enumerate args_schema schema name orig_kwargs all_args append orig_kwargs schema name schema kwarg_only i len orig_args all_args append orig_args i all_args append schema default_value all_args pn_args = get_all_arguments pn args pn kwargs gn_args = get_all_arguments gn args gn kwargs len pn args == len gn args list pn kwargs keys == list gn kwargs keys pn_args = list pn args gn_args = list gn args pn_args extend list pn kwargs values gn_args extend list gn kwargs values match_found = False match_found = match_found pn_args None gn_args None _match_args pn_args gn_args match_found revert saved_match before matching current node match = copy copy saved_match False True match graph Graph node_name_match str = - list InternalMatch Returns The matched subgraphs The returned subgraph would fully self-contained meaning nodes except placeholder nodes returned output can only consumed nodes within matched subgraph Subgraph pattern matcher implemented backtracking style following steps We first identify all anchor nodes pattern graph The anchor nodes sinks nodes no user other than output node pattern graph One pattern graph could have multiple anchors has multiple values In target graph we identify potential candidate nodes can matched each anchor These anchor-candidate pairs starting points pairwise per-node matching For each anchor-candidate pair we simultaneously traverse backwards DFS both pattern target graphs For every pattern nodes along traversal path we compare against target nodes In case any comparison failed match anchor-candidate pair fails A match found when DFS completes traversing graph See ` _match_nodes ` more details In case multiple anchors every anchor will need find match using step In addition matches found between anchors need have common intersection node order match valid This implemented backtracking See ` backtracking ` more details Notice graph traversal must done reverser order because tensor can have multiple consumers can only have single producer Only reverser order we can we jointly traverse pattern target graph deterministic path Warning In theory backtracking algorithm have exponential time complexity However practice s unlikely blow up torch fx passes utils fuser_utils validate_partition find candidate nodes match pattern anchors match_candidates dict Node list Node = defaultdict list pattern_anchor pattern_anchors node graph nodes _nodes_are_equal pattern_anchor node node_name_match match_candidates pattern_anchor append node match_candidates_list = list match_candidates items logger info Initial match_candidates_list s\n match_candidates_list matches list InternalMatch = backtracking anchor_index match anchor_index == len match_candidates_list match placeholder_nodes = match nodes_map pn pn pattern_placeholder_nodes match returning_nodes = match nodes_map pn pn pattern_returning_nodes matches append match logger info Found match s\n match pattern_anchor candidate_nodes = match_candidates_list anchor_index saved_match = copy copy match node candidate_nodes logger info Trying match anchor s s pattern_anchor node match_found = _match_nodes pattern_anchor node match node_name_match match_found match next anchor backtracking anchor_index + match logger info Failed match anchor s s\n pattern_anchor node revert saved_match before matching current anchor match = copy copy saved_match match = InternalMatch anchors=self pattern_anchors match_candidates_list backtracking match filter out matches where subgraph fully_contained before = len matches matches = match match matches _is_contained match nodes_map after = len matches before = after logger info Filtered out s matches because they fully contained before - after filter out matches form cycle subgraph fused valid_matches = match matches matched_compute_nodes = gn pn gn match nodes_map items pn op placeholder output validate_partition matched_compute_nodes valid_matches append match len valid_matches = len matches logger info Filtered out s matches because \ matched subgraph would form cycle fused len matches - len valid_matches remove_overlapping_matches before = len valid_matches matches = _remove_overlapping_matches valid_matches after = len matches before = after logger info Filtered out s matches because matched subgraphs overlapping before - after logger info Matches returned s matches matches