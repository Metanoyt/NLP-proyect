Owner s module dynamo collections dis sys unittest torch torch _dynamo test_case torch _dynamo bytecode_analysis bytecode_transformation torch _dynamo testing skipIfNotPy skipIfNotPy BytecodeTests torch _dynamo test_case TestCase skipIfNotPy test_linetable_ _writer fn = b = prevent LOAD_FAST_LOAD_FAST wrapping b g c = + g b f = linetable_writer f Test f generates correct co_linetable c keys = bytecode_transformation get_code_keys code_options = k getattr fn __code__ k k keys result = bytecode_transformation clean_and_assemble_instructions bytecode_transformation cleaned_instructions fn __code__ keys code_options l l = list fn __code__ co_positions list result co_positions assertEqual len l len l p p zip l l assertEqual p p TODO co_lnotab deprecated will removed In + computed lazily other linetable attributes e g co_linetable so we do set attribute ourselves assertEqual fn __code__ co_lnotab result co_lnotab skipIfNotPy test_linetable_ _writer test large ops LOAD_METHOD EXTENDED_ARGS fn_str form fn x = x = l = x x fn_str = f \ fn foo bar str chr join + x + str i + = i range l = join x + str i + i range locals = exec fn_str locals fn = locals fn orig_inst_str = \n join list map str dis get_instructions fn assertIn EXTENDED_ARG orig_inst_str load_method_str = LOAD_ATTR sys version_info = LOAD_METHOD assertIn load_method_str orig_inst_str keys = bytecode_transformation get_code_keys code_options = k getattr fn __code__ k k keys result = bytecode_transformation clean_and_assemble_instructions bytecode_transformation cleaned_instructions fn __code__ keys code_options new_inst_str = \n join list map str result assertIn EXTENDED_ARG new_inst_str assertIn load_method_str new_inst_str l l = list fn __code__ co_positions list result co_positions assertEqual len l len l p p zip l l assertEqual p p assertEqual fn __code__ co_lnotab result co_lnotab unittest skipIf sys version_info = linetable test Python test_linetable_ _writer fn = b = c = + b f = linetable_writer f Test f generates correct co_linetable c inst = dis get_instructions fn result = bytecode_transformation assemble inst fn __code__ co_firstlineno assertTrue result == fn __code__ co_linetable test_if_tensor_is_none Python adds new jump instructions check TOS None We do support these instructions f x y z = x None z = y None z = z opt_f = torch compile f backend= eager fullgraph=True assertEqual opt_f None torch ones sys version_info = insts = bytecode_transformation cleaned_instructions f __code__ inst insts assertNotIn _NONE inst opname skipIfNotPy test_py _jump_offset new_inst = bytecode_transformation create_instruction consts = None create_test_code jump_opname target_idx targets = new_inst LOAD_CONST argval= new_inst LOAD_CONST argval= jump_to_target_inst = new_inst jump_opname target=targets target_idx pseudocode generated bytecode test_py _fn goto target target target goto target target via fwd bwd jump target test LOAD_GLOBAL since has different instruction size insts = new_inst RESUME arg= new_inst JUMP_FORWARD target=jump_to_target_inst targets new_inst LOAD_GLOBAL arg= argval= print new_inst POP_TOP new_inst RETURN_VALUE jump_to_target_inst new_inst LOAD_CONST argval= new_inst LOAD_GLOBAL arg= argval= print new_inst POP_TOP new_inst RETURN_VALUE targets new_inst RETURN_VALUE new_inst LOAD_CONST argval= new_inst RETURN_VALUE code_options = collections OrderedDict co_argcount co_posonlyargcount co_kwonlyargcount co_nlocals co_stacksize co_flags co_code b co_consts consts co_names print co_varnames co_filename __file__ co_name test_py _fn co_qualname test_py _fn co_firstlineno co_linetable b co_exceptiontable b co_freevars co_cellvars bytecode_transformation clean_and_assemble_instructions insts list code_options keys code_options format jump_opname target_idx expected forward jump expected value test_args = JUMP_FORWARD False JUMP_FORWARD True JUMP_BACKWARD False JUMP_BACKWARD True test test_args insts code = create_test_code test test check offset latest jump instruction forward backward inst reversed insts inst opname startswith JUMP test assertIn FORWARD inst opname assertIn BACKWARD inst opname break run code check result dummy_fn pass dummy_fn __code__ = code assertEqual dummy_fn test dummy_opt = torch compile dummy_fn backend= eager assertEqual dummy_opt test test_exception_table_encode_varint these numbers have no real meaning them nums = b _ _ b _ _ _ b = bytecode_transformation encode_exception_table_varint nums + bytecode_transformation encode_exception_table_varint nums nums_new = b_iter = iter bytes b while True try nums_new append bytecode_transformation decode_exception_table_varint b_iter except StopIteration break assertEqual nums nums_new skipIfNotPy test_exception_table_parsing fn try b c except Exception d finally e f tab = bytecode_transformation parse_exception_table fn __code__ co_exceptiontable b = bytecode_transformation assemble_exception_table tab assertEqual b fn __code__ co_exceptiontable skipIfNotPy test_exception_table_e e fn try b c except Exception d finally e f nothing args pass code _ = bytecode_transformation transform_code_object fn __code__ nothing assertEqual code co_exceptiontable fn __code__ co_exceptiontable skipIfNotPy test_exception_table_e e_ last instructions exn_table entry large instruction i e LOAD_GLOBAL fn try except Exception pass nothing args pass code _ = bytecode_transformation transform_code_object fn __code__ nothing assertEqual code co_exceptiontable fn __code__ co_exceptiontable skipIfNotPy test_exception_table_entry_propagation insts = _ range insts append bytecode_transformation create_instruction NOP insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True bytecode_transformation propagate_inst_exn_table_entries insts expected = inst exp zip insts expected assertIsNotNone inst exn_tab_entry assertIs inst exn_tab_entry target insts exp skipIfNotPy test_compute_exception_table_nested insts = _ range insts append bytecode_transformation create_instruction NOP insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True insts exn_tab_entry = bytecode_transformation InstructionExnTabEntry insts insts insts True bytecode_transformation update_offsets insts tab = bytecode_transformation compute_exception_table insts expected = assertEqual len tab len expected entry exp zip tab expected assertEqual entry start exp assertEqual entry end exp assertEqual entry target exp skipIfNotPy test_remove_dead_code_with_exn_table_entries create_instruction = bytecode_transformation create_instruction target = create_instruction NOP target = create_instruction NOP target = create_instruction NOP exn_start = create_instruction NOP exn_end = create_instruction NOP insts = create_instruction JUMP_FORWARD target=target exn_start dead target create_instruction JUMP_FORWARD target=target exn_end dead target target exn_start exn_tab_entry = bytecode_transformation InstructionExnTabEntry exn_start exn_end target True bytecode_transformation propagate_inst_exn_table_entries insts insts = bytecode_analysis remove_dead_code insts assertEqual len insts assertNotIn exn_start insts assertNotIn exn_end insts assertIn target insts assertIn target insts bytecode_transformation update_offsets insts tab = bytecode_transformation compute_exception_table insts assertEqual len tab assertEqual tab start assertEqual tab end assertEqual tab target test_bytecode_from_template fn d k v d items d k = v varname_map = d var d var k var v var insts = bytecode_transformation bytecode_from_template fn varname_map inst insts assertIsNone inst starts_line inst opname startswith LOAD assertNotIn inst argval varname_map inst opname LOAD_GLOBAL LOAD_ATTR assertIsNone inst arg assertFalse inst opname startswith RETURN skipIfNotPy test_bytecode_from_template_noprefix Test + prefix instructions removed gen_fn cl = None fn cl fn fn = gen_fn dis_insts = list dis get_instructions fn names = inst opname inst dis_insts assertIn RESUME names assertIn COPY_FREE_VARS names insts = bytecode_transformation bytecode_from_template fn names = inst opname inst insts assertNotIn RESUME names assertNotIn COPY_FREE_VARS names test_bytecode_from_template_noreturn Test functions multiple returns will have their returns replaced jumps end fn x y z = z dis_insts = list dis get_instructions fn dis_returns = list filter lambda x x opname startswith RETURN dis_insts assertGreater len dis_returns assertTrue dis_insts - opname startswith RETURN insts = bytecode_transformation bytecode_from_template fn noprefix=False assertEqual insts - opname NOP assertEqual len dis_insts len insts i i zip dis_insts insts i opname startswith RETURN i insts - continue assertIn JUMP i opname assertIs i target insts - Should work testing + sufficient In ` fn ` ends RETURN_VALUE skipIfNotPy test_bytecode_from_template_noreturn Test function doesn t end RETURN_VALUE fn x x x x raise RuntimeError dis_insts = list dis get_instructions fn assertFalse dis_insts - opname startswith RETURN insts = bytecode_transformation bytecode_from_template fn noprefix=False assertEqual insts - opname NOP assertEqual insts - opname dis_insts - opname assertEqual len dis_insts + len insts i i zip dis_insts insts i opname startswith RETURN assertIn JUMP i opname assertIs i target insts - unittest skipIf sys version_info = + removed RETURN_CONST skipIfNotPy test_bytecode_from_template_noreturn_const Test + RETURN_CONST fn x dis_insts = list dis get_instructions fn dis_return_consts = list filter lambda x x opname == RETURN_CONST dis_insts assertGreater len dis_return_consts assertTrue dis_insts - opname == RETURN_CONST insts = bytecode_transformation bytecode_from_template fn noprefix=False assertEqual insts - opname NOP insts_i = inst dis_insts inst opname == RETURN_CONST assertEqual insts insts_i opname LOAD_CONST insts_i += insts_i = len insts - assertIn JUMP insts insts_i opname assertIs insts insts_i target insts - insts_i += test_bytecode_analysis_jump_backward_no_interrupt bytecode_analysis fails JUMP_BACKWARD_NO_INTERRUPT terminal + torch compile backend= eager fn x graph break causes bytecode_analysis analyze rest function torch _dynamo graph_break torch no_grad try x = x + except NotImplementedError x = x + except Exception x = x + x assertEqual fn torch ones torch ones + https github com pytorch pytorch issues test_extended_args_starts_line NOTE need LOAD_CONST i before LOAD_FAST x order get EXTENDED_ARG starts_line set NOTE + introduced LOAD_SMALL_INT so integers need = order LOAD_CONST generated lines = \n join f x = i + + x i range fn_str = f fn x \n lines locals = exec fn_str locals fn = locals fn inst dis get_instructions fn inst opname == EXTENDED_ARG inst starts_line break assertTrue False bad test case no EXTENDED_ARG starts_line found transformations instructions _ inst instructions inst starts_line == break assertTrue False test failure starts_line found instructions bytecode_transformation transform_code_object fn __code__ transformations BytecodeHookTests torch _dynamo test_case TestCase test_bytecode_hook fn b - b hook code out_code print code print out_code code torch _dynamo reset handle = torch _dynamo convert_frame register_bytecode_hook hook try opt_fn = torch compile fn i range opt_fn torch randn i torch randn i finally handle remove __name__ == __main__ torch _dynamo test_case run_tests run_tests