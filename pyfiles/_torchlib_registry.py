Registry aten functions __future__ annotations __all__ = onnx_impl get_torchlib_ops logging collections abc Callable Sequence typing Any TypeVar typing_extensions ParamSpec onnxscript torch torch onnx _internal exporter _constants _registration Use ParamSpec better type preservation instead bound Callable TypeVar _P = ParamSpec _P _R = TypeVar _R logger = logging getLogger __name__ _registry list _registration OnnxDecompMeta = onnx_impl target _registration TorchOp &#124; tuple _registration TorchOp trace_only bool = False complex bool = False opset_introduced int = no_compile bool = False private bool = False - Callable Callable _P _R Callable _P _R Register ONNX implementation torch op isinstance target torch _ops OpOverloadPacket raise TypeError f Target target should provided OpOverload instead OpOverloadPacket You can get default overload op default wrapper func Callable _P _R - Callable _P _R processed_func Any no_compile processed_func = func torchlib_opset = onnxscript values Opset domain=_constants TORCHLIB_DOMAIN version= trace_only Compile function processed_func = onnxscript script opset=torchlib_opset func processed_func = onnxscript TracedOnnxFunction torchlib_opset func private TODO justinchuby Simplify logic remove private attribute Skip registration private isinstance target Sequence targets = target targets = target type ignore assignment t targets _registry append _registration OnnxDecompMeta onnx_function=processed_func fx_target=t signature=None is_complex=complex opset_introduced=opset_introduced skip_signature_inference=no_compile processed_func type ignore return-value wrapper get_torchlib_ops - tuple _registration OnnxDecompMeta Trigger op registration torch onnx _internal exporter _torchlib ops del ops assert len _registry = tuple _registry