__future__ annotations torchgen api cpp torchgen api types Binding CppSignatureGroup CType torchgen model Argument BaseTy BaseType ListType NativeFunction OptionalType Type This file generates code unboxing wrappers i e glue logic unbox boxed operator convert ivalues stack correct arguments unboxed kernel based corresponding JIT schema This codegen alternative way generate unboxing wrappers similar existing C++ metaprogramming approach gets job done statically These generated unboxing wrappers will useful under scenario where we need register fixed set operators known compile time thus can save some time runtime initialization phase Here s example how codegen works - Function Schema source truth aten empty names int size Dimname names ScalarType dtype=None Layout layout=None Device device=None bool pin_memory=None MemoryFormat memory_format=None - Tensor - Argument Conversion Generates C++ code convert ivalue stack its underlying C++ type - int size ` ` ` cpp const c List c IValue size_list_in = std move peek stack toList std vector int _t size_vec c IValue size_elem size_list_in int _t size_base = size_elem int _t size_vec push_back size_base ArrayRef int _t size_list_out size_vec ~~~~~~~~~~~~~ -- The converted argument ivalues stack Will passed unboxed kernel ` ` ` - Dimname names ` ` ` cpp std optional c IValue names_opt = std move peek stack toOptional c IValue std optional ArrayRef Dimname names_opt_out names_opt has_value ~~~~~~~~~~~ -- Unwrapping optional shell const c IValue names_opt_in = names_opt value const c List c IValue names_list_in = names_opt_in toList std vector Dimname names_vec c IValue names_elem names_list_in ~~~~~~~~~~~~~~~~~~~~~~~~~ -- Unrolling list then convert elements one one Dimname names_base = names_elem Dimname names_vec push_back names_base ArrayRef Dimname names_list_out names_vec names_opt_out = std optional ArrayRef Dimname names_list_out names_opt_out = std optional ArrayRef Dimname ` ` ` - ScalarType dtype similarly rest arguments ` ` ` cpp std optional c IValue dtype_opt = std move peek stack toOptional c IValue std optional ScalarType dtype_opt_out dtype_opt has_value const c IValue dtype_opt_in = dtype_opt value ScalarType dtype_base = dtype_opt_in ScalarType ~~~~~~~~~~~~~~~~~~~~ -- For base types convert ivalue directly using T API dtype_opt_out = std optional ScalarType dtype_base dtype_opt_out = std optional ScalarType ` ` ` - Unboxed Kernel Call ` ` ` cpp auto result_ = torch empty size_list_out names_opt_out options memory_format_opt_out ` ` ` - Push Result Back Stack ` ` ` cpp drop stack pack stack std move result_ ` ` ` connector = \n\t Return unboxing function name NativeFunction name f NativeFunction - str f func name unambiguous_name Convert all arguments NativeFunction C++ code convert_arguments f NativeFunction - tuple list Binding list str we need argument so method needs False args = CppSignatureGroup from_native_function f method=False most_faithful_signature arguments code_list = f c IValue args i name = std move peek stack i len args i range len args + binding_list = arg args expecting only Argument isinstance arg argument Argument raise Exception noqa TRY f Unexpected argument type expecting ` Argument ` got arg argument Argument = arg argument unboxed_name _ code decl = argumenttype_ivalue_convert argument type argument name mutable=argument is_write code_list extend decl code_list extend code binding_list append arg with_name unboxed_name binding_list code_list Takes type name mutability corresponding argument generates tuple C++ code necessary unbox argument A Binding corresponding newly created unboxed variable including variable name its CType argumenttype_ivalue_convert t Type arg_name str mutable bool = False - tuple str CType list str list str Unboxing mobile which doesn t care about SymInts ctype = cpp argumenttype_type t=t mutable=mutable binds=arg_name symint=False type isinstance t BaseType out_name = f arg_name _base code decl = _gen_code_base_type arg_name=arg_name out_name=out_name ctype=ctype isinstance t OptionalType out_name = f arg_name _opt_out code decl = _gen_code_optional_type arg_name=arg_name out_name=out_name t=t ctype=ctype isinstance t ListType out_name = f arg_name _list_out code decl = _gen_code_list_type arg_name=arg_name out_name=out_name t=t ctype=ctype raise Exception f Cannot handle type t arg_name arg_name noqa TRY out_name ctype code decl _gen_code_base_type arg_name str out_name str ctype CType - tuple list str list str f ctype cpp_type strip_ref=True out_name = arg_name ctype cpp_type strip_ref=True _gen_code_optional_type arg_name str out_name str t OptionalType ctype CType - tuple list str list str in_name = f arg_name _opt_in res_name _ res_code decl = argumenttype_ivalue_convert t elem in_name f auto arg_name _opt = arg_name toOptional c IValue ctype cpp_type strip_ref=True out_name arg_name _opt has_value const c IValue in_name = arg_name _opt value connector join res_code out_name = ctype cpp_type strip_ref=True res_name out_name = ctype cpp_type strip_ref=True split \n decl _gen_code_list_type arg_name str out_name str t ListType ctype CType - tuple list str list str in_name = f arg_name _list_in elem_name = f arg_name _elem code = f const c List c IValue in_name = arg_name toList res_name res_ctype res_code decl = argumenttype_ivalue_convert t elem elem_name handle list type size e g bool isinstance t elem BaseType t elem name == BaseTy bool t size code extend f ctype cpp_type strip_ref=True out_name = as_array res_ctype cpp_type strip_ref=True t size in_name split \n we have use c List optional element e g Tensor - c List std optional Tensor isinstance t elem OptionalType code extend f ctype cpp_type strip_ref=True out_name c IValue elem_name in_name connector join res_code out_name push_back res_name split \n use ArrayRef default vec_name = arg_name + _vec need bring vector instantiation out scope so ArrayRef has valid data decl append f std vector res_ctype cpp_type strip_ref=True vec_name code extend f c IValue elem_name in_name connector join res_code vec_name push_back res_name ctype cpp_type strip_ref=True out_name vec_name split \n code decl