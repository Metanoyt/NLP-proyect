Ideally there would way Bazel parse version txt use version numbers there substitutions expand_template action Since there isn t silly script exists __future__ annotations argparse os typing cast Version = tuple int int int parse_version version str - Version Parses version string into major minor patch version numbers Args version Full version number string possibly including revision commit hash Returns An int -tuple major minor patch version numbers Extract version number part i e toss any revision hash parts version_number_str = version i range len version c = version i c isdigit c == version_number_str = version i break cast Version tuple int n n version_number_str split apply_replacements replacements dict str str text str - str Applies given replacements within text Args replacements dict Mapping str - str replacements text str Text which make replacements Returns Text replacements applied any before after replacements items text = text replace before after text main args argparse Namespace - None open args version_path f version = f read strip major minor patch = parse_version version replacements = TORCH_VERSION_MAJOR str major TORCH_VERSION_MINOR str minor TORCH_VERSION_PATCH str patch Create output dir doesn t exist os makedirs os path dirname args output_path exist_ok=True open args template_path input open args output_path w output line input output write apply_replacements replacements line __name__ == __main__ parser = argparse ArgumentParser description= Generate version h version h template parser add_argument -- template-path required=True help= Path template i e version h parser add_argument -- version-path required=True help= Path file specifying version parser add_argument -- output-path required=True help= Output path expanded template i e version h args = parser parse_args main args