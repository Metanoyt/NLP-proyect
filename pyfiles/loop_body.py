mypy allow-untyped-defs __future__ annotations collections functools itertools re enum auto Enum typing Any Callable NamedTuple Optional TYPE_CHECKING TypeVar sympy torch fx torch _dynamo utils identity torch fx proxy Scope TracerBase torch utils _sympy symbol SymT config dependencies codegen common index_prevent_reordering ops_handler DefaultHandler OpsHandler WrapperHandler utils cache_on_self reduction_num_outputs sympy_index_symbol_with_prefix sympy_subs virtualized ops V TYPE_CHECKING collections abc Sequence T = TypeVar T InterpreterShim torch fx Interpreter staticmethod functools cache _dummy_gm torch fx symbolic_trace identity __init__ graph submodules call super placeholder avoid constructing GraphModule which very expensive does codegen super __init__ _dummy_gm garbage_collect_values=False module = type ignore assignment graph = graph submodules = submodules extra_traceback = False fetch_attr = submodules __getitem__ type ignore method-assign current_node = None run_node n torch fx Node - Any pyrefly ignore bad-assignment current_node = n super run_node n run args kwargs V set_interpreter_handler super run args kwargs We don t need nn Module constant handling Tracer LightTracer TracerBase __init__ super __init__ graph = torch fx Graph tracer_cls=self __class__ type ignore arg-type scope = Scope None module_stack = type ignore assignment node_name_to_scope = MemoryEntry NamedTuple index_name str LoopBody indexing_exprs index_name buffer_name Optional str mode Optional str V ops store mode=mode MemoryUsageType Enum These opcode generating usage LOAD = auto LOAD_SEED = auto STORE = auto STORE_REDUCTION = auto INDEX_EXPR = auto CHECK_BOUNDS = auto BUCKETIZE = auto LoopBody Captures body Loops subclass into FX graph Persists any indexing simplifications makes easier analyze loop bodies indexing_exprs dict str sympy Expr indexing_exprs_name dict sympy Expr str submodules dict str Any subblocks dict str LoopBodyBlock indirect_vars list sympy Symbol indirect_var_ranges dict sympy Symbol sympy Expr root_block LoopBodyBlock memory_usage dict MemoryUsageType list MemoryEntry op_counts collections Counter str __init__ fn args var_ranges iter_vars reduce_vars allow_same_symbol_in_index=False super __init__ _flat_sizes = tuple var_ranges values sizes = _flat_sizes len iter_vars _flat_sizes len iter_vars iter_vars = iter_vars reduce_vars = reduce_vars var_ranges = var_ranges isinstance fn LoopBody _init_with_copy fn args allow_same_symbol_in_index _init_with_tracing fn args indexing = None get_original_num_rdims - int assert has_partial_accumulate node = root_block graph find_nodes op= call_method target= partial_accumulate meta = node args - meta num_reduction_dims extract_pw_from_reduction root_block = root_block extract_pw_from_reduction has_partial_accumulate = True iter_vars = iter_vars + reduce_vars reduce_vars = sizes = sizes + sizes tuple _init_with_tracing fn args Do FX trace arbitrary callable construct indexing_exprs = indexing_exprs_name = submodules = get_index get_index subblocks = indirect_vars = indirect_var_ranges dict sympy Symbol sympy Expr = memory_usage = t t MemoryUsageType op_counts = collections Counter root_block = LoopBodyBlock fn args traces has_partial_accumulate = root_block graph find_nodes op= call_method target= partial_accumulate del indexing_exprs_name used after _init_with_tracing _init_with_copy other LoopBody args allow_same_symbol_in_index _init_with_tracing slow so fast path case where we just reordering merging splitting args existing LoopBody indexing_exprs = other indexing_from_args args allow_same_symbol_in_index indexing_exprs = name V graph sizevars simplify_with_ranges expr var_ranges name expr indexing_exprs items subblocks = k v clone k v other subblocks items indirect_vars = other indirect_vars indirect_var_ranges = other indirect_var_ranges memory_usage = other memory_usage op_counts = other op_counts root_block = other root_block clone has_partial_accumulate = other has_partial_accumulate submodules = other submodules submodules pop get_index submodules = get_index get_index k v clone k v submodules items type ignore attr-defined has_op name str op_counts get name merge_loops - LoopBody Merge both iteration reduction loops new LoopBody old_body = old_sizes = sizes old_iter_vars old_reduce_vars = old_body vars old_iter_sizes old_reduce_sizes = old_sizes index_exprs = old_body indexing_exprs values iter_sizes iter_reindex _ = V graph sizevars _simplify_loops old_iter_vars old_iter_sizes index_prevent_reordering index_exprs old_iter_vars old_iter_sizes reduce_sizes reduce_reindex _ = V graph sizevars _simplify_loops old_reduce_vars old_reduce_sizes index_prevent_reordering index_exprs old_reduce_vars old_reduce_sizes iter_sizes == old_iter_sizes reduce_sizes == old_reduce_sizes old_body iter_vars reduce_vars var_ranges = dependencies index_vars_no_squeeze iter_sizes reduce_sizes prefix= p new_body = LoopBody old_body iter_reindex iter_vars reduce_reindex reduce_vars var_ranges iter_vars reduce_vars allow_same_symbol_in_index=True new_body expand_dimension_for_pointwise_node dimension int new_range int - LoopBody Expand node ` dimension ` ` new_range ` rely index modular avoid out-of-boundary access old_body = old_sizes = sizes iter_size reduce_size = old_sizes original_range = iter_size dimension new_iter_size = list iter_size new_iter_size dimension = new_range new_sizes = new_iter_size reduce_size iter_vars reduce_vars var_ranges = dependencies index_vars_no_squeeze new_sizes prefix= t type ignore arg-type new_body indices Sequence sympy Expr - Any index = itertools chain from_iterable indices assert len index == len iter_size + len reduce_size iter_idx = index len iter_size reduce_idx = index len iter_size new_iter_idx = list iter_idx new_iter_idx dimension = iter_idx dimension original_range old_body new_iter_idx reduce_idx loop_body = LoopBody new_body iter_vars reduce_vars var_ranges iter_vars reduce_vars use original symbol prefix so we can do multiple round reordering iter_vars reduce_vars var_ranges = dependencies index_vars_no_squeeze new_sizes prefix= p type ignore arg-type new_body = LoopBody loop_body iter_vars reduce_vars var_ranges iter_vars reduce_vars new_body reorder_iter_loops new_order - LoopBody Reorder iteration loops new LoopBody ir same_reorder old_body = old_sizes = sizes assert len old_sizes == len new_order reorder_fn = same_reorder new_order iter_size reduce_size = old_sizes new_iter_size = reorder_fn iter_size new_sizes = new_iter_size reduce_size iter_vars reduce_vars var_ranges = dependencies index_vars_no_squeeze new_sizes prefix= p type ignore arg-type inverse_order = b b enumerate new_order inverse_order = inverse_order i i range len new_order new_body indices Sequence sympy Expr - Any index = itertools chain from_iterable indices assert len index == len iter_size + len reduce_size iter_idx = index len iter_size reduce_idx = index len iter_size iter_idx = iter_idx i i inverse_order old_body iter_idx reduce_idx allow_same_symbol_in_index=True LoopBody new_body iter_vars reduce_vars var_ranges iter_vars reduce_vars property vars assert iter_vars None assert reduce_vars None iter_vars reduce_vars cache_on_self get_nodes all_graphs = itertools chain root_block graph block graph block subblocks values node graph all_graphs node graph nodes cache_on_self bounds Doing local avoid dumping all code here bounds BoundVars BoundVars get_read_expr buffer_name reversed match old behavior entry reversed memory_usage MemoryUsageType LOAD entry buffer_name == buffer_name indexing_exprs entry index_name raise KeyError buffer_name get_write_expr buffer_name entry itertools chain memory_usage MemoryUsageType STORE memory_usage MemoryUsageType STORE_REDUCTION entry buffer_name == buffer_name indexing_exprs entry index_name raise KeyError buffer_name get_read_exprs indexing_exprs entry index_name entry memory_usage MemoryUsageType LOAD get_all_read_expr buffer_name reversed match old behavior out = entry reversed memory_usage MemoryUsageType LOAD entry buffer_name == buffer_name out append indexing_exprs entry index_name out get_write_exprs indexing_exprs entry index_name entry itertools chain memory_usage MemoryUsageType STORE memory_usage MemoryUsageType STORE_REDUCTION get_all_write_expr buffer_name out = entry itertools chain memory_usage MemoryUsageType STORE memory_usage MemoryUsageType STORE_REDUCTION entry buffer_name == buffer_name out append indexing_exprs entry index_name out debug_str lines = f var_ranges = dict var_ranges lines extend f name = val name val indexing_exprs items lines extend block debug_str name name block itertools chain body root_block subblocks items \n join lines is_memory_copy - bool True contains only single loads store Note could involve layout change len memory_usage MemoryUsageType LOAD == len memory_usage MemoryUsageType STORE == len submodules == get_index root_block contains_only_ops load store __repr__ = debug_str add_index_expr expr sympy Expr mtype MemoryUsageType buffer_name Optional str = None mode Optional str = None name = indexing_exprs_name get expr name name = f index len indexing_exprs indexing_exprs_name expr = name indexing_exprs name = expr memory_usage mtype append MemoryEntry name buffer_name mode name add_submodule block prefix Not actually nn Modules subblocks generated code mapped FX call_module opcodes prefix - isnumeric prefix submodules name = prefix name = f prefix len submodules submodules name = block name add_indirect size var = sympy_index_symbol_with_prefix SymT INDIRECT len indirect_vars assert var indirect_var_ranges indirect_vars append var indirect_var_ranges var = size var replace_indirect old new Swap variable used indirect indexing str old == str new assert indexing None pyrefly ignore bad-assignment indexing = k sympy_subs v old new k v indexing items get_index name assert indexing None indexing name indexing_from_args indices allow_same_symbol_in_index=False index = itertools chain from_iterable indices assert len index == len var_ranges index var_ranges assert allow_same_symbol_in_index all v var_ranges v index f var_ranges= indices= replacements = dict zip var_ranges keys index name sympy_subs expr replacements name expr indexing_exprs items __call__ indices allow_same_symbol_in_index=False indexing = indexing_from_args indices allow_same_symbol_in_index result = root_block indexing = None result bind_set_indirect_shim var size check wrap_neg set_indirect new_var replace_indirect var V ops indirect_indexing new_var size check wrap_neg set_indirect clone = functools partial type ignore attr-defined LoopBody bind_set_indirect_shim var=var size=size check=check wrap_neg=wrap_neg set_indirect bind_scan_shim combine_fn shim dtypes values V ops scan dtypes combine_fn values shim clone = functools partial LoopBody bind_scan_shim combine_fn=combine_fn type ignore attr-defined shim bind_masked_shim name shim mask other V ops masked mask subblocks name other shim clone = functools partial LoopBody bind_masked_shim name=name type ignore attr-defined shim LoopBodyBlock Captures body Loops subclass into FX graph In normal cases there will mapping between LoopBody LoopBodyBlock however case ops masked masked out operations will manifest extra LoopBodyBlock __init__ body LoopBody fn Callable Any args list Any body = body tracer = LightTracer proxy_ops = tracer create_proxy placeholder ops index_propagation IndexPropagation handler Any = CountOps CaptureIndexing proxy_ops body tracer body op_counts config constant_and_index_propagation handler = IndexPropagation handler body var_ranges body indirect_var_ranges V set_ops_handler handler This indirection just cute way get IndexPropagation unwrap value ops output fn args graph = tracer graph extract_pw_from_reduction red = None store = None node graph nodes node target == reduction assert red red = node node target == store_reduction assert store store = node assert red assert store reduction_type = red args - red_arg = red args - buf = store args ops = store args extra_meta = num_reduction_dims len body reduce_vars graph inserting_after store graph call_method partial_accumulate ops buf reduction_type red_arg extra_meta graph erase_node store graph erase_node red __call__ graph = graph submodules = body submodules InterpreterShim graph submodules run V get_ops_handler debug_str name= block code = torch fx GraphModule body submodules graph code re sub strip ` del var ` suffixes make output prettier r ^\n code strip replace forward f name contains_only_ops allowed_ops - bool all node target allowed_ops node graph find_nodes op= call_method clone body LoopBody Shallow copy new parent LoopBody copy = LoopBodyBlock __new__ LoopBodyBlock copy __dict__ update __dict__ body body copy CountOps DefaultHandler __init__ inner OpsHandler Any counts collections Counter str _inner = inner _counts = counts _default name str args tuple Any kwargs dict str Any - Any _counts name += getattr _inner name args kwargs CaptureIndexing WrapperHandler name = CaptureIndexing __init__ inner OpsHandler Any body LoopBody tracer LightTracer super __init__ inner body = body tracer = tracer _add_index expr sympy Expr mtype MemoryUsageType kwargs Any tracer create_proxy call_module get_index body add_index_expr expr mtype kwargs _simplify expr sympy Expr - sympy Expr V graph sizevars simplify_with_ranges expr body var_ranges load name str index sympy Expr index = _simplify index index = _add_index index MemoryUsageType LOAD buffer_name=name _inner load name index load_seed name str index int assert isinstance index int body add_index_expr sympy Integer index MemoryUsageType LOAD_SEED buffer_name=name _inner load_seed name index store name index value mode=None index = _simplify index index = _add_index index MemoryUsageType STORE buffer_name=name mode=mode _inner store name index value mode store_reduction name index value index = _simplify index index = _add_index index MemoryUsageType STORE_REDUCTION buffer_name=name _inner store_reduction name index value reduction dtype src_dtype reduction_type value result = _inner reduction dtype src_dtype reduction_type value num_outputs = reduction_num_outputs reduction_type num_outputs tuple result i i range num_outputs result index_expr index dtype index = _simplify index isinstance index int sympy Integer _inner constant int index dtype index = _add_index index MemoryUsageType INDEX_EXPR _inner index_expr index dtype check_bounds index size lower upper index = _simplify index index = _add_index index MemoryUsageType CHECK_BOUNDS size = _add_index size MemoryUsageType CHECK_BOUNDS _inner check_bounds index size lower upper bucketize values T boundaries tuple str sympy Expr sympy Expr sympy Expr boundary_indices T indexing_dtype torch dtype right bool sorter Optional tuple str sympy Expr = None sorter_indices Optional T = None - T See Note Inductor bucketize op boundaries = boundaries _add_index boundaries MemoryUsageType BUCKETIZE buffer_name=boundaries _add_index boundaries MemoryUsageType BUCKETIZE buffer_name=boundaries _add_index boundaries MemoryUsageType BUCKETIZE buffer_name=boundaries sorter None sorter = sorter _add_index sorter MemoryUsageType BUCKETIZE buffer_name=sorter _inner bucketize values boundaries boundary_indices indexing_dtype right sorter sorter_indices masked mask_proxy masked_body Callable Any other_proxy Recursively capture masked out body another LoopBodyBlock name = body add_submodule None masked_subblock body submodules name = body bind_masked_shim name body subblocks name = LoopBodyBlock body masked_body tracer create_proxy call_module name mask_proxy other_proxy scan dtype_proxy combine_fn Callable tuple Any tuple Any tuple Any value_proxy shim = body bind_scan_shim combine_fn name = body add_submodule shim scan result = tracer create_proxy call_module name dtype_proxy value_proxy Proxies iterable some methods expect tuples lists tuple result i i range len value_proxy sort dtypes values stable descending result = _inner sort dtypes values stable descending Proxies iterable some methods expect tuples lists tuple result i i range len values frexp value_proxy result = _inner frexp value_proxy Proxies iterable some methods expect tuples lists result result indirect_indexing index_proxy size check=True wrap_neg=True Flow data tensors into indexing formulas Introduce call_module update indexing var = body add_indirect size set_indirect = body bind_set_indirect_shim var size check wrap_neg tracer create_proxy call_module body add_submodule set_indirect f set_ var index_proxy var output result tracer create_proxy output output result