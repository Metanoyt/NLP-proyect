mypy allow-untyped-defs collections abc Callable typing Any Optional Union torch torch ao ns fx mappings get_node_type_to_io_type_map torch ao quantization fx utils get_new_attr_name_with_prefix torch ao quantization observer _is_activation_post_process torch fx GraphModule map_arg torch fx graph Graph Node ns_types NSNodeTargetType NSSingleResultValuesType NSSubgraph utils get_arg_indices_of_inputs_to_log get_node_first_input_and_output_type get_node_input_qparams get_normalized_nth_input get_number_of_non_param_args get_target_type_str getattr_from_fqn NodeInputOrOutputType op_type_supports_shadowing return_first_non_observer_node _maybe_get_fqn node Node gm GraphModule - Optional str fqn = None hasattr gm _node_name_to_scope fqn observers present because they do exist when fqns created during tracing If observer get fqn node being observed node_to_use_for_fqn = node node op == call_module isinstance node target str raise AssertionError f Expected str got type node target module = getattr_from_fqn gm node target _is_activation_post_process module node_to_use_for_fqn = get_normalized_nth_input node gm fqn = gm _node_name_to_scope node_to_use_for_fqn name type ignore index fqn type ignore return-value _insert_logger_after_node node Node gm GraphModule logger_cls Callable logger_node_name_suffix str ref_node_name str model_name str ref_name str ref_node_target_type str results_type str index_within_arg int index_of_arg int fqn Optional str - Node Given starting graph prev_node - node - next_node This function creates new logger_cls obj adds after node resulting prev_node - node - logger_obj - next_node create new name logger_node_name = get_new_attr_name_with_prefix node name + logger_node_name_suffix gm target_type = get_target_type_str node gm create logger object logger_obj = logger_cls ref_node_name node name model_name ref_name target_type ref_node_target_type results_type index_within_arg index_of_arg fqn attach logger object parent module setattr gm logger_node_name logger_obj logger_node = node graph create_node call_module logger_node_name node logger_node add_loggers_to_model gm GraphModule node_to_instrument_inputs_to_ref_node_name dict Node tuple str str node_to_instrument_outputs_to_ref_node_name dict Node tuple str str logger_cls Callable model_name str - GraphModule Takes graph gm adds loggers output each node nodes_to_instrument Returns GraphModule new graph new_graph = Graph env dict str Any = load_arg map_arg lambda node env node name node gm graph nodes node op == output new_graph output map_arg get_normalized_nth_input node gm load_arg continue node node_to_instrument_inputs_to_ref_node_name node node_to_instrument_outputs_to_ref_node_name fqn = _maybe_get_fqn node gm node node_to_instrument_inputs_to_ref_node_name ref_name ref_node_type = node_to_instrument_inputs_to_ref_node_name node Ops such add mul special because either one two first two arguments can tensors one argument tensor can first second x + versus + x arg_indices_to_log = get_arg_indices_of_inputs_to_log node node_arg_idx arg_indices_to_log node_arg = get_normalized_nth_input node gm node_arg_idx type node_arg Node create single input logger prev_node = env node_arg name env node_arg name = _insert_logger_after_node prev_node gm logger_cls _ns_logger_ node name model_name ref_name ref_node_type NSSingleResultValuesType NODE_INPUT value index_within_arg= index_of_arg=node_arg_idx fqn=fqn type node_arg torch fx immutable_collections immutable_list create N input loggers one each node arg_idx arg enumerate node_arg type ignore var-annotated arg-type prev_node = env arg name env prev_node name = _insert_logger_after_node prev_node gm logger_cls _ns_logger_ node name model_name ref_name ref_node_type NSSingleResultValuesType NODE_INPUT value index_within_arg=arg_idx index_of_arg=node_arg_idx fqn=fqn ensure env populated base node Note runs both inputs outputs env node name = new_graph node_copy node load_arg node node_to_instrument_outputs_to_ref_node_name ref_name ref_node_type = node_to_instrument_outputs_to_ref_node_name node add logger after base node env node name = _insert_logger_after_node env node name gm logger_cls _ns_logger_ node name model_name ref_name ref_node_type NSSingleResultValuesType NODE_OUTPUT value index_within_arg= index_of_arg= fqn=fqn env node name = new_graph node_copy node load_arg new_gm = GraphModule gm new_graph new_gm _insert_quantize_per_tensor_node prev_node_c Node node_a Node gm_b GraphModule graph_c Graph scale Union torch Tensor float zero_point Union torch Tensor int dtype_cast_name str - Node copy scale scale_node_name = get_new_attr_name_with_prefix node_a name + _input_scale_ gm_b setattr gm_b scale_node_name scale scale_node = graph_c create_node get_attr scale_node_name scale_node_name copy zero_point zero_point_node_name = get_new_attr_name_with_prefix node_a name + _input_zero_point_ gm_b setattr gm_b zero_point_node_name zero_point zero_point_node = graph_c create_node get_attr zero_point_node_name zero_point_node_name create quantize_per_tensor call graph_c create_node call_function torch quantize_per_tensor prev_node_c scale_node zero_point_node torch quint dtype_cast_name _insert_dtype_cast_after_node node_a Node node_c Node prev_node_c Union Node list Node gm_a GraphModule gm_b GraphModule graph_c Graph node_name_prefix str logger_cls Callable node_type_to_io_type_map dict str set NSNodeTargetType - Union Node list Node Given starting graph C derived graph B - prev_node_c - node_c - And corresponding related node_a inserts correct dtype cast node after prev_node_c cast into dtype expected node_a resulting dtype_cast - prev_node_c - node_c - For example node_c int op node_a fp op function will insert dequant dtype_cast_op = None dtype_cast_mod_cls = None dtype_cast_method = None dtype_cast_method_dtype = None dtype_cast_scale = None dtype_cast_zero_point = None node_input_type_a _node_output_type_a = get_node_first_input_and_output_type node_a gm_a logger_cls node_type_to_io_type_map node_input_type_c _node_output_type_c = get_node_first_input_and_output_type node_c gm_b logger_cls node_type_to_io_type_map node_input_type_a == NodeInputOrOutputType FP node_input_type_c == NodeInputOrOutputType INT node_input_type_a == NodeInputOrOutputType FP node_input_type_c == NodeInputOrOutputType FP TODO future PR determine actual dtype node_c current code only works because dequantize works multiple input dtypes node_input_type_a == NodeInputOrOutputType FP node_input_type_c == NodeInputOrOutputType FP _OR_INT dtype_cast_op = torch dequantize node_input_type_a == node_input_type_c node_input_type_a = NodeInputOrOutputType UNKNOWN dtype_cast_mod_cls = torch nn Identity node_input_type_a == NodeInputOrOutputType INT node_input_type_c == NodeInputOrOutputType FP int shadows fp dtype cast needs quantize int right qparams node_a_input_qparams = get_node_input_qparams node_a gm_a node_type_to_io_type_map node_a_input_qparams None dtype_cast_op = torch quantize_per_tensor type ignore assignment dtype_cast_scale dtype_cast_zero_point = node_a_input_qparams node_input_type_a == NodeInputOrOutputType FP node_input_type_c == NodeInputOrOutputType FP dtype_cast_method = dtype_cast_method_dtype = torch float raise AssertionError f dtype cast node_input_type_c node_c format_node + f node_input_type_a node_a format_node needs implemented isinstance prev_node_c Node new_dtype_cast_name = get_new_attr_name_with_prefix node_name_prefix gm_b dtype_cast_op dtype_cast_scale None dtype_cast_zero_point None _insert_quantize_per_tensor_node prev_node_c node_a gm_b graph_c dtype_cast_scale dtype_cast_zero_point new_dtype_cast_name graph_c create_node call_function dtype_cast_op prev_node_c new_dtype_cast_name dtype_cast_method graph_c create_node call_method dtype_cast_method prev_node_c dtype_cast_method_dtype new_dtype_cast_name dtype_cast_mod_cls raise AssertionError Expected dtype_cast_mod_cls None dtype_cast_mod = dtype_cast_mod_cls setattr gm_b new_dtype_cast_name dtype_cast_mod graph_c create_node call_module new_dtype_cast_name prev_node_c new_dtype_cast_name isinstance prev_node_c list results = prev_node_c_inner prev_node_c new_dtype_cast_name = get_new_attr_name_with_prefix node_name_prefix gm_b dtype_cast_op TODO future PR add handling quantize_per_tensor new_dtype_cast_node = graph_c create_node call_function dtype_cast_op prev_node_c_inner new_dtype_cast_name results append new_dtype_cast_node dtype_cast_mod_cls raise AssertionError Expected dtype_cast_mod_cls None dtype_cast_mod = dtype_cast_mod_cls setattr gm_b new_dtype_cast_name dtype_cast_mod new_dtype_cast_node = graph_c create_node call_module new_dtype_cast_name prev_node_c_inner new_dtype_cast_name results append new_dtype_cast_node results raise AssertionError f type f type prev_node_c handled TODO future PR look into using copy_node API instead _copy_node_from_a_to_c node_a Node gm_a GraphModule gm_b GraphModule graph_c Graph - Node Simple copy node_a graph_c node_a op == get_attr node_a_copy_name = get_new_attr_name_with_prefix node_a name + _shadow_copy_ gm_b node_a_obj = getattr_from_fqn gm_a node_a target type ignore arg-type torch is_tensor node_a_obj node_a_obj = node_a_obj detach setattr gm_b node_a_copy_name node_a_obj node_a_copy = graph_c create_node node_a op node_a_copy_name node_a_copy_name node_a_copy node_a op == call_method node_a target dequantize raise AssertionError f target node_a target implemented node_a target == dequantize arg_copy = _copy_node_from_a_to_c get_normalized_nth_input node_a gm_a gm_a gm_b graph_c type ignore arg-type node_a_copy_name = get_new_attr_name_with_prefix node_a name + _shadow_copy_ gm_b node_a_copy = graph_c create_node node_a op node_a target arg_copy node_a_copy_name node_a_copy arg_copy = _copy_node_from_a_to_c get_normalized_nth_input node_a gm_a gm_a gm_b graph_c type ignore arg-type node_a_copy_name = get_new_attr_name_with_prefix node_a name + _shadow_copy_ gm_b node_a_copy = graph_c create_node node_a op node_a target arg_copy get_normalized_nth_input node_a gm_a node_a_copy_name node_a_copy raise AssertionError f handling node node_a format_node op node_a op implemented _can_insert_copy_of_subgraph_a subgraph_a NSSubgraph gm_a GraphModule num_non_param_args_node_a int - bool This function returns ` False ` input subgraph cannot copied ` _insert_copy_of_subgraph_a_after_input_node_c ` This usually means there corner case logic which copy yet implemented populate list nodes we need check nodes = cur_node = subgraph_a end_node while cur_node = subgraph_a start_node nodes append cur_node cur_node = get_normalized_nth_input cur_node gm_a type ignore assignment nodes append cur_node nodes reverse _can_insert node_a_arg gm_a isinstance node_a_arg Node arg_a = return_first_non_observer_node node_a_arg gm_a arg_a op == call_method arg_a target dequantize arg_a op == get_attr True False isinstance node_a_arg list tuple el node_a_arg isinstance el Node False True For each node check we handle copy behavior This follows logic ` _insert_copy_of_subgraph_a_after_input_node_c ` node_a nodes local_num_non_param_args_node_a = num_non_param_args_node_a node_a nodes norm_args_kwargs = node_a normalized_arguments gm_a normalize_to_only_use_kwargs=True norm_args_kwargs None norm_args norm_kwargs = norm_args_kwargs norm_args norm_kwargs = node_a args node_a kwargs cur_idx = while cur_idx len norm_args cur_idx == pass cur_idx == local_num_non_param_args_node_a == pass _can_insert norm_args cur_idx gm_a False cur_idx += kwarg_val norm_kwargs values stitch inputs base graph cur_idx == pass cur_idx == local_num_non_param_args_node_a == pass _can_insert kwarg_val gm_a False cur_idx += True _insert_copy_of_subgraph_a_after_input_node_c input_node_c Union Node list Node input_node_c_ Optional Union Node list Node subgraph_a NSSubgraph gm_a GraphModule gm_b GraphModule node_name_prefix str - Node TODO before land real docblock isinstance input_node_c Node list raise AssertionError f Expected Node list got type input_node_c create sequential list subgraphs nodes start end because we need add nodes graph C non-reverse order nodes_of_a = subgraph_a end_node cur_node = subgraph_a end_node while cur_node = subgraph_a start_node cur_node = get_normalized_nth_input cur_node gm_a type ignore assignment nodes_of_a insert cur_node go through nodes order insert them into graph c sequentially cur_node_a = nodes_of_a cur_node_c = _insert_copy_of_node_a_after_input_node_c input_node_c input_node_c_ cur_node_a gm_a gm_b node_name_prefix cur_idx_a range len nodes_of_a cur_node_a = nodes_of_a cur_idx_a prev_node_c = cur_node_c previous added node input next node cur_node_c = _insert_copy_of_node_a_after_input_node_c prev_node_c TODO future PR enable multiple inputs nodes which start subgraph None cur_node_a gm_a gm_b node_name_prefix last inserted node cur_node_c _insert_copy_of_node_a_after_input_node_c input_node_c Union Node list Node input_node_c_ Optional Union Node list Node node_a Node gm_a GraphModule gm_b GraphModule node_name_prefix str - Node Assume node_a graph_a has args input input arg kwargs kw kwarg Note input optional If equals None we assume op has single non-param input If specified we assume op has two non-param inputs Copies underlying values arg argn kwarg kwargn into gm_b creates corresponding nodes graph_c Note observers ignored so arg observer we navigate up until we find non-observer parent If node_a call_module points module pointed node_a gm_b Creates copy node_a graph_c input first arg all other args kwargs pointing copies objects gm_b created above An example pictures graph A ======== input ------------- node_a input_ ---------- weight - weight_obs bias ---------------- graph C derived B ========================= input_node_c -- node_a_copy input_node_c_ weight_copy ---- bias_copy ------ isinstance input_node_c Node graph_c = input_node_c graph isinstance input_node_c list raise AssertionError f Expected list got type input_node_c graph_c = input_node_c graph norm_args_kwargs = node_a normalized_arguments gm_a normalize_to_only_use_kwargs=True norm_args_kwargs None norm_args norm_kwargs = norm_args_kwargs norm_args norm_kwargs = node_a args node_a kwargs new_args = new_kwargs = _copy_arg arg copy other inputs other graph isinstance arg Node arg = return_first_non_observer_node arg gm_a arg = _copy_node_from_a_to_c arg gm_a gm_b graph_c arg isinstance arg int float torch dtype arg isinstance kwarg_val list tuple el kwarg_val isinstance el Node raise AssertionError handling Node inside list implemented arg raise AssertionError f handling kwarg type type kwarg_val implemented cur_idx = while cur_idx len norm_args cur_idx == new_arg = input_node_c cur_idx == input_node_c_ None new_arg = input_node_c_ new_arg = _copy_arg norm_args cur_idx new_args append new_arg cur_idx += kwarg_name kwarg_val norm_kwargs items stitch inputs base graph cur_idx == new_kwargs kwarg_name = input_node_c cur_idx == input_node_c_ None new_kwargs kwarg_name = input_node_c_ new_kwargs kwarg_name = _copy_arg kwarg_val cur_idx += new_args = tuple new_args type ignore assignment node_a_shadows_c_name = get_new_attr_name_with_prefix node_name_prefix gm_b node_a op == call_module target module we point module gm_b new_mod_copy_name = get_new_attr_name_with_prefix node_name_prefix gm_b fetch corresponding module gm_a isinstance node_a target str raise AssertionError f Expected str got type node_a target mod_a = getattr_from_fqn gm_a node_a target setattr gm_b new_mod_copy_name mod_a node_a_shadows_c = graph_c create_node node_a op new_mod_copy_name new_args type ignore arg-type new_kwargs type ignore arg-type node_a_shadows_c_name node_a_shadows_c node_a op call_function call_method raise AssertionError f Unexpected op node_a op node_a_shadows_c = graph_c create_node node_a op node_a target new_args type ignore arg-type new_kwargs type ignore arg-type node_a_shadows_c_name node_a_shadows_c create_a_shadows_b name_a str gm_a GraphModule name_b str gm_b GraphModule matched_subgraph_pairs dict str tuple NSSubgraph NSSubgraph logger_cls Callable should_log_inputs bool node_type_to_io_type_map Optional dict str set NSNodeTargetType = None - GraphModule Creates new GraphModule consisting graph C meaningful nodes A shadowing corresponding nodes B For example Graph A - op _fp - - op _fp - Graph B b - op _int - b - op _int - b matched_node_pairs op op _fp op _int op op _fp op _int Graph C A shadows B dequant - op _fp - logger_a_ dequant_ - op _fp - logger_a_ b ------------- op _int - logger_b_ -------------- op _int - logger_b_ In nutshell function does following each node pair copies necessary attributes modules gm_a gm_b keeping names unique adds dtype cast op dequant quant etc adds copy node_a gm_b s graph adds loggers outputs node_a node_b node_type_to_io_type_map None node_type_to_io_type_map = get_node_type_to_io_type_map graph_c graph created copying nodes graph_b inserting shadows nodes copied graph_a graph_c = Graph env_c dict str Any = load_arg map_arg lambda node env_c node name start_node_b_to_matched_subgraph_a_and_name = end_node_b_to_matched_subgraph_a_and_name = match_name match matched_subgraph_pairs items subgraph_a subgraph_b = match ref_node_type_a = get_target_type_str subgraph_a base_op_node gm_a ref_node_type_b = get_target_type_str subgraph_b base_op_node gm_b start_node_b_to_matched_subgraph_a_and_name subgraph_b start_node = subgraph_a match_name ref_node_type_a ref_node_type_b end_node_b_to_matched_subgraph_a_and_name subgraph_b end_node = subgraph_a match_name ref_node_type_a ref_node_type_b node_b gm_b graph nodes node_b op == output graph_c output map_arg node_b args load_arg continue calculate flags determine what do node node_b_is_start_node = node_b start_node_b_to_matched_subgraph_a_and_name node_b_is_end_node = node_b end_node_b_to_matched_subgraph_a_and_name node_b_is_start_node node_b_is_end_node node_b_is_start_node subgraph_a ref_name ref_node_type_a ref_node_type_b = start_node_b_to_matched_subgraph_a_and_name node_b node_b_is_end_node raise AssertionError Expected node_b_is_end_node false subgraph_a ref_name ref_node_type_a ref_node_type_b = end_node_b_to_matched_subgraph_a_and_name node_b all_op_types_support_shadowing = op_type_supports_shadowing subgraph_a start_node op_type_supports_shadowing node_b all_op_types_support_shadowing print f skipping shadow loggers node_b get_target_type_str node_b gm_b + f start_node_a get_target_type_str subgraph_a start_node gm_a + unsupported env_c node_b name = graph_c node_copy node_b load_arg continue For both start_node end_node verify we know how do dtype cast If we do skip node_input_type_a node_output_type_a = get_node_first_input_and_output_type subgraph_a start_node gm_a logger_cls node_type_to_io_type_map node_input_type_b node_output_type_b = get_node_first_input_and_output_type node_b gm_b logger_cls node_type_to_io_type_map node_io_types_known_a_and_b = node_input_type_a = NodeInputOrOutputType UNKNOWN node_output_type_a = NodeInputOrOutputType UNKNOWN node_input_type_b = NodeInputOrOutputType UNKNOWN node_output_type_b = NodeInputOrOutputType UNKNOWN node_io_types_known_a_and_b print f skipping shadow loggers node_b get_target_type_str node_b gm_b + f start_node_a get_target_type_str subgraph_a start_node gm_a + unknown dtype cast env_c node_b name = graph_c node_copy node_b load_arg continue If we shadowing fp int we need insert quantize_per_tensor call qparams previous node Only do we able infer these qparams graph node_input_type_a == NodeInputOrOutputType INT node_input_type_b == NodeInputOrOutputType FP node_a_input_qparams = get_node_input_qparams subgraph_a start_node gm_a node_type_to_io_type_map node_a_input_qparams print f skipping shadow loggers node_b get_target_type_str node_b gm_b + f start_node_a get_target_type_str subgraph_a start_node gm_a + unknown input qparams env_c node_b name = graph_c node_copy node_b load_arg continue num_non_param_args_node_a = get_number_of_non_param_args subgraph_a start_node gm_a _can_insert_copy_of_subgraph_a subgraph_a gm_a num_non_param_args_node_a print f skipping shadow loggers node_b get_target_type_str node_b gm_b + f start_node_a get_target_type_str subgraph_a start_node gm_a + unhandled logic subgraph copy env_c node_b name = graph_c node_copy node_b load_arg continue fqn_base_a = _maybe_get_fqn subgraph_a base_op_node gm_a fqn_base_b = _maybe_get_fqn subgraph_b base_op_node gm_b type ignore possibly-undefined node_b_is_start_node necessary log input node_c should_log_inputs prev_node_b = get_normalized_nth_input node_b gm_b isinstance prev_node_b Node prev_node_c = env_c prev_node_b name env_c prev_node_c name = _insert_logger_after_node prev_node_c gm_b logger_cls _ns_logger_b_inp_ node_b name name_b ref_name ref_node_type_b NSSingleResultValuesType NODE_INPUT value index_within_arg= index_of_arg= fqn=fqn_base_b isinstance prev_node_b list first save prev_node instances because they will overwritten env after first logger added prev_node_c_list = env_c arg name arg prev_node_b arg_idx prev_node_c enumerate prev_node_c_list env_c prev_node_c name = _insert_logger_after_node prev_node_c gm_b logger_cls _ns_logger_b_inp_ node_b name name_b ref_name ref_node_type_b NSSingleResultValuesType NODE_INPUT value index_within_arg=arg_idx index_of_arg= fqn=fqn_base_b logging inputs which lists supported yet raise AssertionError f type type prev_node_b handled yet subgraph so far prev_node_c + - logger_c_input Note statement always True spelling out clarify code intent node_b_is_start_node node_b_is_end_node ensure env_c populated base node env_c node_b name = graph_c node_copy node_b load_arg node_c = env_c node_b name after point node_a original node graph_a parent module gm_a node_b original node graph_b parent module gm_b node_c copy node_b graph_c subgraph so far prev_node_c + - logger_c_input - node_start_c node_b_is_start_node cast dtype dtype node_c s input dtype node_a s input dequant etc prev_node_c = node_c args prev_node_c = get_normalized_nth_input node_c gm_b type ignore possibly-undefined should_log_inputs skip input logger when inserting dtype cast isinstance prev_node_c Node pyrefly ignore unbound-name prev_node_c = get_normalized_nth_input node_c gm_b isinstance prev_node_c list prev_node_c = get_normalized_nth_input arg gm_b arg prev_node_c dtype_cast_node = _insert_dtype_cast_after_node subgraph_a start_node pyrefly ignore unbound-name node_c prev_node_c gm_a gm_b graph_c node_b name + _dtype_cast_ logger_cls node_type_to_io_type_map note inserting env_c because all nodes which use dtype casts copied graph_a subgraph so far dtype_cast_node + prev_node_c + - logger_c_input - node_start_c input logging enabled log input subgraph should_log_inputs TODO explain ref_node_name = isinstance dtype_cast_node Node dtype_cast_node = _insert_logger_after_node dtype_cast_node gm_b logger_cls _ns_logger_a_inp_ ref_node_name name_a ref_name ref_node_type_a NSSingleResultValuesType NODE_INPUT value index_within_arg= index_of_arg= fqn=fqn_base_a input_logger Union Node list Node = dtype_cast_node isinstance dtype_cast_node list raise AssertionError f Expected list got type dtype_cast_node new_loggers = dtype_cast_idx dtype_cast_node_inner enumerate dtype_cast_node dtype_cast_logger = _insert_logger_after_node dtype_cast_node_inner gm_b logger_cls _ns_logger_a_inp_ ref_node_name name_a ref_name ref_node_type_a NSSingleResultValuesType NODE_INPUT value index_within_arg=dtype_cast_idx index_of_arg= fqn=fqn_base_a new_loggers append dtype_cast_logger dtype_cast_node = new_loggers input_logger = dtype_cast_node subgraph so far dtype_cast_node + - logger_a_input prev_node_c - logger_c_input - node_start_c hook up new mod_a copy graph receiving same inputs mod_b does dtype cast match Some ops such LSTMs have two non-param inputs If we have such op pass second param well Note dtype casting second param implemented yet can added later there use case node_c_second_non_param_arg = None num_non_param_args_node_a = get_number_of_non_param_args subgraph_a start_node gm_a num_non_param_args_node_a == node_c_second_non_param_arg = node_c args node_c_second_non_param_arg = get_normalized_nth_input pyrefly ignore unbound-name node_c gm_b node_a_shadows_c = _insert_copy_of_subgraph_a_after_input_node_c dtype_cast_node node_c_second_non_param_arg subgraph_a gm_a gm_b pyrefly ignore unbound-name node_c name + _shadow_copy_ env_c node_a_shadows_c name = node_a_shadows_c subgraph so far dtype_cast_node - logger_a_input - subgraph_a_copy args kwargs shown prev_node_c + - logger_c_input - node_start_c should_log_inputs When we created input logger we left ref_node_name empty string because subgraph copy did exist yet Now subgraph copy exists we modify name its true value Note alternative create input logger after creating subgraph which slightly more complicated This lesser two evils input_logger = env_c dtype_cast_node name Find first node subgraph cur_node = node_a_shadows_c while get_normalized_nth_input cur_node gm_b = input_logger type ignore possibly-undefined cur_node = get_normalized_nth_input cur_node gm_b type ignore assignment pyrefly ignore unbound-name isinstance input_logger Node pyrefly ignore unbound-name input_logger_mod = getattr gm_b input_logger name input_logger_mod ref_node_name = cur_node name pyrefly ignore unbound-name isinstance input_logger list raise AssertionError pyrefly ignore unbound-name f Expected list got type input_logger pyrefly ignore unbound-name input_logger_inner input_logger input_logger_mod = getattr gm_b input_logger_inner name input_logger_mod ref_node_name = cur_node name hook up logger mod_a copy env_c node_a_shadows_c name = _insert_logger_after_node env_c node_a_shadows_c name gm_b logger_cls _ns_logger_a_ node_a_shadows_c name name_a ref_name ref_node_type_a NSSingleResultValuesType NODE_OUTPUT value index_within_arg= index_of_arg= fqn=fqn_base_a subgraph so far dtype_cast_node - logger_a_input - subgraph_a_copy - logger_a prev_node_c + - logger_c_input - node_start_c node_b_is_end_node hook up logger mod_b copy env_c node_b name = _insert_logger_after_node env_c node_b name gm_b logger_cls _ns_logger_b_ node_b name name_b ref_name ref_node_type_b NSSingleResultValuesType NODE_OUTPUT value index_within_arg= index_of_arg= fqn=fqn_base_b subgraph so far dtype_cast_node - logger_a_input - subgraph_a_copy - logger_a prev_node_c+ - logger_c_input - node_start_c - - node_end_c - logger_c Note node_start_c may same node node_end_c they may have nodes between env_c node_b name = graph_c node_copy node_b load_arg gm_c = GraphModule gm_b graph_c gm_c