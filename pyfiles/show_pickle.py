usr bin env python mypy allow-untyped-defs sys pickle struct pprint zipfile fnmatch typing Any IO __all__ = FakeObject FakeClass DumpUnpickler main FakeObject __init__ module name args module = module name = name args = args NOTE We don t distinguish between state never set state set None state = None __repr__ state_str = state None f state= state r f module name args r state_str __setstate__ state state = state staticmethod pp_format printer obj stream indent allowance context level obj args obj state None stream write repr obj obj state None stream write f obj module obj name printer _format obj args stream indent + allowance + context level obj args stream write f obj module obj name state=\n indent += printer _indent_per_level stream write indent printer _format obj state stream indent allowance + context level + stream write raise Exception Need implement noqa TRY FakeClass __init__ module name module = module name = name __new__ = fake_new type ignore assignment __repr__ f module name __call__ args FakeObject module name args fake_new args FakeObject module name args DumpUnpickler pickle _Unpickler type ignore name-defined __init__ file catch_invalid_utf =False kwargs super __init__ file kwargs catch_invalid_utf = catch_invalid_utf find_class module name FakeClass module name persistent_load pid FakeObject pers obj pid dispatch = dict pickle _Unpickler dispatch type ignore attr-defined Custom objects TorchScript able invalid UTF- strings their pickle __getstate__ functions Install custom loader strings catches decode exception replaces sentinel object load_binunicode strlen = struct unpack I read type ignore attr-defined strlen sys maxsize raise Exception String too long noqa TRY str_bytes = read strlen type ignore attr-defined obj Any try obj = str str_bytes utf- surrogatepass except UnicodeDecodeError exn catch_invalid_utf raise obj = FakeObject builtin UnicodeDecodeError str exn append obj type ignore attr-defined dispatch pickle BINUNICODE = load_binunicode type ignore assignment classmethod dump cls in_stream out_stream value = cls in_stream load pprint pprint value stream=out_stream value main argv output_stream=None len argv = Don t spam stderr using stdout output_stream None raise Exception Pass argv length noqa TRY sys stderr write usage show_pickle PICKLE_FILE\n sys stderr write PICKLE_FILE can any \n sys stderr write path pickle file\n sys stderr write file zip member pkl\n sys stderr write file zip pattern \n sys stderr write shell glob pattern members \n sys stderr write only first match will shown \n fname = argv handle IO bytes fname open fname rb handle DumpUnpickler dump handle output_stream zfname mname = fname split zipfile ZipFile zfname zf mname zf open mname handle DumpUnpickler dump handle output_stream found = False info zf infolist fnmatch fnmatch info filename mname zf open info handle DumpUnpickler dump handle output_stream found = True break found raise Exception f Could find member matching mname zfname noqa TRY __name__ == __main__ This hack works every version Python I ve tested I ve tested following versions True pprint PrettyPrinter _dispatch FakeObject __repr__ = FakeObject pp_format type ignore attr-defined sys exit main sys argv