mypy ignore-errors random typing NamedTuple Optional Union torch Global configuration tensor fuzzing FuzzerConfig Global configuration tensor fuzzing behavior use_real_values bool = True If False use zeros True use random values avoid_complex bool = False If True exclude complex dtypes fuzzing TensorSpec NamedTuple Specification tensor argument size tuple int stride tuple int dtype torch dtype ScalarSpec NamedTuple Specification scalar argument dtype torch dtype constant Optional Union int float bool complex = None If set use constant value instead fuzzing Union type specs Spec = Union TensorSpec ScalarSpec fuzz_torch_tensor_type template str = default - torch dtype Fuzzes PyTorch tensor data types randomly selecting returning different dtypes Args template Template name determine supported dtypes Returns torch dtype A randomly selected PyTorch tensor data type based template constraints Get template-specific dtypes template == dtensor Import here avoid circular imports torchfuzz codegen DTensorFuzzTemplate fuzz_template = DTensorFuzzTemplate tensor_dtypes = fuzz_template supported_dtypes template == unbacked Import here avoid circular imports torchfuzz codegen UnbackedFuzzTemplate fuzz_template = UnbackedFuzzTemplate tensor_dtypes = fuzz_template supported_dtypes torchfuzz codegen DefaultFuzzTemplate fuzz_template = DefaultFuzzTemplate tensor_dtypes = fuzz_template supported_dtypes Randomly select data type random choice tensor_dtypes fuzz_tensor_size max_dims int = max_size_per_dim int = - tuple int Fuzzes PyTorch tensor sizes generating random tensor shapes Args max_dims Maximum number dimensions default max_size_per_dim Maximum size each dimension default Returns Tuple int A tuple representing tensor shape size Randomly choose number dimensions max_dims dimensions = scalar tensor num_dims int = random randint max_dims num_dims == Scalar tensor -dimensional Generate random sizes each dimension sizes list int = _ range num_dims Include edge cases - chance size empty tensor dimension - chance size singleton dimension - chance normal size max_size_per_dim rand_val float = random random rand_val Empty dimension size int = rand_val Singleton dimension size = Normal size size = random randint max_size_per_dim sizes append size tuple sizes fuzz_valid_stride size tuple int - tuple int Fuzzes PyTorch tensor strides generating valid stride patterns given size Args size Tensor shape size tuple integers Returns Tuple int A tuple representing valid tensor strides len size == Scalar tensor has no strides Choose stride pattern type stride_types = contiguous Normal contiguous memory layout transposed Transposed dimensions custom_gaps Custom strides gaps non-dense minimal Minimal valid strides all ones nonoverlapping_and_dense Non-overlapping dense contiguous nonoverlapping_and_dense_non_contig Non-overlapping dense contiguous overlapping Overlapping memory access zero strides sparse_gaps Large gaps definitely non-dense stride_type str = random choice stride_types stride_type contiguous nonoverlapping_and_dense Standard contiguous strides stride i = product sizes i+ tuple _compute_contiguous_strides size stride_type == transposed Create transposed version - swap some dimensions strides base_strides = list _compute_contiguous_strides size len base_strides = Randomly swap strides two dimensions i j = random sample range len base_strides base_strides i base_strides j = base_strides j base_strides i tuple base_strides stride_type == custom_gaps Create strides custom gaps spacing base_strides = list _compute_contiguous_strides size Add random gaps some strides i range len base_strides size i = random random chance add gap gap_multiplier int = random randint base_strides i = gap_multiplier tuple base_strides stride_type == minimal Minimal valid strides all ones tuple len size stride_type == nonoverlapping_and_dense_non_contig Non-overlapping dense contiguous e g column-major tuple _compute_non_contiguous_dense_strides size stride_type == overlapping Create overlapping strides zero strides some dimensions base_strides = list _compute_contiguous_strides size Randomly set some strides cause overlapping i range len base_strides size i random random chance make overlapping base_strides i = tuple base_strides stride_type == sparse_gaps Create strides very large gaps definitely non-dense base_strides = list _compute_contiguous_strides size Add very large gaps create sparse layout i range len base_strides size i gap_multiplier int = random randint Much larger gaps base_strides i = gap_multiplier tuple base_strides Fallback contiguous tuple _compute_contiguous_strides size _compute_contiguous_strides size tuple int - list int Helper function compute standard contiguous strides given size Args size Tensor shape size tuple integers Returns list int List contiguous strides strides list int = current_stride int = Calculate strides right left i range len size - - - strides insert current_stride For dimensions size keep stride size i = current_stride = size i strides _compute_non_contiguous_dense_strides size tuple int - list int Helper function compute non-contiguous dense strides e g column-major order Args size Tensor shape size tuple integers Returns list int List non-contiguous dense strides len size = For D D tensors same contiguous _compute_contiguous_strides size Generate different dense patterns patterns = column_major Reverse order left right instead right left random_permute Random permutation dimensions middle_out Start middle dimension pattern str = random choice patterns pattern == column_major Column-major order calculate strides left right strides list int = len size current_stride int = Calculate strides left right opposite contiguous i range len size strides i = current_stride For dimensions size keep stride size i = current_stride = size i strides pattern == random_permute Create valid permutation s still dense Create dimension permutation indices = list range len size random shuffle indices Apply permutation get new dense layout new_strides = len size current_stride = Sort indices their corresponding size maintain density sorted_indices = sorted indices key=lambda i size i size i = float inf idx sorted_indices new_strides idx = current_stride size idx = current_stride = size idx new_strides pattern == middle_out Start middle dimension work outward strides = len size current_stride = Start middle middle = len size processed = False len size Process middle first strides middle = current_stride size middle = current_stride = size middle processed middle = True Process alternating left right offset range len size direction - idx = middle + direction offset = idx len size processed idx strides idx = current_stride size idx = current_stride = size idx processed idx = True break strides Fallback contiguous _compute_contiguous_strides size _compute_storage_size_needed size tuple int strides tuple int - int Compute minimum storage size needed given shape strides size Find maximum offset max_offset = dim_size stride zip size strides dim_size max_offset += dim_size - abs stride max_offset + fuzz_tensor size Optional tuple int = None stride Optional tuple int = None dtype Optional torch dtype = None seed Optional int = None - tuple torch Tensor int Create tensor fuzzed size stride dtype Args size Tensor shape If None will randomly generated stride Tensor stride If None will randomly generated based size dtype Tensor data type If None will randomly generated seed Random seed reproducibility If None will randomly generated Returns Tuple torch Tensor int A tuple tensor seed_used where tensor has specified randomly generated properties seed_used seed used generation reproducibility Generate use provided seed seed None seed = random randint - Create local Random instance avoid interfering global state local_random = random Random seed Set torch random seed reproducibility Save restore global torch state avoid side effects torch_state = torch get_rng_state torch manual_seed seed Generate random values provided using local random instance old_random_state = random getstate try Temporarily use local random instance deterministic generation random setstate local_random getstate size None size = fuzz_tensor_size dtype None dtype = fuzz_torch_tensor_type default stride None stride = fuzz_valid_stride size Handle empty tensor case len size == torch ones dtype=dtype seed Calculate required storage size custom stride required_storage = _compute_storage_size_needed size stride Create base tensor sufficient storage FuzzerConfig use_real_values Use random values based dtype dtype is_floating_point base_tensor = torch randn required_storage dtype=dtype dtype torch complex torch complex Create complex tensor random real imaginary parts real_part = torch randn required_storage dtype=torch float dtype == torch complex torch float imag_part = torch randn required_storage dtype=torch float dtype == torch complex torch float base_tensor = torch complex real_part imag_part dtype dtype == torch bool base_tensor = torch randint required_storage dtype=torch bool integer types base_tensor = torch randint - required_storage dtype=dtype Use zeros default behavior base_tensor = torch ones required_storage dtype=dtype Create strided tensor view strided_tensor = torch as_strided base_tensor size stride strided_tensor seed finally Restore original random state random setstate old_random_state Restore original torch state torch set_rng_state torch_state fuzz_tensor_simple size Optional tuple int = None stride Optional tuple int = None dtype Optional torch dtype = None seed Optional int = None - torch Tensor Convenience function returns just tensor without seed Args size Tensor shape If None will randomly generated stride Tensor stride If None will randomly generated based size dtype Tensor data type If None will randomly generated seed Random seed reproducibility If None uses current random state Returns torch Tensor A tensor specified randomly generated properties tensor _ = fuzz_tensor size stride dtype seed tensor fuzz_non_contiguous_dense_tensor size Optional tuple int = None dtype Optional torch dtype = None - torch Tensor Specifically generates tensors non-contiguous dense non-overlapping Args size Tensor shape size If None auto-generated dtype PyTorch tensor data type If None auto-generated Returns torch Tensor A non-contiguous dense tensor dtype None dtype = fuzz_torch_tensor_type default size None size = fuzz_tensor_size Force non-contiguous dense stride patterns len size = For D D tensors contiguous they re trivially dense tensor _ = fuzz_tensor size None dtype tensor Choose patterns guarantee non-contiguous dense patterns = column_major transposed permuted_dense pattern = random choice patterns pattern == column_major Column-major order non-contiguous dense stride = tuple _compute_non_contiguous_dense_strides size pattern == transposed Simple transpose last two dimensions base_strides = _compute_contiguous_strides size len base_strides = Swap last two dimensions strides base_strides - base_strides - = base_strides - base_strides - stride = tuple base_strides permuted_dense Random permutation maintains density stride = tuple _compute_non_contiguous_dense_strides size tensor _ = fuzz_tensor size stride dtype tensor fuzz_scalar spec seed Optional int = None - Union float int bool complex Create Python scalar value ScalarSpec Args spec ScalarSpec containing desired dtype optionally constant value seed Random seed reproducibility If None uses current random state Returns Python scalar float int bool complex matching dtype If constant value specified use directly spec constant None spec constant Create local random instance avoid interfering global state seed None local_random = random Random seed Save restore global random state old_random_state = random getstate try random setstate local_random getstate Create scalar value based dtype spec dtype is_floating_point random uniform - spec dtype torch complex torch complex Only generate complex values avoiding complex dtypes FuzzerConfig avoid_complex raise ValueError Cannot generate complex values avoid_complex=True complex random uniform - random uniform - integer bool spec dtype == torch bool random choice True False random randint - finally Restore original random state random setstate old_random_state Use current random state when no seed provided Create scalar value based dtype spec dtype is_floating_point random uniform - spec dtype torch complex torch complex Only generate complex values avoiding complex dtypes FuzzerConfig avoid_complex raise ValueError Cannot generate complex values avoid_complex=True complex random uniform - random uniform - integer bool spec dtype == torch bool random choice True False random randint - specs_compatible spec Spec spec Spec - bool Check two specifications compatible one can used where other expected type spec type spec False isinstance spec ScalarSpec For scalars require exact dtype match simplicity spec dtype == spec dtype isinstance spec TensorSpec assert isinstance spec TensorSpec For tensors shape dtype should match exactly spec size == spec size spec dtype == spec dtype False