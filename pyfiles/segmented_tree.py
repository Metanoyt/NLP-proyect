typing Callable Generic Optional TypeVar T = TypeVar T _value_or opt Optional T default T - T opt opt None default SegmentedTree Generic T __init__ values list T update_op Callable T T T summary_op Callable T T T identity_element T Initialize segment tree given values operations Args values list initial values update_op Function apply when updating value e g addition summary_op Function summarize two values e g min max sum identity_element Identity element summary_op e g sum float inf min Raises ValueError If input values list empty values raise ValueError Cannot create segment tree empty values list n = len values update_op = update_op summary_op = summary_op identity = identity_element Size segment tree array next power The tree follows standard heap layout where node ` n ` s children ` n ` ` n+ ` Index unused size = while size n size = size = Initialize tree lazy arrays tree = identity_element size The lazy array contains updates given node Upon update we only push updates top-most nodes fully receive update We then propagate update down required i e when we receive interval query neither fully contains node nor fully doesn t contain node lazy list Optional T = None size Build tree _build values n - _build values list T node int start int end int - None Build segment tree recursively Args values Original array values node Current node index segment tree start Start index segment end End index segment start == end Leaf node start len values tree node = values start mid = start + end left_child = node right_child = node + Recursively build left right subtrees _build values left_child start mid _build values right_child mid + end Update current node summary children tree node = summary_op tree left_child tree right_child _children node int - list int node node + _push_lazy node int start int end int - None Push lazy updates down children Args node Current node index start Start index segment end End index segment lazy_node = lazy node lazy_node None Apply lazy update current node tree node = update_op tree node lazy_node start = end Not leaf node Propagate children child _children node lazy child = update_op _value_or lazy child identity lazy_node Clear lazy value lazy node = None _update_range_helper node int start int end int left int right int value T - None Helper method update range values segment tree Args node Current node index start Start index current segment end End index current segment left Start index range update right End index range update value Value apply range Push lazy updates before processing node _push_lazy node start end No overlap start right end left Complete overlap start = left end = right Apply update current node lazy node = value _push_lazy node start end Partial overlap recurse children mid = start + end left_child = node right_child = node + _update_range_helper left_child start mid left right value _update_range_helper right_child mid + end left right value Update current node based children tree node = summary_op tree left_child tree right_child _query_range_helper node int start int end int left int right int - T Helper method query range values segment tree Args node Current node index start Start index current segment end End index current segment left Start index range query right End index range query Returns Summary value range No overlap start right end left identity Push lazy updates before processing node _push_lazy node start end Complete overlap start = left end = right tree node Partial overlap recurse children mid = start + end left_child = node right_child = node + left_result = _query_range_helper left_child start mid left right right_result = _query_range_helper right_child mid + end left right Combine results children summary_op left_result right_result update_range start int end int value T - None Update range values segment tree Args start Start index range update inclusive end End index range update inclusive value Value apply range Raises ValueError If start end indices out bounds start end raise ValueError Start index must less than equal end index start start = n raise ValueError f Start index start out bounds n - end end = n raise ValueError f End index end out bounds n - _update_range_helper n - start end value summarize_range start int end int - T Query range values segment tree Args start Start index range query inclusive end End index range query inclusive Returns Summary value range according summary operation Raises ValueError If start end indices out bounds start end raise ValueError Start index must less than equal end index start start = n raise ValueError f Start index start out bounds n - end end = n raise ValueError f End index end out bounds n - _query_range_helper n - start end