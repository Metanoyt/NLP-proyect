copy queue SimpleQueue typing Optional _Optional torch fx torch fx _compatibility compatibility torch fx graph Graph torch fx graph_module GraphModule torch fx node Node torch fx passes tools_common legalize_graph NodeList NodeSet torch fx passes utils lift_subgraph_as_module type ignore attr-defined compatibility is_backward_compatible=False topo_sort nodes NodeList - NodeList sort nodes according topological order indegree_map = dict fromkeys nodes candidates SimpleQueue Node = SimpleQueue node nodes n node all_input_nodes n indegree_map indegree_map node += indegree_map node == candidates put node sorted_nodes NodeList = while candidates empty node = candidates get sorted_nodes append node n node users n indegree_map indegree_map n -= indegree_map n == candidates put n assert len nodes == len sorted_nodes topological sorted nodes doesn t have same length input nodes sorted_nodes compatibility is_backward_compatible=False validate_partition partition NodeList - bool verify partition doesn t form dependency cycle original graph returns True valid partition False invalid partition_set = set partition outputs NodeList = node partition_set user_node node users user_node partition_set external user node need expose output outputs append user_node Perform BFS partition outputs If reaches node within partition then found cycle This function takes ownership ` root_nodes ` may modify bfs_find_cycle root_nodes NodeList - bool Set used exclude nodes have already been visited If node has been visited node all its children have been checked cycles visited NodeSet = set Start ` root_nodes ` traverse through toward child nodes their connected sub-graph Nodes ` visited ` won t added ` queue ` again queue NodeList = root_nodes while queue current = queue pop visited add current current partition_set Started partition s ` output ` nodes reached another node partition Cycle True user_node current users user_node visited continue queue append user_node ` root_nodes ` don t cause cycle False Use all output nodes roots traverse graph check cycles bfs_find_cycle outputs False True compatibility is_backward_compatible=False fuse_as_graphmodule gm GraphModule nodes NodeList module_name str partition_lookup_table _Optional dict Node _Optional int = None always_return_tuple bool = False - tuple GraphModule tuple Node tuple Node Fuse nodes graph_module into GraphModule Args gm GraphModule target graph_module nodes List Node list nodes ` gm ` fuse where node must topologically sorted module_name name fused GraphModule partition_lookup_table Optional Dict Node None optional dict nodes speed up lookup always_return_tuple bool whether always tuple even there only one output Returns fused_gm GraphModule fused graph module where its node copy ` nodes ` ` gm ` original_inputs Tuple Node input nodes ` nodes ` original ` gm ` original_outputs Tuple Node consumer nodes ` nodes ` original ` gm ` assumption nodes already sorted topo order node nodes assert node graph owning_module gm f node doesn t belong passed graph module gm _get_name assert node _erased f node has been removed owning graph assert node gm graph _find_nodes_lookup_table f node found graph module gm _get_name validates partition doesn t introduce dependency circles graph assert validate_partition nodes Invalid partition found dependency cycles no dict partition nodes provided reconstruct nodes list reduce lookup time partition_lookup_table None partition_lookup_table = dict fromkeys nodes subgraph = Graph node_to_placeholder dict Node Node = mapping nodes old graph placeholder new graph node_map dict Node Node = mapping nodes old graph new graph handles inputs through graph node_copy s arg_transform functions remap_inputs x Node - Node x op == get_attr TODO do we really need copy get_attr node into graph do something here pass x partition_lookup_table x inside subgraph copied node node should have been copied already we copying graph topological order node_map x x node_to_placeholder x subgraph create new placeholder subgraph placeholder_node = subgraph placeholder x name type_expr=x type copy all meta fields even some fields might irrelevant placeholder node placeholder_node meta = copy copy x meta node_to_placeholder x = placeholder_node node_to_placeholder x copy nodes topological order node nodes new_node = subgraph node_copy node remap_inputs node_map node = new_node handles outputs output_mapping dict Node Node = mapping old output new outputs node nodes user_node node users user_node partition_lookup_table external user node need expose output output_mapping node = node_map node outs contain nodes new subgraph outs = tuple output_mapping values always_return_tuple always tuple even there only one output subgraph output outs If there s single output then directly otherwise tuple subgraph output outs len outs == outs lint ensure correctness subgraph lint type ignore no-untyped-call fused_gm GraphModule fused_gm _ = lift_subgraph_as_module gm subgraph comp_name= class_name=module_name sub_gm s input nodes original module original_inputs tuple Node = tuple node_to_placeholder keys sub_gm s outputs node original module original_outputs tuple Node = tuple output_mapping keys fused_gm original_inputs original_outputs compatibility is_backward_compatible=False insert_subgm gm GraphModule sub_gm GraphModule orig_inputs tuple Node orig_outputs tuple Node - GraphModule add sub_gm into gm submodule_name = sub_gm __class__ __name__ gm add_submodule submodule_name sub_gm Create call_module node main graph module_node = gm graph call_module submodule_name args=orig_inputs kwargs=None output_node = sub_gm graph output_node len orig_outputs == isinstance output_node args tuple main_remapping comp orig_outputs = module_node orig_outputs replace_all_uses_with module_node propagate_meta=True i orig_output enumerate orig_outputs Use Proxy record getitem access proxy_out = torch fx Proxy module_node i node type ignore index orig_output replace_all_uses_with proxy_out propagate_meta=True module_node meta val = tuple orig_output meta get val None orig_output orig_outputs gm compatibility is_backward_compatible=False erase_nodes gm GraphModule nodes NodeList - None erase original nodes inversed topological order node reversed nodes gm graph erase_node node compatibility is_backward_compatible=False fuse_by_partitions gm GraphModule partitions list dict Node _Optional int prefix str = fused_ always_return_tuple bool = False - GraphModule partition_id partition enumerate partitions sorted_nodes = topo_sort list partition submodule_name = prefix + str partition_id sub_gm orig_inputs orig_outputs = fuse_as_graphmodule gm sorted_nodes submodule_name partition always_return_tuple=always_return_tuple insert_subgm gm sub_gm orig_inputs orig_outputs erase_nodes gm sorted_nodes topological sort original gm newly created sub_gm legalize_graph gm gm