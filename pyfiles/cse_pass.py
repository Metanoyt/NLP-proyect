mypy allow-untyped-defs typing Any torch torch fx Graph GraphModule Node torch fx passes infra pass_base PassBase PassResult torch utils _pytree tree_flatten aten = torch ops aten stateful ops banned CSE rand_ops = aten dropout aten _fused_dropout aten _standard_gamma aten bernoulli aten multinomial aten native_dropout aten normal aten poisson aten binomial aten rrelu aten rand_like aten rand aten randint aten randn aten randperm noqa E B inplace_ops = aten add_ aten sub_ aten mul_ aten div_ aten pow_ aten lerp_ aten relu_ aten sigmoid_ aten tanh_ noqa E torch fx _compatibility compatibility is_backward_compatible=False get_CSE_banned_ops rand_ops union inplace_ops torch fx _compatibility compatibility is_backward_compatible=False CSEPass PassBase __init__ banned_ops=None This version CSE Pass aims dialect agnostic s implemented purely based connectivity between fx Node For functional dialects user would only need specify random ops ban list Warning CSE Pass cannot safely applied FX graph non-functional dialects If your dialect contains stateful operators please customized banned_ops banned_ops None banned_ops = set banned_ops = banned_ops super __init__ call graph_module GraphModule - PassResult Return new copy torch fx GraphModule CSE applied input graph Example usage torch fx experimental proxy_tensor make_fx f b = c = b+c p = CSEPass traced_graph = make_fx f torch tensor print traced_graph result = p traced_graph print result graph_module get_aten_target node hasattr node target overloadpacket node target overloadpacket node target modified = False new_graph = Graph env dict Node Node = map node old graph node new graph hash_env dict tuple torch _ops OpOverload int Node = map hash node new graph token_map dict tuple torch _ops OpOverload int dict str Any = map hash token n graph_module graph nodes The placeholder output get_attr nodes copied new graph without change do CSE away random operations n op == placeholder n op == output n op == get_attr get_aten_target n banned_ops new_node = new_graph node_copy n lambda x env x env n = new_node n op == call_function should never see n op == call_module call_method substitute args kwargs members their mapping env exists specs can used reconstruct nested list dictionaries substitute arg_list arg_list spec = tree_flatten arg_list i range len arg_list v = arg_list i isinstance v Node v env arg_list i = env v tuple arg_list spec args args_spec = substitute n args kwargs kwargs_spec = substitute n kwargs each token corresponds unique node nodes same token can substituted token = target n target args args args_spec args_spec kwargs kwargs kwargs_spec kwargs_spec hash substituted args number do hash specs because specs hashable hash_arg = hash args kwargs hash_val = n target hash_arg check node has substitute can eliminated hash_val_in_hash_env = hash_val hash_env hash_val_in_hash_env token_map hash_val == token modified = True substitution happens graph modified env n = hash_env hash_val continue new_node = new_graph node_copy n lambda x env x env n = new_node hash_val_in_hash_env hash_env hash_val = new_node token_map hash_val = token csed_gm = GraphModule graph_module new_graph PassResult csed_gm modified