Owner s module dynamo Test functions linalg module functools itertools os subprocess sys textwrap traceback unittest expectedFailure xfail skipIf skipif SkipTest numpy pytest numpy linalg linalg _multi_dot_matrix_chain_order pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests slowTest slow TEST_WITH_TORCHDYNAMO TestCase xpassIfTorchDynamo_np If we going trace through these we should use NumPy If testing eager mode we use torch _numpy TEST_WITH_TORCHDYNAMO numpy np numpy array asarray atleast_ d cdouble csingle dot double identity inf linalg matmul single swapaxes numpy linalg LinAlgError matrix_power matrix_rank multi_dot norm numpy testing assert_raises_regex HAS_LAPACK IS_WASM assert_ assert_allclose assert_almost_equal assert_array_equal assert_equal suppress_warnings torch _numpy np torch _numpy array asarray atleast_ d cdouble csingle dot double identity inf linalg matmul single swapaxes torch _numpy linalg LinAlgError matrix_power matrix_rank multi_dot norm torch _numpy testing assert_ assert_allclose assert_almost_equal assert_array_equal assert_equal suppress_warnings skip = functools partial skipif True IS_WASM = False HAS_LAPACK = False consistent_subclass out in_ For ndarray subclass input our output should have same subclass non-ndarray input gets converted ndarray type out type in_ isinstance in_ np ndarray np ndarray old_assert_almost_equal = assert_almost_equal assert_almost_equal b single_decimal= double_decimal= kw asarray dtype type single csingle decimal = single_decimal decimal = double_decimal old_assert_almost_equal b decimal=decimal kw get_real_dtype dtype single single double double csingle single cdouble double dtype get_complex_dtype dtype single csingle double cdouble csingle csingle cdouble cdouble dtype get_rtol dtype Choose safe rtol dtype single csingle e- e- used categorize tests all_tags = square nonsquare hermitian mutually exclusive generalized size- strided optional additions LinalgCase __init__ name b tags=None A bundle arguments passed test case identifying name operands b set tags filter tests tags None tags = set assert_ isinstance name str name = name = b = b tags = frozenset tags prevent shared tags check do Run function ` do ` test case expanding arguments do b tags=self tags __repr__ f LinalgCase name apply_tag tag cases Add given tag string each cases list LinalgCase objects assert tag all_tags Invalid tag case cases case tags = case tags &#124; tag cases Base test cases np random seed CASES = square test cases CASES += apply_tag square LinalgCase single array dtype=single array dtype=single LinalgCase double array dtype=double array dtype=double LinalgCase double_ array dtype=double array dtype=double LinalgCase csingle array + j + j + j + j dtype=csingle array + j + j dtype=csingle LinalgCase cdouble array + j + j + j + j dtype=cdouble array + j + j dtype=cdouble LinalgCase cdouble_ array + j + j + j + j dtype=cdouble array + j + j + j - j - j - j dtype=cdouble LinalgCase x np empty dtype=double np empty dtype=double tags= size- LinalgCase x np random rand np random rand LinalgCase x np random rand np random rand LinalgCase nonarray non-square test-cases CASES += apply_tag nonsquare LinalgCase single_nsq_ array dtype=single array dtype=single LinalgCase single_nsq_ array dtype=single array dtype=single LinalgCase double_nsq_ array dtype=double array dtype=double LinalgCase double_nsq_ array dtype=double array dtype=double LinalgCase csingle_nsq_ array + j + j - j - j + j + j dtype=csingle array + j + j dtype=csingle LinalgCase csingle_nsq_ array + j + j - j - j - j + j dtype=csingle array + j + j - j dtype=csingle LinalgCase cdouble_nsq_ array + j + j - j - j + j + j dtype=cdouble array + j + j dtype=cdouble LinalgCase cdouble_nsq_ array + j + j - j - j - j + j dtype=cdouble array + j + j - j dtype=cdouble LinalgCase cdouble_nsq_ _ array + j + j - j - j + j + j dtype=cdouble array + j + j - j - j dtype=cdouble LinalgCase cdouble_nsq_ _ array + j + j - j - j - j + j dtype=cdouble array + j + j - j - j - j - j dtype=cdouble LinalgCase x np random rand np random rand LinalgCase x np random rand np random rand LinalgCase x np random rand np random rand LinalgCase x np random rand np random rand tags= size- LinalgCase x np random rand np random rand tags= size- hermitian test-cases CASES += apply_tag hermitian LinalgCase hsingle array dtype=single None LinalgCase hdouble array dtype=double None LinalgCase hcsingle array + j - j dtype=csingle None LinalgCase hcdouble array + j - j dtype=cdouble None LinalgCase hempty np empty dtype=double None tags= size- LinalgCase hnonarray None LinalgCase matrix_b_only array None LinalgCase hmatrix_ x np random rand None Gufunc test cases _make_generalized_cases new_cases = case CASES isinstance case np ndarray continue = np stack case case case case b None b = None b = np stack case b case b case b new_case = LinalgCase case name + _tile b tags=case tags &#124; generalized new_cases append new_case = np array case reshape + case shape case b None b = None b = np array case b reshape + case b shape new_case = LinalgCase case name + _tile b tags=case tags &#124; generalized new_cases append new_case new_cases CASES += _make_generalized_cases Test different routines against above cases LinalgTestCase TEST_CASES = CASES check_cases require=None exclude=None Run func each cases all tags require none tags exclude require None require = set exclude None exclude = set case TEST_CASES filter require exclude case tags require = require continue case tags exclude continue try case check do except Exception e msg = f In test case case r \n\n msg += traceback format_exc raise AssertionError msg e LinalgSquareTestCase LinalgTestCase test_sq_cases check_cases require= square exclude= generalized size- test_empty_sq_cases check_cases require= square size- exclude= generalized LinalgNonsquareTestCase LinalgTestCase test_nonsq_cases check_cases require= nonsquare exclude= generalized size- test_empty_nonsq_cases check_cases require= nonsquare size- exclude= generalized HermitianTestCase LinalgTestCase test_herm_cases check_cases require= hermitian exclude= generalized size- test_empty_herm_cases check_cases require= hermitian size- exclude= generalized LinalgGeneralizedSquareTestCase LinalgTestCase slow test_generalized_sq_cases check_cases require= generalized square exclude= size- slow test_generalized_empty_sq_cases check_cases require= generalized square size- LinalgGeneralizedNonsquareTestCase LinalgTestCase slow test_generalized_nonsq_cases check_cases require= generalized nonsquare exclude= size- slow test_generalized_empty_nonsq_cases check_cases require= generalized nonsquare size- HermitianGeneralizedTestCase LinalgTestCase slow test_generalized_herm_cases check_cases require= generalized hermitian exclude= size- slow test_generalized_empty_herm_cases check_cases require= generalized hermitian size- exclude= none dot_generalized b = asarray ndim = ndim == b ndim matrix x matrix new_shape = shape - + b shape - ndim == b ndim + matrix x vector new_shape = shape - raise ValueError Not implemented r = np empty new_shape dtype=np common_type b c itertools product map range shape - r c = dot c b c r dot b identity_like_generalized = asarray ndim = r = np empty shape dtype=a dtype r = identity shape - r identity shape SolveCases LinalgSquareTestCase LinalgGeneralizedSquareTestCase kept apart TestSolve use testing matrices do b tags x = linalg solve b assert_almost_equal b dot_generalized x single_decimal= assert_ consistent_subclass x b instantiate_parametrized_tests TestSolve SolveCases TestCase parametrize dtype single double csingle cdouble test_types dtype x = np array dtype=dtype assert_equal linalg solve x x dtype dtype skip reason= subclass test_ _size ArraySubclass np ndarray pass Test system x matrices = np arange reshape b = np arange reshape view ArraySubclass expected = linalg solve b result = linalg solve b assert_array_equal result expected assert_ isinstance result ArraySubclass Test errors non-square only b s dimension being assert_raises linalg LinAlgError linalg solve b assert_raises ValueError linalg solve b Test broadcasting error b = np arange reshape broadcasting error assert_raises ValueError linalg solve b assert_raises ValueError linalg solve b Test zero single equations x matrices b = np arange reshape view ArraySubclass expected = linalg solve b result = linalg solve b assert_array_equal result expected assert_ isinstance result ArraySubclass b = np arange reshape assert_raises ValueError linalg solve b assert_raises ValueError linalg solve b assert_raises ValueError linalg solve b skip reason= subclass test_ _size_k test zero multiple equation K= case ArraySubclass np ndarray pass = np arange reshape b = np arange reshape view ArraySubclass expected = linalg solve b result = linalg solve b assert_array_equal result expected assert_ isinstance result ArraySubclass test both zero expected = linalg solve b result = linalg solve b assert_array_equal result expected assert_ isinstance result ArraySubclass InvCases LinalgSquareTestCase LinalgGeneralizedSquareTestCase do b tags a_inv = linalg inv assert_almost_equal dot_generalized a_inv identity_like_generalized assert_ consistent_subclass a_inv instantiate_parametrized_tests TestInv InvCases TestCase parametrize dtype single double csingle cdouble test_types dtype x = np array dtype=dtype assert_equal linalg inv x dtype dtype skip reason= subclass test_ _size Check all kinds -sized arrays work ArraySubclass np ndarray pass = np zeros dtype=np int_ view ArraySubclass res = linalg inv assert_ res dtype type np float assert_equal shape res shape assert_ isinstance res ArraySubclass = np zeros dtype=np complex view ArraySubclass res = linalg inv assert_ res dtype type np complex assert_equal shape res shape assert_ isinstance res ArraySubclass EigvalsCases LinalgSquareTestCase LinalgGeneralizedSquareTestCase do b tags ev = linalg eigvals evalues evectors = linalg eig assert_almost_equal ev evalues instantiate_parametrized_tests TestEigvals EigvalsCases TestCase parametrize dtype single double csingle cdouble test_types dtype x = np array dtype=dtype assert_equal linalg eigvals x dtype dtype x = np array - dtype=dtype assert_equal linalg eigvals x dtype get_complex_dtype dtype skip reason= subclass test_ _size Check all kinds -sized arrays work ArraySubclass np ndarray pass = np zeros dtype=np int_ view ArraySubclass res = linalg eigvals assert_ res dtype type np float assert_equal res shape This just documentation might make sense change assert_ isinstance res np ndarray = np zeros dtype=np complex view ArraySubclass res = linalg eigvals assert_ res dtype type np complex assert_equal res shape This just documentation might make sense change assert_ isinstance res np ndarray EigCases LinalgSquareTestCase LinalgGeneralizedSquareTestCase do b tags evalues evectors = linalg eig assert_allclose dot_generalized evectors np asarray evectors np asarray evalues None rtol=get_rtol evalues dtype assert_ consistent_subclass evectors instantiate_parametrized_tests TestEig EigCases TestCase parametrize dtype single double csingle cdouble test_types dtype x = np array dtype=dtype w v = np linalg eig x assert_equal w dtype dtype assert_equal v dtype dtype x = np array - dtype=dtype w v = np linalg eig x assert_equal w dtype get_complex_dtype dtype assert_equal v dtype get_complex_dtype dtype skip reason= subclass test_ _size Check all kinds -sized arrays work ArraySubclass np ndarray pass = np zeros dtype=np int_ view ArraySubclass res res_v = linalg eig assert_ res_v dtype type np float assert_ res dtype type np float assert_equal shape res_v shape assert_equal res shape This just documentation might make sense change assert_ isinstance np ndarray = np zeros dtype=np complex view ArraySubclass res res_v = linalg eig assert_ res_v dtype type np complex assert_ res dtype type np complex assert_equal shape res_v shape assert_equal res shape This just documentation might make sense change assert_ isinstance np ndarray instantiate_parametrized_tests SVDBaseTests hermitian = False parametrize dtype single double csingle cdouble test_types dtype x = np array dtype=dtype u s vh = linalg svd x assert_equal u dtype dtype assert_equal s dtype get_real_dtype dtype assert_equal vh dtype dtype s = linalg svd x compute_uv=False hermitian=self hermitian assert_equal s dtype get_real_dtype dtype SVDCases LinalgSquareTestCase LinalgGeneralizedSquareTestCase do b tags u s vt = linalg svd False assert_allclose dot_generalized np asarray u np asarray s None np asarray vt rtol=get_rtol u dtype assert_ consistent_subclass u assert_ consistent_subclass vt TestSVD SVDCases SVDBaseTests TestCase test_empty_identity Empty input should put identity matrix u vh x = np empty u s vh = linalg svd x compute_uv=True hermitian=self hermitian assert_equal u shape assert_equal vh shape assert_equal u np eye x = np empty u s vh = linalg svd x compute_uv=True hermitian=self hermitian assert_equal u shape assert_equal vh shape assert_equal vh np eye SVDHermitianCases HermitianTestCase HermitianGeneralizedTestCase do b tags u s vt = linalg svd False hermitian=True assert_allclose dot_generalized np asarray u np asarray s None np asarray vt rtol=get_rtol u dtype hermitian mat axes = list range mat ndim axes - axes - = axes - axes - np conj np transpose mat axes=axes assert_almost_equal np matmul u hermitian u np broadcast_to np eye u shape - u shape assert_almost_equal np matmul vt hermitian vt np broadcast_to np eye vt shape - vt shape assert_equal np sort s np flip s - assert_ consistent_subclass u assert_ consistent_subclass vt TestSVDHermitian SVDHermitianCases SVDBaseTests TestCase hermitian = True CondCases LinalgSquareTestCase LinalgGeneralizedSquareTestCase cond x p p None - do b tags c = asarray might matrix size- tags assert_raises LinAlgError linalg cond c +- norms s = linalg svd c compute_uv=False assert_almost_equal linalg cond s s - single_decimal= double_decimal= assert_almost_equal linalg cond s s - single_decimal= double_decimal= assert_almost_equal linalg cond - s - s single_decimal= double_decimal= Other norms cinv = np linalg inv c assert_almost_equal linalg cond abs c sum - max - abs cinv sum - max - single_decimal= double_decimal= assert_almost_equal linalg cond - abs c sum - min - abs cinv sum - min - single_decimal= double_decimal= assert_almost_equal linalg cond np inf abs c sum - max - abs cinv sum - max - single_decimal= double_decimal= assert_almost_equal linalg cond -np inf abs c sum - min - abs cinv sum - min - single_decimal= double_decimal= assert_almost_equal linalg cond fro np sqrt abs c sum - sum - abs cinv sum - sum - single_decimal= double_decimal= TestCond CondCases TestCase test_basic_nonsvd Smoketest non-svd norms A = array - assert_almost_equal linalg cond A inf assert_almost_equal linalg cond A -inf assert_almost_equal linalg cond A assert_almost_equal linalg cond A - assert_almost_equal linalg cond A fro np sqrt test_singular Singular matrices have infinite condition number positive norms negative norms shouldn t raise exceptions As = np zeros np ones p_pos = None fro p_neg = - - A p itertools product As p_pos Inversion may hit exact infinity so just check number large assert_ linalg cond A p e A p itertools product As p_neg linalg cond A p skip reason= NP_VER fails CI True run=False reason= Platform LAPACK-dependent failure see gh- test_nan nans should passed through converted infs ps = None - - fro p_pos = None fro A = np ones A = np nan p ps c = linalg cond A p assert_ isinstance c np float assert_ np isnan c A = np ones A = np nan p ps c = linalg cond A p assert_ np isnan c p p_pos assert_ c e assert_ c e assert_ np isnan c assert_ np isnan c test_stacked_singular Check behavior when only some stacked matrices singular np random seed A = np random rand A = A = p None fro - - c = linalg cond A p assert_equal c np inf assert_equal c np inf assert_ np isfinite c assert_ np isfinite c PinvCases LinalgSquareTestCase LinalgNonsquareTestCase LinalgGeneralizedSquareTestCase LinalgGeneralizedNonsquareTestCase do b tags a_ginv = linalg pinv ` a_ginv == I ` does hold singular dot = dot_generalized assert_almost_equal dot dot a_ginv single_decimal= double_decimal= assert_ consistent_subclass a_ginv TestPinv PinvCases TestCase pass PinvHermitianCases HermitianTestCase HermitianGeneralizedTestCase do b tags a_ginv = linalg pinv hermitian=True ` a_ginv == I ` does hold singular dot = dot_generalized assert_almost_equal dot dot a_ginv single_decimal= double_decimal= assert_ consistent_subclass a_ginv TestPinvHermitian PinvHermitianCases TestCase pass DetCases LinalgSquareTestCase LinalgGeneralizedSquareTestCase do b tags d = linalg det s ld = linalg slogdet asarray dtype type single double ad = asarray astype double ad = asarray astype cdouble ev = linalg eigvals ad assert_almost_equal d np prod ev axis=- assert_almost_equal s np exp ld np prod ev axis=- single_decimal= s = np atleast_ d s ld = np atleast_ d ld m = s = assert_almost_equal np abs s m assert_equal ld ~m -inf instantiate_parametrized_tests TestDet DetCases TestCase test_zero NB comment out tests type det double we zero-dim arrays assert_equal linalg det assert_equal type linalg det double assert_equal linalg det j assert_equal type linalg det j cdouble assert_equal linalg slogdet -inf assert_equal type linalg slogdet double assert_equal type linalg slogdet double assert_equal linalg slogdet j j -inf assert_equal type linalg slogdet j cdouble assert_equal type linalg slogdet j double parametrize dtype single double csingle cdouble test_types dtype x = np array dtype=dtype assert_equal np linalg det x dtype dtype ph s = np linalg slogdet x assert_equal s dtype get_real_dtype dtype assert_equal ph dtype dtype test_ _size = np zeros dtype=np complex res = linalg det assert_equal res assert_ res dtype type np complex res = linalg slogdet assert_equal res assert_ res dtype type np complex assert_ res dtype type np float = np zeros dtype=np float res = linalg det assert_equal res assert_ res dtype type np float res = linalg slogdet assert_equal res assert_ res dtype type np float assert_ res dtype type np float LstsqCases LinalgSquareTestCase LinalgNonsquareTestCase do b tags arr = np asarray m n = arr shape u s vt = linalg svd False x residuals rank sv = linalg lstsq b rcond=- m == assert_ x == all m = n assert_almost_equal b dot x single_decimal= assert_equal rank m assert_equal rank n assert_almost_equal sv sv __array_wrap__ s rank == n m n expect_resids = np asarray abs np dot x - b sum axis= expect_resids = np asarray expect_resids np asarray b ndim == expect_resids = expect_resids reshape assert_equal residuals shape expect_resids shape expect_resids = np array view type x assert_almost_equal residuals expect_resids single_decimal= assert_ np issubdtype residuals dtype np floating assert_ consistent_subclass x b assert_ consistent_subclass residuals b instantiate_parametrized_tests TestLstsq LstsqCases TestCase xpassIfTorchDynamo_np reason= Lstsq we use future default =None test_future_rcond = np array T b = np array suppress_warnings sup w = sup record FutureWarning ` rcond ` parameter will change x residuals rank s = linalg lstsq b assert_ rank == x residuals rank s = linalg lstsq b rcond=- assert_ rank == x residuals rank s = linalg lstsq b rcond=None assert_ rank == Warning should raised exactly once first command assert_ len w == parametrize m n n_rhs Intel MKL ERROR Parameter incorrect entry DLALSD test_empty_a_b m n n_rhs = np arange m n reshape m n b = np ones m n_rhs x residuals rank s = linalg lstsq b rcond=None m == assert_ x == all assert_equal x shape n n_rhs assert_equal residuals shape n_rhs m n m n n_rhs residuals exactly squared norms b s columns r = b - np dot x assert_almost_equal residuals r r sum axis=- assert_equal rank min m n assert_equal s shape min m n test_incompatible_dims use modified version docstring example x = np array y = np array - A = np vstack x np ones len x T assert_raises_regex LinAlgError Incompatible dimensions assert_raises RuntimeError LinAlgError linalg lstsq A y rcond=None xfail reason= no block skip FIXME otherwise fails setUp calling np block instantiate_parametrized_tests TestMatrixPower TestCase setUp rshft_ = np eye rshft_ = rshft_ rshft_ = rshft_ rshft_ = rshft_ rshft_all = rshft_ rshft_ rshft_ rshft_ noninv = array stacked = np block rshft_ FIXME e dtype might work future dtnoinv = object np dtype e np dtype g np dtype G parametrize dt np dtype c c bBhilefdFD test_large_power dt rshft = rshft_ astype dt assert_equal matrix_power rshft + + + rshft_ assert_equal matrix_power rshft + + + rshft_ assert_equal matrix_power rshft + + + rshft_ assert_equal matrix_power rshft + + + rshft_ parametrize dt np dtype c c bBhilefdFD test_power_is_zero dt tz M mz = matrix_power M assert_equal mz identity_like_generalized M assert_equal mz dtype M dtype mat rshft_all tz mat astype dt dt object tz stacked astype dt parametrize dt np dtype c c bBhilefdFD test_power_is_one dt tz mat mz = matrix_power mat assert_equal mz mat assert_equal mz dtype mat dtype mat rshft_all tz mat astype dt dt object tz stacked astype dt parametrize dt np dtype c c bBhilefdFD test_power_is_two dt tz mat mz = matrix_power mat mmul = matmul mat dtype = object dot assert_equal mz mmul mat mat assert_equal mz dtype mat dtype mat rshft_all tz mat astype dt dt object tz stacked astype dt parametrize dt np dtype c c bBhilefdFD test_power_is_minus_one dt tz mat invmat = matrix_power mat - mmul = matmul mat dtype = object dot assert_almost_equal mmul invmat mat identity_like_generalized mat mat rshft_all dt dtnoinv tz mat astype dt parametrize dt np dtype c c bBhilefdFD test_exceptions_bad_power dt mat = rshft_ astype dt assert_raises TypeError matrix_power mat assert_raises TypeError matrix_power mat parametrize dt np dtype c c bBhilefdFD test_exceptions_non_square dt assert_raises LinAlgError matrix_power np array dt assert_raises LinAlgError matrix_power np array dt assert_raises LinAlgError matrix_power np ones dt skipif IS_WASM reason= fp errors don t work wasm parametrize dt np dtype c c bBhilefdFD test_exceptions_not_invertible dt dt dtnoinv mat = noninv astype dt assert_raises LinAlgError matrix_power mat - TestEigvalshCases HermitianTestCase HermitianGeneralizedTestCase do b tags pytest xfail reason= sort complex note eigenvalue arrays returned eig must sorted since their order isn t guaranteed ev = linalg eigvalsh L evalues evectors = linalg eig evalues sort axis=- assert_allclose ev evalues rtol=get_rtol ev dtype ev = linalg eigvalsh U assert_allclose ev evalues rtol=get_rtol ev dtype instantiate_parametrized_tests TestEigvalsh TestCase parametrize dtype single double csingle cdouble test_types dtype x = np array dtype=dtype w = np linalg eigvalsh x assert_equal w dtype get_real_dtype dtype test_invalid x = np array dtype=np float assert_raises RuntimeError ValueError np linalg eigvalsh x UPLO= lrong assert_raises RuntimeError ValueError np linalg eigvalsh x lower assert_raises RuntimeError ValueError np linalg eigvalsh x upper test_UPLO Klo = np array dtype=np double Kup = np array dtype=np double tgt = np array - dtype=np double rtol = get_rtol np double Check default L w = np linalg eigvalsh Klo assert_allclose w tgt rtol=rtol Check L w = np linalg eigvalsh Klo UPLO= L assert_allclose w tgt rtol=rtol Check l w = np linalg eigvalsh Klo UPLO= l assert_allclose w tgt rtol=rtol Check U w = np linalg eigvalsh Kup UPLO= U assert_allclose w tgt rtol=rtol Check u w = np linalg eigvalsh Kup UPLO= u assert_allclose w tgt rtol=rtol test_ _size Check all kinds -sized arrays work ArraySubclass np ndarray pass = np zeros dtype=np int_ view ArraySubclass res = linalg eigvalsh assert_ res dtype type np float assert_equal res shape This just documentation might make sense change assert_ isinstance res np ndarray = np zeros dtype=np complex view ArraySubclass res = linalg eigvalsh assert_ res dtype type np float assert_equal res shape This just documentation might make sense change assert_ isinstance res np ndarray TestEighCases HermitianTestCase HermitianGeneralizedTestCase do b tags pytest xfail reason= sort complex note eigenvalue arrays returned eig must sorted since their order isn t guaranteed ev evc = linalg eigh evalues evectors = linalg eig evalues sort axis=- assert_almost_equal ev evalues assert_allclose dot_generalized evc np asarray ev None np asarray evc rtol=get_rtol ev dtype ev evc = linalg eigh U assert_almost_equal ev evalues assert_allclose dot_generalized evc np asarray ev None np asarray evc rtol=get_rtol ev dtype err_msg=repr instantiate_parametrized_tests TestEigh TestCase parametrize dtype single double csingle cdouble test_types dtype x = np array dtype=dtype w v = np linalg eigh x assert_equal w dtype get_real_dtype dtype assert_equal v dtype dtype test_invalid x = np array dtype=np float assert_raises RuntimeError ValueError np linalg eigh x UPLO= lrong assert_raises RuntimeError ValueError np linalg eigh x lower assert_raises RuntimeError ValueError np linalg eigh x upper test_UPLO Klo = np array dtype=np double Kup = np array dtype=np double tgt = np array - dtype=np double rtol = get_rtol np double Check default L w v = np linalg eigh Klo assert_allclose w tgt rtol=rtol Check L w v = np linalg eigh Klo UPLO= L assert_allclose w tgt rtol=rtol Check l w v = np linalg eigh Klo UPLO= l assert_allclose w tgt rtol=rtol Check U w v = np linalg eigh Kup UPLO= U assert_allclose w tgt rtol=rtol Check u w v = np linalg eigh Kup UPLO= u assert_allclose w tgt rtol=rtol test_ _size Check all kinds -sized arrays work ArraySubclass np ndarray pass = np zeros dtype=np int_ view ArraySubclass res res_v = linalg eigh assert_ res_v dtype type np float assert_ res dtype type np float assert_equal shape res_v shape assert_equal res shape This just documentation might make sense change assert_ isinstance np ndarray = np zeros dtype=np complex view ArraySubclass res res_v = linalg eigh assert_ res_v dtype type np complex assert_ res dtype type np float assert_equal shape res_v shape assert_equal res shape This just documentation might make sense change assert_ isinstance np ndarray _TestNormBase dt = None dec = None staticmethod check_dtype x res issubclass x dtype type np inexact assert_equal res dtype x real dtype For integer input don t have test float precision output assert_ issubclass res dtype type np floating _TestNormGeneral _TestNormBase test_empty assert_equal norm assert_equal norm array dtype=self dt assert_equal norm atleast_ d array dtype=self dt test_vector_return_type = np array exact_types = Bbhil np typecodes AllInteger inexact_types = efdFD np typecodes AllFloat all_types = exact_types + inexact_types each_type all_types = astype each_type each_type == np dtype float FIXME move looping parametrize add decorators= xfail pytest xfail float float = float raise SkipTest float float = float = norm -np inf check_dtype assert_almost_equal suppress_warnings sup sup filter RuntimeWarning divide zero encountered = norm - check_dtype assert_almost_equal = norm check_dtype assert_almost_equal = norm check_dtype assert_almost_equal = norm check_dtype assert_almost_equal dtype type dtype type = norm check_dtype assert_almost_equal dtype type dtype type = norm np inf check_dtype assert_almost_equal test_vector = b = - - - - c = - - _test v np testing assert_almost_equal norm v decimal=self dec np testing assert_almost_equal norm v inf decimal=self dec np testing assert_almost_equal norm v -inf decimal=self dec np testing assert_almost_equal norm v decimal=self dec np testing assert_almost_equal norm v - decimal=self dec np testing assert_almost_equal norm v decimal=self dec np testing assert_almost_equal norm v - - decimal=self dec np testing assert_almost_equal norm v decimal=self dec v b c _test v v array dtype=self dt array b dtype=self dt array c dtype=self dt _test v test_axis Vector norms Compare use ` axis ` computing norm each row column separately A = array dtype=self dt order None - np inf -np inf expected = norm A k ord=order k range A shape assert_almost_equal norm A ord=order axis= expected expected = norm A k ord=order k range A shape assert_almost_equal norm A ord=order axis= expected Matrix norms B = np arange dtype=self dt reshape nd = B ndim order None - - np inf -np inf fro axis itertools combinations range -nd nd row_axis col_axis = axis row_axis row_axis += nd col_axis col_axis += nd row_axis == col_axis assert_raises RuntimeError ValueError norm B ord=order axis=axis n = norm B ord=order axis=axis The logic using k_index only works nd = This has changed nd increased k_index = nd - row_axis + col_axis row_axis col_axis expected = norm B take k axis=k_index ord=order k range B shape k_index expected = norm B take k axis=k_index T ord=order k range B shape k_index assert_almost_equal n expected test_keepdims A = np arange dtype=self dt reshape allclose_err = order axis = shape_err = Shape mismatch found expected order= axis= check order=None axis=None case expected = norm A ord=None axis=None found = norm A ord=None axis=None keepdims=True assert_allclose np squeeze found expected err_msg=allclose_err format None None expected_shape = assert_ found shape == expected_shape shape_err format found shape expected_shape None None Vector norms order None - np inf -np inf k range A ndim expected = norm A ord=order axis=k found = norm A ord=order axis=k keepdims=True assert_allclose np squeeze found expected err_msg=allclose_err format order k expected_shape = list A shape expected_shape k = expected_shape = tuple expected_shape assert_ found shape == expected_shape shape_err format found shape expected_shape order k Matrix norms order None - - np inf -np inf fro nuc k itertools permutations range A ndim expected = norm A ord=order axis=k found = norm A ord=order axis=k keepdims=True assert_allclose np squeeze found expected err_msg=allclose_err format order k expected_shape = list A shape expected_shape k = expected_shape k = expected_shape = tuple expected_shape assert_ found shape == expected_shape shape_err format found shape expected_shape order k _TestNorm D _TestNormBase Define part d arrays separately so we can subclass run tests using np matrix matrixlib tests test_matrix_linalg test_matrix_empty assert_equal norm np array dtype=self dt test_matrix_return_type = np array exact_types = Bbhil np typecodes AllInteger float complex float complex types only types allowed ` linalg ` which performs matrix operations used within ` norm ` inexact_types = fdFD all_types = exact_types + inexact_types each_type all_types = astype each_type = norm -np inf check_dtype assert_almost_equal suppress_warnings sup sup filter RuntimeWarning divide zero encountered = norm - check_dtype assert_almost_equal = norm check_dtype assert_almost_equal = norm check_dtype assert_almost_equal = norm - check_dtype assert_almost_equal = norm np inf check_dtype assert_almost_equal = norm fro check_dtype assert_almost_equal = norm nuc check_dtype Lower bar needed support low precision floats They end up being off th place np testing assert_almost_equal decimal= test_matrix_ x A = np array dtype=self dt assert_almost_equal norm A assert_almost_equal norm A fro assert_almost_equal norm A nuc assert_almost_equal norm A inf assert_almost_equal norm A -inf assert_almost_equal norm A assert_almost_equal norm A - assert_almost_equal norm A assert_almost_equal norm A - assert_raises RuntimeError ValueError norm A nofro assert_raises RuntimeError ValueError norm A - assert_raises RuntimeError ValueError norm A test_matrix_ x This test has been added because x example happened have equal nuclear norm induced -norm The scaling factor accommodates absolute tolerance used assert_almost_equal A = np array dtype=self dt assert_almost_equal norm A assert_almost_equal norm A fro assert_almost_equal norm A nuc assert_almost_equal norm A inf assert_almost_equal norm A -inf assert_almost_equal norm A assert_almost_equal norm A - assert_almost_equal norm A assert_almost_equal norm A - test_bad_args Check bad arguments raise appropriate exceptions A = np array dtype=self dt B = np arange dtype=self dt reshape Using ` axis= integer ` passing -D array implies vector norms being computed so also using ` ord= fro ` ` ord= nuc ` any other string raises ValueError assert_raises RuntimeError ValueError norm A fro assert_raises RuntimeError ValueError norm A nuc assert_raises RuntimeError ValueError norm fro None assert_raises RuntimeError ValueError norm nuc None assert_raises RuntimeError ValueError norm test None Similarly norm should raise exception when ord any finite number other than - - when computing matrix norms order assert_raises RuntimeError ValueError norm A order None assert_raises RuntimeError ValueError norm A order assert_raises RuntimeError ValueError norm B order Invalid axis assert_raises IndexError np AxisError norm B None assert_raises IndexError np AxisError norm B None assert_raises RuntimeError ValueError norm B None _TestNorm _TestNorm D _TestNormGeneral pass TestNorm_NonSystematic TestCase test_intmin Non-regression test p-norm signed integer would previously do float cast abs wrong order x = np array - dtype=np int old_assert_almost_equal norm x ord= decimal= Separate definitions so we can use them matrix tests _TestNormDoubleBase _TestNormBase TestCase dt = np double dec = _TestNormSingleBase _TestNormBase TestCase dt = np float dec = _TestNormInt Base _TestNormBase TestCase dt = np int dec = TestNormDouble _TestNorm _TestNormDoubleBase TestCase pass TestNormSingle _TestNorm _TestNormSingleBase TestCase pass TestNormInt _TestNorm _TestNormInt Base pass TestMatrixRank TestCase test_matrix_rank Full rank matrix assert_equal matrix_rank np eye rank deficient matrix I = np eye I - - = assert_equal matrix_rank I All zeros - zero rank assert_equal matrix_rank np zeros dimension - rank unless all assert_equal matrix_rank assert_equal matrix_rank np zeros accepts array-like assert_equal matrix_rank greater than dimensions treated stacked matrices ms = np array I np eye np zeros assert_equal matrix_rank ms np array works scalar assert_equal matrix_rank test_symmetric_rank assert_equal matrix_rank np eye hermitian=True assert_equal matrix_rank np ones hermitian=True assert_equal matrix_rank np zeros hermitian=True rank deficient matrix I = np eye I - - = assert_equal matrix_rank I hermitian=True manually supplied tolerance I - - = e- assert_equal matrix_rank I hermitian=True tol= e- assert_equal matrix_rank I hermitian=True tol= e- test_reduced_rank Test matrices reduced rank rng = np random RandomState np random seed _ range Make rank deficient matrix X = np random normal size= X = X + X Assert matrix_rank detected deficiency assert_equal matrix_rank X X = X + X assert_equal matrix_rank X instantiate_parametrized_tests TestQR TestCase check_qr This test expects argument ` ` ndarray subclass ndarray inexact type a_type = type a_dtype = dtype m n = shape k = min m n mode == complete q r = linalg qr mode= complete assert_ q dtype == a_dtype assert_ r dtype == a_dtype assert_ isinstance q a_type assert_ isinstance r a_type assert_ q shape == m m assert_ r shape == m n assert_almost_equal dot q r single_decimal= assert_almost_equal dot q T conj q np eye m assert_almost_equal np triu r r mode == reduced q r = linalg qr mode= reduced assert_ q dtype == a_dtype assert_ r dtype == a_dtype assert_ isinstance q a_type assert_ isinstance r a_type assert_ q shape == m k assert_ r shape == k n assert_almost_equal dot q r single_decimal= assert_almost_equal dot q T conj q np eye k assert_almost_equal np triu r r mode == r r = linalg qr mode= r assert_ r dtype == a_dtype assert_ isinstance r a_type assert_almost_equal r r xpassIfTorchDynamo_np reason= torch does allow qr mode= raw parametrize m n test_qr_empty m n k = min m n = np empty m n check_qr h tau = np linalg qr mode= raw assert_equal h dtype np double assert_equal tau dtype np double assert_equal h shape n m assert_equal tau shape k xpassIfTorchDynamo_np reason= torch does allow qr mode= raw test_mode_raw The factorization unique varies between libraries so possible check against known values Functional testing possibility awaits exposure more functions lapack_lite Consequently test very limited scope Note results FORTRAN order hence h arrays transposed = np array dtype=np double Test double h tau = linalg qr mode= raw assert_ h dtype == np double assert_ tau dtype == np double assert_ h shape == assert_ tau shape == h tau = linalg qr T mode= raw assert_ h dtype == np double assert_ tau dtype == np double assert_ h shape == assert_ tau shape == test_mode_all_but_economic = np array b = np array dt fd m = astype dt m = b astype dt check_qr m check_qr m check_qr m T dt fd m = + j astype dt m = + j b astype dt check_qr m check_qr m check_qr m T check_qr_stacked This test expects argument ` ` ndarray subclass ndarray inexact type a_type = type a_dtype = dtype m n = shape - k = min m n mode == complete q r = linalg qr mode= complete assert_ q dtype == a_dtype assert_ r dtype == a_dtype assert_ isinstance q a_type assert_ isinstance r a_type assert_ q shape - == m m assert_ r shape - == m n assert_almost_equal matmul q r single_decimal= I_mat = np identity q shape - stack_I_mat = np broadcast_to I_mat q shape - + q shape - assert_almost_equal matmul swapaxes q - - conj q stack_I_mat assert_almost_equal np triu r r mode == reduced q r = linalg qr mode= reduced assert_ q dtype == a_dtype assert_ r dtype == a_dtype assert_ isinstance q a_type assert_ isinstance r a_type assert_ q shape - == m k assert_ r shape - == k n assert_almost_equal matmul q r single_decimal= I_mat = np identity q shape - stack_I_mat = np broadcast_to I_mat q shape - + q shape - assert_almost_equal matmul swapaxes q - - conj q stack_I_mat assert_almost_equal np triu r r mode == r r = linalg qr mode= r assert_ r dtype == a_dtype assert_ isinstance r a_type assert_almost_equal r r skipif numpy __version__ reason= NP_VER fails CI numpy parametrize size parametrize outer_size parametrize dt np single np double np csingle np cdouble test_stacked_inputs outer_size size dt A = np random normal size=outer_size + size astype dt B = np random normal size=outer_size + size astype dt check_qr_stacked A check_qr_stacked A + j B instantiate_parametrized_tests TestCholesky TestCase TODO there no other tests cholesky parametrize shape parametrize dtype np float np float np complex np complex test_basic_property shape dtype Check A = L L^H np random seed = np random randn shape np issubdtype dtype np complexfloating = + j np random randn shape t = list range len shape t - = - - = np matmul transpose t conj = np asarray dtype=dtype c = np linalg cholesky b = np matmul c c transpose t conj atol = shape np finfo dtype eps assert_allclose b atol=atol err_msg=f shape dtype \n \n c test_ _size ArraySubclass np ndarray pass = np zeros dtype=np int_ view ArraySubclass res = linalg cholesky assert_equal shape res shape assert_ res dtype type np float documentation purpose assert_ isinstance res np ndarray = np zeros dtype=np complex view ArraySubclass res = linalg cholesky assert_equal shape res shape assert_ res dtype type np complex assert_ isinstance res np ndarray TestMisc TestCase xpassIfTorchDynamo_np reason= endianness test_byteorder_check Byte order check should pass native order sys byteorder == little native = native = dtt np float np float arr = np eye dtype=dtt n_arr = arr newbyteorder native sw_arr = arr newbyteorder S byteswap assert_equal arr dtype byteorder = routine linalg inv linalg det linalg pinv Normal call res = routine arr Native = assert_array_equal res routine n_arr Swapped assert_array_equal res routine sw_arr pytest mark skipif IS_WASM reason= fp errors don t work wasm test_generalized_raise_multiloop It should raise error even error doesn t occur last iteration ufunc inner loop invertible = np array non_invertible = np array x = np zeros x = invertible x = non_invertible assert_raises np linalg LinAlgError np linalg inv x test_xerbla_override Check our xerbla has been successfully linked If default xerbla routine called which prints message stdout may may abort process depending LAPACK package XERBLA_OK = try pid = os fork except OSError AttributeError fork failed running POSIX raise SkipTest Not POSIX fork failed noqa B pid == child close i o file handles os close os close Avoid producing core files resource resource setrlimit resource RLIMIT_CORE These calls may abort try np linalg lapack_lite xerbla except ValueError pass except Exception os _exit os EX_CONFIG try = np array np linalg lapack_lite dorgqr - invalid value except ValueError e DORGQR parameter number str e success reuse error code mark success FORTRAN STOP returns success os _exit XERBLA_OK Did abort our xerbla linked os _exit os EX_CONFIG parent pid status = os wait os WEXITSTATUS status = XERBLA_OK raise SkipTest Numpy xerbla linked pytest mark skipif IS_WASM reason= Cannot start subprocess slow test_sdot_bug_ Regression test loading certain other libraries does result wrong results float linear algebra There s bug gh- OSX can trigger perhaps there also other situations which occurs Do check separate process bad_libs = PyQt QtWidgets IPython template = textwrap dedent sys before try bad_lib except ImportError sys exit after x = np ones dtype=np float sys exit np allclose x dot x bad_lib bad_libs code = template format before= numpy np after= bad_lib=bad_lib subprocess check_call sys executable -c code Swapped order code = template format after= numpy np before= bad_lib=bad_lib subprocess check_call sys executable -c code TestMultiDot TestCase test_basic_function_with_three_arguments multi_dot three arguments uses fast hand coded algorithm determine optimal order Therefore test separately A = np random random B = np random random C = np random random assert_almost_equal multi_dot A B C A dot B dot C assert_almost_equal multi_dot A B C np dot A np dot B C test_basic_function_with_two_arguments separate code path two arguments A = np random random B = np random random assert_almost_equal multi_dot A B A dot B assert_almost_equal multi_dot A B np dot A B test_basic_function_with_dynamic_programming_optimization multi_dot four more arguments uses dynamic programming optimization therefore deserve separate A = np random random B = np random random C = np random random D = np random random assert_almost_equal multi_dot A B C D A dot B dot C dot D test_vector_as_first_argument The first argument can -D A d = np random random -D B = np random random C = np random random D = np random random result should -D assert_equal multi_dot A d B C D shape test_vector_as_last_argument The last argument can -D A = np random random B = np random random C = np random random D d = np random random -D result should -D assert_equal multi_dot A B C D d shape test_vector_as_first_and_last_argument The first last arguments can -D A d = np random random -D B = np random random C = np random random D d = np random random -D result should scalar assert_equal multi_dot A d B C D d shape test_three_arguments_and_out multi_dot three arguments uses fast hand coded algorithm determine optimal order Therefore test separately A = np random random B = np random random C = np random random out = np zeros ret = multi_dot A B C out=out assert out ret assert_almost_equal out A dot B dot C assert_almost_equal out np dot A np dot B C test_two_arguments_and_out separate code path two arguments A = np random random B = np random random out = np zeros ret = multi_dot A B out=out assert out ret assert_almost_equal out A dot B assert_almost_equal out np dot A B test_dynamic_programming_optimization_and_out multi_dot four more arguments uses dynamic programming optimization therefore deserve separate test A = np random random B = np random random C = np random random D = np random random out = np zeros ret = multi_dot A B C D out=out assert out ret assert_almost_equal out A dot B dot C dot D test_dynamic_programming_logic Test dynamic programming part This test directly taken Cormen page arrays = np random random np random random np random random np random random np random random np random random m_expected = np array s_expected = np array dtype=int s_expected -= Cormen uses -based index python does s m = _multi_dot_matrix_chain_order arrays return_costs=True Only upper triangular part without diagonal interesting assert_almost_equal np triu s - np triu s_expected - assert_almost_equal np triu m np triu m_expected test_too_few_input_arrays assert_raises RuntimeError ValueError multi_dot assert_raises RuntimeError ValueError multi_dot np random random instantiate_parametrized_tests TestTensorinv TestCase parametrize arr ind np ones np ones test_non_square_handling arr ind assert_raises LinAlgError RuntimeError linalg tensorinv arr ind=ind parametrize shape ind examples docstring test_tensorinv_shape shape ind = np eye reshape shape ainv = linalg tensorinv a=a ind=ind expected = shape ind + shape ind actual = ainv shape assert_equal actual expected parametrize ind - test_tensorinv_ind_limit ind = np eye reshape assert_raises ValueError RuntimeError linalg tensorinv a=a ind=ind test_tensorinv_result mimic docstring example = np eye reshape ainv = linalg tensorinv ind= b = np ones assert_allclose np tensordot ainv b np linalg tensorsolve b instantiate_parametrized_tests TestTensorsolve TestCase parametrize axes np ones None np ones test_non_square_handling axes assert_raises LinAlgError RuntimeError b = np ones shape linalg tensorsolve b axes=axes skipif numpy __version__ reason= NP_VER fails CI numpy parametrize shape test_tensorsolve_result shape = np random randn shape b = np ones shape x = np linalg tensorsolve b assert_allclose np tensordot x axes=len x shape b TestMisc TestCase xpassIfTorchDynamo_np reason= TODO test_unsupported_commontype linalg gracefully handles unsupported type arr = np array - dtype= float assert_raises_regex TypeError unsupported linalg assert_raises TypeError linalg cholesky arr slow pytest mark xfail HAS_LAPACK run=False reason= Numpy compiled -bit BLAS LAPACK requires_memory free_bytes= e skip reason= Bad memory reports lead OOM ci testing test_blas _dot n = = np zeros n dtype=np float b = np ones dtype=np float - = c = np dot b assert_equal c - skip reason= lapack-lite specific xfail HAS_LAPACK reason= Numpy compiled -bit BLAS LAPACK test_blas _geqrf_lwork_smoketest Smoke test LAPACK geqrf lwork call -bit integers dtype = np float lapack_routine = np linalg lapack_lite dgeqrf m = + n = + lda = m Dummy arrays referenced lapack routine so don t need right size = np zeros dtype=dtype work = np zeros dtype=dtype tau = np zeros dtype=dtype Size query results = lapack_routine m n lda tau work - assert_equal results info assert_equal results m m assert_equal results n m Should result integer reasonable size lwork = int work item assert_ lwork __name__ == __main__ run_tests