copy collections abc Callable dataclasses dataclass typing Any NamedTuple Optional TYPE_CHECKING Union torch _compatibility compatibility _symbolic_trace symbolic_trace graph Graph graph_module GraphModule node Node TYPE_CHECKING passes utils matcher_with_name_node_map_utils InternalMatch __all__ = Match replace_pattern replace_pattern_with_filters ReplacedPatterns compatibility is_backward_compatible=True Match NamedTuple Node which match found anchor Node Maps nodes pattern subgraph nodes larger graph nodes_map dict Node Node compatibility is_backward_compatible=False dataclass ReplacedPatterns Node which match found anchor Node Maps nodes pattern subgraph nodes larger graph nodes_map dict Node Node List nodes added into graph replacements list Node _replace_attributes gm GraphModule replacement torch nn Module - None gm delete_all_unused_submodules isinstance replacement GraphModule replacement graph lint try_get_attr gm torch nn Module target str - Optional Any module_path _ attr_name = target rpartition try mod torch nn Module = gm get_submodule module_path except AttributeError None attr = getattr mod attr_name None attr node gm graph nodes node op == call_module node op == get_attr gm_attr = try_get_attr gm node target replacement_attr = try_get_attr replacement node target CASE This target already exists attribute our result GraphModule Whether exists ` replacement ` existing submodule takes precedence gm_attr None continue CASE The target exists attribute ` replacement ` only so we need copy over replacement_attr None new_attr = copy deepcopy replacement_attr isinstance replacement_attr torch nn Module gm add_submodule node target new_attr setattr gm node target new_attr CASE The target doesn t exist attribute ` gm ` ` replacement ` raise RuntimeError Attempted create node op node during subgraph rewriting f target node target referenced attribute does exist replacement GraphModule gm graph lint compatibility is_backward_compatible=True replace_pattern gm GraphModule pattern Union Callable GraphModule replacement Union Callable GraphModule - list Match Matches all possible non-overlapping sets operators their data dependencies ` ` pattern ` ` Graph GraphModule ` ` gm ` ` then replaces each these matched subgraphs another subgraph ` ` replacement ` ` Args ` ` gm ` ` The GraphModule wraps Graph operate ` ` pattern ` ` The subgraph match ` ` gm ` ` replacement ` ` replacement ` ` The subgraph replace ` ` pattern ` ` Returns List Match A list ` ` Match ` ` objects representing places original graph ` ` pattern ` ` matched The list empty there no matches ` ` Match ` ` defined code-block python Match NamedTuple Node which match found anchor Node Maps nodes pattern subgraph nodes larger graph nodes_map Dict Node Node Examples code-block python torch torch fx symbolic_trace subgraph_rewriter M torch nn Module __init__ - None super __init__ forward x w w m = torch cat w w sum m = torch cat w w sum x + torch max m + torch max m pattern w w torch cat w w replacement w w torch stack w w traced_module = symbolic_trace M subgraph_rewriter replace_pattern traced_module pattern replacement The above code will first match ` ` pattern ` ` ` ` forward ` ` method ` ` traced_module ` ` Pattern-matching done based use-def relationships node names For example you had ` ` p = torch cat b ` ` ` ` pattern ` ` you could match ` ` m = torch cat b ` ` original ` ` forward ` ` function despite variable names being different ` ` p ` ` vs ` ` m ` ` The ` ` ` ` statement ` ` pattern ` ` matched based its value only may may match ` ` ` ` statement larger graph In other words pattern doesn t have extend end larger graph When pattern matched will removed larger function replaced ` ` replacement ` ` If there multiple matches ` ` pattern ` ` larger function each non-overlapping match will replaced In case match overlap first found match set overlapping matches will replaced First here being defined first topological ordering Nodes use-def relationships In most cases first Node parameter appears directly after ` ` ` ` while last Node whatever function returns One important thing note parameters ` ` pattern ` ` Callable must used Callable itself parameters ` ` replacement ` ` Callable must match pattern The first rule why above code block ` ` forward ` ` function has parameters ` ` x w w ` ` ` ` pattern ` ` function only has parameters ` ` w w ` ` ` ` pattern ` ` doesn t use ` ` x ` ` so shouldn t specify ` ` x ` ` parameter As example second rule consider replacing code-block python pattern x y torch neg x + torch relu y code-block python replacement x y torch relu x In case ` ` replacement ` ` needs same number parameters ` ` pattern ` ` both ` ` x ` ` ` ` y ` ` even though parameter ` ` y ` ` isn t used ` ` replacement ` ` After calling ` ` subgraph_rewriter replace_pattern ` ` generated Python code looks like code-block python forward x w w stack_ = torch stack w w sum_ = stack_ sum stack_ = torch stack w w sum_ = stack_ sum max_ = torch max sum_ add_ = x + max_ max_ = torch max sum_ add_ = add_ + max_ add_ match_and_replacements = _replace_pattern gm pattern replacement Match anchor=m anchor nodes_map=m nodes_map m match_and_replacements Experimental API backward compatible compatibility is_backward_compatible=False replace_pattern_with_filters gm GraphModule pattern Union Callable Graph GraphModule replacement Union Callable Graph GraphModule None = None match_filters Optional list Callable InternalMatch Graph Graph bool = None ignore_literals bool = False Placed end avoid breaking backward compatibility replacement_callback Optional Callable InternalMatch Graph Graph Graph = None node_name_match str = - list ReplacedPatterns See replace_pattern documentation This function overload additional match_filter argument Args ` ` match_filters ` ` A list functions take match InternalMatch original_graph Graph pattern_graph Graph boolean indicating whether match satisfies condition See matcher_utils py definition InternalMatch ` ` replacement_callback ` ` A function takes match returns Graph used replacement This allows you construct replacement graph based match ` ` replacement_callback ` ` Node name match If empty will try match node name _replace_pattern gm pattern replacement match_filters ignore_literals replacement_callback node_name_match _replace_pattern gm GraphModule pattern Union Callable Graph GraphModule replacement Union Callable Graph GraphModule None = None match_filters Optional list Callable InternalMatch Graph Graph bool = None ignore_literals bool = False Placed end avoid breaking backward compatibility replacement_callback Optional Callable InternalMatch Graph Graph Graph = None node_name_match str = - list ReplacedPatterns torch fx passes utils matcher_utils InternalMatch SubgraphMatcher match_filters None match_filters = Get graphs ` gm ` ` pattern ` ` replacement ` original_graph Graph = gm graph isinstance pattern GraphModule pattern_graph = pattern graph isinstance pattern Graph pattern_graph = pattern pattern_graph = symbolic_trace pattern graph type ignore arg-type matcher = SubgraphMatcher pattern_graph match_output=False match_placeholder=False remove_overlapping_matches=True ignore_literals=ignore_literals _matches list InternalMatch = matcher match original_graph node_name_match=node_name_match Filter out matches don t match filter _matches = m m _matches all match_filter m original_graph pattern_graph match_filter match_filters isinstance replacement GraphModule common_replacement_graph = replacement graph isinstance replacement Graph common_replacement_graph = replacement callable replacement common_replacement_graph = symbolic_trace replacement graph assert replacement_callback None Must provide either replacement GraphModule replacement callback common_replacement_graph = None type ignore assignment As we progressively replace nodes we ll need keep track how match results should change match_changed_node dict Node Node = match_and_replacements = match _matches replacement_callback None replacement_graph = replacement_callback match original_graph pattern_graph assert common_replacement_graph None Must provide either replacement GraphModule replacement callback replacement_graph = common_replacement_graph replacement_placeholders = n n replacement_graph nodes n op == placeholder Build connecting between replacement graph s input original graph input producer node Initialize ` val_map ` mappings placeholder nodes ` replacement ` their corresponding node ` original_graph ` assert len match placeholder_nodes == len replacement_placeholders val_map dict Node Node = rn gn zip replacement_placeholders match placeholder_nodes isinstance gn Node val_map rn = match_changed_node get gn gn gn = val_map rn Update match placeholder_nodes match nodes_map node replaced gn gn_ind = match placeholder_nodes index gn match placeholder_nodes gn_ind = match_changed_node gn map_key = list match nodes_map keys list match nodes_map values index gn match nodes_map map_key = match_changed_node gn val_map rn = gn Copy replacement graph over user_nodes set Node = set n match returning_nodes user_nodes update n users first_user_node = None len user_nodes == first_user_node = None len user_nodes == first_user_node = next iter user_nodes If there multiple user nodes we need find first user node current execution order ` original_graph ` n original_graph nodes n user_nodes first_user_node = n break first_next_node = None first_user_node None no users so we insert replacement graph before first next node returning nodes next_node = None n reversed original_graph nodes n match returning_nodes first_next_node = next_node break next_node = n insert_point = first_user_node first_user_node None first_next_node assert insert_point None The insert point can t None original_graph inserting_before insert_point copied_returning_nodes = original_graph graph_copy replacement_graph val_map isinstance copied_returning_nodes Node copied_returning_nodes = copied_returning_nodes Get list nodes have been replaced into graph replacement_nodes list Node = v v val_map values v match placeholder_nodes Hook output Node replacement subgraph original Graph correct location assert len match returning_nodes == len copied_returning_nodes type ignore arg-type gn copied_node zip match returning_nodes copied_returning_nodes type ignore arg-type gn replace_all_uses_with copied_node match_changed_node gn = copied_node Remove original nodes node reversed pattern_graph nodes node op = placeholder node op = output gn = match nodes_map node gm graph erase_node gn match_and_replacements append ReplacedPatterns anchor=match anchors nodes_map=match nodes_map replacements=replacement_nodes Update passed-in GraphModule reflect new state ` original_graph ` gm recompile If ` replacement ` nn Module we ll need make sure all submodules have been copied over correctly isinstance replacement torch nn Module _replace_attributes gm replacement match_and_replacements