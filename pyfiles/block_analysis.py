collections functools textwrap typing Optional sympy sympy Expr Symbol torch utils _sympy functions FloorDiv ModularIndexing utils sympy_dot sympy_subs virtualized V BlockPatternMatcher Matches block indexing expressions _indexing_wild_signed_int = functools partial sympy Wild properties= lambda x x is_integer _indexing_wild_unsigned_int = functools partial sympy Wild properties= lambda x x is_integer x is_nonnegative classmethod get_subexpr_involving_symbol cls expr Expr symbol Symbol - Expr Given sympy expression subexpression comprised only terms involving specified symbol For example ` expr ` ` x + x + y + ` ` symbol ` ` x ` returns ` x + x ` expr = cls _preprocess expr sympy S Zero + sum term term sympy Add make_args expr symbol term free_symbols staticmethod get_slice_numels dims list Expr - list Expr Compute cumulative size each dimension s slice This proceeds last dim up second numels = collections deque sympy S One dim dims - numel = dim numels numels appendleft numel numels staticmethod _preprocess expr Expr - Expr Remove any Identity nodes e g expand x + y x + y expr expand identity=True classmethod match_mod_div_block_expr cls index Expr index_var Symbol numel Expr num_dims int - Optional tuple list Expr list Expr list Expr Matches modular indexing expressions converting them implied block dimensions strides See triton py more information index = cls _preprocess index Pattern match find strides offset wild_unsigned_int = functools partial cls _indexing_wild_unsigned_int exclude= index_var wild_signed_int = functools partial cls _indexing_wild_signed_int exclude= index_var dims list Expr = wild_unsigned_int f dim_mod idx idx range num_dims strides list Expr = wild_signed_int f stride_mod idx idx range num_dims The first dimension s index computed division The remaining computed modulo slice_numels = cls get_slice_numels dims num_dims block_index_exprs = FloorDiv index_var slice_numels + ModularIndexing index_var numel dim dim numel zip dims slice_numels Calculate linear index block indices match_expr = sympy_dot strides block_index_exprs Heuristic number dimensions high check minimum requirements met before attempting expensive full match see triton py match_mod_div_block more details In short here we check each subexpression sympy Add contains only FloorDiv ModularIndexing expressions num_dims = stride = sympy symbols stride cls=wild_signed_int denom other = sympy symbols denominator other cls=wild_unsigned_int mod_div_pattern = stride ModularIndexing index_var denom other floor_div_pattern = stride FloorDiv index_var denom first_dim_floor_div_matched = False match_failed = False arg sympy Add make_args index arg match floor_div_pattern There should only single FloorDiv index denom expression corresponding first dimension first_dim_floor_div_matched match_failed = True break first_dim_floor_div_matched = True arg match mod_div_pattern continue match_failed = True break match_failed None Pattern match match = index match match_expr match None None Provide default values unmatched dims strides dim dims dim match match dim = sympy S One stride strides stride match match stride = sympy S Zero sizevars = V graph sizevars get_match expr Expr - Expr sizevars lookup_precomputed_size match expr Replace wildcards matched expressions dims = dims + get_match dim dim dims strides = get_match stride stride strides slice_numels = cls get_slice_numels dims block_index_exprs = sympy_subs expr match expr block_index_exprs The leading dimension directly matched our expression We solve dividing range tree numel product all other dimensions We quit they known divisible assert dims match Expected match leading dimension sizevars statically_known_multiple_of numel slice_numels None dims = numel slice_numels Sanity check we can recover index matched subexpressions matched_index = sympy_dot strides block_index_exprs assert sizevars statically_known_equals New precomputed replacements may generated when ` get_match ` function above called ` index ` being matched has been updated So remove them when checking equivalence e g ps = s index= s expr matched_index=ps expr then index == matched_index sizevars remove_precomputed_replacements matched_index sizevars remove_precomputed_replacements index textwrap dedent f Invalid match Index index Matched expression matched_index dims strides block_index_exprs classmethod match_affine_block_expr cls index Expr index_var Symbol - Optional Expr Matches simple expressions form stride index returning stride index = cls _preprocess index stride = cls _indexing_wild_signed_int name= stride exclude= index_var m = index match index_var stride m None None m stride