math typing Any sympy torch torch utils _sympy value_ranges ValueRanges loop_body LoopBody utils dominated_nodes val_expressable_in_ _bits val Any - bool getattr val is_Boolean False True isinstance val sympy Expr assert val is_number val is_Integer val is_Boolean val = int val val = float val bound within mantissa isinstance val float val = val = - isinstance val int iinfo = torch iinfo torch int val = iinfo max val = iinfo min raise TypeError f Unexpected value val range_expressable_in_ _bits range ValueRanges sympy Expr - bool val_expressable_in_ _bits range lower val_expressable_in_ _bits range upper try_to_reduce_precision node Any bounds dict Any Any indirect_vars list Any indices dict Any sympy Expr replacement_vals dict Any ValueRanges sympy Expr - None downstream use node explicitly converts int float float float then s precision set chain uses we don t need consider those dominated values skip_filter node Any - bool node target == to_dtype node args torch int torch float torch float TODO - there dominated uses whose dtype does depend whether we reduce precision here e g add int int one args can reduced int without changing output precision node case hasn t shown up dominated dominated_nodes node skip_filter dominated target store output continue isinstance dominated target str set_indirect dominated target idx = int dominated target len set_indirect indirect_var = indirect_vars idx We check we can compute all indices s involved int index expr indices items indirect_var expr free_symbols index_val = replacement_vals index math isinf index_val lower math isinf index_val upper all indices integers so make sure we use bounds integers instead floats TODO - sure we should doing int float casts while tracing might interfere sympy index_val_int = ValueRanges sympy Expr int index_val lower int index_val upper range_expressable_in_ _bits index_val_int range_expressable_in_ _bits bounds dominated args = list node args args = torch int node args = tuple args indexing_dtype_strength_reduction loop_body LoopBody - None Performs Value Range Analysis LoopBody s fx graph reduce precision intermediaries int int bv = loop_body bounds int _dtype_nodes = node node loop_body get_nodes node target == to_dtype node args == torch int node bv unbounded_vars int _dtype_nodes bounds = bv get_bounds TODO - dominated node one to_dtype expressible int we should short circuit another to_dtype node node also dominates node int _dtype_nodes try_to_reduce_precision node bounds loop_body indirect_vars loop_body indexing_exprs bv replacement_vals