mypy allow-untyped-defs __future__ annotations collections dataclasses itertools pprint typing Any Optional Protocol TYPE_CHECKING sympy torch torch fx experimental symbolic_shapes free_unbacked_symbols torch utils _ordered_set OrderedSet config utils _align align cache_on_self CachedMethod IndentedBuffer virtualized V wrapper AllocateLine BufferLike FreeIfNotReusedLine MemoryPlanningLine NullLine ReuseLine TYPE_CHECKING collections abc Iterable dataclasses dataclass LiveRange A range where given tensor live Begin end both counters representing points program grouped memory operations Begin inclusive end exclusive Invariant begin = end begin float int &#124; + -inf end float int &#124; + -inf contains other LiveRange Is other entirely within begin = other begin other end = end join other LiveRange Combine two ranges using union operation LiveRange min begin other begin max end other end __len__ end - begin LiveRanges A collection LiveRange regions allowing non-contiguous live regions Invariant LiveRanges ranges sorted order non-overlapping __init__ ranges Iterable LiveRange ranges = sorted ranges key=lambda x x begin ranges = ranges r ranges assert ranges - begin = r begin ranges - end = r begin ranges - = LiveRange join ranges - r ranges append r overlaps other LiveRanges Check any pair ranges other overlap left = collections deque ranges right = collections deque other ranges while left right left begin right begin left right = right left assert left begin = right begin left end right begin True left popleft False property begin ranges begin property end ranges - end __repr__ f __class__ __name__ join map repr ranges AllocationTreeNode Abstract base nodes allocation pool allocate block Allocation is_last bool - bool Try assign block memory location bool Return True assignment made False get_live_ranges - LiveRanges Aggregate LiveRanges all objects below tree raise NotImplementedError get_size_hint - int Number bytes used example inputs raise NotImplementedError get_symbolic_size - sympy Expr Number bytes needed runtime raise NotImplementedError finalize pool offset - AllocationTreeNode Called after all allocations have been made is_empty False dataclasses dataclass Allocation AllocationTreeNode Represents memory allocated given node allocation pool node BufferLike live_range LiveRange size_hint int symbolic_size sympy Expr allocated bool = False pool Optional AllocationPool = None offset Optional sympy Expr = None earliest_available Optional float = None __post_init__ - None has_unbacked_sym = False s node get_layout size free_unbacked_symbols s has_unbacked_sym = True break has_unbacked_sym earliest_available = get_live_ranges begin property device node get_device get_live_ranges LiveRanges live_range get_size_hint size_hint get_symbolic_size symbolic_size mark_allocated assert allocated allocated = True finalize pool offset assert pool None offset None pool = pool offset = offset codegen_alloc_from_pool wrapper assert pool node = node shape = tuple node get_size stride = tuple node get_stride wrapper codegen_alloc_from_pool pool name offset node get_dtype shape stride __repr__ f __class__ __name__ f node= node get_name f live_range= live_range f size_hint= size_hint f symbolic_size= symbolic_size f pool= pool name pool None f offset= offset get_earliest_available earliest_available dataclasses dataclass Empty AllocationTreeNode Placeholder represent empty space allocation pool Only exists get size_hint correct parent nodes size_hint int get_live_ranges LiveRanges get_size_hint size_hint get_symbolic_size is_empty True MemorySplitProtocol Protocol get_live_ranges CachedMethod LiveRanges get_size_hint CachedMethod int get_symbolic_size CachedMethod sympy Expr _allocate block Allocation is_last bool - bool ClearCacheOnAllocateMixin MemorySplitProtocol Helper assist caching get_live_ranges get_size_hint get_symbolic_size allocate block Allocation is_last bool is_allocated = _allocate block is_last is_allocated clear_cache is_allocated clear_cache get_live_ranges clear_cache get_size_hint clear_cache get_symbolic_size clear_cache dataclasses dataclass TemporalSplit ClearCacheOnAllocateMixin AllocationTreeNode Contains list allocations overlapping LiveRanges Invariant no pair b allocations will have get_live_ranges overlaps b get_live_ranges allocations list AllocationTreeNode _allocate block Allocation is_last bool slot_size = get_size_hint block_size = block get_size_hint is_last block_size slot_size False doesn t fit block_live = block get_live_ranges overlapping = s s allocations s get_live_ranges overlaps block_live len overlapping TODO jansel we could try harder here merging overlapping space False len overlapping == overlapping allocate block is_last block mark_allocated len allocations == isinstance allocations - Empty allocations pop slot_size == block_size perfect fit allocations append block slot_size block_size allocations append SpatialSplit create block slot_size - block_size grow allocation assert is_last allocations = SpatialSplit create block_size - slot_size allocations block True cache_on_self get_live_ranges - LiveRanges LiveRanges itertools chain from_iterable x get_live_ranges ranges x allocations cache_on_self get_size_hint - int allocations max x get_size_hint x allocations cache_on_self get_symbolic_size - sympy Expr allocations type ignore return-value sympy Max x get_symbolic_size x allocations is_empty len allocations == allocations is_empty finalize pool offset allocations = block finalize pool offset block allocations clear_cache len allocations == allocations dataclasses dataclass SpatialSplit ClearCacheOnAllocateMixin AllocationTreeNode Contains two allocations left right do overlap space Right will allocated immediately after left memory left TemporalSplit right TemporalSplit staticmethod create left extra_space assert isinstance left AllocationTreeNode assert isinstance extra_space int extra_space = SpatialSplit TemporalSplit left TemporalSplit Empty extra_space _allocate block Allocation is_last bool left allocate block False right allocate block is_last cache_on_self get_live_ranges LiveRanges itertools chain left get_live_ranges ranges right get_live_ranges ranges cache_on_self get_size_hint - int _align left get_size_hint + right get_size_hint cache_on_self get_symbolic_size - sympy Expr align left get_symbolic_size + right get_symbolic_size finalize pool offset left = left finalize pool offset right = right finalize pool offset + align left get_symbolic_size clear_cache right is_empty left dataclasses dataclass AllocationPool Represents pool allocations will generated single call torch empty device torch device root TemporalSplit can_expand bool = True restrict_live_range Optional LiveRange = None name Optional str = None names_to_del list str = dataclasses field default_factory=list creation_cache dict str str = dataclasses field default_factory=dict __post_init__ - None block root allocations isinstance block Allocation update_restrict_live_range block allocate block Allocation is_last bool restrict_live_range None restrict_live_range contains block live_range False block_earliest_available = block get_earliest_available pool_begin = root get_live_ranges begin block_earliest_available block_earliest_available pool_begin False is_last = can_expand is_last root allocate block is_last update_restrict_live_range block True is_last allocate_at_end block False update_restrict_live_range block Allocation block_earliest_available = block get_earliest_available restrict_live_range None restrict_live_range = LiveRange block_earliest_available float inf restrict_live_range = LiveRange min restrict_live_range begin block_earliest_available restrict_live_range end allocate_at_end block block mark_allocated root = TemporalSplit SpatialSplit root TemporalSplit block update_restrict_live_range block True finalize name assert name name = name names_to_del append name root finalize codegen_create wrapper code IndentedBuffer assert name nbytes = root get_symbolic_size block root allocations isinstance block Allocation nbytes == block get_symbolic_size node = block node code writeline wrapper make_allocation name device=self device dtype=node get_dtype shape=tuple node get_size stride=tuple node get_stride code writeline wrapper make_allocation name device=self device dtype=torch uint shape= nbytes stride= codegen_destroy wrapper code IndentedBuffer code writeline wrapper make_free_by_names names_to_del __eq__ other other __hash__ id dataclasses dataclass AllocationPools Collection many AllocationPool objects grouped device device_to_pools dict torch device list AllocationPool = dataclasses field default_factory=dict get_pools block block device device_to_pools device_to_pools block device = device_to_pools block device allocate block Allocation pools = get_pools block pool pools pool allocate block is_last=pool pools - everything full make new pool pools append AllocationPool block device TemporalSplit block can_expand=config memory_pool = none block mark_allocated allocate_output block Allocation Outputs get different pools so memory gets freed properly pools = get_pools block pools config memory_pool outputs combined pools - allocate_at_end block create new pool block mark_allocated pools append AllocationPool block device TemporalSplit block can_expand=config memory_pool == combined finalize Called end allocation process i pool enumerate itertools chain from_iterable device_to_pools values pool finalize f pool i pprint pool itertools chain from_iterable device_to_pools values print print pool name print pool root get_live_ranges pprint pprint pool root BufferGroup Due inplace reuse allocated buffer can have many names This tracks these collections buffers sharing underlying memory __init__ node BufferLike node = node names = node get_name is_output = False allocation Optional Allocation = None live_range = LiveRange float inf -float inf update_usage timestep int Expand live_range include timestep live_range = LiveRange min timestep live_range begin max timestep live_range end sym_nbytes node get_layout storage_size node get_dtype itemsize make_allocation assert allocation multiple allocations assert isinstance live_range begin int live ranges computed nbytes = sym_nbytes For now fallback value will used we encounter unbacked SymInt The longer-term plan have size_hint use better heuristics unbackeds which point fallback value will ignored size_hint = V graph sizevars size_hint nbytes fallback= allocation = Allocation node live_range size_hint=size_hint symbolic_size=nbytes __repr__ f __class__ __name__ names r is_output= is_output f live_range= live_range dataclasses dataclass PoolMemoryPlanningLine MemoryPlanningLine Abstract base Alloc Dealloc FromPoolLine group BufferGroup timestep Optional int = None property node group node dataclasses dataclass AllocFromPoolLine PoolMemoryPlanningLine Similar AllocationLine takes memory pool is_first_pool_usage bool = False codegen code IndentedBuffer allocation = group allocation assert allocation allocation pool pool = allocation pool name = node get_name is_first_pool_usage pool codegen_create wrapper code pool names_to_del extend group names alloc_from_pool allocation_lines_to_write = allocation codegen_alloc_from_pool wrapper code writelines allocation_lines_to_write alloc_from_pool pool creation_cache code writeline wrapper make_tensor_alias name pool creation_cache alloc_from_pool alloc pool creation_cache alloc_from_pool = name code writeline f wrapper declare name = alloc_from_pool wrapper ending dataclasses dataclass DeallocFromPoolLine PoolMemoryPlanningLine Similar FreeIfNotReusedLine takes memory pool is_last_pool_usage bool = False codegen code IndentedBuffer is_last_pool_usage assert group allocation group allocation pool group allocation pool codegen_destroy wrapper code dataclasses dataclass MemoryPlanner Coordination object run memory planning passes during wrapper codegen wrapper Any pools AllocationPools = dataclasses field default_factory=AllocationPools buffer_groups Optional list BufferGroup = None plan lines list Any - list Any Call all memory planning passes sequence lines = lines drop_removed_buffers lines convert_to_pool_lines lines compute_live_ranges lines allocate_groups mark_first_last_usage lines lines drop_removed_buffers lines Replace any memory planning lines V graph removed_buffers NullLine drop any removed buffers i line enumerate lines isinstance line AllocateLine FreeIfNotReusedLine ReuseLine line node get_name V graph removed_buffers lines i = NullLine wrapper compute_buffer_groups lines Populates buffer_groups BufferGroup objects join allocations common storage due inplace reuse into single object name_to_group = line lines isinstance line AllocateLine name = line node get_name assert name name_to_group name_to_group name = BufferGroup line node isinstance line ReuseLine old_name = line node get_name new_name = line reused_as get_name assert new_name name_to_group TODO jansel we should support reusing buffers created via ExternKernelAlloc old_name name_to_group name_to_group old_name names append new_name name_to_group new_name = name_to_group old_name outputs = OrderedSet V graph get_output_names unique_groups = id g g g name_to_group values values group unique_groups group is_output = any x outputs x group names assert buffer_groups None buffer_groups = unique_groups name_to_group convert_to_pool_lines lines Convert AllocateLine FreeIfNotReusedLine ReuseLine into their pool-based counterparts name_to_group = compute_buffer_groups lines i line enumerate lines isinstance line AllocateLine line node get_name name_to_group lines i = AllocFromPoolLine wrapper name_to_group line node get_name isinstance line FreeIfNotReusedLine assert line is_reused line node get_name name_to_group lines i = DeallocFromPoolLine wrapper name_to_group line node get_name isinstance line ReuseLine line node get_name name_to_group line delete_old = False compute_live_ranges lines Populate every BufferGroup live_ranges field based first last usage timestep = worklist = collections deque lines while worklist isinstance worklist MemoryPlanningLine timestep += while worklist isinstance worklist MemoryPlanningLine line = worklist popleft isinstance line PoolMemoryPlanningLine line group update_usage timestep line timestep = timestep worklist popleft timestep += assert buffer_groups None group buffer_groups group is_output group update_usage timestep allocate_groups Assign every allocation specific location specific AllocationPool assert config memory_pool none intermediates outputs combined assert buffer_groups None group buffer_groups group make_allocation outputs list Allocation = intermediates list Allocation = group buffer_groups assert group allocation group is_output config memory_pool = combined outputs append group allocation intermediates append group allocation block sorted outputs key=lambda x x size_hint -len x live_range pools allocate_output block block sorted intermediates key=lambda x -x size_hint -len x live_range pools allocate block pools finalize mark_first_last_usage lines Populate AllocFromPoolLine is_first_pool_usage DeallocFromPoolLine is_last_pool_usage fields so pools created destroyed seen = OrderedSet AllocationPool line lines isinstance line AllocFromPoolLine assert line group allocation pool = line group allocation pool assert pool None pool seen line is_first_pool_usage = True seen add pool seen = OrderedSet AllocationPool line reversed lines isinstance line DeallocFromPoolLine assert line group allocation pool = line group allocation pool assert pool None pool seen line is_last_pool_usage = pool root get_live_ranges end = line timestep seen add pool