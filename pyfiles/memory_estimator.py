itertools logging collections defaultdict dataclasses dataclass typing Callable torch torch fx fx torch fx experimental symbolic_shapes hint_int torch utils _ordered_set OrderedSet torch utils _pytree tree_map_only log = logging getLogger __name__ dataclass frozen=True StorageKey storage torch UntypedStorage device torch device __hash__ - int storage _cdata __eq__ other object - bool isinstance other StorageKey False storage _cdata == other storage _cdata device == other device GraphAliasTracker Tracks storage allocation usage relationships FX graph Differentiates between - Fresh allocations nodes allocate new storage views aliases - Uses nodes use storage input __init__ nodes list fx Node Map node fresh storages allocates views aliases node_to_fresh_allocations dict fx Node OrderedSet StorageKey = Map storage node originally allocated storage_to_allocator dict StorageKey fx Node = Map node all storages uses inputs node_to_storage_uses dict fx Node OrderedSet StorageKey = Map storage all nodes use storage_to_uses dict StorageKey OrderedSet fx Node = defaultdict OrderedSet Map storage last node uses storage_to_last_user dict StorageKey fx Node = Map node storages have their last use node node_to_storages_last_used dict fx Node OrderedSet StorageKey = defaultdict OrderedSet Track all output storages each node building usage graph node_to_output_storages dict fx Node OrderedSet StorageKey = First pass build storage allocations track uses node nodes Get output storages output_storages = _get_output_storages node node_to_output_storages node = output_storages Track fresh allocations fresh_allocations OrderedSet StorageKey = OrderedSet storage_key output_storages storage_key storage_to_allocator storage_to_allocator storage_key = node fresh_allocations add storage_key node_to_fresh_allocations node = fresh_allocations Track input storage uses safe because inputs already processed input_storages = _get_input_storages node node_to_storage_uses node = input_storages storage_key input_storages storage_to_uses storage_key add node Second pass find last users iterate reverse node reversed nodes input_storages = node_to_storage_uses node storage_key input_storages storage_key storage_to_last_user storage_to_last_user storage_key = node node_to_storages_last_used node add storage_key staticmethod _get_output_storages node fx Node - OrderedSet StorageKey Get all storages node s outputs Uses pytree handle arbitrary nested structures val = node meta get val val None OrderedSet storages OrderedSet StorageKey = OrderedSet collect_storage tensor torch _subclasses FakeTensor - None storages add StorageKey tensor untyped_storage tensor device Use tree_map_only handle FakeTensors nested structures tree_map_only torch _subclasses FakeTensor collect_storage val storages _get_input_storages node fx Node - OrderedSet StorageKey Get all storages node s inputs input_storages OrderedSet StorageKey = OrderedSet input_node node all_input_nodes input_storages update node_to_output_storages input_node input_storages get_fresh_allocations node fx Node - OrderedSet StorageKey Get all fresh storage allocations node views aliases node_to_fresh_allocations node get_storage_uses node fx Node - OrderedSet StorageKey Get all storages node uses inputs node_to_storage_uses node get_storages_last_used node fx Node - OrderedSet StorageKey Get storages whose last use node node_to_storages_last_used node _size_of_default num_bytes int &#124; torch SymInt - int hint_int num_bytes fallback=torch _inductor config unbacked_symint_fallback device_filter device torch device - bool device type = cpu build_memory_profile graph fx Graph is_releasable Callable fx Node bool size_of Callable int &#124; torch SymInt int &#124; None = None - list int Function estimate memory profile input FX graph Args - graph fx Graph The input FX graph which memory profile estimated - is_releasable Callable fx Node bool A function determines node s memory can released e g primal nodes cannot released - size_of Callable int &#124; torch SymInt int A function converts byte counts possibly symbolic concrete integers Returns - List int A list representing memory profile over execution graph where each entry corresponds memory usage particular point execution size_of = size_of _size_of_default nodes = list graph nodes alias_info = GraphAliasTracker nodes Build memory profile current_memory = node itertools chain graph find_nodes op= placeholder graph find_nodes op= get_attr storage_key alias_info get_fresh_allocations node device_filter storage_key device current_memory += size_of storage_key storage nbytes memory_profile = current_memory node nodes node op placeholder get_attr output continue Process allocations storage_key alias_info get_fresh_allocations node device_filter storage_key device current_memory += size_of storage_key storage nbytes memory_profile append current_memory Process deallocations storage_key alias_info get_storages_last_used node allocator = alias_info storage_to_allocator storage_key is_releasable allocator device_filter storage_key device current_memory -= size_of storage_key storage nbytes memory_profile append current_memory memory_profile get_fwd_bwd_interactions fwd_graph fx Graph bwd_graph fx Graph size_of Callable int &#124; torch SymInt int &#124; None = None - tuple int OrderedSet str Analyze interactions between forward fwd backward bwd graphs determine memory usage characteristics Args - fwd_graph fx Graph The forward graph representing forward pass - bwd_graph fx Graph The backward graph representing backward pass - size_of Callable int &#124; torch SymInt int A function converts byte counts possibly symbolic concrete integers Returns - tuple int OrderedSet str A tuple containing The baseline memory usage during backward pass accounting storages persist forward pass i e fwd output bwd input A set node names whose storage cannot released during bwd pass These include nodes use storage primals bwd input fwd output size_of = size_of _size_of_default Build alias info forward graph fwd_nodes = list fwd_graph nodes fwd_alias_info = GraphAliasTracker fwd_nodes Identify storages allocated primal placeholder nodes primal_storages OrderedSet StorageKey = OrderedSet node fwd_graph find_nodes op= placeholder node name startswith primals primal_storages update fwd_alias_info get_fresh_allocations node Get storages forward output fwd_output_node = next iter reversed fwd_graph nodes - assert fwd_output_node op == output fwd_output_storages = fwd_alias_info get_storage_uses fwd_output_node Node names should deleted during memory profile estimation bwd_graph do_not_delete OrderedSet str = OrderedSet Collect all storages backward inputs identify nodes delete bwd_input_storages OrderedSet StorageKey = OrderedSet node bwd_graph find_nodes op= placeholder node_storages = GraphAliasTracker _get_output_storages node bwd_input_storages update node_storages Check node uses primal storage node_storages primal_storages do_not_delete add node name Check node s storages forward outputs meaning s external input backward pass node_storages fwd_output_storages do_not_delete add node name Calculate baseline memory storages fwd output bwd input These storages persist throughout backward pass baseline_storages = fwd_output_storages - bwd_input_storages bwd_baseline_memory = storage_key baseline_storages storage_key device type = cpu bwd_baseline_memory += size_of storage_key storage nbytes bwd_baseline_memory do_not_delete _is_releasable n fx Node - bool Storages primals cannot released during fwd bwd pass n name startswith primals get_peak_memory fwd_graph fx Graph bwd_graph fx Graph - int fwd_peak_memory = max build_memory_profile fwd_graph _is_releasable bwd_baseline_memory bwd_do_not_delete = get_fwd_bwd_interactions fwd_graph bwd_graph _is_bwd_releasable n fx Node - bool Storages nodes bwd_do_not_delete cannot released during bwd pass _is_releasable n n name bwd_do_not_delete bwd_peak_memory = bwd_baseline_memory + max build_memory_profile bwd_graph _is_bwd_releasable max fwd_peak_memory bwd_peak_memory MemoryTracker Tracks memory usage alternative scheduling orders FX graph This enables tracking memory usage nodes scheduled different order than original graph __init__ graph fx Graph is_releasable Callable fx Node bool &#124; None = None device_filter Callable torch device bool &#124; None = None Initialize memory tracker alternative scheduling given graph Args graph FX graph track memory under alternative scheduling is_releaseable do we consider input graph release memory upon final use allocated duration graph default we assume all nodes those start primals releasable device_filter Function determine which devices track default non-CPU graph = graph nodes = list graph nodes device_filter = device_filter lambda device device type = cpu scheduled OrderedSet fx Node = OrderedSet Memory tracking using GraphAliasTracker alias_tracker = GraphAliasTracker nodes current_live_storages OrderedSet StorageKey = OrderedSet current_memory_bytes = is_releasable = _is_releasable is_releasable None is_releasable Initialize live storages placeholders get_attr nodes node nodes node op placeholder get_attr fresh_allocations = alias_tracker get_fresh_allocations node storage_key fresh_allocations device_filter storage_key device current_live_storages add storage_key current_memory_bytes += _get_storage_size storage_key peak_memory = current_memory_bytes log debug Memory tracker initialized initial memory d MB current_memory_bytes schedule_node node fx Node - None Schedule node update memory tracking new scheduling order Args node The node being scheduled potentially out original order assert node scheduled should schedule node twice scheduled add node _update_memory_for_node node get_current_memory_bytes - int Get current live memory bytes under current scheduling current_memory_bytes _get_storage_size storage_key StorageKey - int Get size storage bytes handling symbolic shapes size_bytes = storage_key storage nbytes hint_int size_bytes fallback=torch _inductor config unbacked_symint_fallback _get_storages_freed_by_node node fx Node - OrderedSet StorageKey Get storages would freed we schedule node freed_storages OrderedSet StorageKey = OrderedSet input_storages = alias_tracker get_storage_uses node storage_key input_storages device_filter storage_key device continue Invariant node uses storage must live assert storage_key current_live_storages all input storages should currently allocated is_releasable alias_tracker storage_to_allocator storage_key continue all_uses = alias_tracker storage_to_uses storage_key If no more unscheduled uses remain storage can freed all u scheduled u all_uses freed_storages add storage_key freed_storages _update_memory_for_node node fx Node - None Update memory tracking when node scheduled node op placeholder get_attr output Add fresh allocations fresh_allocations = alias_tracker get_fresh_allocations node alloc_bytes = storage_key fresh_allocations device_filter storage_key device storage_key current_live_storages size = _get_storage_size storage_key current_live_storages add storage_key current_memory_bytes += size alloc_bytes += size peak_memory = max current_memory_bytes peak_memory Remove storages no longer used storages_to_free = _get_storages_freed_by_node node freed_bytes = storage_key storages_to_free storage_key current_live_storages size = _get_storage_size storage_key current_live_storages remove storage_key current_memory_bytes -= size freed_bytes += size log debug Scheduled s memory change d allocs d frees current memory d MB node name len fresh_allocations len storages_to_free current_memory_bytes