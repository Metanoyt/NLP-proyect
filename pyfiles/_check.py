mypy allow-untyped-defs ast inspect sys textwrap warnings torch AttributeTypeIsSupportedChecker ast NodeVisitor Check ` ` __init__ ` ` method given ` ` nn Module ` ` It ensures all instance-level attributes can properly initialized Specifically we do type inference based attribute values even attribute question has already been typed using Python -style annotations ` ` torch jit annotate ` ` This means setting instance-level attribute ` ` ` ` ` ` List ` ` ` ` ` ` ` ` Dict ` ` ` ` None ` ` ` ` Optional ` ` isn t enough information us properly initialize attribute An object can walk given ` ` nn Module ` ` s AST determine meets our requirements Known limitations We can only check AST nodes certain constructs we can t ` ` eval ` ` arbitrary expressions This means function calls instantiations complex expressions resolve one empty values specified above will NOT flagged problematic We match string literals so user decides use non-standard e g ` typing List foo ` we won t catch Example code-block python M torch nn Module fn __init__ - None super __init__ x List int = forward x List int x = x The above code will pass ` ` AttributeTypeIsSupportedChecker ` ` check since we have function call ` ` __init__ ` ` However will still fail later ` ` RuntimeError ` ` Tried set nonexistent attribute x Did you forget initialize __init__ Args nn_module - The instance ` ` torch nn Module ` ` whose ` ` __init__ ` ` method we wish check check nn_module torch nn Module - None source_lines = inspect getsource nn_module __class__ __init__ Ignore comments no matter indentation is_useless_comment line line = line strip line startswith line startswith type source_lines = \n join l l source_lines split \n is_useless_comment l This AST only contains ` __init__ ` method nn Module init_ast = ast parse textwrap dedent source_lines Get items annotated body sys version_info = annotationlib class_level_annotations = list annotationlib get_annotations nn_module format=annotationlib Format FORWARDREF keys class_level_annotations = list nn_module __annotations__ keys Flag later visiting_class_level_ann = False visit init_ast _is_empty_container node ast AST ann_type str - bool ann_type == List Assigning ` ` ` List ` type gives you Node where value=List elts= ctx=Load isinstance node ast List False node elts False ann_type == Dict Assigning ` ` ` Dict ` type gives you Node where value=Dict keys= values= isinstance node ast Dict False node keys False ann_type == Optional Assigning ` None ` ` Optional ` type gives you Node where value=Constant value=None kind=None isinstance node ast Constant False node value type ignore attr-defined False True visit_Assign node Store assignment state when assigning Call Node If we re visiting Call Node right-hand side assignment statement we won t able check variable we re assigning left-hand side assignment Because we need store state visitAssign Luckily we only have do we re assigning Call Node i e ` ` torch jit annotate ` ` If we re using normal Python annotations we ll visiting AnnAssign Node which has its target built try isinstance node value ast Call node targets attr class_level_annotations visiting_class_level_ann = True except AttributeError generic_visit node visiting_class_level_ann = False visit_AnnAssign node Visit AnnAssign node ` ` nn Module ` ` s ` ` __init__ ` ` method It checks conforms our attribute annotation rules If we have local variable try node target value id = except AttributeError If we have attribute s already been annotated level node target attr class_level_annotations TODO ansley add ` Union ` once landed NB Even though ` Tuple ` container we don t want check here ` Tuple ` functions type infinite number subtypes sense you can have ` Tuple ` ` Tuple T ` ` Tuple T ` ` Tuple T T ` ` Tuple T T ` so none these subtypes can used place other Therefore assigning empty tuple ` __init__ ` CORRECTLY means variable cannot reassigned later non-empty tuple Same deal ` NamedTuple ` containers = List list Dict dict Optional If we re evaluating one specified problem types try node annotation value id containers except AttributeError To evaluate base type ` str ` ` int ` etc we would have needed get name through ` node annotation id ` instead ` node annotation value id ` Seems we re evaluating one our containers Check assigned variable empty ann_type = node annotation value id _is_empty_container node value ann_type warnings warn The TorchScript type system doesn t support instance-level annotations empty non-base types ` __init__ ` Instead either use type annotation body wrap type ` torch jit Attribute ` stacklevel= visit_Call node Determine Call node torch jit annotate __init__ Visit Call node ` ` nn Module ` ` s ` ` __init__ ` ` method determine s ` ` torch jit annotate ` ` If so see conforms our attribute annotation rules If we have attribute s already been annotated level visiting_class_level_ann If isn t call ` torch jit annotate ` try node func value value id = torch node func value attr = jit node func attr = annotate generic_visit node node func value value id = jit node func value attr = annotate generic_visit node except AttributeError Looks like we didn t even have right node structure check ` torch jit annotate ` first place generic_visit node Invariant we have ` torch jit annotate ` ` torch annotate ` call A Call Node ` torch jit annotate ` should have ` args ` list length where args represents annotation args represents actual value len node args = isinstance node args ast Subscript See notes ` visit_AnnAssign ` r e containers containers = List Dict Optional try ann_type = node args value id type ignore attr-defined except AttributeError ann_type containers Check assigned variable empty _is_empty_container node args ann_type warnings warn The TorchScript type system doesn t support instance-level annotations empty non-base types ` __init__ ` Instead either use type annotation body wrap type ` torch jit Attribute ` stacklevel=