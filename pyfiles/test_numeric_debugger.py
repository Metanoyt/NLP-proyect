Owner s oncall quantization copy unittest collections Counter packaging version torch torch ao quantization compare_results CUSTOM_KEY extract_results_from_loggers generate_numeric_debug_handle NUMERIC_DEBUG_HANDLE_KEY prepare_for_propagation_comparison torch ao quantization pt e graph_utils bfs_trace_with_node_process torch ao quantization quantize_pt e convert_pt e prepare_pt e torch ao quantization quantizer xnnpack_quantizer get_symmetric_quantization_config XNNPACKQuantizer torch export export torch testing _internal common_quantization TestHelperModules torch testing _internal common_utils IS_WINDOWS raise_on_run_directly skipIfCrossRef TestCase version parse torch __version__ = version parse torch _dynamo config cache_size_limit = unittest skipIf IS_WINDOWS Windows yet supported torch compile TestNumericDebugger TestCase _assert_each_node_has_debug_handle model - None _assert_node_has_debug_handle node assertTrue CUSTOM_KEY node meta NUMERIC_DEBUG_HANDLE_KEY node meta CUSTOM_KEY f Node node doesn t have debug handle bfs_trace_with_node_process model _assert_node_has_debug_handle _extract_debug_handles model - dict str int debug_handle_map dict str int = _extract_debug_handles_from_node node nonlocal debug_handle_map CUSTOM_KEY node meta NUMERIC_DEBUG_HANDLE_KEY node meta CUSTOM_KEY debug_handle_map str node = node meta CUSTOM_KEY NUMERIC_DEBUG_HANDLE_KEY bfs_trace_with_node_process model _extract_debug_handles_from_node debug_handle_map _extract_debug_handles_with_prev_decomp_op model - dict str int prev_decomp_op_to_debug_handle_map dict str int = _extract_debug_handles_with_prev_decomp_op_from_node node nonlocal prev_decomp_op_to_debug_handle_map CUSTOM_KEY node meta NUMERIC_DEBUG_HANDLE_KEY node meta CUSTOM_KEY prev_decomp_op = str node meta get nn_module_stack debug_handle = node meta CUSTOM_KEY NUMERIC_DEBUG_HANDLE_KEY prev_decomp_op prev_decomp_op_to_debug_handle_map prev_decomp_op_to_debug_handle_map prev_decomp_op = debug_handle assert prev_decomp_op_to_debug_handle_map prev_decomp_op == debug_handle f Node node has different debug handle debug_handle f than previous node sharing same decomp op prev_decomp_op bfs_trace_with_node_process model _extract_debug_handles_with_prev_decomp_op_from_node prev_decomp_op_to_debug_handle_map test_simple m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep _assert_each_node_has_debug_handle ep debug_handle_map = _extract_debug_handles ep assertEqual len set debug_handle_map values len debug_handle_map test_control_flow m = TestHelperModules ControlFlow example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep _assert_each_node_has_debug_handle ep debug_handle_map = _extract_debug_handles ep assertEqual len set debug_handle_map values len debug_handle_map test_quantize_pt e_preserve_handle m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep m = ep module quantizer = XNNPACKQuantizer set_global get_symmetric_quantization_config is_per_channel=False m = prepare_pt e m quantizer debug_handle_map = _extract_debug_handles m res_counter = Counter debug_handle_map values repeated_debug_handle_ids = ids repeated because we copy over id node its output observer torch ops aten conv d default torch ops aten squeeze dim torch ops aten conv d default dh_id repeated_debug_handle_ids assertEqual res_counter dh_id m example_inputs m = convert_pt e m _assert_each_node_has_debug_handle ep debug_handle_map = _extract_debug_handles m res_counter = Counter debug_handle_map values same set ids where repeated because we copy over id observer fake_quant dequantize node repeated_debug_handle_ids = dh_id repeated_debug_handle_ids assertEqual res_counter dh_id test_copy_preserve_handle m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = torch export export m example_inputs strict=True generate_numeric_debug_handle ep _assert_each_node_has_debug_handle ep debug_handle_map_ref = _extract_debug_handles ep ep_copy = copy copy ep debug_handle_map = _extract_debug_handles ep_copy _assert_each_node_has_debug_handle ep assertEqual debug_handle_map debug_handle_map_ref test_deepcopy_preserve_handle m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = torch export export m example_inputs strict=True generate_numeric_debug_handle ep debug_handle_map_ref = _extract_debug_handles ep ep_copy = copy deepcopy ep debug_handle_map = _extract_debug_handles ep_copy _assert_each_node_has_debug_handle ep assertEqual debug_handle_map debug_handle_map_ref skipIfCrossRef mlazos retracing FX graph torch function mode doesn t propagate metadata because stack trace mode torch function impl doesn t match traced graph stored lineno test_re_export_preserve_handle m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep m = ep module _assert_each_node_has_debug_handle ep debug_handle_map_ref = _extract_debug_handles ep ep_reexport = export m example_inputs strict=True _assert_each_node_has_debug_handle ep_reexport debug_handle_map = _extract_debug_handles ep_reexport assertEqual debug_handle_map debug_handle_map_ref test_run_decompositions_same_handle_id m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep _assert_each_node_has_debug_handle ep debug_handle_map_ref = _extract_debug_handles ep ep_copy = copy copy ep ep_copy = ep_copy run_decompositions _assert_each_node_has_debug_handle ep_copy debug_handle_map = _extract_debug_handles ep_copy checking map still has same ids node may change assertEqual set debug_handle_map values set debug_handle_map_ref values test_run_decompositions_map_handle_to_new_nodes test_models = TestHelperModules TwoLinearModule TestHelperModules Conv dThenConv d m test_models example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep _assert_each_node_has_debug_handle ep pre_decomp_to_debug_handle_map_ref = _extract_debug_handles_with_prev_decomp_op ep ep_copy = copy copy ep ep_copy = ep_copy run_decompositions _assert_each_node_has_debug_handle ep_copy pre_decomp_to_debug_handle_map = _extract_debug_handles_with_prev_decomp_op ep_copy checking map still has same ids node may change assertEqual pre_decomp_to_debug_handle_map pre_decomp_to_debug_handle_map_ref test_prepare_for_propagation_comparison m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep m = ep module m_logger = prepare_for_propagation_comparison m ref = m example_inputs res = m_logger example_inputs torch ao quantization pt e _numeric_debugger OutputLogger loggers = m m m_logger modules isinstance m OutputLogger assertEqual len loggers assertTrue conv d logger node_name logger loggers assertEqual res ref test_extract_results_from_loggers m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep m = ep module m_ref_logger = prepare_for_propagation_comparison m quantizer = XNNPACKQuantizer set_global get_symmetric_quantization_config is_per_channel=False m = prepare_pt e m quantizer m example_inputs m = convert_pt e m m_quant_logger = prepare_for_propagation_comparison m m_ref_logger example_inputs m_quant_logger example_inputs ref_results = extract_results_from_loggers m_ref_logger quant_results = extract_results_from_loggers m_quant_logger comparison_results = compare_results ref_results quant_results node_summary comparison_results values len node_summary results assertGreaterEqual node_summary results sqnr test_extract_results_from_loggers_list_output m = TestHelperModules Conv dWithSplit example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep m = ep module m_ref_logger = prepare_for_propagation_comparison m quantizer = XNNPACKQuantizer set_global get_symmetric_quantization_config is_per_channel=False m = prepare_pt e m quantizer m example_inputs m = convert_pt e m m_quant_logger = prepare_for_propagation_comparison m m_ref_logger example_inputs m_quant_logger example_inputs ref_results = extract_results_from_loggers m_ref_logger quant_results = extract_results_from_loggers m_quant_logger comparison_results = compare_results ref_results quant_results node_summary comparison_results values len node_summary results sqnr = node_summary results sqnr isinstance sqnr list sqnr_i sqnr assertGreaterEqual sqnr_i assertGreaterEqual sqnr test_added_node_gets_unique_id - None m = TestHelperModules Conv dThenConv d example_inputs = m example_inputs ep = export m example_inputs strict=True generate_numeric_debug_handle ep ref_handles = _extract_debug_handles ep ref_counter = Counter ref_handles values k v ref_counter items assertEqual v msg=f For handle k there v nodes handle expected only Now we have unique ids add new node into graph re-generate make sure new node gets unique id last_node = next iter reversed ep graph nodes ep graph inserting_before last_node arg = last_node args assertIsInstance arg list tuple arg = arg Add function only requires single tensor input n = ep graph call_function torch ops aten relu default args= arg arg replace_all_uses_with n lambda x x = n ep graph_module recompile Regenerate handles make sure only new relu node has new id doesn t clash any existing ids generate_numeric_debug_handle ep _assert_each_node_has_debug_handle ep handles_after_modification = _extract_debug_handles ep handles_counter = Counter handles_after_modification values name handle ref_handles items assertIn name handles_after_modification Check handle unchanged assertEqual handles_after_modification name handle Check total count unchanged ref_count = ref_counter handle after_count = handles_counter handle assertEqual after_count ref_count msg=f For handle handle there after_count nodes handle expected only ref_count Check relu specifically Avoid hardcoding handle id since may change future node ordering changes assertNotEqual handles_after_modification relu_default assertEqual handles_counter handles_after_modification relu_default __name__ == __main__ raise_on_run_directly test test_quantization py