mypy allow-untyped-defs collections importlib machinery io linecache os pickletools platform types collections defaultdict OrderedDict collections abc Callable Sequence dataclasses dataclass enum Enum importlib machinery SourceFileLoader pathlib Path typing Any cast IO Optional Union torch torch serialization location_tag normalize_storage_type torch types FileLike Storage torch utils hooks RemovableHandle _digraph DiGraph _importlib _normalize_path _mangling demangle is_mangled _package_pickler create_pickler _stdlib is_stdlib_module find_file_dependencies find_files_source_depends_on glob_group GlobGroup GlobPattern importer Importer OrderedImporter sys_importer __all__ = PackagingErrorReason EmptyMatchError PackagingError PackageExporter _gate_torchscript_serialization = True ActionHook = Callable PackageExporter str None _ModuleProviderAction Enum Represents one actions ` PackageExporter ` can take module See meth ` PackageExporter extern ` friends description what actions do INTERN = EXTERN = MOCK = DENY = Special case when module mocked PackageExporter writes out ` _mock ` module implements our mocking stubs If we re-package code we may encounter ` _mock ` module original package If we do just ignore write ` _mock ` module once REPACKAGED_MOCK_MODULE = Special case PackageImporter adds fake module ` torch_package_importer ` allows packaged code access Don t re-export SKIP = PackagingErrorReason Enum Listing different reasons dependency may fail package This enum used provide good error messages when ` PackagingError ` raised __repr__ f __class__ __name__ name IS_EXTENSION_MODULE = Module C extension module torch package supports Python modules only NO_DUNDER_FILE = Module had no __file__ defined SOURCE_FILE_NOT_FOUND = Module had __file__ we could find your filesystem DEPENDENCY_RESOLUTION_FAILED = Dependency resolution failed NO_ACTION = Module did match against any action pattern Extern mock intern DENIED = Module denied pattern MOCKED_BUT_STILL_USED = Module mocked out still being used package Please intern extern mocked modules objects supposed package dataclass _PatternInfo Holds ` PackageExporter ` -specific info about how execute matches against What action take module matches pattern action _ModuleProviderAction The value ` allow_empty ` user gave when specifying pattern allow_empty bool Whether pattern has been matched during packaging was_matched bool __init__ action allow_empty action = action allow_empty = allow_empty was_matched = False EmptyMatchError Exception This exception thrown when mock extern marked ` ` allow_empty=False ` ` matched any module during packaging PackagingError Exception This exception raised when there issue exporting package ` ` PackageExporter ` ` will attempt gather up all errors present them you once __init__ dependency_graph DiGraph debug=False Group errors reason broken dict PackagingErrorReason list str = defaultdict list module_name attrs dependency_graph nodes items error = attrs get error error None continue error == PackagingErrorReason NO_ACTION assert action attrs broken error append module_name message = io StringIO message write \n reason module_names broken items message write f reason value \n module_name module_names message write f module_name \n Print additional context s provided error_context = dependency_graph nodes module_name get error_context error_context None message write f Context error_context \n module_name _DISALLOWED_MODULES message write Note While we usually use modules python standard library f local environment ` module_name ` has lot system level access therefore can pose security risk We heavily f recommend removing ` module_name ` your packaged code However possible add extern list calling f PackageExporter extern ` module_name ` \n debug module_path = dependency_graph first_path module_name message write f A path module_name - join module_path \n debug message write \n message write Set debug=True when invoking PackageExporter visualization where broken modules coming \n Save dependency graph so tooling can get dependency_graph = dependency_graph super __init__ message getvalue PackageExporter Exporters allow you write packages code pickled Python data arbitrary binary text resources into self-contained package Imports can load code hermetic way such code loaded package rather than normal Python system This allows packaging PyTorch model code data so can run server used future transfer learning The code contained packages copied file-by-file original source when created file format specially organized zip file Future users package can unzip package edit code order perform custom modifications The importer packages ensures code module can only loaded within package except modules explicitly listed external using meth ` extern ` The file ` ` extern_modules ` ` zip archive lists all modules package externally depends This prevents implicit dependencies where package runs locally because importing locally-installed package then fails when package copied another machine When source code added package exporter can optionally scan further code dependencies ` ` dependencies=True ` ` It looks statements resolves relative references qualified module names performs action specified user See meth ` extern ` meth ` mock ` meth ` intern ` A importer will searched order find modules referenced other modules pickled objects The default module environment just uses sys_importer which searches Python environment importer Importer __init__ f FileLike importer Union Importer Sequence Importer = sys_importer debug bool = False - None Create exporter Args f The location export Can ` ` string ` ` ` ` Path ` ` object containing filename binary I O object importer If single Importer passed use search modules If sequence importers passed ` ` OrderedImporter ` ` will constructed out them debug If set True add path broken modules PackagingErrors torch _C _log_api_usage_once torch package PackageExporter debug = debug isinstance f str os PathLike f = os fspath f buffer Optional IO bytes = None byte buffer buffer = f zip_file = torch _C PyTorchFileWriter f zip_file set_min_version _written_files set str = set serialized_reduces dict int Any = A graph tracking all modules pickle objects added package dependencies between them - Each node module name pickle name looks like foo obj pkl - Each directed edge u v means u depends v - Nodes may contain metadata describe how write thing zipfile dependency_graph = DiGraph script_module_serializer = torch _C ScriptModuleSerializer zip_file storage_context = script_module_serializer storage_context These OrderedDicts compatibility RemovableHandle Generic OrderedDict type annotations present until The real type signature OrderedDict int Callable PackageExporter str None _extern_hooks OrderedDict = OrderedDict _mock_hooks OrderedDict = OrderedDict _intern_hooks OrderedDict = OrderedDict isinstance importer Importer importer = importer isinstance importer collections abc Sequence raise TypeError importer arg should Importer sequence Importers f got type importer instead importer = OrderedImporter importer patterns dict GlobGroup _PatternInfo = _unique_id = save_source_file module_name str file_or_directory str dependencies=True Adds local file system ` ` file_or_directory ` ` source package provide code ` ` module_name ` ` Args module_name str e g ` ` my_package my_subpackage ` ` code will saved provide code package file_or_directory str path file directory code When directory all python files directory recursively copied using meth ` save_source_file ` If file named ` ` __init__ py ` ` code treated package dependencies bool optional If ` ` True ` ` we scan source dependencies path = Path file_or_directory path is_dir to_save = list tuples arguments save_source_string module_path = module_name replace filename path glob py relative_path = filename relative_to path as_posix archivename = module_path + + relative_path submodule_name = None filename name == __init__ py submodule_name = archivename -len __init__ py replace is_package = True submodule_name = archivename -len py replace is_package = False we delay call save_source_string so we record all source files being provided directory structure _before_ attempting resolve dependencies source This makes sure we don t try copy over modules will just get overwritten directory blob to_save append submodule_name _read_file str filename is_package dependencies item to_save save_source_string item is_package = path name == __init__ py save_source_string module_name _read_file file_or_directory is_package dependencies get_unique_id - str Get id This id guaranteed only handed out once package ret = str _unique_id _unique_id += ret _get_dependencies src str module_name str is_package bool - list str Return all modules source code depends Dependencies found scanning source code import-like statements Arguments src The Python source code analyze dependencies module_name The name module ` ` src ` ` corresponds is_package Whether module should treated package See py meth ` save_source_string ` more info Returns A list containing modules detected direct dependencies ` ` src ` ` The items list guaranteed unique package_name = module_name is_package module_name rsplit maxsplit= try dep_pairs = find_files_source_depends_on src package_name except Exception e dependency_graph add_node module_name error=PackagingErrorReason DEPENDENCY_RESOLUTION_FAILED error_context=str e Use dict get uniquing also deterministic order dependencies = dep_module_name dep_module_obj dep_pairs handle case where someone did something like ` pack sub ` where ` sub ` submodule In case we don t have save pack just sub ensures we don t pick up additional dependencies pack However case where ` sub ` submodule object then we do have save pack dep_module_obj None possible_submodule = f dep_module_name dep_module_obj _module_exists possible_submodule dependencies possible_submodule = True we don t need save ` pack ` continue _module_exists dep_module_name dependencies dep_module_name = True list dependencies keys save_source_string module_name str src str is_package bool = False dependencies bool = True Adds ` ` src ` ` source code ` ` module_name ` ` exported package Args module_name str e g ` ` my_package my_subpackage ` ` code will saved provide code package src str The Python source code save package is_package bool optional If ` ` True ` ` module treated package Packages allowed have submodules e g ` ` my_package my_subpackage my_subsubpackage ` ` resources can saved inside them Defaults ` ` False ` ` dependencies bool optional If ` ` True ` ` we scan source dependencies dependency_graph add_node module_name source=src is_package=is_package provided=True action=_ModuleProviderAction INTERN dependencies deps = _get_dependencies src module_name is_package dep deps dependency_graph add_edge module_name dep add_dependency dep _write_source_string module_name str src str is_package bool = False Write ` ` src ` ` source code ` ` module_name ` ` zip archive Arguments otherwise same meth ` save_source_string ` extension = __init__ py is_package py filename = module_name replace + extension _write filename src _import_module module_name str try importer import_module module_name except ModuleNotFoundError is_mangled module_name raise msg = f Module found module_name Make sure PackageImporter created module present ` importer ` raise ModuleNotFoundError msg None _module_exists module_name str - bool try _import_module module_name True except Exception False _get_source_of_module module types ModuleType - Optional str filename = None spec = getattr module __spec__ None spec None loader = getattr spec loader None loader None isinstance loader SourceFileLoader try filename = loader get_filename module __name__ except ImportError pass filename None filename = getattr module __file__ None isinstance filename str filename endswith py join linecache getlines filename module __dict__ None add_dependency module_name str dependencies=True Given module add dependency graph according patterns specified user module_name dependency_graph dependency_graph nodes module_name get provided True Special case PackageImporter provides special module called ` torch_package_importer ` allows packaged modules reference their PackageImporter We don t want re-export module_name == torch_package_importer dependency_graph add_node module_name action=_ModuleProviderAction SKIP provided=True module_name == _mock dependency_graph add_node module_name action=_ModuleProviderAction REPACKAGED_MOCK_MODULE provided=True _can_implicitly_extern module_name dependency_graph add_node module_name action=_ModuleProviderAction EXTERN provided=True pattern pattern_info patterns items pattern matches module_name pattern_info was_matched = True dependency_graph add_node module_name action=pattern_info action provided=True pattern_info action == _ModuleProviderAction DENY Requiring denied module just adds error graph dependency_graph add_node module_name error=PackagingErrorReason DENIED If we interning module we need retrieve its dependencies package those well pattern_info action == _ModuleProviderAction INTERN _intern_module module_name dependencies No patterns have matched Explicitly add error dependency_graph add_node module_name error=PackagingErrorReason NO_ACTION save_module module_name str dependencies=True Save code ` ` module ` ` into package Code module resolved using ` ` importers ` ` path find module object then using its ` ` __file__ ` ` attribute find source code Args module_name str e g ` ` my_package my_subpackage ` ` code will saved provide code package dependencies bool optional If ` ` True ` ` we scan source dependencies isinstance module_name str raise TypeError save_module expects string input did you perhaps mean pass ` __name__ ` _intern_module module_name dependencies _intern_module module_name str dependencies bool Adds module dependency graph interned module along any metadata needed write out zipfile serialization time module_obj = _import_module module_name Subtle above succeeded either The module name mangled just regular The module name mangled one importers able recognize mangling Either way now safe demangle name so we don t serialize mangled version package module_name = demangle module_name Find dependencies module require them well is_package = hasattr module_obj __path__ source = _get_source_of_module module_obj source None Couldn t find source Add our dependency graph broken continue filename = getattr module_obj __file__ None error_context = None filename None packaging_error = PackagingErrorReason NO_DUNDER_FILE filename endswith tuple importlib machinery EXTENSION_SUFFIXES packaging_error = PackagingErrorReason IS_EXTENSION_MODULE packaging_error = PackagingErrorReason SOURCE_FILE_NOT_FOUND error_context = f filename filename dependency_graph add_node module_name action=_ModuleProviderAction INTERN is_package=is_package error=packaging_error error_context=error_context provided=True dependency_graph add_node module_name action=_ModuleProviderAction INTERN is_package=is_package source=source provided=True dependencies deps = _get_dependencies source module_name is_package dep deps dependency_graph add_edge module_name dep add_dependency dep save_pickle package str resource str obj Any dependencies bool = True pickle_protocol int = Save python object archive using pickle Equivalent func ` torch save ` saving into archive rather than stand-alone file Standard pickle does save code only objects If ` ` dependencies ` ` true method will also scan pickled objects which modules required reconstruct them save relevant code To able save object where ` ` type obj __name__ ` ` ` ` my_module MyObject ` ` ` ` my_module MyObject ` ` must resolve object according ` ` importer ` ` order When saving objects have previously been packaged importer s ` ` import_module ` ` method will need present ` ` importer ` ` list work Args package str The name module package resource should go e g ` ` my_package my_subpackage ` ` resource str A unique name resource used identify load obj Any The object save must picklable dependencies bool optional If ` ` True ` ` we scan source dependencies assert pickle_protocol == pickle_protocol == torch package only supports pickle protocols filename = _filename package resource Write pickle data ` obj ` data_buf = io BytesIO pickler = create_pickler data_buf importer protocol=pickle_protocol pickler persistent_id = _persistent_id pickler dump obj data_value = data_buf getvalue mocked_modules = defaultdict list name_in_dependency_graph = f package resource dependency_graph add_node name_in_dependency_graph action=_ModuleProviderAction INTERN provided=True is_pickle=True _check_mocked_error module Optional str field Optional str checks object field comes mocked module then adds pair mocked_modules which contains mocked modules paired their list mocked objects present pickle We also hold invariant first user defined rule applies module one we use assert isinstance module str assert isinstance field str _can_implicitly_extern module pattern pattern_info patterns items pattern matches module pattern_info action == _ModuleProviderAction MOCK mocked_modules module append field dependencies all_dependencies = module = None field = None memo defaultdict int str = defaultdict None memo_count = pickletools dis data_value pyrefly ignore bad-assignment opcode arg _pos pickletools genops data_value pickle_protocol == opcode name == SHORT_BINUNICODE opcode name == BINUNICODE opcode name == BINUNICODE assert isinstance arg str module = field field = arg memo memo_count = arg opcode name == LONG_BINGET opcode name == BINGET opcode name == GET assert isinstance arg int module = field field = memo get arg None opcode name == MEMOIZE memo_count += opcode name == STACK_GLOBAL module None If module passed entries preceding one continue continue assert isinstance module str module all_dependencies all_dependencies append module _check_mocked_error module field pickle_protocol == opcode name == GLOBAL global reference assert isinstance arg str module field = arg split module all_dependencies all_dependencies append module _check_mocked_error module field module_name all_dependencies dependency_graph add_edge name_in_dependency_graph module_name If object happens come mocked module then we collect these errors spit them out other errors found package exporter module_name mocked_modules assert isinstance module_name str fields = mocked_modules module_name dependency_graph add_node module_name action=_ModuleProviderAction MOCK error=PackagingErrorReason MOCKED_BUT_STILL_USED error_context=f Object s fields module ` module_name ` mocked out during packaging f being used resource - ` resource ` package ` package ` provided=True add_dependency module_name _write filename data_value save_text package str resource str text str Save text data package Args package str The name module package resource should go e g ` ` my_package my_subpackage ` ` resource str A unique name resource used identify load text str The contents save save_binary package resource text encode utf- save_binary package resource binary bytes Save raw bytes package Args package str The name module package resource should go e g ` ` my_package my_subpackage ` ` resource str A unique name resource used identify load binary str The data save filename = _filename package resource _write filename binary register_extern_hook hook ActionHook - RemovableHandle Registers extern hook exporter The hook will called each time module matches against meth ` extern ` pattern It should have following signature hook exporter PackageExporter module_name str - None Hooks will called order registration Returns ` torch utils hooks RemovableHandle ` A handle can used remove added hook calling ` ` handle remove ` ` handle = RemovableHandle _extern_hooks _extern_hooks handle id = hook handle register_mock_hook hook ActionHook - RemovableHandle Registers mock hook exporter The hook will called each time module matches against meth ` mock ` pattern It should have following signature hook exporter PackageExporter module_name str - None Hooks will called order registration Returns ` torch utils hooks RemovableHandle ` A handle can used remove added hook calling ` ` handle remove ` ` handle = RemovableHandle _mock_hooks _mock_hooks handle id = hook handle register_intern_hook hook ActionHook - RemovableHandle Registers intern hook exporter The hook will called each time module matches against meth ` intern ` pattern It should have following signature hook exporter PackageExporter module_name str - None Hooks will called order registration Returns ` torch utils hooks RemovableHandle ` A handle can used remove added hook calling ` ` handle remove ` ` handle = RemovableHandle _intern_hooks _intern_hooks handle id = hook handle intern include GlobPattern exclude GlobPattern = allow_empty bool = True Specify modules should packaged A module must match some ` ` intern ` ` pattern order included package have its dependencies processed recursively Args include Union List str str A string e g my_package my_subpackage list strings names modules externed This can also glob-style pattern described meth ` mock ` exclude Union List str str An optional pattern excludes some patterns match include string allow_empty bool An optional flag specifies whether intern modules specified call ` ` intern ` ` method must matched some module during packaging If ` ` intern ` ` module glob pattern added ` ` allow_empty=False ` ` meth ` close ` called either explicitly via ` ` __exit__ ` ` before any modules match pattern exception thrown If ` ` allow_empty=True ` ` no such exception thrown patterns GlobGroup include exclude=exclude = _PatternInfo _ModuleProviderAction INTERN allow_empty mock include GlobPattern exclude GlobPattern = allow_empty bool = True Replace some required modules mock implementation Mocked modules will fake object any attribute accessed Because we copy file-by-file dependency resolution will sometimes find files imported model files whose functionality never used e g custom serialization code training helpers Use function mock functionality out without having modify original code Args include Union List str str A string e g ` ` my_package my_subpackage ` ` list strings names modules mocked out Strings can also glob-style pattern string may match multiple modules Any required dependencies match pattern string will mocked out automatically Examples ` ` torch ` ` -- matches ` ` torch ` ` all submodules torch e g ` ` torch nn ` ` ` ` torch nn functional ` ` ` ` torch ` ` -- matches ` ` torch nn ` ` ` ` torch functional ` ` ` ` torch nn functional ` ` exclude Union List str str An optional pattern excludes some patterns match include string e g ` ` include= torch exclude= torch foo ` ` will mock all torch packages except ` ` torch foo ` ` Default ` ` ` ` allow_empty bool An optional flag specifies whether mock implementation s specified call meth ` mock ` method must matched some module during packaging If mock added ` ` allow_empty=False ` ` meth ` close ` called either explicitly via ` ` __exit__ ` ` mock has been matched module used package being exported exception thrown If ` ` allow_empty=True ` ` no such exception thrown patterns GlobGroup include exclude=exclude = _PatternInfo _ModuleProviderAction MOCK allow_empty extern include GlobPattern exclude GlobPattern = allow_empty bool = True Include ` ` module ` ` list external modules package can This will prevent dependency discovery saving package The importer will load external module directly standard system Code extern modules must also exist process loading package Args include Union List str str A string e g ` ` my_package my_subpackage ` ` list strings names modules externed This can also glob-style pattern described meth ` mock ` exclude Union List str str An optional pattern excludes some patterns match include string allow_empty bool An optional flag specifies whether extern modules specified call ` ` extern ` ` method must matched some module during packaging If extern module glob pattern added ` ` allow_empty=False ` ` meth ` close ` called either explicitly via ` ` __exit__ ` ` before any modules match pattern exception thrown If ` ` allow_empty=True ` ` no such exception thrown patterns GlobGroup include exclude=exclude = _PatternInfo _ModuleProviderAction EXTERN allow_empty deny include GlobPattern exclude GlobPattern = Blocklist modules who names match given glob patterns list modules package can If dependency any matching packages found ` PackagingError ` raised Args include Union List str str A string e g ` ` my_package my_subpackage ` ` list strings names modules externed This can also glob-style pattern described meth ` mock ` exclude Union List str str An optional pattern excludes some patterns match include string patterns GlobGroup include exclude=exclude = _PatternInfo _ModuleProviderAction DENY allow_empty=True _persistent_id obj torch is_storage obj isinstance obj torch storage TypedStorage storage Storage isinstance obj torch storage TypedStorage TODO Once we decide break serialization FC we can remove case untyped_storage = obj _untyped_storage storage_type_str = obj pickle_storage_type storage_type = getattr torch storage_type_str storage = cast Storage untyped_storage storage_numel = obj size isinstance obj torch UntypedStorage untyped_storage = obj storage = cast Storage untyped_storage storage_type = normalize_storage_type type storage storage_numel = storage nbytes raise RuntimeError f storage type recognized type obj location = location_tag storage serialize storage already written storage_present = storage_context has_storage storage storage_id = storage_context get_or_add_storage storage storage_present storage device type = cpu storage = storage cpu num_bytes = storage nbytes zip_file write_record f data storage_id storage storage num_bytes storage storage_type storage_id location storage_numel hasattr obj __reduce_package__ _gate_torchscript_serialization isinstance obj torch jit RecursiveScriptModule raise Exception noqa TRY Serializing ScriptModules directly into package beta feature To use set global ` torch package package_exporter _gate_torchscript_serialization ` ` False ` serialized_reduces get id obj None serialized_reduces id obj = reduce_package id obj obj __reduce_package__ serialized_reduces id obj None __enter__ __exit__ exc_type exc_value traceback If __exit__ called because exception raised we do attempt finalize package Instead control returned caller continue raising exception exc_type None Do bare minimum leave open buffer valid state _finalize_zip close _write filename str_or_bytes filename _written_files raise AssertionError f Tried write file filename already exists archive Please file bug _written_files add filename is_mangled filename raise AssertionError f Tried save torch package d module filename Directly saving torch package d modules allowed isinstance str_or_bytes str str_or_bytes = str_or_bytes encode utf- zip_file write_record filename str_or_bytes len str_or_bytes _validate_dependency_graph Check graph any errors inserted during dependency analysis attrs dependency_graph nodes values error attrs raise PackagingError dependency_graph debug=self debug Check all patterns which allow_empty=False have been matched least once pattern pattern_info patterns items pattern_info allow_empty pattern_info was_matched raise EmptyMatchError f Exporter did match any modules pattern which marked allow_empty=False _write_mock_file _mock py _written_files mock_file = str Path __file__ parent _mock py _write_source_string _mock _read_file mock_file is_package=False _execute_dependency_graph Takes finalized dependency graph describing how package all modules executes writing ZIP archive _validate_dependency_graph extern_modules = module_name attrs dependency_graph nodes items action = attrs action action == _ModuleProviderAction EXTERN hook _extern_hooks values hook module_name extern_modules append module_name action == _ModuleProviderAction MOCK hook _mock_hooks values hook module_name _write_mock_file is_package = hasattr _import_module module_name __path__ _write_source_string module_name _MOCK_IMPL is_package action == _ModuleProviderAction INTERN hook _intern_hooks values hook module_name The node dependency graph contains metadata tells us how intern module provided attrs raise AssertionError f Module marked ` intern ` provided module_name attrs get is_pickle True This node came save_pickle we don t need write any source continue is_package = attrs is_package source = attrs source _write_source_string module_name source is_package action == _ModuleProviderAction REPACKAGED_MOCK_MODULE _write_mock_file action == _ModuleProviderAction SKIP continue raise AssertionError f Invalid action module_name action Please report bug PyTorch extern_file_contents = \n join extern_modules + \n _write data extern_modules extern_file_contents _write_python_version Writes python version package created data python_version _write data python_version platform python_version close Write package filesystem Any calls after meth ` close ` now invalid It preferable use resource guard syntax instead PackageExporter file zip e _execute_dependency_graph _write_python_version script_module_serializer write_files _finalize_zip _finalize_zip Called very end packaging leave zipfile closed valid state del zip_file buffer buffer flush _filename package resource package_path = package replace resource = _normalize_path resource f package_path resource _can_implicitly_extern module_name str top_level_package_name = module_name partition top_level_package_name == torch top_level_package_name _DISALLOWED_MODULES is_stdlib_module top_level_package_name dependency_graph_string - str Returns digraph string representation dependencies package Returns A string representation dependencies package dependency_graph to_dot _nodes_with_action_type action Optional _ModuleProviderAction - list str result = name node_dict dependency_graph nodes items node_action = node_dict get action None node_action == action is_pickle node_dict result append name result sort result externed_modules - list str Return all modules currently externed Returns A list containing names modules which will externed package _nodes_with_action_type _ModuleProviderAction EXTERN interned_modules - list str Return all modules currently interned Returns A list containing names modules which will interned package _nodes_with_action_type _ModuleProviderAction INTERN mocked_modules - list str Return all modules currently mocked Returns A list containing names modules which will mocked package _nodes_with_action_type _ModuleProviderAction MOCK denied_modules - list str Return all modules currently denied Returns A list containing names modules which will denied package _nodes_with_action_type _ModuleProviderAction DENY get_rdeps module_name str - list str Return list all modules which depend module ` ` module_name ` ` Returns A list containing names modules which depend ` ` module_name ` ` module_name dependency_graph _pred keys list dependency_graph _pred module_name keys all_paths src str dst str - str Return dot representation subgraph has all paths src dst Returns A dot representation containing all paths src dst https graphviz org doc info lang html dependency_graph all_paths src dst even though these standard library we do allow them automatically externed since they offer lot system level access _DISALLOWED_MODULES = sys io _MOCK_IMPL = \ _mock MockedObject __getattr__ attr str MockedObject __name__ + + attr _suppress_err=True _read_file filename str - str open filename rb f b = f read b decode utf-