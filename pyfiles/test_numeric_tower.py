======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_numeric_tower py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests __TestCase = CPythonTestCase ======= END DYNAMO PATCH ======= test interactions between int float Decimal Fraction unittest random math sys operator decimal Decimal D fractions Fraction F Constants related hash implementation hash x based reduction x modulo prime _PyHASH_MODULUS _PyHASH_MODULUS = sys hash_info modulus _PyHASH_INF = sys hash_info inf DummyIntegral int Dummy Integral test conversion Rational float __mul__ other DummyIntegral super __mul__ other __rmul__ = __mul__ __truediv__ other NotImplemented __rtruediv__ = __truediv__ property numerator DummyIntegral property denominator DummyIntegral HashTest __TestCase check_equal_hash x y check both x y equal their hashes equal assertEqual hash x hash y got different hashes r r format x y assertEqual x y test_bools check_equal_hash False check_equal_hash True test_integers check equal values hash equal exact integers i range - check_equal_hash i float i check_equal_hash i D i check_equal_hash i F i current hash based reduction modulo n- some n so pay special attention numbers form n n- i range n = i - n == int float n check_equal_hash n float n check_equal_hash -n -float n check_equal_hash n D n check_equal_hash n F n check_equal_hash -n D -n check_equal_hash -n F -n n = i check_equal_hash n float n check_equal_hash -n -float n check_equal_hash n D n check_equal_hash n F n check_equal_hash -n D -n check_equal_hash -n F -n random values various sizes _ range e = random randrange n = random randrange - e e check_equal_hash n D n check_equal_hash n F n n == int float n check_equal_hash n float n test_binary_floats check floats hash equal corresponding Fractions Decimals floats distinct numerically equal should hash same check_equal_hash - zeros check_equal_hash D check_equal_hash - D check_equal_hash - D - check_equal_hash F infinities nans check_equal_hash float inf D inf check_equal_hash float -inf D -inf _ range x = random random math exp random random - check_equal_hash x D from_float x check_equal_hash x F from_float x test_complex complex numbers zero imaginary part should hash equal corresponding float test_values = - - - float inf float -inf zero - value test_values check_equal_hash value complex value zero test_decimals check Decimal instances have different representations equal values give same hash zeros = - - e e- zero zeros check_equal_hash D zero D check_equal_hash D D check_equal_hash D D check_equal_hash D - D - check_equal_hash D - D - check_equal_hash D e D check_equal_hash D e D check_equal_hash D D check_equal_hash D D check_equal_hash D D check_equal_hash D D test_fractions check special case fractions where either numerator denominator multiple _PyHASH_MODULUS assertEqual hash F _PyHASH_MODULUS _PyHASH_INF assertEqual hash F - _PyHASH_MODULUS -_PyHASH_INF assertEqual hash F _PyHASH_MODULUS assertEqual hash F -_PyHASH_MODULUS The numbers ABC doesn t enforce true division integers produces float This tests Rational __float__ method has required type conversions x = F _from_coprime_ints DummyIntegral DummyIntegral assertRaises TypeError lambda x numerator x denominator assertEqual float x test_hash_normalization Test bug encountered while changing long_hash Given objects x y should possible y s __hash__ method hash x order ensure hash x == hash y But hash x exactly equal result x __hash__ there s some internal normalization make sure result fits C long equal invalid hash value - This internal normalization must therefore change result hash x any x HalibutProxy __hash__ hash halibut __eq__ other other == halibut x = halibut HalibutProxy assertEqual len x ComparisonTest __TestCase test_mixed_comparisons ordered list distinct test values various types int float Fraction Decimal test_values = float -inf D - e - e F - - - e- True F D float F D F F e D infinity i first enumerate test_values second test_values i+ assertLess first second assertLessEqual first second assertGreater second first assertGreaterEqual second first test_complex comparisons complex special equality inequality comparisons should always succeed order comparisons should raise TypeError z = + j w = - + j v F D complex assertEqual z v assertEqual v z v F D complex assertNotEqual z v assertNotEqual v z assertNotEqual w v assertNotEqual v w v F D complex F D complex w op operator le operator lt operator ge operator gt assertRaises TypeError op z v assertRaises TypeError op v z __name__ == __main__ run_tests