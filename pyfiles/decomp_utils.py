mypy allow-untyped-defs collections abc Callable torch torch _export utils _collect_all_valid_cia_ops _collect_all_valid_cia_ops_for_aten_namespace _get_decomp_for_cia _is_aten_op __all__ = CustomDecompTable Core ATen ops Composite Implicit Autograd dispatch should excluded decomposition default The decomposition logic should eventually exclude all core-tagged CIA ops until all backends ready list allows opt-in one time PRESERVED_ATEN_CIA_OPS = torch ops aten upsample_bilinear d vec torch ops aten upsample_nearest d vec CustomDecompTable dict torch _ops OperatorBase Callable This custom dictionary specifically used handling decomp_table export The reason we need because new world you can only delete op decomp table preserve This problematic custom ops because we don t know when custom op will actually loaded dispatcher As result we need record custom ops operations until we really need materialize which when we run decomposition pass Invariants we hold All aten decomp loaded init time We materialize ALL ops when user ever reads table make more likely dispatcher picks up custom op If write operation we don t necessarily materialize We load final time during export right before calling run_decompositions __init__ super __init__ torch _decomp _core_aten_decompositions_post_autograd For aten ops we load them up beginning decomp_table = _core_aten_decompositions_post_autograd op _collect_all_valid_cia_ops_for_aten_namespace op PRESERVED_ATEN_CIA_OPS op decomp_table decomp_table op = _get_decomp_for_cia op This track pending deleted custom ops haven t been materialized yet deleted_custom_ops = set When true there shouldn t any pending operations table has_materialized = False __getitem__ key _materialize_if_needed decomp_table __getitem__ key __setitem__ key value - None decomp_table __setitem__ key value key deleted_custom_ops deleted_custom_ops remove key keys _materialize_if_needed decomp_table keys __delitem__ key - None pop key update other_dict type ignore override k v other_dict items decomp_table __setitem__ k v __missing__ key - bool __contains__ key __contains__ key - bool _materialize_if_needed decomp_table __contains__ key __len__ - int _materialize_if_needed decomp_table __len__ __iter__ _materialize_if_needed decomp_table __iter__ __reversed__ _materialize_if_needed decomp_table __reversed__ copy - CustomDecompTable new_dict = CustomDecompTable new_dict decomp_table = decomp_table copy new_dict deleted_custom_ops = deleted_custom_ops copy new_dict has_materialized = has_materialized new_dict pop args _pop_if_can key _is_aten_op key decomp_table pop key key decomp_table Even we materialized we should add deleted custom ops list so when we materialize next time we should respect user s intention deleted_custom_ops add key decomp_table pop key key deleted_custom_ops raise KeyError f key doesn t exist table deleted_custom_ops add key We would come here when user pops off something table In case we just pretend table _get_decomp_for_cia key len args == _pop_if_can args len args == try _pop_if_can args except KeyError args items _materialize_if_needed decomp_table items materialize - dict torch _ops OperatorBase Callable op _collect_all_valid_cia_ops _is_aten_op op continue op decomp_table continue op deleted_custom_ops decomp_table op = _get_decomp_for_cia op has_materialized = True deleted_custom_ops = set decomp_table _materialize_if_needed - None has_materialized materialize