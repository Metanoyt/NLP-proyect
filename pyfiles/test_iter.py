======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_iter py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils skipIfTorchDynamo run_tests __TestCase = CPythonTestCase redirect statements sys importlib abc redirect_imports = test mapping_tests test typinganndata test test_grammar test test_math test test_iter test typinganndata ann_module RedirectImportFinder importlib abc MetaPathFinder find_spec fullname path target=None Check problematic one fullname redirect_imports try Attempt standalone module name = fullname removeprefix test r = importlib import_module name Redirect module sys modules sys modules fullname = r Return module spec found module importlib util find_spec name except ImportError None None Add custom finder sys meta_path sys meta_path insert RedirectImportFinder ======= END DYNAMO PATCH ======= Test iterators sys unittest test support cpython_only test support os_helper TESTFN unlink test support check_free_after_iterating ALWAYS_EQ NEVER_EQ test support BrokenIter pickle collections abc functools contextlib builtins traceback Test result triple loop too big inline TRIPLETS = Helper classes BasicIterClass __init__ n n = n i = __next__ res = i res = n raise StopIteration i = res + res __iter__ IteratingSequenceClass __init__ n n = n __iter__ BasicIterClass n IteratorProxyClass __init__ i i = i __next__ next i __iter__ SequenceClass __init__ n n = n __getitem__ i = i n i raise IndexError SequenceProxyClass __init__ s s = s __getitem__ i s i UnlimitedSequenceClass __getitem__ i i DefaultIterClass pass NoIterClass __getitem__ i i __iter__ = None BadIterableClass __iter__ raise ZeroDivisionError CallableIterClass __init__ i = __call__ i = i i = i + i raise IndexError Emergency stop i EmptyIterClass __len__ __getitem__ i raise StopIteration Main test suite TestCase __TestCase Helper check iterator returns given sequence check_iterator seq pickle=True res = while try val = next except StopIteration break res append val assertEqual res seq Helper check loop generates given sequence check_for_loop expr seq pickle=True res = val expr res append val assertEqual res seq Helper check picklability check_pickle itorg seq proto range pickle HIGHEST_PROTOCOL + d = pickle dumps itorg proto = pickle loads d Cannot assert type equality because dict iterators unpickle list iterators assertEqual type itorg type assertTrue isinstance collections abc Iterator assertEqual list seq = pickle loads d try next except StopIteration continue d = pickle dumps proto = pickle loads d assertEqual list seq Test basic use iter function test_iter_basic check_iterator iter range list range Test iter iter x same iter x test_iter_idempotency seq = list range = iter seq = iter assertTrue Test loops over iterators work test_iter_for_loop check_for_loop iter range list range Test several independent iterators over same list test_iter_independence seq = range res = i iter seq j iter seq k iter seq res append i j k assertEqual res TRIPLETS Test triple list comprehension using iterators test_nested_comprehensions_iter seq = range res = i j k i iter seq j iter seq k iter seq assertEqual res TRIPLETS Test triple list comprehension without iterators test_nested_comprehensions_for seq = range res = i j k i seq j seq k seq assertEqual res TRIPLETS Test __iter__ loop test_iter_class_for check_for_loop IteratingSequenceClass list range Test __iter__ explicit iter test_iter_class_iter check_iterator iter IteratingSequenceClass list range Test loop sequence without __iter__ test_seq_class_for check_for_loop SequenceClass list range Test iter sequence without __iter__ test_seq_class_iter check_iterator iter SequenceClass list range test_mutating_seq_class_iter_pickle orig = SequenceClass proto range pickle HIGHEST_PROTOCOL + initial iterator itorig = iter orig d = pickle dumps itorig orig proto seq = pickle loads d seq n = assertIs type type itorig assertEqual list list range running iterator next itorig d = pickle dumps itorig orig proto seq = pickle loads d seq n = assertIs type type itorig assertEqual list list range empty iterator i range next itorig d = pickle dumps itorig orig proto seq = pickle loads d seq n = assertIs type type itorig assertEqual list list range exhausted iterator assertRaises StopIteration next itorig d = pickle dumps itorig orig proto seq = pickle loads d seq n = assertTrue isinstance collections abc Iterator assertEqual list test_mutating_seq_class_exhausted_iter = SequenceClass exhit = iter empit = iter x exhit exhaust iterator next empit exhausted n = assertEqual list exhit assertEqual list empit assertEqual list test_reduce_mutating_builtins_iter This reproducer issue where iter ` __reduce__ ` calls could lead segfault SystemError depending order C argument evaluation which undefined Backup builtins builtins_dict = builtins __dict__ orig = iter iter reversed reversed run builtin_name item sentinel=None = iter item sentinel None iter item sentinel torch _dynamo error_on_graph_break False CustomStr __init__ name iterator name = name iterator = iterator __hash__ hash name __eq__ other Here we exhaust our iterator possibly changing its ` it_seq ` pointer NULL The ` __reduce__ ` call should correctly get pointers after call list iterator other == name del required here prematurely call __eq__ hash collision old key del builtins_dict builtin_name builtins_dict CustomStr builtin_name = orig builtin_name __reduce__ types = EmptyIterClass bytes bytearray lambda tuple int GenericAlias try run_iter = functools partial run iter The returned value ` __reduce__ ` should only valid also empty ` ` exhausted during ` __eq__ ` i e xyz returns iter assertEqual run_iter xyz orig iter assertEqual run_iter orig iter _PyEval_GetBuiltin also called ` reversed ` branch listiter_reduce_general assertEqual run reversed orig reversed list range reversed case types assertEqual run_iter case orig iter finally Restore original builtins key func orig items need suppress KeyErrors case failed test deletes key without setting anything contextlib suppress KeyError del required here invoke our custom __eq__ hash collision old key del builtins_dict key builtins_dict key = func Test new_style __iter__ no next method test_new_style_iter_class torch _dynamo error_on_graph_break False IterClass object __iter__ assertRaises TypeError iter IterClass Test two-argument iter callable instance test_iter_callable check_iterator iter CallableIterClass list range pickle=True Test two-argument iter function test_iter_function spam state= i = state state = i+ i check_iterator iter spam list range pickle=False Test two-argument iter function raises StopIteration test_iter_function_stop spam state= i = state i == raise StopIteration state = i+ i check_iterator iter spam list range pickle=False test_iter_function_concealing_reentrant_exhaustion gh- Test two-argument iter function exhausts its associated iterator forgets either sentinel value raise StopIteration HAS_MORE = NO_MORE = exhaust iterator Exhaust iterator without raising StopIteration list iterator spam Touching iterator exhaust below will call spam once again so protect against recursion spam is_recursive_call NO_MORE spam is_recursive_call = True exhaust spam iterator HAS_MORE spam is_recursive_call = False spam iterator = iter spam NO_MORE assertRaises StopIteration next spam iterator Test exception propagation through function iterator test_exception_function spam state= i = state state = i+ i == raise RuntimeError i res = try x iter spam res append x except RuntimeError assertEqual res list range fail should have raised RuntimeError Test exception propagation through sequence iterator test_exception_sequence torch _dynamo error_on_graph_break False MySequenceClass SequenceClass __getitem__ i i == raise RuntimeError SequenceClass __getitem__ i res = try x MySequenceClass res append x except RuntimeError assertEqual res list range fail should have raised RuntimeError Test StopIteration __getitem__ test_stop_sequence torch _dynamo error_on_graph_break False MySequenceClass SequenceClass __getitem__ i i == raise StopIteration SequenceClass __getitem__ i check_for_loop MySequenceClass list range pickle=False Test big range test_iter_big_range check_for_loop iter range list range Test empty list test_iter_empty check_for_loop iter Test tuple test_iter_tuple check_for_loop iter list range Test range test_iter_range check_for_loop iter range list range Test string test_iter_string check_for_loop iter abcde b c d e Test directory test_iter_dict dict = i range dict i = None check_for_loop dict list dict keys Test file test_iter_file f = open TESTFN w encoding= utf- try i range f write d\n i finally f close f = open TESTFN r encoding= utf- try check_for_loop f \n \n \n \n \n pickle=False check_for_loop f pickle=False finally f close try unlink TESTFN except OSError pass Test list s use iterators test_builtin_list assertEqual list SequenceClass list range assertEqual list SequenceClass assertEqual list d = one two three assertEqual list d list d keys assertRaises TypeError list list assertRaises TypeError list f = open TESTFN w encoding= utf- try i range f write d\n i finally f close f = open TESTFN r encoding= utf- try assertEqual list f \n \n \n \n \n f seek assertEqual list f \n \n \n \n \n finally f close try unlink TESTFN except OSError pass Test tuples s use iterators test_builtin_tuple assertEqual tuple SequenceClass assertEqual tuple SequenceClass assertEqual tuple assertEqual tuple assertEqual tuple abc b c d = one two three assertEqual tuple d tuple d keys assertRaises TypeError tuple list assertRaises TypeError tuple f = open TESTFN w encoding= utf- try i range f write d\n i finally f close f = open TESTFN r encoding= utf- try assertEqual tuple f \n \n \n \n \n f seek assertEqual tuple f \n \n \n \n \n finally f close try unlink TESTFN except OSError pass Test filter s use iterators test_builtin_filter assertEqual list filter None SequenceClass list range assertEqual list filter None SequenceClass assertEqual list filter None assertEqual list filter None abc b c d = one two three assertEqual list filter None d list d keys assertRaises TypeError filter None list assertRaises TypeError filter None torch _dynamo error_on_graph_break False Boolean __init__ truth truth = truth __bool__ truth bTrue = Boolean True bFalse = Boolean False torch _dynamo error_on_graph_break False Seq __init__ args vals = args __iter__ SeqIter __init__ vals vals = vals i = __iter__ __next__ i = i i = i + i len vals vals i raise StopIteration SeqIter vals seq = Seq bTrue bFalse assertEqual list filter lambda x x seq bFalse assertEqual list filter lambda x x iter seq bFalse Test max min s use iterators test_builtin_max_min assertEqual max SequenceClass assertEqual min SequenceClass assertEqual max - assertEqual min - - d = one two three assertEqual max d two assertEqual min d one assertEqual max d values assertEqual min iter d values f = open TESTFN w encoding= utf- try f write medium line\n f write xtra large line\n f write itty-bitty line\n finally f close f = open TESTFN r encoding= utf- try assertEqual min f itty-bitty line\n f seek assertEqual max f xtra large line\n finally f close try unlink TESTFN except OSError pass Test map s use iterators test_builtin_map assertEqual list map lambda x x+ SequenceClass list range d = one two three assertEqual list map lambda k d=d k d k d list d items dkeys = list d keys expected = i len d dkeys i None i i len d dkeys i None i range f = open TESTFN w encoding= utf- try i range f write xy i + \n line i has len i+ finally f close f = open TESTFN r encoding= utf- try assertEqual list map len f list range finally f close try unlink TESTFN except OSError pass Test zip s use iterators skipIfTorchDynamo infinite loop test_builtin_zip assertEqual list zip assertEqual list zip assertEqual list zip ab b assertRaises TypeError zip None assertRaises TypeError zip range assertRaises TypeError zip range zip assertEqual list zip IteratingSequenceClass assertEqual list zip SequenceClass d = one two three assertEqual list d items list zip d d values Generate all ints starting constructor arg torch _dynamo error_on_graph_break False IntsFrom __init__ start i = start __iter__ __next__ i = i i = i+ i f = open TESTFN w encoding= utf- try f write a\n bbb\n cc\n finally f close f = open TESTFN r encoding= utf- try assertEqual list zip IntsFrom f IntsFrom - a\n - bbb\n - cc\n - finally f close try unlink TESTFN except OSError pass assertEqual list zip range i i range Classes lie about their lengths torch _dynamo error_on_graph_break False NoGuessLen __getitem__ i i = raise IndexError i Guess Len NoGuessLen __len__ Guess Len NoGuessLen __len__ lzip args list zip args assertEqual len Guess Len assertEqual len Guess Len assertEqual lzip NoGuessLen lzip range assertEqual lzip Guess Len lzip range assertEqual lzip Guess Len lzip range expected = i i i range x NoGuessLen Guess Len Guess Len y NoGuessLen Guess Len Guess Len assertEqual lzip x y expected test_unicode_join_endcase This inserts Unicode object into its argument s natural iteration rd position torch _dynamo error_on_graph_break False OhPhooey __init__ seq = iter seq i = __iter__ __next__ i = i i = i+ i == fooled you next f = open TESTFN w encoding= utf- try f write a\n + b\n + c\n finally f close f = open TESTFN r encoding= utf- Nasty string join s can t know whether unicode join needed until s seen all s s elements But case f s iterator cannot restarted So what we re testing here whether string join can manage remember everything s seen pass unicode join try got = - join OhPhooey f assertEqual got a\n - b\n - fooled you - c\n finally f close try unlink TESTFN except OSError pass Test iterators x y x y test_in_and_not_in sc IteratingSequenceClass SequenceClass i range assertIn i sc i abc - - j sc assertNotIn i sc assertIn ALWAYS_EQ IteratorProxyClass iter assertIn ALWAYS_EQ SequenceProxyClass assertNotIn ALWAYS_EQ IteratorProxyClass iter NEVER_EQ assertNotIn ALWAYS_EQ SequenceProxyClass NEVER_EQ assertIn NEVER_EQ IteratorProxyClass iter ALWAYS_EQ assertIn NEVER_EQ SequenceProxyClass ALWAYS_EQ assertRaises TypeError lambda assertRaises TypeError lambda map assertRaises ZeroDivisionError lambda BadIterableClass d = one two three j j k d assertIn k d assertNotIn k d values v d values assertIn v d values assertNotIn v d k v d items assertIn k v d items assertNotIn v k d items f = open TESTFN w encoding= utf- try f write a\n b\n c\n finally f close f = open TESTFN r encoding= utf- try chunk abc f seek assertNotIn chunk f f seek assertIn chunk + \n f finally f close try unlink TESTFN except OSError pass Test iterators operator countOf PySequence_Count test_countOf operator countOf assertEqual countOf assertEqual countOf assertEqual countOf assertEqual countOf assertRaises TypeError countOf assertRaises TypeError countOf countOf countOf d = one two three j j k d assertEqual countOf d k assertEqual countOf d values assertEqual countOf d values j assertEqual countOf d values j f = open TESTFN w encoding= utf- try f write a\n b\n c\n b\n finally f close f = open TESTFN r encoding= utf- try letter count b c d f seek assertEqual countOf f letter + \n count finally f close try unlink TESTFN except OSError pass Test iterators operator indexOf PySequence_Index test_indexOf operator indexOf assertEqual indexOf assertEqual indexOf assertEqual indexOf assertEqual indexOf assertRaises ValueError indexOf assertRaises ValueError indexOf assertEqual indexOf assertEqual indexOf assertRaises ValueError indexOf assertRaises TypeError indexOf assertRaises TypeError indexOf indexOf indexOf assertRaises ZeroDivisionError indexOf BadIterableClass f = open TESTFN w encoding= utf- try f write a\n b\n c\n d\n e\n finally f close f = open TESTFN r encoding= utf- try fiter = iter f assertEqual indexOf fiter b\n assertEqual indexOf fiter d\n assertEqual indexOf fiter e\n assertRaises ValueError indexOf fiter a\n finally f close try unlink TESTFN except OSError pass iclass = IteratingSequenceClass i range assertEqual indexOf iclass i i assertRaises ValueError indexOf iclass - Test iterators file writelines test_writelines f = open TESTFN w encoding= utf- try assertRaises TypeError f writelines None assertRaises TypeError f writelines f writelines \n \n f writelines \n \n f writelines \n None f writelines Try big chunk too torch _dynamo error_on_graph_break False Iterator __init__ start finish start = start finish = finish i = start __next__ i = finish raise StopIteration result = str i + \n i += result __iter__ Whatever __init__ start finish start = start finish = finish __iter__ Iterator start finish f writelines Whatever + f close f = open TESTFN encoding= utf- expected = str i + \n i range assertEqual list f expected finally f close try unlink TESTFN except OSError pass Test iterators RHS unpacking assignments test_unpack_iter b = assertEqual b b c = IteratingSequenceClass assertEqual b c try too many values b = IteratingSequenceClass except ValueError pass fail should have raised ValueError try enough values b c = IteratingSequenceClass except ValueError pass fail should have raised ValueError try iterable b c = len except TypeError pass fail should have raised TypeError b c = values assertEqual b c f = open TESTFN w encoding= utf- lines = a\n bb\n ccc\n try line lines f write line finally f close f = open TESTFN r encoding= utf- try b c = f assertEqual b c lines finally f close try unlink TESTFN except OSError pass b c = IteratingSequenceClass assertEqual b c cpython_only test_ref_counting_behavior torch _dynamo error_on_graph_break False C object count = __new__ cls cls count += object __new__ cls __del__ cls = __class__ assert cls count cls count -= x = C assertEqual C count del x assertEqual C count l = C C C assertEqual C count try b = iter l except ValueError pass del l assertEqual C count Make sure StopIteration sink state This tests various things weren t sink states Python plus various things always fine test_sinkstate_list This used fail = list range b = iter assertEqual list b list range extend range assertEqual list b test_sinkstate_tuple = b = iter assertEqual list b list range assertEqual list b test_sinkstate_string = abcde b = iter assertEqual list b b c d e assertEqual list b test_sinkstate_sequence This used fail = SequenceClass b = iter assertEqual list b list range n = assertEqual list b test_sinkstate_callable This used fail spam state= i = state state = i+ i == raise AssertionError shouldn t have gotten far i b = iter spam assertEqual list b list range assertEqual list b test_sinkstate_dict XXX For more thorough test see towards end http mail python org pipermail python-dev -July html = b iter keys items values b = iter assertEqual len list b assertEqual list b test_sinkstate_yield gen i range yield i b = gen assertEqual list b list range assertEqual list b test_sinkstate_range = range b = iter assertEqual list b list range assertEqual list b test_sinkstate_enumerate = range e = enumerate b = iter e assertEqual list b list zip range range assertEqual list b test_ Avoid crash when iterator deletes its next method torch _dynamo error_on_graph_break False BadIterator object __iter__ __next__ del BadIterator __next__ try i BadIterator pass except TypeError pass test_extending_list_with_iterator_does_not_segfault The code extend list iterator has fair amount nontrivial logic terms guessing how much memory allocate advance stealing refs then shrinking end This basic smoke test scenario gen i range yield i lst = i range lst pop lst extend gen assertEqual len lst cpython_only test_iter_overflow Test issue = iter UnlimitedSequenceClass Manually set ` it_index ` PY_SSIZE_T_MAX- without loop __setstate__ sys maxsize - assertEqual next sys maxsize - assertEqual next sys maxsize - assertRaises OverflowError next Check Overflow error always raised assertRaises OverflowError next test_iter_neg_setstate = iter UnlimitedSequenceClass __setstate__ - assertEqual next assertEqual next test_free_after_iterating check_free_after_iterating iter SequenceClass test_error_iter typ DefaultIterClass NoIterClass assertRaises TypeError iter typ assertRaises ZeroDivisionError iter BadIterableClass test_exception_locations The location exception raised __init__ __next__ should should iterator expression init_raises try x BrokenIter init_raises=True pass except Exception e e next_raises try x BrokenIter next_raises=True pass except Exception e e iter_raises try x BrokenIter iter_raises=True pass except Exception e e func expected init_raises BrokenIter init_raises=True next_raises BrokenIter next_raises=True iter_raises BrokenIter iter_raises=True subTest func exc = func f = traceback extract_tb exc __traceback__ indent = co = func __code__ assertEqual f lineno co co_firstlineno + assertEqual f end_lineno co co_firstlineno + assertEqual f line f colno - indent f end_colno - indent expected __name__ == __main__ run_tests