Owner s module dynamo functools sys unittest expectedFailure xfail skipIf skipif pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests TEST_WITH_TORCHDYNAMO TestCase xfailIfTorchDynamo xpassIfTorchDynamo_np If we going trace through these we should use NumPy If testing eager mode we use torch _numpy TEST_WITH_TORCHDYNAMO numpy np numpy apply_along_axis array_split column_stack dsplit dstack expand_dims hsplit kron put_along_axis split take_along_axis tile vsplit numpy random rand randint numpy testing assert_ assert_array_equal assert_equal torch _numpy np torch _numpy array_split column_stack dsplit dstack expand_dims hsplit kron put_along_axis split take_along_axis tile vsplit torch _numpy random rand randint torch _numpy testing assert_ assert_array_equal assert_equal skip = functools partial skipif True IS_ BIT = sys maxsize _add_keepdims func hack keepdims behavior into function taking axis functools wraps func wrapped axis kwargs res = func axis=axis kwargs axis None axis = res now scalar so we can insert anywhere np expand_dims res axis=axis wrapped TestTakeAlongAxis TestCase test_argequivalent Test translates arg func func = rand funcs = np sort np argsort _add_keepdims np min _add_keepdims np argmin _add_keepdims np max _add_keepdims np argmax FIXME np partition np argpartition dict kth= func argfunc kwargs funcs axis list range ndim + None a_func = func axis=axis kwargs ai_func = argfunc axis=axis kwargs assert_equal a_func take_along_axis ai_func axis=axis test_invalid Test errors when indices has too few dimensions = np ones ai = np ones dtype=np intp sanity check take_along_axis ai axis= enough indices assert_raises ValueError RuntimeError take_along_axis np array axis= bool arrays allowed assert_raises IndexError RuntimeError take_along_axis ai astype bool axis= float arrays allowed assert_raises IndexError RuntimeError take_along_axis ai astype float axis= invalid axis assert_raises np AxisError take_along_axis ai axis= test_empty Test everything ok empty results even inserted dims = np ones ai = np ones dtype=np intp actual = take_along_axis ai axis= assert_equal actual shape ai shape test_broadcast Test non-indexing dimensions broadcast both directions = np ones ai = np ones dtype=np intp actual = take_along_axis ai axis= assert_equal actual shape TestPutAlongAxis TestCase test_replace_max a_base = np array axis list range a_base ndim + None we mutate loop = a_base copy replace max small value i_max = _add_keepdims np argmax axis=axis put_along_axis i_max - axis=axis find new minimum which should max i_min = _add_keepdims np argmin axis=axis assert_equal i_min i_max xpassIfTorchDynamo_np reason= RuntimeError Expected index smaller than apart dimension test_broadcast Test non-indexing dimensions broadcast both directions = np ones ai = np arange dtype=np intp reshape put_along_axis ai axis= assert_equal take_along_axis ai axis= xpassIfTorchDynamo_np reason= apply_along_axis implemented TestApplyAlongAxis TestCase test_simple = np ones d assert_array_equal apply_along_axis len len np ones shape test_simple = np ones d assert_array_equal apply_along_axis len len np ones shape test_ d = np arange reshape assert_array_equal apply_along_axis np sum test_scalar_array cls=np ndarray = np ones view cls res = apply_along_axis np sum assert_ isinstance res cls assert_array_equal res np array view cls test_ d_array cls=np ndarray sum_to_ d x Sum x returning d array same assert_equal x ndim np squeeze np sum x keepdims=True = np ones view cls res = apply_along_axis sum_to_ d assert_ isinstance res cls assert_array_equal res np array view cls res = apply_along_axis sum_to_ d assert_ isinstance res cls assert_array_equal res np array view cls test_axis_insertion cls=np ndarray f x produces asymmetric non-square matrix x assert_equal x ndim x - x None view cls d = np arange reshape d insertion along first axis actual = apply_along_axis f d expected = np stack f d i i range d shape axis=- view cls assert_equal type actual type expected assert_equal actual expected d insertion along last axis actual = apply_along_axis f d expected = np stack f d i i range d shape axis= view cls assert_equal type actual type expected assert_equal actual expected d insertion along middle axis d = np arange reshape actual = apply_along_axis f d expected = np stack np stack f d i j i range d shape axis= j range d shape axis=- view cls assert_equal type actual type expected assert_equal actual expected test_axis_insertion_ma f x produces asymmetric non-square matrix x assert_equal x ndim res = x - x None np ma masked_where res == res = np arange reshape res = apply_along_axis f assert_ isinstance res np ma masked_array assert_equal res ndim assert_array_equal res mask f mask assert_array_equal res mask f mask assert_array_equal res mask f mask test_tuple_func d sample_ d x x x res = np apply_along_axis sample_ d np array assert_array_equal res np array test_empty can t apply_along_axis when there s no chance call function never_call x assert_ False should never reached = np empty assert_raises ValueError np apply_along_axis never_call assert_raises ValueError np apply_along_axis never_call s sometimes ok some non-zero dimensions empty_to_ x assert_ len x == = np empty actual = np apply_along_axis empty_to_ assert_equal actual np ones assert_raises ValueError np apply_along_axis empty_to_ skip TypeError descriptor union set objects doesn t apply numpy int object test_with_iterable_object issue d = np array actual = np apply_along_axis lambda set union d expected = np array assert_equal actual expected issue - assert_equal doesn t detect i np ndindex actual shape assert_equal type actual i type expected i xfail reason= apply_over_axes implemented TestApplyOverAxes TestCase test_simple = np arange reshape aoa_a = apply_over_axes np sum assert_array_equal aoa_a np array TestExpandDims TestCase test_functionality s = = np empty s axis range - b = expand_dims axis assert_ b shape axis == assert_ np squeeze b shape == s test_axis_tuple = np empty assert np expand_dims axis= shape == assert np expand_dims axis= - - shape == assert np expand_dims axis= shape == assert np expand_dims axis= - - shape == test_axis_out_of_range s = = np empty s assert_raises np AxisError expand_dims - assert_raises np AxisError expand_dims = np empty assert_raises np AxisError expand_dims - assert_raises np AxisError expand_dims test_repeated_axis = np empty assert_raises ValueError expand_dims axis= TestArraySplit TestCase test_integer_ _split = np arange assert_raises ValueError array_split test_integer_split = np arange res = array_split desired = np arange compare_results res desired res = array_split desired = np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange np arange np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange np arange np arange np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange np arange np arange np arange np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange np arange np arange np arange np arange np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange np arange np arange np arange np arange np arange np arange np arange compare_results res desired res = array_split desired = np arange np arange np arange np arange np arange np arange np arange np arange np arange np arange np array compare_results res desired test_integer_split_ D_rows = np array np arange np arange res = array_split axis= tgt = np array np arange np array np arange np zeros compare_results res tgt assert_ dtype type res - dtype type Same thing manual splits res = array_split axis= tgt = np zeros np array np arange np array np arange compare_results res tgt assert_ dtype type res - dtype type test_integer_split_ D_cols = np array np arange np arange res = array_split axis=- desired = np array np arange np arange np array np arange np arange np array np arange np arange compare_results res desired test_integer_split_ D_default This will fail we change default axis = np array np arange np arange res = array_split tgt = np array np arange np array np arange np zeros compare_results res tgt assert_ dtype type res - dtype type perhaps should check higher dimensions skipif IS_ BIT reason= Needs bit platform test_integer_split_ D_rows_greater_max_int = np broadcast_to res = array_split chunk = np broadcast_to tgt = chunk i range len tgt assert_equal res i shape tgt i shape test_index_split_simple = np arange indices = res = array_split indices axis=- desired = np arange np arange np arange np arange compare_results res desired test_index_split_low_bound = np arange indices = res = array_split indices axis=- desired = np array np arange np arange np arange compare_results res desired test_index_split_high_bound = np arange indices = res = array_split indices axis=- desired = np array np arange np arange np arange np array np array compare_results res desired TestSplit TestCase The split function essentially same array_split except test splitting will result equal split Only test case test_equal_split = np arange res = split desired = np arange np arange compare_results res desired test_unequal_split = np arange assert_raises ValueError split TestColumnStack TestCase test_non_iterable assert_raises TypeError column_stack test_ D_arrays example docstring = np array b = np array expected = np array actual = np column_stack b assert_equal actual expected test_ D_arrays same hstack D docstring example = np array b = np array expected = np array actual = np column_stack b assert_equal actual expected test_generator numpy emits warning we don t assert_warns FutureWarning column_stack np arange _ range TestDstack TestCase test_non_iterable assert_raises TypeError dstack test_ D_array = np array b = np array res = dstack b desired = np array assert_array_equal res desired test_ D_array = np array b = np array res = dstack b desired = np array assert_array_equal res desired test_ D_array = np array b = np array res = dstack b desired = np array assert_array_equal res desired test_ D_array = np array b = np array res = dstack b desired = np array assert_array_equal res desired test_generator numpy emits warning we don t assert_warns FutureWarning dstack np arange _ range array_split has more comprehensive test splitting only do simple test hsplit vsplit dsplit TestHsplit TestCase Only testing integer splits test_non_iterable assert_raises ValueError hsplit test_ D_array = np array try hsplit assert_ except ValueError pass test_ D_array = np array res = hsplit desired = np array np array compare_results res desired test_ D_array = np array res = hsplit desired = np array np array compare_results res desired TestVsplit TestCase Only testing integer splits test_non_iterable assert_raises ValueError vsplit test_ D_array = np array assert_raises ValueError vsplit test_ D_array = np array try vsplit assert_ except ValueError pass test_ D_array = np array res = vsplit desired = np array np array compare_results res desired TestDsplit TestCase Only testing integer splits test_non_iterable assert_raises ValueError dsplit test_ D_array = np array assert_raises ValueError dsplit test_ D_array = np array assert_raises ValueError dsplit test_ D_array = np array try dsplit assert_ except ValueError pass test_ D_array = np array res = dsplit desired = np array np array compare_results res desired TestSqueeze TestCase test_basic = rand b = rand c = rand assert_array_equal np squeeze np reshape assert_array_equal np squeeze b np reshape b assert_array_equal np squeeze c np reshape c Squeezing -dim should still give ndarray = res = np squeeze assert_equal res assert_equal res ndim assert type res np ndarray xfailIfTorchDynamo test_basic_ aa = np ones assert aa squeeze tensor _base aa tensor test_squeeze_axis A = assert_equal np squeeze A shape assert_equal np squeeze A axis= A assert_equal np squeeze np zeros shape assert_equal np squeeze np zeros axis= shape assert_equal np squeeze np zeros axis=- shape assert_equal np squeeze np zeros axis= shape assert_equal np squeeze np zeros shape assert_equal np squeeze np zeros axis= shape assert_equal np squeeze np zeros axis= shape assert_equal np squeeze np zeros axis=- shape test_squeeze_type Ticket = np array b = np array assert type squeeze np ndarray assert type b squeeze np ndarray skip reason= XXX order= F implemented test_squeeze_contiguous Similar GitHub issue = np zeros squeeze b = np zeros order= F squeeze assert_ flags c_contiguous assert_ flags f_contiguous assert_ b flags f_contiguous xpassIfTorchDynamo_np reason= XXX noop torch while numpy raises test_squeeze_axis_handling assert_raises ValueError np squeeze np array axis= instantiate_parametrized_tests TestKron TestCase test_basic Using -dimensional ndarray = np array b = np array k = np array assert_array_equal np kron b k = np array b = np array assert_array_equal np kron b k Using -dimensional ndarray = np array b = np array k = np array assert_array_equal np kron b k = np array b = np array assert_array_equal np kron b k Using -dimensional ndarray = np array b = np array k = np array assert_array_equal np kron b k = np array b = np array k = np array assert_array_equal np kron b k skip reason= NP_VER fails CI parametrize shape_a shape_b test_kron_shape shape_a shape_b = np ones shape_a b = np ones shape_b normalised_shape_a = max len shape_b - len shape_a + shape_a normalised_shape_b = max len shape_a - len shape_b + shape_b expected_shape = np multiply normalised_shape_a normalised_shape_b k = np kron b assert np array_equal k shape expected_shape Unexpected shape kron TestTile TestCase test_basic = np array b = assert_equal tile assert_equal tile assert_equal tile assert_equal tile b assert_equal tile b assert_equal tile b test_tile_one_repetition_on_array_gh = np arange b = tile b += assert_equal np arange test_empty = np array b = np array c = tile b shape d = tile shape assert_equal c assert_equal d test_kroncompare reps = shape = s shape b = randint size=s r reps = np ones r b dtype large = tile b r klarge = kron b assert_equal large klarge xfail Maybe implement one day TestMayShareMemory TestCase test_basic d = np ones d = np ones assert_ np may_share_memory d d assert_ np may_share_memory d d - assert_ np may_share_memory d d assert_ np may_share_memory d d - assert_ np may_share_memory d - d assert_ np may_share_memory d d assert_ np may_share_memory d - d assert_ np may_share_memory d - d Utility compare_results res desired Compare lists arrays len res = len desired raise ValueError Iterables have different lengths See also PEP Python x y zip res desired assert_array_equal x y __name__ == __main__ run_tests