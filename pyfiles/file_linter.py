__future__ annotations json sys abc abstractmethod functools cached_property pathlib Path typing TYPE_CHECKING typing_extensions Never ParseError argument_parser ArgumentParser messages LintResult python_file PythonFile TYPE_CHECKING argparse Namespace collections abc Iterator Sequence ErrorLines How many lines display before after error WINDOW = BEFORE = AFTER = WINDOW - BEFORE - FileLinter The base all token-based linters inherit description str linter_name str epilog str &#124; None = None is_fixer bool = True report_column_numbers bool = False abstractmethod _lint python_file PythonFile - Iterator LintResult raise NotImplementedError __init__ argv Sequence str &#124; None = None - None argv = argv parser = ArgumentParser is_fixer=self is_fixer description=self description epilog=self epilog result_shown = False classmethod run cls - Never sys exit cls lint_all lint_all - bool args fix args lintrunner raise ValueError -- fix -- lintrunner incompatible success = True p paths success = _lint_file p success args lintrunner success classmethod make_file cls pc Path &#124; str &#124; None = None - PythonFile PythonFile make cls linter_name pc cached_property args - Namespace args = parser parse_args argv args cached_property code - str linter_name upper cached_property paths - list Path files = file_parts = f fp args files f fp split f file_parts f startswith files extend Path f read_text splitlines f = -- files append f sorted Path f f files _lint_file p Path - bool args verbose print p Reading file=sys stderr pf = make_file p replacement results = _replace pf display = list _display pf results print display sep= \n results args fix pf path pf contents = replacement pf path write_text replacement results args fix all r is_edit r results _error pf PythonFile result LintResult - None Called files unparsable _replace pf PythonFile - tuple str list LintResult Because recursive replacements we need repeat replacing reparsing inside out until all possible replacements complete previous_result_count = float inf first_results = None original = replacement = pf contents pyrefly ignore bad-assignment while True try results = sorted _lint pf key=LintResult sort_key except IndentationError e error _name lineno column _line = e args results = LintResult error lineno column _error pf results except ParseError e results = LintResult str e e token start _error pf results i ri enumerate results ri is_recursive rj results i + ri contains rj rj is_recursive = True break first_results = first_results results results len results = previous_result_count break previous_result_count = len results lines = pf lines r reversed results r is_edit r is_recursive r apply lines replacement = join lines any r is_recursive r results break pf = pf with_contents replacement first_results args lintrunner name = f Suggested fixes linter_name msg = LintResult name=name original=original replacement=replacement first_results append msg replacement first_results _display pf PythonFile results list LintResult - Iterator str Emit series human-readable strings representing results r results args lintrunner msg = r as_message code=self code path=str pf path yield json dumps msg asdict sort_keys=True result_shown yield result_shown = True r line None yield f pf path r name yield i rstrip i _display_window pf r _display_window pf PythonFile r LintResult - Iterator str Display window onto code error r char None report_column_numbers yield f pf path r line r name yield f pf path r line r char + r name begin = max r line - ErrorLines BEFORE end = min begin + ErrorLines WINDOW + len pf lines lineno range begin end source_line = pf lines lineno - rstrip yield f lineno &#124; source_line lineno == r line spaces = + r char carets = len source_line r char None r length yield spaces + carets ^