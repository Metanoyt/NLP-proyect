mypy allow-untyped-defs functools inspect itertools logging collections abc Callable dataclasses dataclass typing Any Optional Union torch torch utils _pytree pytree log = logging getLogger __name__ trace_shape_events_log = torch _logging getArtifactLogger __name__ trace_shape_events __all__ = ShapeEnvEvent record_shapeenv_event replay_shape_env_events FakeTensorMeta shape_env_check_state_equal NotEqualError Note Recording ShapeEnv Events ================================= What ShapeEnv event ------------------------- We consider ShapeEnv event every function call ShapeEnv method independent function modifies state ShapeEnv instance Such calls recorded alongside their positional keyword arguments so may replayed over different ShapeEnv instance See Note ShapeEnv State Equality what considered state ShapeEnv instance What --------------- ShapeEnv events recording used reconstructing ShapeEnv arbitrary state time Being able arbitrarily replay events like so useful mainly translation validation bisection i e ValidationException has been raised find earliest point time where translation validation fails Besides also allows us inspect given instance example check guards would actually issued point What kind arguments can stored event ------------------------------------------------- There s no specific rule what cannot used argument That said pay special attention following cases Tensor inputs there some tests check whether inputs garbage collected after execution These will fail there s event holding reference those inputs ShapeEnv arguments there argument ShapeEnv type will automatically replaced new given ShapeEnv instance SymTypes arguments they also hold references ShapeEnv So whenever we see them we create new instance replacing ShapeEnv reference FX nodes specifically FX nodes FX graph symbolic shapes That argument must replaced when replaying event ShapeEnvEvent run since has reference node given instance recorded instance Event reconstructing ShapeEnv arbitrary time Represents method call mutates ShapeEnv way affects issued guards when ShapeEnv produce_guards called dataclass ShapeEnvEvent ShapeEnv method f Callable Arguments keyword arguments called args Optional list Any = None kwargs Optional dict str Any = None List tracked_fakes time method called tracked_fakes Optional list Any = None Name captured event Used special handling particular methods name Optional str = None Replay itself using shape_env run shape_env=None - Any torch fx experimental symbolic_shapes is_symbolic ShapeEnv SymTypes Special handling constructor event f ShapeEnv assert shape_env None args None kwargs None ShapeEnv kwargs assert shape_env None args = list args kwargs = dict kwargs Replace any argument type ShapeEnv given one args kwargs = pytree tree_map_only ShapeEnv lambda _ shape_env args kwargs Replace any argument type SymTypes new instance replacing its ShapeEnv reference args kwargs = pytree tree_map_only lambda x isinstance x SymTypes is_symbolic x lambda type node with_shape_env shape_env args kwargs Converts FX nodes using mapping argument maybe_convert_node x Any - Any isinstance x torch fx Node Don t do anything x s FX node x If some point we created FX node means translation validation It also means we building FX graph symbolic shapes shape_env graph we tracking node names shape_env name_to_node assert hasattr shape_env name_to_node name_to_node = shape_env name_to_node type ignore attr-defined assert x name name_to_node name_to_node x name Replaces value specific argument result fn replacearg index int key str fn Callable index len args args index = fn args index key kwargs kwargs key = fn kwargs key is_create_fx_call_function ShapeEnv create_fx_call_function args parameter tuple FX nodes FX graph old ShapeEnv They must replaced since call_function FX node tuple argument will added FX graph new shape_env replacearg index= key= args fn=lambda args tuple maybe_convert_node args is_evaluate_expr is_defer_runtime_assert ShapeEnv evaluate_expr ShapeEnv guard_or_defer_runtime_assert fx_node parameter optional FX node represents evaluate expression They must replaced since will part call_function FX node torch _assert which will added FX graph new shape_env replacearg index= key= fx_node fn=maybe_convert_node Actually call method converted arguments f args kwargs __str__ - str name = name name None f __name__ f event name args kwargs is_create_fx_call_function - bool name == _create_fx_call_function is_evaluate_expr - bool name == evaluate_expr is_defer_runtime_assert - bool name == guard_or_defer_runtime_assert NEST = Extracts ShapeEnv instance inside args kwargs Specifically looks ShapeEnv arguments SymInt SymFloat SymBool arguments If we find more than one object any above types we also check ShapeEnv instance same all them _extract_shape_env_and_assert_equal args kwargs torch fx experimental symbolic_shapes is_symbolic ShapeEnv SymTypes assert_equal old Optional ShapeEnv new ShapeEnv - ShapeEnv old None assert old new call different ShapeEnv new shape_env = None val itertools chain args kwargs values isinstance val ShapeEnv shape_env = assert_equal shape_env val isinstance val SymTypes is_symbolic val shape_env = assert_equal shape_env val node shape_env shape_env Decorator recording given function replayable event This decorator should used every function mutates state ShapeEnv some way affects resulting issued guards i e when ShapeEnv produce_guards called save_tracked_fakes saves snapshot TrackedFake list This used when calling ShapeEnv produce_guards arbitrary points time name name function being recorded Normally default taken decorated function can set you need override When save list TrackedFake ===================================== We should save list TrackedFake whenever translation validation bisection may actually stop call produce_guards method moment right after recorded function played In other words since bisection bisects through torch _assert calls we should save all methods adds torch _assert call symbolic shapes FX graph At moment there methods save list - ShapeEnv evaluate_expr - ShapeEnv guard_or_defer_runtime_assert record_shapeenv_event save_tracked_fakes bool = False name Optional str = None - Callable decorator fn Callable - Callable assert callable fn args = inspect getfullargspec fn args assert args args == record_shapeenv_event should only wrap methods ShapeEnv refactor your code so calls into method ShapeEnv nonlocal name name None name = fn __name__ functools wraps fn wrapper args kwargs torch fx experimental symbolic_shapes ShapeEnv assert isinstance args ShapeEnv global NEST trace_shape_events_log debug scall s r r NEST name args kwargs NEST += retlog r trace_shape_events_log debug s- s NEST - r r shape_env = args try shape_env should_record_events shape_env is_recording type ignore has-type If ShapeEnv already recording event call wrapped function directly NB here we skip check whether all ShapeEnv instances equal favor faster dispatch retlog fn args kwargs Retrieve instance ShapeEnv Assumption collection args kwargs may reference different ShapeEnv instances = _extract_shape_env_and_assert_equal args kwargs If we calling function without any ShapeEnv instance alive its arguments we don t record call original None retlog fn args kwargs Otherwise start recording call function _recording Take snapshot current tracked_fakes tracked_fakes = _snapshot_tracked_fakes save_tracked_fakes None Record event fn event = ShapeEnvEvent fn list args kwargs tracked_fakes name=name Play event ShapeEnv NB It s important put event first because running event can trigger internal events must ordered after event However exception happens we do NOT want have event list so pop off record error happened events append event try retlog event run except Exception events pop raise except Exception shape_env should_record_events shape_env is_recording If ShapeEnv disabled already recording event re-raise exception without logging raise log error noqa G failed while running s s s name args kwargs exc_info=log isEnabledFor logging INFO raise finally NEST -= wrapper decorator Replays ShapeEnvEvents list It assumes first event constructor call fn transforms old FX node into one corresponding newly created ShapeEnv replay_shape_env_events events torch fx experimental symbolic_shapes ShapeEnv constructor_event = events assert constructor_event f == ShapeEnv Constructs new ShapeEnv shape_env = constructor_event run event events try Actually replays each event We need call create_mapping_fn every time since node list might change after each event replayed event run shape_env except Exception log error failed when running event s event raise shape_env FakeTensor metadata This used place FakeTensor placeholders when calling ShapeEnv produce_guards dataclass FakeTensorMeta tensor_size tuple Union int torch SymInt tensor_stride tuple Union int torch SymInt tensor_storage_offset Union int torch SymInt is_nested bool size - tuple Union int torch SymInt tensor_size stride - tuple Union int torch SymInt tensor_stride storage_offset - Union int torch SymInt tensor_storage_offset dim - int len tensor_size staticmethod from_fake fake - FakeTensorMeta FakeTensorMeta fake size fake stride fake storage_offset fake is_nested Note ShapeEnv State Equality =============================== What considered ShapeEnv state ---------------------------------- We consider state ShapeEnv instance everything inline tuple inside remove_nonstate_variables function That fields within ShapeEnv modify flow execution program So example replacements field might influence how expression simplified That turn may result guard being statically known i e added On other hand var_to_stack serves only changes what printed screen i e used only debugging purposes Therefore we should consider when comparing states What do NotEqualError ---------------------------- Here few possible causes getting NotEqualError raised New field does belong ShapeEnv state For example log field type ShapeEnvLoggerAdapter Different ShapeEnv instances will always have different ShapeEnvLoggerAdapter instances i e equality comparison would fail Solution add inlined tuple inside remove_nonstate_variables function inside check_equal method New field directly comparable across instances For example guards field type List ShapeGuard More specifically ShapeGuard type holds expression stack information debugging purposes When replaying even new ShapeEnv instance stack would different which would trigger error Solution add special case map_value function inside check_equal function Mutation ShapeEnv some recorded function If mutation state ShapeEnv happens inside function recorded no caller stack recorded then replayed ShapeEnv won t catch Solution decorate function record_shape_env_event Checks whether state two ShapeEnv equal w r t guards returned ShapeEnv produce_guards shape_env_check_state_equal env env non_state_variable_names map_value Collect remove variables don t necessarily represent state ShapeEnv Note we copy dictionary so we don t modify instance itself env _vars = vars env copy env _vars = vars env copy v non_state_variable_names v env _vars env _vars pop v v env _vars env _vars pop v Function transforming mismatched values into string Needed since dict set entries order might same every time value_to_str value Any - str isinstance value dict + join f k value k k sorted value keys key=str + isinstance value set + join f v v sorted value + str value Compares env _vars env _vars Here we allow value each field mapped so we appropriately compare two values compare_vars map_value Callable str Any Any - list tuple str str str env _set env _set = set env _vars set env _vars First compare set keys each vars dictionary env _set = env _set raise NotEqualError field set mismatch found unique fields str sorted env _set - env _set str sorted env _set - env _set Then sort keys compare mapped values each key sorted_keys = list env _set sorted_keys sort mapped_dict = k map_value k env _vars k map_value k env _vars k k sorted_keys Return list tuples representing fields did match alongside their respective mapped values f k values don t match value_to_str val value_to_str val k val val mapped_dict val = val Accumulate mismatching fields errors = compare_vars map_value len errors raise NotEqualError field values don t match errors NotEqualError Exception __init__ msg str mismatched list tuple str str str - None details = \n join \n join f == inner_msg f Left str f Right str inner_msg str str mismatched super __init__ f \ ShapeEnv equal msg details