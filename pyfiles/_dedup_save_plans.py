Copyright c Meta Platforms Inc affiliates dataclasses collections defaultdict typing TYPE_CHECKING torch distributed checkpoint planner SavePlan WriteItem TYPE_CHECKING torch distributed checkpoint metadata MetadataIndex __all__ = dedup_save_plans dedup_save_plans all_plans list SavePlan save_to_lowest_rank bool = False - list SavePlan Removes duplicate entries appearing multiple SavePlans For each duplicate across set SavePlans only smallest SavePlan terms planned storage keeps entry Please note function does modify original SavePlans rather returns Map query plan indices write item duplicated write_item_to_plan_indices dict MetadataIndex set int = defaultdict set Map query write item its index write_item_idx_to_write_item dict MetadataIndex WriteItem = Set write item indices present each plan After deduplication will set write item indices present final plans plan_to_item_indices list set MetadataIndex = item index item plan items plan all_plans plan_idx plan enumerate all_plans write_item plan items map each write item its plan write_item_to_plan_indices write_item index add plan_idx write_item_idx_to_write_item write_item index = write_item plan_to_size = len all_plans write_item_idx plan_indices write_item_to_plan_indices items save_to_lowest_rank select_plan_idx = min plan_indices select_plan_idx = min plan_indices key=lambda plan_idx plan_to_size plan_idx write_item = write_item_idx_to_write_item write_item_idx Ignore storage size anything tensor since we don t know how much storage they represent plan_to_size select_plan_idx += write_item tensor_storage_size plan_idx plan_indices - select_plan_idx plan_to_item_indices plan_idx discard write_item_idx Sanity check len all_plans = len plan_to_item_indices raise AssertionError len all_plans = len plan_to_item_indices Create new plans updated write items post deduplication dataclasses replace plan items= item item plan items item index item_indexes plan item_indexes zip all_plans plan_to_item_indices