atexit collections dataclasses functools os shutil sys tempfile dataclasses dataclass field typing Callable Optional torch _inductor runtime cache_dir_utils cache_dir Set subdirectory name SUBDIR_NAME = bisect dataclass Subsystem name str dataclass BisectSubsystem Subsystem pass dataclass BinarySubsystem Subsystem pass dataclass ConfigChange BinarySubsystem name str = field init=False config_name str config_field str config_value object __post_init__ - None name = f config_name _ config_field Dictionary backend - subsystems BACKENDS dict str list Subsystem = run dynamo without aot_autograd eager run dynamo aot_autograd no partitioner decomps aot_eager run dynamo aot autograd decompositions partitioner aot_eager_decomp_partition ConfigChange aot_eager_decomp_partition cse False BisectSubsystem decomposition number decompositions we apply tracing TODO - add cse applies CrossRefFakeMode invocation aot_eager_decomp_partition_crossref inductor BisectSubsystem pre_grad_passes passes applied pre-grad IR BisectSubsystem joint_graph_passes passes applied joint graph BisectSubsystem post_grad_passes passes applied individually forward backward inductor ConfigChange inductor fallback_random True ConfigChange inductor emulate_precision_casts True ConfigChange inductor layout_optimization False ConfigChange inductor comprehensive_padding False BisectSubsystem lowerings lowering aten operators inductor TODO - add more - fusions subsystem_call_counter dict str int = collections Counter call_counter_debug_info dict int str = reset_counters - None subsystem_call_counter clear call_counter_debug_info clear functools cache get_env_val env_str str - Optional str os environ get env_str None dataclasses dataclass BisectionResult backend torch compile backend responsible failure subsystem optional registered component identified failure bisect_number optional number times subsystem needed applied trigger failure debug_info associated info triggering bisect application subsystem backend str subsystem Optional str = None bisect_number Optional int = None debug_info Optional str = None CompilerBisector This iteratively runs torch compile backends eager aot_eager inductor find first backend can repro issue Once discovers offending backend will iteratively disable subsystems within backend For subsystems which applied repeatedly such number post grad passes number lowering nodes inductor ir will bisect find offending application The idiomatic way run ` do_bisect ` You can also use setting env flags ` TORCH_BISECT_BACKEND ` ` TORCH_BISECT_SUBSYSTEM ` ` TORCH_BISECT_MAX ` It also supports CLI interface although less well tested You must run python compiler_bisector py start &#124; good &#124; bad &#124; end bisection_enabled bool = False in_process_cache Optional str = None classmethod get_dir cls - str f cache_dir cls in_process_cache cls in_process_cache SUBDIR_NAME classmethod write_lines_to_file cls file_path str lines list str - None os makedirs os path dirname file_path exist_ok=True open file_path w file file writelines lines classmethod read_lines_from_file cls file_path str - list str os path exists file_path open file_path file file readlines classmethod update_run_state cls backend_name str subsystem Subsystem run_state str - None file_path = os path join cls get_dir backend_name f subsystem name _run_state txt isinstance subsystem ConfigChange assert run_state == test_disable cls set_config_values backend_name subsystem name subsystem config_field subsystem config_value cls write_lines_to_file file_path run_state classmethod set_config_values cls backend str subsystem str config_data dict str object - None file_path = os path join cls get_dir backend f subsystem _config txt lines = f k = v \n k v config_data items cls write_lines_to_file file_path lines classmethod update_bisect_status cls backend_name str subsystem_name str - None assert isinstance subsystem_name str file_path = os path join cls get_dir bisect_status txt lines = f backend= backend_name \n f subsystem= subsystem_name \n cls write_lines_to_file file_path lines classmethod update_bisect_range cls backend_name str subsystem_name str low int high int - None assert isinstance subsystem_name str file_path = os path join cls get_dir backend_name f subsystem_name _bisect_range txt lines = f low= low \n f high= high \n cls write_lines_to_file file_path lines classmethod get_backend cls - Optional str Returns active backend any val = get_env_val TORCH_BISECT_BACKEND val file_path = os path join cls get_dir bisect_status txt lines = cls read_lines_from_file file_path line lines line startswith backend= line strip split = None classmethod get_subsystem cls - Optional str Returns active subsystem any val = get_env_val TORCH_BISECT_SUBSYSTEM val file_path = os path join cls get_dir bisect_status txt lines = cls read_lines_from_file file_path line lines line startswith subsystem= out = line strip split = out out None None classmethod get_subsystem_object cls backend_name str subsystem_name str - Subsystem next obj obj BACKENDS backend_name obj name == subsystem_name classmethod get_run_state cls backend_name str subsystem_name str - Optional str Returns current stage bisecting Any file_path = os path join cls get_dir backend_name f subsystem_name _run_state txt lines = cls read_lines_from_file file_path lines out = lines strip assert out test_disable find_max_bounds bisect out None classmethod get_bisect_range cls backend_name str subsystem_name str - tuple int int file_path = os path join cls get_dir backend_name f subsystem_name _bisect_range txt lines = cls read_lines_from_file file_path low = None high = None pyrefly ignore bad-assignment line reversed lines line startswith low= low = int line strip split = line startswith high= high = int line strip split = low None high None break low None high None raise RuntimeError f Trying get bisect range when set subsystem subsystem_name low high classmethod update_config_change cls backend str subsystem ConfigChange - None file_path = os path join cls get_dir backend f subsystem name _config txt lines = f config_name= subsystem config_name \n f config_field= subsystem config_field \n f config_value= subsystem config_value \n cls write_lines_to_file file_path lines classmethod get_config_change cls config_name str - Optional dict str object backend = cls get_backend subsystem = cls get_subsystem backend subsystem None file_path = os path join cls get_dir backend f subsystem _config txt os path exists file_path None lines = cls read_lines_from_file file_path config_data = line lines key value = line strip split = config_data key = eval value config_data classmethod delete_bisect_status cls - None process_cache we have created exists just subdirectory non created dir dir_name = cls in_process_cache cls in_process_cache cls get_dir os path exists dir_name shutil rmtree dir_name print Bisection status deleted print No bisection status found classmethod get_system_counter cls name str increment bool = True - int global subsystem_call_counter curr = subsystem_call_counter name increment subsystem_call_counter name += curr classmethod disable_subsystem cls backend str subsystem str debug_info Optional Callable str = None - bool cls bisection_enabled False cls get_backend = backend False cls get_subsystem = subsystem False val = get_env_val TORCH_BISECT_MAX counter = cls get_system_counter subsystem increment=True counter int val run_state = cls get_run_state backend subsystem run_state == test_disable First run disable completely True run_state == find_max_bounds Second run update bisection range True enable subsystem cls update_bisect_range backend subsystem cls get_system_counter subsystem increment=True False assert run_state == bisect If environment variable set use bisection range midpoint low high = cls get_bisect_range backend subsystem high - low = midpoint = low + high call_counter = cls get_system_counter subsystem call_counter = low call_counter = high low - high = debug_info None call_counter_debug_info call_counter = debug_info call_counter midpoint classmethod advance_subsystem cls curr_backend str curr_subsystem Subsystem - Optional Subsystem Tries move next subsystem within current system print f Disabling curr_subsystem name did fix issue current_subsystems = BACKENDS curr_backend current_subsystem_index = next i i subsystem enumerate current_subsystems subsystem name == curr_subsystem name current_subsystem_index len current_subsystems - next_subsystem = current_subsystems current_subsystem_index + cls update_bisect_status curr_backend next_subsystem name cls update_run_state curr_backend next_subsystem test_disable print f Moving next subsystem curr_backend - next_subsystem name next_subsystem print f All subsystems curr_backend have been checked The issue system None classmethod advance_backend cls curr_backend str - Optional str Tries Move next backend current_system_index = list BACKENDS keys index curr_backend current_system_index len BACKENDS - curr_backend = list BACKENDS keys current_system_index + cls update_bisect_status curr_backend print f Moving next system curr_backend curr_backend None classmethod process_subsystem cls curr_backend str curr_subsystem Subsystem fn Callable bool cli_interface bool = True - bool Process current subsystem Returns True issue found False otherwise assert isinstance curr_subsystem Subsystem while True run_state = cls get_run_state curr_backend curr_subsystem name reset_counters run_state == test_disable fn next_subsystem = cls advance_subsystem curr_backend curr_subsystem next_subsystem False curr_subsystem = next_subsystem isinstance curr_subsystem ConfigChange print f Setting config curr_subsystem config_name field curr_subsystem config_field f curr_subsystem config_value fixed issue print f Disabling curr_subsystem name fixed issue isinstance curr_subsystem BinarySubsystem True print Starting bisect getting upper bound cls update_run_state curr_backend curr_subsystem find_max_bounds run_state == find_max_bounds fn raise RuntimeError f Function succeeded find_max_bounds status curr_backend - curr_subsystem name _ high = cls get_bisect_range curr_backend curr_subsystem name print f Upper bound high found curr_backend cls update_run_state curr_backend curr_subsystem bisect run_state == bisect low high = cls get_bisect_range curr_backend curr_subsystem name midpoint = low + high print f Bisecting curr_backend - curr_subsystem name Range low high Midpoint midpoint fn cls update_bisect_range curr_backend curr_subsystem name midpoint + high cls update_bisect_range curr_backend curr_subsystem name low midpoint low high = cls get_bisect_range curr_backend curr_subsystem name low == high print f Binary search completed curr_backend - curr_subsystem name The bisect number low f Debug info call_counter_debug_info get low found True raise RuntimeError f Unexpected run_state run_state cli_interface sys exit classmethod initialize_system cls - None curr_backend = next iter BACKENDS keys curr_subsystem = cls update_bisect_status curr_backend curr_subsystem print f Starting bisection process system curr_backend classmethod do_bisect cls fn Callable bool cli_interface bool = False - Optional BisectionResult Run fn repeatedly attempting bisect torch compile fn should True success False failure TODO graph bisecting well composed lowering bisector so far Use config opt-in torch _inductor config inductor_config inductor_config test_configs bisect_pre_grad_graph BACKENDS inductor insert BisectSubsystem pre_grad_graph cli_interface bisection_enabled_orig = cls bisection_enabled cls delete_bisect_status cls bisection_enabled = True cls in_process_cache = tempfile mkdtemp cleanup - None cls bisection_enabled = bisection_enabled_orig cls delete_bisect_status cls in_process_cache = None BACKENDS inductor name == pre_grad_graph del BACKENDS inductor cleanup_handler = atexit register cleanup DisableBisect __del__ - None cleanup atexit unregister cleanup_handler _cleanup = DisableBisect curr_backend = cls get_backend curr_subsystem_name = cls get_subsystem curr_backend cls initialize_system curr_backend = cls get_backend assert curr_backend None curr_subsystem_name = cls get_subsystem curr_subsystem = cls get_subsystem_object curr_backend curr_subsystem_name curr_subsystem_name None None while True assert curr_backend None reset_counters curr_subsystem result = cls process_subsystem curr_backend curr_subsystem fn cli_interface=cli_interface result curr_subsystem = cls get_subsystem_object curr_backend cls get_subsystem type ignore arg-type isinstance curr_subsystem BinarySubsystem BisectionResult curr_backend curr_subsystem name curr_subsystem name low _ = cls get_bisect_range curr_backend curr_subsystem name BisectionResult curr_backend curr_subsystem name low call_counter_debug_info get low next_subsystem = cls advance_subsystem curr_backend curr_subsystem next_subsystem print f The issue curr_backend system could identify subsystem assert curr_backend None BisectionResult curr_backend curr_subsystem = next_subsystem fn next_backend = cls advance_backend curr_backend next_backend print All systems have been checked None curr_backend = next_backend current_subsystems = BACKENDS curr_backend current_subsystems curr_subsystem = current_subsystems cls update_bisect_status curr_backend curr_subsystem name cls update_run_state curr_backend curr_subsystem test_disable print f The issue curr_backend system Moving first subsystem curr_subsystem print f The issue curr_backend system BisectionResult curr_backend cli_interface sys exit command_line_usage - None len sys argv print Usage python bisect_update py start &#124; end &#124; good &#124; bad sys exit bisection_manager = CompilerBisector command = sys argv command == end bisection_manager delete_bisect_status sys exit command == start bisection_manager delete_bisect_status bisection_manager initialize_system sys exit command good bad print Invalid command Must good bad start end sys exit test_function - bool command == good bisection_manager get_backend raise ValueError Must call start prior good bad bisection_manager do_bisect test_function cli_interface=True get_is_bisection_enabled - bool CompilerBisector get_subsystem None CompilerBisector get_backend None CompilerBisector bisection_enabled = get_is_bisection_enabled __name__ == __main__ command_line_usage