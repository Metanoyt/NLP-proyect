__future__ annotations typing Any TYPE_CHECKING Union TYPE_CHECKING collections abc Sequence torch noqa TC _dim_entry _match_levels DimEntry ndim_of_levels _wrap_dim arg Any orig_ndim int allow_none bool = True - DimEntry Convert various dimension representations DimEntry Args arg The argument convert Dim int other orig_ndim Original number dimensions allow_none Whether allow None values Returns DimEntry representation dimension Dim arg None allow_none DimEntry None entry isinstance arg Dim DimEntry arg isinstance arg int arg pos = arg pos = arg - orig_ndim DimEntry pos DimEntry order tensor_or_dim Union torch Tensor Any dims Union Any Sequence Any - torch Tensor Reorder dimensions tensor create tensor dimension It allows reordering tensor dimensions using first-class dimensions positional indices Args tensor_or_dim Input tensor first-class dimensions Dim object dims Dimensions sequences dimensions specifying new order Returns Tensor reordered dimensions Examples torch functorch dim dims batch channel height width = dims x = torch randn batch channel height width Reorder height width batch channel y = order x height width batch channel Dim DimList Tensor Handle first argument - tensor dimension isinstance tensor_or_dim Tensor First-class tensor orig_levels = tensor_or_dim _levels data = tensor_or_dim _tensor has_device = tensor_or_dim _has_device isinstance tensor_or_dim Dim Single dimension - create range tensor orig_levels = DimEntry tensor_or_dim data = tensor_or_dim _get_range has_device = False raise ValueError First argument must Tensor Dim object flat_positional_dims = to_flatten = List start_index length pairs flattening levels = orig_levels orig_ndim = ndim_of_levels levels append_dim d DimEntry - None Add dimension reordering removing available levels try idx = levels index d except ValueError idx = None idx None d is_positional raise ValueError f tensor has orig_ndim positional dimensions d position + orig_ndim specified f specified twice raise ValueError f tensor does contain dim d dim specified twice levels idx = DimEntry flat_positional_dims append d n_new_positional = Process each dimension argument arg dims entry = _wrap_dim arg orig_ndim False entry is_none append_dim entry n_new_positional += isinstance arg DimList Handle DimList dim arg _dims append_dim DimEntry dim n_new_positional += Handle sequences dimensions flattening n_new_positional += hasattr arg __iter__ raise ValueError expected Dim List Dim Sequence Dim Convert list get length seq = list arg to_flatten append len flat_positional_dims len seq item seq entry = _wrap_dim item orig_ndim False entry is_none raise ValueError expected Dim int append_dim entry Build new level ordering insert_point = - new_levels list DimEntry = Add remaining non-reordered levels finding insertion point new dimensions level levels level is_none continue level is_positional insert_point == - insert_point = len new_levels new_levels extend flat_positional_dims new_levels append level If no positional dimensions found append new dims end insert_point == - insert_point = len new_levels new_levels extend flat_positional_dims Match tensor new level structure assert data None Cannot reorder None tensor ndata = _match_levels data orig_levels new_levels Handle dimension flattening requested to_flatten Now build reshape target view_shape = sizes = ndata size Add dimensions before reordered ones i range insert_point view_shape append sizes i Process flattening groups i = start_idx length to_flatten Add individual dims before flattening group while i start_idx view_shape append sizes insert_point + i i += Flatten group new_size = j range length new_size = sizes insert_point + i + j view_shape append new_size i += length Add remaining individual dims while i len flat_positional_dims view_shape append sizes insert_point + i i += Add dimensions after reordered ones i range insert_point + len flat_positional_dims len levels view_shape append sizes i Update levels removing flattened dimensions n_to_remove = len flat_positional_dims - n_new_positional n_to_remove Remove flattened levels new_levels = new_levels insert_point + new_levels insert_point + n_to_remove ndata = ndata reshape view_shape Renumber positional dimensions negative indexing right seen = i range len new_levels - - - new_levels i is_positional i = insert_point i insert_point + n_new_positional seen -= new_levels i = DimEntry seen result = Tensor from_positional ndata new_levels has_device result type ignore return-value