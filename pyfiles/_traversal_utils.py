NOTE This file must imported like ` ` torch distributed fsdp _traversal_utils ` ` like ` ` torch distributed fsdp _traversal_utils ` ` avoid circular imports For brevity we may file ` ` traversal_utils ` ` collections torch nn nn torch distributed _composable contract _get_registry torch distributed fsdp _common_utils _FSDPState _get_module_fsdp_state Note FSDP State Traversal For wrapper code path ` ` _FSDPState ` ` ` ` FullyShardedDataParallel ` ` module wrapping fully sharded module non-wrapper code path ` ` _FSDPState ` ` object gets embedded fully sharded module See Note Fully Sharded Module definition There three common traversal idioms Given root module - ` ` _get_fsdp_states ` ` returns all ` ` _FSDPState ` ` s tree - ` ` get_fsdp_root_states ` ` returns all local root ` ` _FSDPState ` ` s tree i e those ` ` _is_root == True ` ` - ` ` _get_fsdp_handles ` ` returns all ` ` FlatParamHandle ` ` s tree All these methods must take root module i e ` ` nn Module ` ` general ` ` _FSDPState ` ` because ` ` _FSDPState ` ` does support graph traversal whereas ` ` nn Module ` ` has ` ` nn Module modules ` ` traversal _composable module nn Module - bool Returns ` ` module ` ` can compose ` ` fully_shard ` ` TODO Add any other composable APIs mutually exclusive registry = _get_registry module registry None True replicate registry TODO awgu We may able remove function we retired ` use_orig_params=False ` code path since so far we only need module ` FlatParameter ` registration which needed ` use_orig_params=True ` _get_fsdp_states_with_modules module nn Module - tuple list _FSDPState list nn Module Returns tuple containing A list ` ` _FSDPState ` ` instances module tree rooted ` ` module ` ` without any duplicates following ` ` module modules ` ` traversal order which assumed depth-first A corresponding list modules owning states first list For wrapper code path both returned lists same each containing all ` ` FullyShardedDataParallel ` ` instances For composable code path returns list all composable state instances list corresponding fully sharded modules See Note Fully Sharded Module NOTE The traversal does proceed into any module annotated incompatible API e g ` ` replicate ` ` fsdp_states list _FSDPState = fsdp_modules list nn Module = Track visited FSDP states since multiple modules may share same one we want de-duplicated list visited_fsdp_states set _FSDPState = set Track visited modules case shared modules which implies module graph no longer tree visited_modules set nn Module = set Perform depth-first search ` module ` ensure we do traverse into incompatible API s subtree use DFS instead BFS match ` modules ` order deque collections deque nn Module = collections deque module while deque submodule = deque popleft visited_modules add submodule _composable submodule continue child_module reversed list submodule children child_module visited_modules deque appendleft child_module optional_state = _get_module_fsdp_state submodule optional_state None optional_state visited_fsdp_states visited_fsdp_states add optional_state fsdp_states append optional_state fsdp_modules append submodule fsdp_states fsdp_modules _get_fsdp_states module nn Module - list _FSDPState See func ` _get_fsdp_states_with_modules ` fsdp_states _ = _get_fsdp_states_with_modules module fsdp_states _get_fsdp_handles module nn Module - list Returns all ` ` FlatParamHandle ` ` s module tree rooted ` ` module ` ` following rules func ` _get_fsdp_state ` handles = fsdp_state _handle fsdp_state _get_fsdp_states module fsdp_state _handle None handles