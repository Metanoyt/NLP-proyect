Owner s oncall package deploy io BytesIO textwrap dedent unittest skipIf torch torch package PackageExporter PackageImporter sys_importer torch testing _internal common_utils IS_FBCODE IS_SANDCASTLE run_tests try torchvision models resnet HAS_TORCHVISION = True except ImportError HAS_TORCHVISION = False skipIfNoTorchVision = skipIf HAS_TORCHVISION no torchvision try common PackageTestCase except ImportError Support case where we run file directly common PackageTestCase skipIf True Does work recent torchvision see https github com pytorch pytorch issues skipIfNoTorchVision ModelTest PackageTestCase End-to-end tests packaging entire model skipIf IS_FBCODE IS_SANDCASTLE Tests use temporary files disabled fbcode test_resnet resnet = resnet f = temp create package will save along its code PackageExporter f e put pickled resnet package default will also save all code files references objects pickle e intern e save_pickle model model pkl resnet we can now load saved model i = PackageImporter f r = i load_pickle model model pkl test works input = torch rand ref = resnet input assertEqual r input ref functions exist also get private modules each package torchvision = i import_module torchvision noqa F f = BytesIO we doing transfer learning we might want re-save things loaded package We need tell exporter about any modules came imported packages so can resolve names like torchvision models resnet ResNet their source code PackageExporter f importer= i sys_importer e e importers list module importing functions default contains importlib import_module searched order until first success module taken what torchvision models resnet should code package In case name collisions such trying save ResNet two different packages we take first thing found path so only ResNet objects one importer will work This avoids bunch name mangling source code If you need actually mix ResNet objects we suggest reconstructing model objects using code single package using functions like save_state_dict load_state_dict transfer state correct code objects e intern e save_pickle model model pkl r f seek i = PackageImporter f r = i load_pickle model model pkl assertEqual r input ref skipIfNoTorchVision test_model_save This example shows how you might package model so creator model has flexibility about how they want save server can always use same API load package The convention each model provide model package load function actual reads model out archive How load function implemented up packager get our normal torchvision resnet resnet = resnet f = BytesIO Option save pickling whole model + single-line similar torch jit save - more difficult edit code after model created PackageExporter f e e intern e save_pickle model pickled resnet note source same all models approach so can made part API just takes model packages source src = dedent \ importlib torch_package_importer resources server knows call model load get model maybe future passes options arguments convention load resources load_pickle model pickled e save_source_string model src is_package=True f = BytesIO Option save state dict - more code write save load model + code can edited later adjust adapt model later PackageExporter f e e intern e save_pickle model state_dict resnet state_dict src = dedent \ importlib torch_package_importer resources torchvision models resnet resnet load you want you can later edit how resnet constructed here edit model package while still loading original state dict weights r = resnet state_dict = resources load_pickle model state_dict r load_state_dict state_dict r e save_source_string model src is_package=True regardless how we chose package we can now use model server same way input = torch rand results = m f f m seek importer = PackageImporter m the_model = importer import_module model load r = the_model input results append r assertEqual results skipIfNoTorchVision test_script_resnet resnet = resnet f = BytesIO Option save pickling whole model + single-line similar torch jit save - more difficult edit code after model created PackageExporter f e e intern e save_pickle model pickled resnet f seek i = PackageImporter f loaded = i load_pickle model pickled Model should script successfully scripted = torch jit script loaded Scripted model should save load successfully f = BytesIO torch jit save scripted f f seek loaded = torch jit load f input = torch rand assertEqual loaded input resnet input __name__ == __main__ run_tests