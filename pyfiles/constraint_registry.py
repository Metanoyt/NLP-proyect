mypy allow-untyped-defs r PyTorch provides two global ` ConstraintRegistry ` objects link ` ~torch distributions constraints Constraint ` objects ` ~torch distributions transforms Transform ` objects These objects both input constraints transforms they have different guarantees bijectivity ` ` biject_to constraint ` ` looks up bijective ` ~torch distributions transforms Transform ` ` ` constraints real ` ` given ` ` constraint ` ` The returned transform guaranteed have ` ` bijective = True ` ` should implement ` ` log_abs_det_jacobian ` ` ` ` transform_to constraint ` ` looks up not-necessarily bijective ` ~torch distributions transforms Transform ` ` ` constraints real ` ` given ` ` constraint ` ` The returned transform guaranteed implement ` ` log_abs_det_jacobian ` ` The ` ` transform_to ` ` registry useful performing unconstrained optimization constrained parameters probability distributions which indicated each distribution s ` ` arg_constraints ` ` dict These transforms often overparameterize space order avoid rotation they thus more suitable coordinate-wise optimization algorithms like Adam loc = torch zeros requires_grad=True unconstrained = torch zeros requires_grad=True scale = transform_to Normal arg_constraints scale unconstrained loss = -Normal loc scale log_prob data sum The ` ` biject_to ` ` registry useful Hamiltonian Monte Carlo where samples probability distribution constrained ` ` support ` ` propagated unconstrained space algorithms typically rotation invariant dist = Exponential rate unconstrained = torch zeros requires_grad=True sample = biject_to dist support unconstrained potential_energy = -dist log_prob sample sum note An example where ` ` transform_to ` ` ` ` biject_to ` ` differ ` ` constraints simplex ` ` ` ` transform_to constraints simplex ` ` returns ` ~torch distributions transforms SoftmaxTransform ` simply exponentiates normalizes its inputs cheap mostly coordinate-wise operation appropriate algorithms like SVI In contrast ` ` biject_to constraints simplex ` ` returns ` ~torch distributions transforms StickBreakingTransform ` bijects its input down one-fewer-dimensional space more expensive less numerically stable transform needed algorithms like HMC The ` ` biject_to ` ` ` ` transform_to ` ` objects can extended user-defined constraints transforms using their ` ` register ` ` method either function singleton constraints transform_to register my_constraint my_transform decorator parameterized constraints transform_to register MyConstraintClass my_factory constraint assert isinstance constraint MyConstraintClass MyTransform constraint param constraint param You can create your own registry creating new ` ConstraintRegistry ` object torch distributions constraints transforms torch types _Number __all__ = ConstraintRegistry biject_to transform_to ConstraintRegistry Registry link constraints transforms __init__ _registry = super __init__ register constraint factory=None Registers ` ~torch distributions constraints Constraint ` subclass registry Usage my_registry register MyConstraintClass construct_transform constraint assert isinstance constraint MyConstraint MyTransform constraint arg_constraints Args constraint subclass ` ~torch distributions constraints Constraint ` A subclass ` ~torch distributions constraints Constraint ` singleton object desired factory Callable A callable inputs constraint object returns ` ~torch distributions transforms Transform ` object Support use decorator factory None lambda factory register constraint factory Support calling singleton instances isinstance constraint constraints Constraint constraint = type constraint isinstance constraint type issubclass constraint constraints Constraint raise TypeError f Expected constraint either Constraint subclass instance got constraint _registry constraint = factory factory __call__ constraint Looks up transform constrained space given constraint object Usage constraint = Normal arg_constraints scale scale = transform_to constraint torch zeros constrained u = transform_to constraint inv scale unconstrained Args constraint ` ~torch distributions constraints Constraint ` A constraint object Returns A ` ~torch distributions transforms Transform ` object Raises ` NotImplementedError ` no transform has been registered Look up Constraint subclass try factory = _registry type constraint except KeyError raise NotImplementedError f Cannot transform type constraint __name__ constraints None factory constraint biject_to = ConstraintRegistry transform_to = ConstraintRegistry ################################################################################ Registration Table ################################################################################ biject_to register constraints real transform_to register constraints real _transform_to_real constraint transforms identity_transform biject_to register constraints independent _biject_to_independent constraint base_transform = biject_to constraint base_constraint transforms IndependentTransform base_transform constraint reinterpreted_batch_ndims transform_to register constraints independent _transform_to_independent constraint base_transform = transform_to constraint base_constraint transforms IndependentTransform base_transform constraint reinterpreted_batch_ndims biject_to register constraints positive biject_to register constraints nonnegative transform_to register constraints positive transform_to register constraints nonnegative _transform_to_positive constraint transforms ExpTransform biject_to register constraints greater_than biject_to register constraints greater_than_eq transform_to register constraints greater_than transform_to register constraints greater_than_eq _transform_to_greater_than constraint transforms ComposeTransform transforms ExpTransform transforms AffineTransform constraint lower_bound biject_to register constraints less_than transform_to register constraints less_than _transform_to_less_than constraint transforms ComposeTransform transforms ExpTransform transforms AffineTransform constraint upper_bound - biject_to register constraints interval biject_to register constraints half_open_interval transform_to register constraints interval transform_to register constraints half_open_interval _transform_to_interval constraint Handle special case unit interval lower_is_ = isinstance constraint lower_bound _Number constraint lower_bound == upper_is_ = isinstance constraint upper_bound _Number constraint upper_bound == lower_is_ upper_is_ transforms SigmoidTransform loc = constraint lower_bound scale = constraint upper_bound - constraint lower_bound transforms ComposeTransform transforms SigmoidTransform transforms AffineTransform loc scale biject_to register constraints simplex _biject_to_simplex constraint transforms StickBreakingTransform transform_to register constraints simplex _transform_to_simplex constraint transforms SoftmaxTransform TODO define bijection LowerCholeskyTransform transform_to register constraints lower_cholesky _transform_to_lower_cholesky constraint transforms LowerCholeskyTransform transform_to register constraints positive_definite transform_to register constraints positive_semidefinite _transform_to_positive_definite constraint transforms PositiveDefiniteTransform biject_to register constraints corr_cholesky transform_to register constraints corr_cholesky _transform_to_corr_cholesky constraint transforms CorrCholeskyTransform biject_to register constraints cat _biject_to_cat constraint transforms CatTransform biject_to c c constraint cseq constraint dim constraint lengths transform_to register constraints cat _transform_to_cat constraint transforms CatTransform transform_to c c constraint cseq constraint dim constraint lengths biject_to register constraints stack _biject_to_stack constraint transforms StackTransform biject_to c c constraint cseq constraint dim transform_to register constraints stack _transform_to_stack constraint transforms StackTransform transform_to c c constraint cseq constraint dim