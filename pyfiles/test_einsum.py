Owner s module dynamo functools itertools unittest expectedFailure xfail skipIf skipif SkipTest pytest raises assert_raises torch _numpy np torch _numpy testing assert_ assert_allclose assert_almost_equal assert_array_equal assert_equal suppress_warnings torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests TestCase skip = functools partial skipif True Setup optimize einsum chars = abcdefghij sizes = np array global_size_dict = dict zip chars sizes instantiate_parametrized_tests TestEinsum TestCase test_einsum_errors do_opt True False Need enough arguments assert_raises TypeError IndexError ValueError np einsum optimize=do_opt assert_raises IndexError ValueError np einsum optimize=do_opt subscripts must string assert_raises AttributeError TypeError np einsum optimize=do_opt out parameter must array assert_raises TypeError np einsum out= test optimize=do_opt order parameter must valid order assert_raises NotImplementedError ValueError np einsum order= W optimize=do_opt casting parameter must valid casting assert_raises ValueError np einsum casting= blah optimize=do_opt dtype parameter must valid dtype assert_raises TypeError np einsum dtype= bad_data_type optimize=do_opt other keyword arguments rejected assert_raises TypeError np einsum bad_arg= optimize=do_opt issue revealed segfault call assert_raises RuntimeError TypeError np einsum None optimize=do_opt number operands must match count subscripts string assert_raises RuntimeError ValueError np einsum optimize=do_opt assert_raises RuntimeError ValueError np einsum optimize=do_opt assert_raises RuntimeError ValueError np einsum optimize=do_opt can t have more subscripts than dimensions operand assert_raises RuntimeError ValueError np einsum i optimize=do_opt assert_raises RuntimeError ValueError np einsum ij optimize=do_opt assert_raises RuntimeError ValueError np einsum i optimize=do_opt assert_raises RuntimeError ValueError np einsum i j optimize=do_opt assert_raises RuntimeError ValueError np einsum i optimize=do_opt assert_raises RuntimeError ValueError np einsum ij optimize=do_opt invalid ellipsis assert_raises RuntimeError ValueError np einsum i optimize=do_opt assert_raises RuntimeError ValueError np einsum i optimize=do_opt assert_raises RuntimeError ValueError np einsum j- j optimize=do_opt assert_raises RuntimeError ValueError np einsum j- j optimize=do_opt invalid subscript character assert_raises RuntimeError ValueError np einsum i optimize=do_opt assert_raises RuntimeError ValueError np einsum j$ optimize=do_opt assert_raises RuntimeError ValueError np einsum i- optimize=do_opt output subscripts must appear input assert_raises RuntimeError ValueError np einsum i- ij optimize=do_opt output subscripts may only specified once assert_raises RuntimeError ValueError np einsum ij- jij optimize=do_opt dimensions much match when being collapsed assert_raises RuntimeError ValueError np einsum ii np arange reshape optimize=do_opt assert_raises RuntimeError ValueError np einsum ii- i np arange reshape optimize=do_opt broadcasting new dimensions must enabled explicitly assert_raises RuntimeError ValueError np einsum i np arange reshape optimize=do_opt assert_raises RuntimeError ValueError np einsum i- i out=np arange reshape optimize=do_opt assert_raises RuntimeError ValueError match= b gh- - c erroneously appeared error message = np ones b = np ones np einsum aabcb abc b Check order kwarg asanyarray allows d pass through assert_raises NotImplementedError ValueError np einsum i- i np arange reshape - optimize=do_opt order= d xfail reason= view into smth test_einsum_views pass-through do_opt True False = np arange = reshape b = np einsum optimize=do_opt assert_ b tensor _base tensor b = np einsum Ellipsis optimize=do_opt assert_ b base b = np einsum ij optimize=do_opt assert_ b base assert_equal b b = np einsum optimize=do_opt assert_ b base assert_equal b output writeable whenever input writeable b = np einsum optimize=do_opt assert_ b flags WRITEABLE flags WRITEABLE = False b = np einsum optimize=do_opt assert_ b flags WRITEABLE transpose = np arange shape = b = np einsum ji optimize=do_opt assert_ b base assert_equal b T b = np einsum optimize=do_opt assert_ b base assert_equal b T diagonal = np arange shape = b = np einsum ii- i optimize=do_opt assert_ b base assert_equal b i i i range b = np einsum optimize=do_opt assert_ b base assert_equal b i i i range diagonal various ways broadcasting additional dimension = np arange shape = b = np einsum ii- i optimize=do_opt assert_ b base assert_equal b x i i i range x b = np einsum Ellipsis Ellipsis optimize=do_opt assert_ b base assert_equal b x i i i range x b = np einsum ii - i optimize=do_opt assert_ b base assert_equal b x i i i range x transpose b = np einsum Ellipsis Ellipsis optimize=do_opt assert_ b base assert_equal b x i i i range x transpose b = np einsum ii- i optimize=do_opt assert_ b base assert_equal b i i i range b = np einsum Ellipsis Ellipsis optimize=do_opt assert_ b base assert_equal b i i i range b = np einsum jii- ij optimize=do_opt assert_ b base assert_equal b i i i range b = np einsum optimize=do_opt assert_ b base assert_equal b i i i range b = np einsum ii - i optimize=do_opt assert_ b base assert_equal b transpose i i i range b = np einsum Ellipsis Ellipsis optimize=do_opt assert_ b base assert_equal b transpose i i i range b = np einsum i i- i optimize=do_opt assert_ b base assert_equal b transpose i i i range b = np einsum Ellipsis Ellipsis optimize=do_opt assert_ b base assert_equal b transpose i i i range b = np einsum i i- i optimize=do_opt assert_ b base assert_equal b x i i i range x transpose b = np einsum Ellipsis Ellipsis optimize=do_opt assert_ b base assert_equal b x i i i range x transpose triple diagonal = np arange shape = b = np einsum iii- i optimize=do_opt assert_ b base assert_equal b i i i i range b = np einsum optimize=do_opt assert_ b base assert_equal b i i i i range swap axes = np arange shape = b = np einsum ijk- jik optimize=do_opt assert_ b base assert_equal b swapaxes b = np einsum optimize=do_opt assert_ b base assert_equal b swapaxes np _no_nep _warning check_einsum_sums dtype do_opt=False dtype = np dtype dtype Check various sums Does many sizes exercise unrolled loops sum axis=- n range = np arange n dtype=dtype assert_equal np einsum i- optimize=do_opt np sum axis=- astype dtype assert_equal np einsum optimize=do_opt np sum axis=- astype dtype n range = np arange n dtype=dtype reshape n assert_equal np einsum i- optimize=do_opt np sum axis=- astype dtype assert_equal np einsum Ellipsis Ellipsis optimize=do_opt np sum axis=- astype dtype sum axis= n range = np arange n dtype=dtype reshape n assert_equal np einsum i - optimize=do_opt np sum axis= astype dtype assert_equal np einsum Ellipsis Ellipsis optimize=do_opt np sum axis= astype dtype n range = np arange n dtype=dtype reshape n assert_equal np einsum i - optimize=do_opt np sum axis= astype dtype assert_equal np einsum Ellipsis Ellipsis optimize=do_opt np sum axis= astype dtype trace n range = np arange n n dtype=dtype reshape n n assert_equal np einsum ii optimize=do_opt np trace astype dtype assert_equal np einsum optimize=do_opt torch np trace astype dtype gh- should accept numpy int type subscript list np_array = np asarray assert_equal np einsum np_array optimize=do_opt np trace astype dtype assert_equal np einsum list np_array optimize=do_opt np trace astype dtype multiply b assert_equal np einsum scalar case n range = np arange n dtype=dtype reshape n b = np arange n dtype=dtype reshape n assert_equal np einsum b optimize=do_opt np multiply b assert_equal np einsum Ellipsis b Ellipsis optimize=do_opt np multiply b inner b n range = np arange n dtype=dtype reshape n b = np arange n dtype=dtype assert_equal np einsum i i b optimize=do_opt np inner b assert_equal np einsum Ellipsis b Ellipsis optimize=do_opt np inner b n range = np arange n dtype=dtype reshape n b = np arange n dtype=dtype assert_equal np einsum i i b optimize=do_opt np inner T b T T assert_equal np einsum Ellipsis b Ellipsis optimize=do_opt np inner T b T T outer b n range = np arange dtype=dtype + b = np arange n dtype=dtype + assert_equal np einsum i j b optimize=do_opt np outer b assert_equal np einsum b optimize=do_opt np outer b Suppress complex warnings f tests suppress_warnings matvec b dot b where matrix b vector n range = np arange n dtype=dtype reshape n b = np arange n dtype=dtype assert_equal np einsum ij j b optimize=do_opt np dot b assert_equal np einsum b optimize=do_opt np dot b c = np arange dtype=dtype np einsum ij j b out=c dtype= f casting= unsafe optimize=do_opt assert_equal c np dot astype f b astype f astype dtype c = np einsum b out=c dtype= f casting= unsafe optimize=do_opt assert_equal c np dot astype f b astype f astype dtype n range = np arange n dtype=dtype reshape n b = np arange n dtype=dtype assert_equal np einsum ji j T b T optimize=do_opt np dot b T T assert_equal np einsum T b T optimize=do_opt np dot b T T c = np arange dtype=dtype np einsum ji j T b T out=c dtype= f casting= unsafe optimize=do_opt assert_equal c np dot b T astype f T astype f astype dtype c = np einsum T b T out=c dtype= f casting= unsafe optimize=do_opt assert_equal c np dot b T astype f T astype f astype dtype matmat b dot b where matrix b matrix n range n dtype = f = np arange n dtype=dtype reshape n b = np arange n dtype=dtype reshape n assert_equal np einsum ij jk b optimize=do_opt np dot b assert_equal np einsum b optimize=do_opt np dot b n range = np arange n dtype=dtype reshape n b = np arange n dtype=dtype reshape n c = np arange dtype=dtype reshape np einsum ij jk b out=c dtype= f casting= unsafe optimize=do_opt assert_equal c np dot astype f b astype f astype dtype c = np einsum b out=c dtype= f casting= unsafe optimize=do_opt assert_equal c np dot astype f b astype f astype dtype matrix triple product note currently efficient way multiply matrices = np arange dtype=dtype reshape b = np arange dtype=dtype reshape c = np arange dtype=dtype reshape dtype = f assert_equal np einsum ij jk kl b c optimize=do_opt dot b dot c assert_equal np einsum b c optimize=do_opt dot b dot c d = np arange dtype=dtype reshape np einsum ij jk kl b c out=d dtype= f casting= unsafe optimize=do_opt tgt = astype f dot b astype f tgt = tgt dot c astype f astype dtype assert_equal d tgt d = np einsum b c out=d dtype= f casting= unsafe optimize=do_opt tgt = astype f dot b astype f tgt = tgt dot c astype f astype dtype assert_equal d tgt tensordot b np dtype dtype = np dtype f = np arange dtype=dtype reshape b = np arange dtype=dtype reshape assert_equal np einsum ijk jil - kl b np tensordot b axes= assert_equal np einsum b np tensordot b axes= c = np arange dtype=dtype reshape np einsum ijk jil- kl b out=c dtype= f casting= unsafe optimize=do_opt assert_equal c np tensordot astype f b astype f axes= astype dtype c = np einsum b out=c dtype= f casting= unsafe optimize=do_opt assert_equal c np tensordot astype f b astype f axes= astype dtype logical_and logical_and = b = c = neg_val = - dtype kind = u np iinfo dtype max - = np array neg_val dtype=dtype b = np array neg_val dtype=dtype c = np array True True False True True False True True assert_equal np einsum i i i- i b c dtype= casting= unsafe optimize=do_opt np logical_and np logical_and = b = c = assert_equal np einsum b c dtype= casting= unsafe np logical_and np logical_and = b = c = = np arange dtype=dtype assert_equal np einsum i- np sum assert_equal np einsum np sum assert_equal np einsum i - np sum assert_equal np einsum np sum Various stride contiguous SSE aligned variants n range = np arange n dtype=dtype np dtype dtype itemsize assert_equal np einsum optimize=do_opt np multiply assert_equal np einsum i i optimize=do_opt np dot assert_equal np einsum i - i optimize=do_opt assert_equal np einsum i- i optimize=do_opt assert_equal np einsum i - optimize=do_opt np sum assert_equal np einsum i- optimize=do_opt np sum assert_equal np einsum - optimize=do_opt np multiply - assert_equal np einsum i i - optimize=do_opt np dot - assert_equal np einsum i - i optimize=do_opt assert_equal np einsum i- i optimize=do_opt assert_equal np einsum i - optimize=do_opt np sum assert_equal np einsum i- optimize=do_opt np sum An object array summed data type = np arange dtype=object b = np einsum i- dtype=dtype casting= unsafe assert_equal b np sum assert_equal b dtype np dtype dtype b = np einsum dtype=dtype casting= unsafe assert_equal b np sum assert_equal b dtype np dtype dtype A case which failing ticket p = np arange + q = np arange reshape + r = np arange reshape + assert_equal np einsum z mz zm- p q r singleton dimensions broadcast gh- p = np ones q = np ones assert_array_equal np einsum ij ij- j p q optimize=True np einsum ij ij- j p q optimize=False assert_array_equal np einsum ij ij- j p q optimize=True blas-compatible contraction broadcasting case which failing optimize=True ticket x = np array y = np array assert_array_equal np einsum i i x y optimize=False assert_array_equal np einsum i i x y optimize=True all-ones array bypassing bug ticket p = np ones q = np ones optimize True False assert_array_equal np einsum ij jk- ik p p optimize=optimize np einsum ij jk- ik p q optimize=optimize assert_array_equal np einsum ij jk- ik p q optimize=optimize np full Cases which failing gh- x = np eye dtype=dtype y = np ones dtype=dtype assert_array_equal np einsum ji i- x y optimize=optimize contig_contig_outstride _two assert_array_equal np einsum i ij- y x optimize=optimize stride _contig_outstride _two assert_array_equal np einsum ij i- x y optimize=optimize contig_stride _outstride _two xfail reason= int overflow differs numpy pytorch test_einsum_sums_int check_einsum_sums i xfail reason= int overflow differs numpy pytorch test_einsum_sums_uint check_einsum_sums u xfail reason= int overflow differs numpy pytorch test_einsum_sums_int check_einsum_sums i test_einsum_sums_int check_einsum_sums i check_einsum_sums i True test_einsum_sums_int check_einsum_sums i xfail reason= np float == test_einsum_sums_float check_einsum_sums f test_einsum_sums_float check_einsum_sums f test_einsum_sums_float check_einsum_sums f check_einsum_sums f True test_einsum_sums_cfloat check_einsum_sums c check_einsum_sums c True test_einsum_sums_cfloat check_einsum_sums c test_einsum_misc This call used crash because bug PyArray_AssignZero = np ones b = np ones assert_equal np einsum ij j - i b assert_equal np einsum ij j - i b optimize=True Regression test issue test unicode inputs Python assert_equal np einsum ij j - i b assert_equal np einsum i i assert_equal np einsum i i optimize= greedy The iterator had issue buffering reduction = np ones np int b = np ones np int assert_equal np einsum ijklm ijn ijn- b b np einsum ijklm ijn- b assert_equal np einsum ijklm ijn ijn- b b optimize=True np einsum ijklm ijn- b optimize=True Issue problem contiguous -argument inner loop implementation = np arange b = np arange reshape c = np arange reshape assert_equal np einsum x yx zx- xzy b c assert_equal np einsum x yx zx- xzy b c optimize=True Ensure explicitly setting out=None does cause error see issue gh- issue gh- assert_equal np einsum i j out=None test_subscript_range Issue make sure all letters Latin alphabet both uppercase lowercase can used when creating subscript arrays = np ones b = np ones np einsum b optimize=False np einsum b optimize=False np einsum b optimize=False assert_raises ValueError lambda np einsum b optimize=False assert_raises ValueError lambda np einsum - b - optimize=False test_einsum_broadcast Issue change handling ellipsis remove middle broadcast error only use RIGHT iteration prepare_op_axes adds auto broadcast left where belongs broadcast right has explicit We need test optimized parsing well A = np arange reshape B = np arange ref = np einsum ijk j- ijk A B optimize=False opt True False assert_equal np einsum ij j - ij A B optimize=opt ref assert_equal np einsum ij j- ij A B optimize=opt ref assert_equal np einsum ij j- ij A B optimize=opt ref used raise error A = np arange reshape B = np arange reshape ref = np einsum ik kj- ij A B optimize=False opt True False assert_equal np einsum ik k - i A B optimize=opt ref assert_equal np einsum ik kj- i j A B optimize=opt ref assert_equal np einsum k kj A B optimize=opt ref used raise error assert_equal np einsum ik k - i A B optimize=opt ref used raise error dims = = np arange np prod dims reshape dims v = np arange dims ref = np einsum ijkl k- ijl v optimize=False opt True False assert_equal np einsum ijkl k v optimize=opt ref assert_equal np einsum kl k v optimize=opt ref used raise error assert_equal np einsum kl k v optimize=opt ref J K M = A = np arange J K M reshape J K M B = np arange J K M reshape J K M ref = np einsum lmn lmno- o A B optimize=False opt True False assert_equal np einsum lmn lmno- o A B optimize=opt ref used raise error test_einsum_fixedstridebug Issue obscure einsum bug This case revealed bug nditer where reported stride fixed when fact fixed during processing The reason bug check fixed stride using information D inner loop reuse restrict iteration dimensions had validate same D inner loop reuse logic only triggered during buffer copying step hence invalid rely those values The fix check all dimensions stride question which test case reveals stride fixed NOTE This test triggered fact default buffersize used einsum = larger than results mismatch between buffering striding operand A A = np arange reshape astype np float B = np arange reshape astype np int es = np einsum cl cpx- lpx A B tp = np tensordot A B axes= assert_equal es tp The following original test case bug report made repeatable changing random arrays aranges A = np arange reshape astype np float B = np arange reshape astype np float es = np einsum cl cpxy- lpxy A B tp = np tensordot A B axes= assert_equal es tp test_einsum_fixed_collapsingbug Issue The bug only occurred when output argument einssum used x = np random normal y = np zeros np einsum aabb- ab x out=y idx = np arange y = x idx None idx None idx idx assert_equal y y test_einsum_failed_on_p _and_s x Issues gh- gh- Bug signed vs unsigned char errored power s x Linux tensor = np random random_sample x = np einsum ijij- tensor y = tensor trace axis = axis = trace assert_allclose x y xfail reason= no base test_einsum_all_contig_non_contig_output Issue gh- tests all contiguous special case actually checks contiguity output x = np ones out = np ones correct_base = np ones correct_base = Always worked inner iteration done -stride np einsum mi mi mi- m x x x out=out assert_array_equal out base correct_base Example out = np ones np einsum im im im- m x x x out=out assert_array_equal out base correct_base Example buffering causes x contiguous special cases do catch operation before out = np ones correct_base = np ones correct_base = x = np ones np float np einsum ij jk- ik x x out=out assert_array_equal out base correct_base parametrize dtype np typecodes AllFloat + np typecodes AllInteger test_different_paths dtype Test originally added cover broken float path gh- Likely most covered elsewhere least partially dtype = np dtype dtype Simple test designed exercise most specialized code paths note + floats This makes sure we use float value where results must exact arr = np arange + astype dtype scalar = np array dtype=dtype contig - scalar res = np einsum i- arr assert res == arr sum contig contig - contig res = np einsum i i- i arr arr assert_array_equal res arr arr noncontig noncontig - contig res = np einsum i i- i arr repeat arr repeat assert_array_equal res arr arr contig + contig - scalar assert np einsum i i- arr arr == arr arr sum contig + scalar - contig out out = np ones dtype=dtype res = np einsum i - i arr dtype type out=out assert_array_equal res arr dtype type scalar + contig - contig out res = np einsum i- i scalar arr assert_array_equal res arr dtype type scalar + contig - scalar res = np einsum i- scalar arr Use einsum compare have difference due sum round-offs assert res == np einsum i- scalar arr contig + scalar - scalar res = np einsum i - arr scalar Use einsum compare have difference due sum round-offs assert res == np einsum i- scalar arr contig + contig + contig - scalar dtype e B b FIXME make xfail raise SkipTest overflow differs pytorch numpy arr = np array dtype=dtype res = np einsum i i i- arr arr arr assert_array_equal res arr arr arr sum four arrays res = np einsum i i i i- arr arr arr arr assert_array_equal res arr arr arr arr sum test_small_boolean_arrays See gh- Use array True embedded False = np zeros dtype=np bool_ = True out = np zeros dtype=np bool_ tgt = np ones dtype=np bool_ res = np einsum ij jk- ik out=out assert_equal res tgt test_out_is_res = np arange reshape res = np einsum ij jk- ik out=a assert res optimize_compare subscripts operands=None Tests all paths optimization function against conventional einsum operands None args = subscripts terms = subscripts split - split term terms dims = global_size_dict x x term args append np random rand dims args = subscripts + operands noopt = np einsum args optimize=False opt = np einsum args optimize= greedy assert_almost_equal opt noopt opt = np einsum args optimize= optimal assert_almost_equal opt noopt test_hadamard_like_products Hadamard outer products optimize_compare ab abc- abc optimize_compare b ab- ab test_index_transformations Simple index transformation cases optimize_compare ea fb gc hd abcd- efgh optimize_compare ea fb abcd gc hd- efgh optimize_compare abcd ea fb gc hd- efgh test_complex Long test cases optimize_compare acdf jbje gihb hfac gfac gifabc hfac optimize_compare acdf jbje gihb hfac gfac gifabc hfac optimize_compare cd bdhe aidb hgca gc hgibcd hgac optimize_compare abhe hidj jgba hiab gab optimize_compare bde cdh agdb hica ibd hgicd hiac optimize_compare chd bde agbc hiad hgc hgi hiad optimize_compare chd bde agbc hiad bdi cgh agdb optimize_compare bdhe acad hiab agac hibd test_collapse Inner products optimize_compare ab ab c- optimize_compare ab ab c- c optimize_compare ab ab cd cd- optimize_compare ab ab cd cd- ac optimize_compare ab ab cd cd- cd optimize_compare ab ab cd cd ef ef- test_expand Outer products optimize_compare ab cd ef- abcdef optimize_compare ab cd ef- acdf optimize_compare ab cd de- abcde optimize_compare ab cd de- optimize_compare ab bcd cd- abcd optimize_compare ab bcd cd- abd test_edge_cases Difficult edge cases optimization optimize_compare eb cb fb- cef optimize_compare dd fb cdb- cef optimize_compare bca cdb dbf afc- optimize_compare dcc fce ea dbf- ab optimize_compare fdf cdd ccd afe- ae optimize_compare abcd ad optimize_compare ed fcd ff bcf- optimize_compare baa dcf af cde- optimize_compare bd db eac- ace optimize_compare fff fae bef def- abd optimize_compare efc dbc acf fd- abe optimize_compare ba ac da- bcd test_inner_product Inner products optimize_compare ab ab optimize_compare ab ba optimize_compare abc abc optimize_compare abc bac optimize_compare abc cba test_random_cases Randomly built test cases optimize_compare aab fa df ecc- bde optimize_compare ecb fef bad ed- ac optimize_compare bcf bbb fbf fc- optimize_compare bb ff be- e optimize_compare bcb bb fc fff- optimize_compare fbb dfd fc fc- optimize_compare afd ba cc dc- bf optimize_compare adb bc fa cfc- d optimize_compare bbd bda fc db- acf optimize_compare dba ead cad- bce optimize_compare aef fbc dca- bde test_combined_views_mapping gh- = np arange reshape b = np einsum bbcdc- d assert_equal b test_broadcasting_dot_cases Ensures broadcasting cases mistaken GEMM = np random rand b = np random rand c = np random rand d = np random rand optimize_compare ijk kl jl operands= b c optimize_compare ijk kl jl i- i operands= b c d e = np random rand f = np random rand optimize_compare abjk kl jl operands= e b c optimize_compare abjk kl jl ab- ab operands= e b c f Edge case found gh- g = np arange reshape optimize_compare obk ijk- ioj operands= g g xfail reason= order= F supported test_output_order Ensure output order respected optimize cases below contraction should yield reshaped tensor view gh- = np ones order= F b = np ones order= F opt True False tmp = np einsum ft mf- mt b order= optimize=opt assert_ tmp flags f_contiguous tmp = np einsum ft mf- mt b order= f optimize=opt assert_ tmp flags f_contiguous tmp = np einsum ft mf- mt b order= c optimize=opt assert_ tmp flags c_contiguous tmp = np einsum ft mf- mt b order= k optimize=opt assert_ tmp flags c_contiguous False assert_ tmp flags f_contiguous False tmp = np einsum ft mf- mt b optimize=opt assert_ tmp flags c_contiguous False assert_ tmp flags f_contiguous False c = np ones order= C opt True False tmp = np einsum ft mf- mt c order= optimize=opt assert_ tmp flags c_contiguous d = np ones order= C opt True False tmp = np einsum ft mf- mt d c order= optimize=opt assert_ tmp flags c_contiguous skip reason= no pytorch analog TestEinsumPath TestCase build_operands string size_dict=global_size_dict Builds views based off initial operands operands = string terms = string split - split term terms dims = size_dict x x term operands append np random rand dims operands assert_path_equal comp benchmark Checks list tuples equivalent ret = len comp == len benchmark assert_ ret pos range len comp - ret = isinstance comp pos + tuple ret = comp pos + == benchmark pos + assert_ ret test_memory_contraints Ensure memory constraints satisfied outer_test = build_operands b c- abc path path_str = np einsum_path outer_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path outer_test optimize= optimal assert_path_equal path einsum_path long_test = build_operands acdf jbje gihb hfac path path_str = np einsum_path long_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path long_test optimize= optimal assert_path_equal path einsum_path test_long_paths Long complex cases Long test long_test = build_operands acdf jbje gihb hfac gfac gifabc hfac path path_str = np einsum_path long_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path long_test optimize= optimal assert_path_equal path einsum_path Long test long_test = build_operands chd bde agbc hiad bdi cgh agdb path path_str = np einsum_path long_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path long_test optimize= optimal assert_path_equal path einsum_path test_edge_paths Difficult edge cases Edge test edge_test = build_operands eb cb fb- cef path path_str = np einsum_path edge_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path edge_test optimize= optimal assert_path_equal path einsum_path Edge test edge_test = build_operands dd fb cdb- cef path path_str = np einsum_path edge_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path edge_test optimize= optimal assert_path_equal path einsum_path Edge test edge_test = build_operands bca cdb dbf afc- path path_str = np einsum_path edge_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path edge_test optimize= optimal assert_path_equal path einsum_path Edge test edge_test = build_operands dcc fce ea dbf- ab path path_str = np einsum_path edge_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path edge_test optimize= optimal assert_path_equal path einsum_path Edge test edge_test = build_operands ac ab ad cd bd bc- size_dict= b c d path path_str = np einsum_path edge_test optimize= greedy assert_path_equal path einsum_path path path_str = np einsum_path edge_test optimize= optimal assert_path_equal path einsum_path test_path_type_input Test explicit path handling path_test = build_operands dcc fce ea dbf- ab path path_str = np einsum_path path_test optimize=False assert_path_equal path einsum_path path path_str = np einsum_path path_test optimize=True assert_path_equal path einsum_path exp_path = einsum_path path path_str = np einsum_path path_test optimize=exp_path assert_path_equal path exp_path Double check einsum works input path noopt = np einsum path_test optimize=False opt = np einsum path_test optimize=exp_path assert_almost_equal noopt opt test_path_type_input_internal_trace gh- path_test = build_operands cab cdd- ab exp_path = einsum_path path path_str = np einsum_path path_test optimize=exp_path assert_path_equal path exp_path Double check einsum works input path noopt = np einsum path_test optimize=False opt = np einsum path_test optimize=exp_path assert_almost_equal noopt opt test_path_type_input_invalid path_test = build_operands ab bc cd de- ae exp_path = einsum_path assert_raises RuntimeError np einsum path_test optimize=exp_path assert_raises RuntimeError np einsum_path path_test optimize=exp_path path_test = build_operands a- exp_path = einsum_path assert_raises RuntimeError np einsum path_test optimize=exp_path assert_raises RuntimeError np einsum_path path_test optimize=exp_path test_spaces gh- arr = np array sp itertools product repeat= no error any spacing np einsum - format sp arr TestMisc TestCase test_overlap = np arange dtype=int reshape b = np arange dtype=int reshape d = np dot b sanity check c = np einsum ij jk- ik b assert_equal c d gh- out overlaps one operands c = np einsum ij jk- ik b out=b assert_equal c d __name__ == __main__ run_tests