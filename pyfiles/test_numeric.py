Owner s module dynamo functools itertools math platform sys warnings numpy pytest IS_WASM = False HAS_REFCOUNT = True operator unittest expectedFailure xfail skipIf skipif SkipTest hypothesis given strategies st hypothesis extra numpy hynp pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests subtest TEST_WITH_TORCHDYNAMO TestCase xfailIfTorchDynamo xpassIfTorchDynamo_np If we going trace through these we should use NumPy If testing eager mode we use torch _numpy TEST_WITH_TORCHDYNAMO numpy np numpy random rand randint randn numpy testing assert_ assert_allclose assert_almost_equal assert_array_almost_equal assert_array_equal assert_equal assert_warns assert_array_max_ulp HAS_REFCOUNT IS_WASM torch _numpy np torch _numpy random rand randint randn torch _numpy testing assert_ assert_allclose assert_almost_equal assert_array_almost_equal assert_array_equal assert_equal assert_warns assert_array_max_ulp HAS_REFCOUNT IS_WASM skip = functools partial skipif True instantiate_parametrized_tests TestResize TestCase test_copies A = np array Ar = np array assert_equal np resize A Ar Ar = np array assert_equal np resize A Ar Ar = np array assert_equal np resize A Ar test_repeats A = np array Ar = np array assert_equal np resize A Ar Ar = np array assert_equal np resize A Ar Ar = np array assert_equal np resize A Ar test_zeroresize A = np array Ar = np resize A assert_array_equal Ar np array assert_equal A dtype Ar dtype Ar = np resize A assert_equal Ar shape Ar = np resize A assert_equal Ar shape test_reshape_from_zero See also gh- A = np zeros dtype=np float Ar = np resize A assert_array_equal Ar np zeros Ar dtype assert_equal A dtype Ar dtype test_negative_resize A = np arange dtype=np float new_shape = - - pytest raises RuntimeError ValueError np resize A new_shape=new_shape instantiate_parametrized_tests TestNonarrayArgs TestCase check non-array arguments functions wrap them arrays test_choose choices = tgt = = out = np choose choices assert_equal out tgt test_clip arr = - - - out = np clip arr tgt = assert_equal out tgt xpassIfTorchDynamo_np reason= TODO implement compress test_compress arr = tgt = out = np compress arr axis= assert_equal out tgt test_count_nonzero arr = tgt = np array out = np count_nonzero arr axis= assert_equal out tgt test_cumproduct A = assert_ np all np cumprod A == np array test_diagonal = out = np diagonal tgt = assert_equal out tgt test_mean A = assert_ np mean A == assert_ np all np mean A == np array assert_ np all np mean A == np array warnings catch_warnings record=True w warnings filterwarnings always RuntimeWarning assert_ np isnan np mean assert_ w category RuntimeWarning test_ptp = - - assert_equal np ptp axis= test_prod arr = tgt = assert_equal np prod arr axis=- tgt test_ravel = tgt = assert_equal np ravel tgt test_repeat = tgt = out = np repeat assert_equal out tgt test_reshape arr = tgt = assert_equal np reshape arr tgt test_round arr = tgt = assert_equal np around arr decimals= tgt s = np float assert_equal s round test_round_ s = np float assert_ isinstance s round np float np ndarray xpassIfTorchDynamo_np reason= scalar instances parametrize dtype np int np int np int np int np uint np float np float np float test_dunder_round dtype s = dtype assert_ isinstance round s int assert_ isinstance round s None int assert_ isinstance round s ndigits=None int assert_equal round s assert_equal round s None assert_equal round s ndigits=None parametrize val ndigits pytest param - - marks=pytest mark xfail reason= Out range int subtest - - decorators= xpassIfTorchDynamo_np subtest - - math ceil math log - decorators= xpassIfTorchDynamo_np subtest - -math ceil math log - decorators= xpassIfTorchDynamo_np test_dunder_round_edgecases val ndigits assert_equal round val ndigits round np int val ndigits xfail reason= scalar instances test_dunder_round_accuracy f = np float assert_ isinstance round f - np float assert_array_max_ulp round f - assert_ isinstance round f ndigits=- np float assert_array_max_ulp round f ndigits=- i = np int assert_ isinstance round i - np int assert_array_max_ulp round i - assert_ isinstance round i ndigits=- np int assert_array_max_ulp round i ndigits=- xfail raises=AssertionError reason= gh- test_round_py_consistency f = assert_equal round np float f - round f - test_searchsorted arr = - - - out = np searchsorted arr assert_equal out test_size A = assert_ np size A == assert_ np size A == assert_ np size A == test_squeeze A = assert_equal np squeeze A shape assert_equal np squeeze np zeros shape assert_equal np squeeze np zeros axis= shape assert_equal np squeeze np zeros axis=- shape assert_equal np squeeze np zeros axis= shape assert_equal np squeeze np zeros shape assert_equal np squeeze np zeros axis= shape assert_equal np squeeze np zeros axis= shape assert_equal np squeeze np zeros axis=- shape test_std A = assert_almost_equal np std A assert_almost_equal np std A np array assert_almost_equal np std A np array warnings catch_warnings record=True w warnings filterwarnings always RuntimeWarning assert_ np isnan np std assert_ w category RuntimeWarning test_swapaxes tgt = = out = np swapaxes assert_equal out tgt test_sum m = tgt = out = np sum m axis= keepdims=True assert_equal tgt out test_take tgt = indices = = out = np take indices assert_equal out tgt test_trace c = assert_equal np trace c test_transpose arr = tgt = assert_equal np transpose arr tgt test_var A = assert_almost_equal np var A assert_almost_equal np var A np array assert_almost_equal np var A np array warnings catch_warnings record=True w warnings filterwarnings always RuntimeWarning assert_ np isnan np var assert_ w category RuntimeWarning xfail reason= TODO TestIsscalar TestCase test_isscalar assert_ np isscalar assert_ np isscalar np int assert_ np isscalar False assert_ np isscalar numpy assert_ np isscalar assert_ np isscalar None PEP fractions Fraction assert_ np isscalar Fraction numbers Number assert_ np isscalar Number TestBoolScalar TestCase test_logical f = np False_ t = np True_ s = xyz assert_ t s s assert_ f s f test_bitwise_or_eq f = np False_ t = np True_ assert_ t &#124; t == t assert_ f &#124; t == t assert_ t &#124; f == t assert_ f &#124; f == f test_bitwise_or_is f = np False_ t = np True_ assert_ bool t &#124; t bool t assert_ bool f &#124; t bool t assert_ bool t &#124; f bool t assert_ bool f &#124; f bool f test_bitwise_and_eq f = np False_ t = np True_ assert_ t t == t assert_ f t == f assert_ t f == f assert_ f f == f test_bitwise_and_is f = np False_ t = np True_ assert_ bool t t bool t assert_ bool f t bool f assert_ bool t f bool f assert_ bool f f bool f test_bitwise_xor_eq f = np False_ t = np True_ assert_ t ^ t == f assert_ f ^ t == t assert_ t ^ f == t assert_ f ^ f == f test_bitwise_xor_is f = np False_ t = np True_ assert_ bool t ^ t bool f assert_ bool f ^ t bool t assert_ bool t ^ f bool t assert_ bool f ^ f bool f TestBoolArray TestCase setUp super setUp offset simd tests t = np array True dtype=bool f = np array False dtype=bool o = np array False dtype=bool nm = f copy im = t copy nm = True nm - = True im = False im - = False test_all_any assert_ t all assert_ t any assert_ f all assert_ f any assert_ nm any assert_ im any assert_ nm all assert_ im all check bad element all positions i range - d = np array False dtype=bool d i = True assert_ np any d e = np array True dtype=bool e i = False assert_ np all e assert_array_equal e ~d big array test blocked libc loops i list range + - d = np array False dtype=bool d i = True assert_ np any d msg=f i r e = np array True dtype=bool e i = False assert_ np all e msg=f i r test_logical_not_abs assert_array_equal ~self t f assert_array_equal np abs ~self t f assert_array_equal np abs ~self f t assert_array_equal np abs f f assert_array_equal ~np abs f t assert_array_equal ~np abs t f assert_array_equal np abs ~self nm im np logical_not t out=self o assert_array_equal o f np abs t out=self o assert_array_equal o t test_logical_and_or_xor assert_array_equal t &#124; t t assert_array_equal f &#124; f f assert_array_equal t &#124; f t assert_array_equal f &#124; t t np logical_or t t out=self o assert_array_equal o t assert_array_equal t t t assert_array_equal f f f assert_array_equal t f f assert_array_equal f t f np logical_and t t out=self o assert_array_equal o t assert_array_equal t ^ t f assert_array_equal f ^ f f assert_array_equal t ^ f t assert_array_equal f ^ t t np logical_xor t t out=self o assert_array_equal o f assert_array_equal nm t nm assert_array_equal im f False assert_array_equal nm True nm assert_array_equal im False f assert_array_equal nm &#124; t t assert_array_equal im &#124; f im assert_array_equal nm &#124; True t assert_array_equal im &#124; False im assert_array_equal nm ^ t im assert_array_equal im ^ f im assert_array_equal nm ^ True im assert_array_equal im ^ False im xfailIfTorchDynamo TestBoolCmp TestCase setUp super setUp f = np ones dtype=np float ef = np ones f size dtype=bool d = np ones dtype=np float ed = np ones d size dtype=bool generate values all permutation bit simd vectors s = i range f s s + = i x x range ef s s + = i x = x range s += s = i range d s s + = i x x range ed s s + = i x = x range s += nf = f copy nd = d copy nf ef = np nan nd ed = np nan inff = f copy infd = d copy inff ef = np inf infd ed = np inf inff ef = -np inf infd ed = -np inf inff ef = np nan infd ed = np nan efnonan = ef copy efnonan = False ednonan = ed copy ednonan = False signf = f copy signd = d copy signf ef = - signd ed = - signf ef = -np inf signd ed = -np inf signf ef = -np nan signd ed = -np nan signf ef = - signd ed = - test_float offset alignment test i range assert_array_equal f i ef i assert_array_equal f i - = ef i assert_array_equal f i == ~self ef i assert_array_equal -self f i ef i assert_array_equal -self f i + = ef i r = f i = assert_array_equal r ef i r = f i = np zeros_like f i r = = f i assert_array_equal r r assert_array_equal r r check bool == x assert_array_equal r view np int r astype np int assert_array_equal r view np int r astype np int assert_array_equal r view np int r astype np int isnan amd takes same code path assert_array_equal np isnan nf i ef i assert_array_equal np isfinite nf i ~self ef i assert_array_equal np isfinite inff i ~self ef i assert_array_equal np isinf inff i efnonan i assert_array_equal np signbit signf i ef i test_double offset alignment test i range assert_array_equal d i ed i assert_array_equal d i - = ed i assert_array_equal d i == ~self ed i assert_array_equal -self d i ed i assert_array_equal -self d i + = ed i r = d i = assert_array_equal r ed i r = d i = np zeros_like d i r = = d i assert_array_equal r r assert_array_equal r r check bool == x assert_array_equal r view np int r astype np int assert_array_equal r view np int r astype np int assert_array_equal r view np int r astype np int isnan amd takes same code path assert_array_equal np isnan nd i ed i assert_array_equal np isfinite nd i ~self ed i assert_array_equal np isfinite infd i ~self ed i assert_array_equal np isinf infd i ednonan i assert_array_equal np signbit signd i ed i xpassIfTorchDynamo_np reason= TODO TestSeterr TestCase test_default err = np geterr assert_equal err dict divide= warn invalid= warn over= warn under= ignore test_set err = np seterr old = np seterr divide= print assert_ err == old new = np seterr assert_ new divide == print np seterr over= raise assert_ np geterr over == raise assert_ new divide == print np seterr old assert_ np geterr == old xfail skipif IS_WASM reason= no wasm fp exception support skipif platform machine == armv tel reason= See gh- test_divide_err assert_raises FloatingPointError np array np array np seterr divide= ignore np array np array skipif IS_WASM reason= no wasm fp exception support test_errobj olderrobj = np geterrobj called = try warnings catch_warnings record=True w warnings simplefilter always np seterrobj None np array np array assert_equal len w log_err args called += extobj_err = args assert_ len extobj_err == assert_ divide extobj_err np seterrobj log_err np array np array assert_equal called np seterrobj olderrobj np divide extobj= log_err assert_equal called finally np seterrobj olderrobj del called xfail reason= TODO instantiate_parametrized_tests TestFloatExceptions TestCase assert_raises_fpe fpeerr flop x y ftype = type x try flop x y assert_ False f Type ftype did raise fpe error fpeerr except FloatingPointError exc assert_ str exc find fpeerr = f Type ftype raised wrong fpe error exc assert_op_raises_fpe fpeerr flop sc sc Check fpe exception raised Given floating operation ` flop ` two scalar values check operation raises floating point exception specified ` fpeerr ` Tests all variants -d array scalars well assert_raises_fpe fpeerr flop sc sc assert_raises_fpe fpeerr flop sc sc assert_raises_fpe fpeerr flop sc sc assert_raises_fpe fpeerr flop sc sc Test all real complex float types skipif IS_WASM reason= no wasm fp exception support parametrize typecode np typecodes AllFloat test_floating_exceptions typecode Test basic arithmetic function errors ftype = np dtype typecode type np dtype ftype kind == f Get some extreme values type fi = np finfo ftype ft_tiny = fi _machar tiny ft_max = fi max ft_eps = fi eps underflow = underflow divbyzero = divide zero c complex corresponding real dtype rtype = type ftype real fi = np finfo rtype ft_tiny = ftype fi _machar tiny ft_max = ftype fi max ft_eps = ftype fi eps The complex types raise different exceptions underflow = divbyzero = overflow = overflow invalid = invalid The value tiny double double NaN so we need pass assert np isnan ft_tiny assert_raises_fpe underflow operator truediv ft_tiny ft_max assert_raises_fpe underflow operator mul ft_tiny ft_tiny assert_raises_fpe overflow operator mul ft_max ftype assert_raises_fpe overflow operator truediv ft_max ftype assert_raises_fpe overflow operator add ft_max ft_max ft_eps assert_raises_fpe overflow operator sub -ft_max ft_max ft_eps assert_raises_fpe overflow np power ftype ftype fi nexp assert_raises_fpe divbyzero operator truediv ftype ftype assert_raises_fpe invalid operator truediv ftype np inf ftype np inf assert_raises_fpe invalid operator truediv ftype ftype assert_raises_fpe invalid operator sub ftype np inf ftype np inf assert_raises_fpe invalid operator add ftype np inf ftype -np inf assert_raises_fpe invalid operator mul ftype ftype np inf skipif IS_WASM reason= no wasm fp exception support test_warnings test warning code path warnings catch_warnings record=True w warnings simplefilter always np divide assert_equal len w assert_ divide zero str w message np array e np array e assert_equal len w assert_ overflow str w - message np array np inf - np array np inf assert_equal len w assert_ invalid value str w - message np array e- np array e- assert_equal len w assert_ underflow str w - message TestTypes TestCase check_promotion_cases promote_func tests scalars get coerced correctly b = np bool_ i i i i = np int np int np int np int u = np uint f f = np float np float c c = np complex np complex coercion within same kind assert_equal promote_func i i np dtype np int assert_equal promote_func i i np dtype np int assert_equal promote_func i i np dtype np int assert_equal promote_func f f np dtype np float assert_equal promote_func c c np dtype np complex coercion between kinds assert_equal promote_func b i np dtype np int assert_equal promote_func b u np dtype np uint assert_equal promote_func i u np dtype np int assert_equal promote_func u i np dtype np int assert_equal promote_func f i np dtype np float assert_equal promote_func f c np dtype np complex assert_equal promote_func c f np dtype np complex coercion between scalars -D arrays assert_equal promote_func np array b i np dtype np int assert_equal promote_func np array b u np dtype np uint assert_equal promote_func np array b i np dtype np int assert_equal promote_func c np array f np dtype np complex assert_equal promote_func np complex j np array f np dtype np complex coercion between scalars -D arrays where scalar has greater kind than array assert_equal promote_func np array b f np dtype np float assert_equal promote_func np array b i np dtype np int assert_equal promote_func np array i f np dtype np float check_promotion_cases_ promote_func these failing because scalars do upcast arrays rule Two first tests i + f - f i +f - f xfail until ufuncs implement proper type promotion ufunc loops i i i = np int np int np int f f = np float np float c = np complex assert_equal promote_func i f np dtype np float assert_equal promote_func i f np dtype np float assert_equal promote_func np array i i np dtype np int assert_equal promote_func f np array f np dtype np float float complex treated same kind purposes array-scalar promotion so you can do j + float array get complex array instead complex array assert_equal promote_func np array f c np dtype np complex test_coercion res_type b np add b dtype check_promotion_cases res_type Use-case float complex scalar bool int array shouldn t narrow float complex type np array True False np array - dtype=np int b = assert_equal b dtype np dtype f f array type dtype b = np float assert_equal b dtype np dtype f f array type dtype b = np float assert_equal b dtype np dtype f f array type dtype b = np float assert_equal b dtype np dtype f f array type dtype b = j assert_equal b dtype np dtype c f array type dtype b = np complex j assert_equal b dtype np dtype c f array type dtype b = np complex j assert_equal b dtype np dtype c f array type dtype The following use-case problematic resolve its tricky side-effects requires more changes Use-case -t where t boolean array float shouldn t promote float = np array dtype=np float t = np array True False b = t assert_equal b assert_equal b dtype np dtype f b = -t assert_equal b assert_equal b dtype np dtype f Probably ~t bitwise negation more proper use here arguably less intuitive understand glance would fail t actually integer array instead boolean b = ~t assert_equal b assert_equal b dtype np dtype f xpassIfTorchDynamo_np reason= Scalars do upcast arrays rule test_coercion_ res_type b np add b dtype check_promotion_cases_ res_type test_result_type check_promotion_cases np result_type skip reason= array None supported test_tesult_type_ assert_ np result_type None == np dtype None skip reason= no endianness dtypes test_promote_types_endian promote_types should always native-endian types assert_equal np promote_types i i np dtype i assert_equal np promote_types i i np dtype i test_can_cast assert_ np can_cast np int np int assert_ np can_cast np float complex assert_ np can_cast complex float assert_ np can_cast i f assert_ np can_cast i f assert_ np can_cast i i no skip reason= no endianness dtypes test_can_cast_ assert_ np can_cast i i no assert_ np can_cast i i equiv assert_ np can_cast i i equiv assert_ np can_cast i i safe assert_ np can_cast i i safe assert_ np can_cast i i same_kind assert_ np can_cast i u same_kind assert_ np can_cast i u unsafe assert_raises TypeError np can_cast i None assert_raises TypeError np can_cast None i Also test keyword arguments assert_ np can_cast from_=np int to=np int xpassIfTorchDynamo_np reason= value-based casting test_can_cast_values gh- dt np int np int np int np int + np uint np uint np uint np uint ii = np iinfo dt assert_ np can_cast ii min dt assert_ np can_cast ii max dt assert_ np can_cast ii min - dt assert_ np can_cast ii max + dt dt np float np float np float np longdouble fi = np finfo dt assert_ np can_cast fi min dt assert_ np can_cast fi max dt Custom exception test exception propagation fromiter NIterError Exception pass skip reason= NP_VER fails CI xpassIfTorchDynamo_np reason= TODO instantiate_parametrized_tests TestFromiter TestCase makegen x x range test_types ai = np fromiter makegen np int ai = np fromiter makegen np int af = np fromiter makegen float assert_ ai dtype == np dtype np int assert_ ai dtype == np dtype np int assert_ af dtype == np dtype float test_lengths expected = np array list makegen = np fromiter makegen int = np fromiter makegen int assert_ len == len expected assert_ len == assert_raises ValueError np fromiter makegen int len expected + test_values expected = np array list makegen = np fromiter makegen int = np fromiter makegen int assert_ np all == expected axis= assert_ np all == expected axis= load_data n eindex Utility method issue tests Raise exception desired index iterator e range n e == eindex raise NIterError f error index eindex yield e parametrize dtype int parametrize count error_index test_ count error_index dtype Test iteration exceptions correctly raised The data generator has ` count ` elements errors ` error_index ` iterable = load_data count error_index pytest raises NIterError np fromiter iterable dtype=dtype count=count skip reason= NP_VER fails CI test_empty_result MyIter __length_hint__ __iter__ iter actual iterator empty res = np fromiter MyIter dtype= d assert res shape == assert res dtype == d test_too_few_items msg = iterator too short Expected iterator had only items pytest raises ValueError match=msg np fromiter count= dtype=int test_failed_itemsetting pytest raises TypeError np fromiter None dtype=int The following manages hit somewhat trickier code paths iterable = i range pytest raises ValueError np fromiter iterable dtype=np dtype int instantiate_parametrized_tests TestNonzeroAndCountNonzero TestCase test_count_nonzero_list lst = assert np count_nonzero lst == assert_array_equal np count_nonzero lst axis= np array assert_array_equal np count_nonzero lst axis= np array test_nonzero_trivial assert_equal np count_nonzero np array assert_equal np count_nonzero np array dtype= assert_equal np nonzero np array assert_equal np count_nonzero np array assert_equal np count_nonzero np array dtype= assert_equal np nonzero np array assert_equal np count_nonzero np array assert_equal np count_nonzero np array dtype= assert_equal np nonzero np array test_nonzero_trivial_differs numpy returns python int we D array assert isinstance np count_nonzero np ndarray test_nonzero_zerod assert_equal np count_nonzero np array assert_equal np count_nonzero np array dtype= assert_equal np count_nonzero np array assert_equal np count_nonzero np array dtype= test_nonzero_zerod_differs numpy returns python int we D array assert isinstance np count_nonzero np array np ndarray test_nonzero_onedim x = np array - assert_equal np count_nonzero x assert_equal np count_nonzero x assert_equal np nonzero x test_nonzero_onedim_differs numpy returns python int we D array x = np array - assert isinstance np count_nonzero x np ndarray test_nonzero_twodim x = np array assert_equal np count_nonzero x astype i assert_equal np count_nonzero x astype i assert_equal np count_nonzero x astype i assert_equal np count_nonzero x astype i assert_equal np nonzero x x = np eye assert_equal np count_nonzero x astype i assert_equal np count_nonzero x astype i assert_equal np count_nonzero x astype i assert_equal np count_nonzero x astype i assert_equal np nonzero x test_sparse test special sparse condition boolean code path i range c = np zeros dtype=bool c i = True assert_equal np nonzero c np arange i + i c = np zeros dtype=bool c + i + i = True c + i = True assert_equal np nonzero c np concatenate np arange + i + i + i test_count_nonzero_axis Basic check functionality m = np array expected = np array assert_array_equal np count_nonzero m axis= expected expected = np array assert_array_equal np count_nonzero m axis= expected assert isinstance np count_nonzero m axis= np ndarray assert_raises ValueError np count_nonzero m axis= assert_raises TypeError np count_nonzero m axis= foo assert_raises np AxisError np count_nonzero m axis= assert_raises TypeError np count_nonzero m axis=np array parametrize typecode efdFDBbhil test_count_nonzero_axis_all_dtypes typecode More thorough test axis argument respected all dtypes responds correctly when presented either integer tuple arguments axis m = np zeros dtype=typecode n = np ones dtype=typecode m = n m = n expected = np array dtype=np intp result = np count_nonzero m axis= assert_array_equal result expected assert expected dtype == result dtype expected = np array dtype=np intp result = np count_nonzero m axis= assert_array_equal result expected assert expected dtype == result dtype expected = np array assert_array_equal np count_nonzero m axis= expected assert_array_equal np count_nonzero m axis=None expected assert_array_equal np count_nonzero m expected test_countnonzero_axis_empty = np array assert_equal np count_nonzero axis= astype bool test_countnonzero_keepdims = np array assert_array_equal np count_nonzero axis= keepdims=True assert_array_equal np count_nonzero axis= keepdims=True assert_array_equal np count_nonzero keepdims=True assert isinstance np count_nonzero axis= keepdims=True np ndarray TestIndex TestCase test_boolean = rand V = rand g = randint size= g = randint size= V g g = -V g g assert_ np array V V V == V all test_boolean_edgecase = np array dtype= int b = np array dtype= bool c = b assert_equal c assert_equal c dtype np dtype int xpassIfTorchDynamo_np reason= TODO TestBinaryRepr TestCase test_zero assert_equal np binary_repr test_positive assert_equal np binary_repr assert_equal np binary_repr assert_equal np binary_repr test_negative assert_equal np binary_repr - - assert_equal np binary_repr - - assert_equal np binary_repr - - assert_equal np binary_repr - - test_sufficient_width assert_equal np binary_repr width= assert_equal np binary_repr width= assert_equal np binary_repr - width= test_neg_width_boundaries see gh- Ensure example issue does break before proceeding more thorough test assert_equal np binary_repr - width= width range num = - width - exp = + width - assert_equal np binary_repr num width=width exp test_large_neg_int See gh- assert_equal np binary_repr np int - width= + xpassIfTorchDynamo_np reason= TODO TestBaseRepr TestCase test_base assert_equal np base_repr test_positive assert_equal np base_repr assert_equal np base_repr assert_equal np base_repr assert_equal np base_repr QR ROFCEW test_negative assert_equal np base_repr - - assert_equal np base_repr - - assert_equal np base_repr - - test_base_range assert_raises ValueError np base_repr assert_raises ValueError np base_repr TestArrayComparisons TestCase test_array_equal res = np array_equal np array np array assert_ res assert_ type res bool res = np array_equal np array np array assert_ res assert_ type res bool res = np array_equal np array np array assert_ res assert_ type res bool res = np array_equal np array np array assert_ res assert_ type res bool test_array_equal_equal_nan Test array_equal equal_nan kwarg = np array np nan = np array np nan = np array np inf equal_nan=False default assert_ np array_equal assert_ np array_equal equal_nan=True assert_ np array_equal equal_nan=True nan s conflated inf s assert_ np array_equal equal_nan=True -D arrays = np array np nan assert_ np array_equal assert_ np array_equal equal_nan=True Non-float dtype - equal_nan should have no effect = np array dtype=int assert_ np array_equal assert_ np array_equal equal_nan=True Multi-dimensional array = np array np nan assert_ np array_equal assert_ np array_equal equal_nan=True Complex values b = np array + j real b imag = np nan np nan assert_ np array_equal b equal_nan=False assert_ np array_equal b equal_nan=True test_none_compares_elementwise = np ones assert_equal __eq__ None False False False assert_equal __ne__ None True True True test_array_equiv res = np array_equiv np array np array assert_ res assert_ type res bool res = np array_equiv np array np array assert_ res assert_ type res bool res = np array_equiv np array np array assert_ res assert_ type res bool res = np array_equiv np array np array assert_ res assert_ type res bool res = np array_equiv np array np array assert_ res assert_ type res bool res = np array_equiv np array np array assert_ res assert_ type res bool res = np array_equiv np array np array assert_ res assert_ type res bool res = np array_equiv np array np array assert_ res assert_ type res bool res = np array_equiv np array np array assert_ res assert_ type res bool instantiate_parametrized_tests TestClip TestCase setUp super setUp nr = nc = fastclip m M out=None casting=None out None casting None clip m M clip m M casting=casting casting None clip m M out clip m M out casting=casting clip m M out=None use slow-clip selector = np less m + np greater M selector choose m M out=out Handy functions _generate_data n m randn n m _generate_data_complex n m randn n m + j rand n m _generate_flt_data n m randn n m astype np float _neg_byteorder = np asarray sys byteorder == little = astype dtype newbyteorder = astype dtype newbyteorder _generate_non_native_data n m data = randn n m data = _neg_byteorder data assert_ data dtype isnative data _generate_int_data n m rand n m astype np int _generate_int _data n m rand n m astype np int Now real test cases parametrize dtype bhilBfd test_ones_pathological dtype preservation behavior described gh- amin amax behavior may still change future arr = np ones dtype=dtype expected = np zeros dtype=dtype actual = np clip arr assert_equal actual expected parametrize dtype eFD test_ones_pathological_ dtype dtype FD FIXME make xfail raise SkipTest torch clamp implemented complex types preservation behavior described gh- amin amax behavior may still change future arr = np ones dtype=dtype expected = np zeros dtype=dtype actual = np clip arr assert_equal actual expected test_simple_double Test native double input scalar min max = _generate_data nr nc m = M = ac = fastclip m M act = clip m M assert_array_equal ac act test_simple_int Test native int input scalar min max = _generate_int_data nr nc = astype int m = - M = ac = fastclip m M act = clip m M assert_array_equal ac act test_array_double Test native double input array min max = _generate_data nr nc m = np zeros shape M = m + ac = fastclip m M act = clip m M assert_array_equal ac act xpassIfTorchDynamo_np reason= byteorder supported torch test_simple_nonnative Test non native double input scalar min max Test native double input non native double scalar min max = _generate_non_native_data nr nc m = - M = ac = fastclip m M act = clip m M assert_array_equal ac act Test native double input non native double scalar min max = _generate_data nr nc m = - M = _neg_byteorder assert_ M dtype isnative ac = fastclip m M act = clip m M assert_array_equal ac act xpassIfTorchDynamo_np reason= clamp supported complex test_simple_complex Test native complex input native double scalar min max Test native input complex double scalar min max = _generate_data_complex nr nc m = - M = ac = fastclip m M act = clip m M assert_array_equal ac act Test native input complex double scalar min max = _generate_data nr nc m = - + j M = + j ac = fastclip m M act = clip m M assert_array_equal ac act xfail reason= clamp supported complex test_clip_complex Address Issue gh- clipping complex arrays Test native complex input without explicit min max ie either min=None max=None = np ones dtype=complex m = min M = max am = fastclip m None aM = fastclip None M assert_array_equal am assert_array_equal aM test_clip_non_contig Test clip non contiguous native input native scalar min max = _generate_data nr nc = assert_ flags F_CONTIGUOUS assert_ flags C_CONTIGUOUS ac = fastclip - act = clip - assert_array_equal ac act test_simple_out Test native double input scalar min max = _generate_data nr nc m = - M = ac = np zeros shape act = np zeros shape fastclip m M ac clip m M act assert_array_equal ac act xpassIfTorchDynamo_np reason= casting supported parametrize casting subtest None decorators= xfail subtest unsafe decorators= xpassIfTorchDynamo_np test_simple_int _inout casting Test native int input double min max int out = _generate_int _data nr nc m = np float M = np float ac = np zeros shape dtype=np int act = ac copy casting None explicitly passing unsafe will silence warning fastclip m M ac casting=casting clip m M act assert_array_equal ac act test_simple_int _out Test native int input int scalar min max int out = _generate_int _data nr nc m = np int - M = np int ac = np zeros shape dtype=np int act = ac copy fastclip m M ac clip m M act assert_array_equal ac act xfail reason= FIXME arrays equal test_simple_int _inout Test native int input double array min max int out = _generate_int _data nr nc m = np zeros shape np float M = np float ac = np zeros shape dtype=np int act = ac copy clip m M act assert_array_equal ac act xfail reason= FIXME arrays equal test_simple_int _out Test native double input scalar min max int out = _generate_data nr nc m = - M = ac = np zeros shape dtype=np int act = ac copy clip m M act assert_array_equal ac act test_simple_inplace_ Test native double input array min max in-place = _generate_data nr nc ac = copy m = np zeros shape M = fastclip m M clip m M ac assert_array_equal ac test_simple_inplace_ Test native double input scalar min max in-place = _generate_data nr nc ac = copy m = - M = fastclip m M clip ac m M ac assert_array_equal ac test_noncontig_inplace Test non contiguous double input double scalar min max in-place = _generate_data nr nc = assert_ flags F_CONTIGUOUS assert_ flags C_CONTIGUOUS ac = copy m = - M = fastclip m M clip ac m M ac assert_array_equal ac test_type_cast_ Test native double input scalar min max = _generate_data nr nc m = - M = ac = fastclip m M act = clip m M assert_array_equal ac act test_type_cast_ Test native int input int scalar min max = _generate_int_data nr nc = astype np int m = - M = ac = fastclip m M act = clip m M assert_array_equal ac act test_type_cast_ Test native int input float scalar min max = _generate_int _data nr nc m = - M = ac = fastclip np float m np float M act = clip np float m np float M assert_array_equal ac act test_type_cast_ Test native int input float scalar min max = _generate_int _data nr nc m = np float - M = np float act = fastclip m M ac = clip m M assert_array_equal ac act test_type_cast_ Test native int double arrays min max = _generate_int_data nr nc m = - M = ac = fastclip m np zeros shape M act = clip m np zeros shape M assert_array_equal ac act xpassIfTorchDynamo_np reason= newbyteorder supported test_type_cast_ Test native NON native scalar min max = _generate_data nr nc m = m_s = _neg_byteorder m M = act = clip m_s M ac = fastclip m_s M assert_array_equal ac act xpassIfTorchDynamo_np reason= newbyteorder supported test_type_cast_ Test NON native native array min max = _generate_data nr nc m = - np ones shape M = a_s = _neg_byteorder assert_ a_s dtype isnative act = a_s clip m M ac = fastclip a_s m M assert_array_equal ac act xpassIfTorchDynamo_np reason= newbyteorder supported test_type_cast_ Test NON native native scalar min max = _generate_data nr nc m = - M = a_s = _neg_byteorder assert_ a_s dtype isnative ac = fastclip a_s m M act = a_s clip m M assert_array_equal ac act xpassIfTorchDynamo_np reason= newbyteorder supported test_type_cast_ Test native NON native array min max = _generate_data nr nc m = - np ones shape M = m_s = _neg_byteorder m assert_ m_s dtype isnative ac = fastclip m_s M act = clip m_s M assert_array_equal ac act test_type_cast_ Test native int float min max float out output argument = _generate_int_data nr nc b = np zeros shape dtype=np float m = np float - M = np float act = clip m M out=b ac = fastclip m M out=b assert_array_equal ac act xpassIfTorchDynamo_np reason= newbyteorder supported test_type_cast_ Test non native native scalar min max out non native = _generate_non_native_data nr nc b = copy b = b astype b dtype newbyteorder bt = b copy m = - M = fastclip m M out=b clip m M out=bt assert_array_equal b bt test_type_cast_ Test native int input min max float out = _generate_int_data nr nc b = np zeros shape dtype=np float m = np int M = np int act = clip m M out=b ac = fastclip m M out=b assert_array_equal ac act test_clip_with_out_simple Test native double input scalar min max = _generate_data nr nc m = - M = ac = np zeros shape act = np zeros shape fastclip m M ac clip m M act assert_array_equal ac act xfail reason= FIXME arrays equal test_clip_with_out_simple Test native int input double min max int out = _generate_int _data nr nc m = np float M = np float ac = np zeros shape dtype=np int act = ac copy clip m M act assert_array_equal ac act test_clip_with_out_simple_int Test native int input int scalar min max int out = _generate_int _data nr nc m = np int - M = np int ac = np zeros shape dtype=np int act = ac copy fastclip m M ac clip m M act assert_array_equal ac act xfail reason= FIXME arrays equal test_clip_with_out_array_int Test native int input double array min max int out = _generate_int _data nr nc m = np zeros shape np float M = np float ac = np zeros shape dtype=np int act = ac copy clip m M act assert_array_equal ac act xfail reason= FIXME arrays equal test_clip_with_out_array_outint Test native double input scalar min max int out = _generate_data nr nc m = - M = ac = np zeros shape dtype=np int act = ac copy clip m M act assert_array_equal ac act test_clip_with_out_transposed Test out argument works when transposed = np arange reshape out = np empty_like T clip out=out expected = clip assert_array_equal out expected test_clip_with_out_memory_overlap Test out argument works when has memory overlap = np arange reshape ac = copy - clip out=a expected = clip ac - assert_array_equal expected test_clip_inplace_array Test native double input array min max = _generate_data nr nc ac = copy m = np zeros shape M = fastclip m M clip m M ac assert_array_equal ac test_clip_inplace_simple Test native double input scalar min max = _generate_data nr nc ac = copy m = - M = fastclip m M clip m M ac assert_array_equal ac test_clip_func_takes_out Ensure clip function takes out=argument = _generate_data nr nc ac = copy m = - M = = np clip m M out=a clip m M ac assert_array_equal ac assert_ skip reason= Edge case Wait until deprecation graduates test_clip_nan d = np arange assert_warns DeprecationWarning assert_equal d clip min=np nan d assert_warns DeprecationWarning assert_equal d clip max=np nan d assert_warns DeprecationWarning assert_equal d clip min=np nan max=np nan d assert_warns DeprecationWarning assert_equal d clip min=- max=np nan d assert_warns DeprecationWarning assert_equal d clip min=np nan max= d parametrize amin amax two scalars mix scalar array np zeros two arrays np ones np zeros test_clip_value_min_max_flip amin amax = np arange dtype=np int requirement ufunc_docstrings py expected = np minimum np maximum amin amax actual = np clip amin amax assert_equal actual expected parametrize arr amin amax problematic scalar nan case hypothesis np zeros dtype=np int np array np nan np zeros dtype=np int test_clip_scalar_nan_propagation arr amin amax enforcement scalar nan propagation comparisons called through clip expected = np minimum np maximum arr amin amax actual = np clip arr amin amax assert_equal actual expected skip hypothesis hynp from_dtype fails CI versions given data=st data arr=hynp arrays dtype=hynp integer_dtypes &#124; hynp floating_dtypes shape=hynp array_shapes test_clip_property data arr A property-based test using Hypothesis This aims maximum generality could principle generate any valid inputs np clip practice generates much more varied inputs than human testers come up Because many inputs have tricky dependencies - compatible dtypes mutually-broadcastable shapes - we use ` st data ` strategy draw values inside test function strategies we construct based previous values An alternative would define custom strategy ` st composite ` until we have duplicated code inline fine That accounts most function actual test just three lines calculate compare actual vs expected results numeric_dtypes = hynp integer_dtypes &#124; hynp floating_dtypes Generate shapes bounds which can broadcast each other base shape Below we might decide use scalar bounds s clearer generate these shapes unconditionally advance in_shapes result_shape = data draw hynp mutually_broadcastable_shapes num_shapes= base_shape=arr shape Scalar ` nan ` deprecated due differing behaviour shows s = numeric_dtypes flatmap lambda x hynp from_dtype x allow_nan=False amin = data draw s &#124; hynp arrays dtype=numeric_dtypes shape=in_shapes elements= allow_nan False amax = data draw s &#124; hynp arrays dtype=numeric_dtypes shape=in_shapes elements= allow_nan False Then calculate our result expected result check they re equal See gh- gh- discussion deciding property result_type argument result = np clip arr amin amax t = np result_type arr amin amax expected = np minimum amax np maximum arr amin dtype=t dtype=t assert result dtype == t assert_array_equal result expected TestAllclose TestCase rtol = e- atol = e- tst_allclose x y assert_ np allclose x y f x y close tst_not_allclose x y assert_ np allclose x y f x y shouldn t close test_ip_allclose Parametric test factory arr = np array aran = np arange reshape atol = atol rtol = rtol data = atol + rtol + atol arr arr + arr rtol arr arr + arr rtol + atol aran aran + aran rtol np inf np inf np inf np inf x y data tst_allclose x y test_ip_not_allclose Parametric test factory aran = np arange reshape atol = atol rtol = rtol data = np inf np inf np inf np inf np inf np inf np inf np inf -np inf np inf np nan np nan atol + rtol + atol aran aran + aran atol + atol np array np inf np array np inf x y data tst_not_allclose x y test_no_parameter_modification x = np array np inf y = np array np inf np allclose x y assert_array_equal x np array np inf assert_array_equal y np array np inf test_min_int Could make problems because abs min_int == min_int min_int = np iinfo np int_ min = np array min_int dtype=np int_ assert_ np allclose test_equalnan x = np array np nan assert_ np allclose x x equal_nan=True TestIsclose TestCase rtol = e- atol = e- _setup atol = atol rtol = rtol arr = np array aran = np arange reshape all_close_tests = atol + rtol + atol arr arr + arr rtol arr arr + arr rtol + atol aran aran + aran rtol np inf np inf np inf np inf np inf -np inf np inf -np inf none_close_tests = np inf np inf np inf -np inf np inf np inf -np inf np inf np inf np nan np nan -np inf atol + rtol + atol aran aran + rtol aran + atol np array np inf np array np inf some_close_tests = np inf np inf atol atol e + rtol + atol np nan e np arange np nan np nan np nan np nan atol np inf -np inf np nan atol np inf -np inf np nan some_close_results = True False True False False True True False False False False True False False False True False False False test_ip_isclose _setup tests = some_close_tests results = some_close_results x y result zip tests results assert_array_equal np isclose x y result tst_all_isclose x y assert_ np all np isclose x y f x y close tst_none_isclose x y msg = s s shouldn t close assert_ np any np isclose x y msg x y tst_isclose_allclose x y msg = isclose all allclose aren t same s s msg = isclose allclose aren t same s s np isscalar x np isscalar y assert_ np isclose x y == np allclose x y msg=msg x y assert_array_equal np isclose x y all np allclose x y msg x y test_ip_all_isclose _setup x y all_close_tests tst_all_isclose x y test_ip_none_isclose _setup x y none_close_tests tst_none_isclose x y test_ip_isclose_allclose _setup tests = all_close_tests + none_close_tests + some_close_tests x y tests tst_isclose_allclose x y test_equal_nan assert_array_equal np isclose np nan np nan equal_nan=True True arr = np array np nan assert_array_equal np isclose arr arr equal_nan=True True True xfailIfTorchDynamo scalars vs D test_scalar_return assert_ np isscalar np isclose test_no_parameter_modification x = np array np inf y = np array np inf np isclose x y assert_array_equal x np array np inf assert_array_equal y np array np inf test_non_finite_scalar GH when two scalars compared output should also scalar XXX test modified since there array scalars assert_ np isclose np inf -np inf item False assert_ np isclose np inf item False TestStdVar TestCase setUp super setUp A = np array - - real_var = test_basic assert_almost_equal np var A real_var assert_almost_equal np std A real_var test_scalars assert_equal np var assert_equal np std test_ddof assert_almost_equal np var A ddof= real_var len A len A - assert_almost_equal np std A ddof= real_var len A len A - test_ddof assert_almost_equal np var A ddof= real_var len A len A - assert_almost_equal np std A ddof= real_var len A len A - test_out_scalar d = np arange out = np array r = np std d out=out assert_ r out assert_array_equal r out r = np var d out=out assert_ r out assert_array_equal r out r = np mean d out=out assert_ r out assert_array_equal r out TestStdVarComplex TestCase test_basic A = np array j - - j real_var = assert_almost_equal np var A real_var assert_almost_equal np std A real_var test_scalars assert_equal np var j assert_equal np std j TestCreationFuncs TestCase Test ones zeros empty full setUp super setUp dtypes = np dtype tp tp efdFDBbhil dtypes = dtypes orders = C c_contiguous XXX reeenable when implemented F f_contiguous ndims = check_function func fill_value=None par = range ndims orders dtypes fill_kwarg = fill_value None fill_kwarg = fill_value fill_value size ndims order dtype itertools product par shape = ndims size arr = func shape order=order dtype=dtype fill_kwarg assert_equal arr dtype dtype assert_ getattr arr flags orders order fill_value None val = fill_value assert_equal arr dtype type val test_zeros check_function np zeros test_ones check_function np ones test_empty check_function np empty test_full check_function np full check_function np full skipif TEST_WITH_TORCHDYNAMO reason= fails dynamo skipif HAS_REFCOUNT reason= Python lacks refcounts test_for_reference_leak Make sure we have object reference dim = beg = sys getrefcount dim np zeros dim assert_ sys getrefcount dim == beg np ones dim assert_ sys getrefcount dim == beg np empty dim assert_ sys getrefcount dim == beg np full dim assert_ sys getrefcount dim == beg skip reason= implement order etc FIXME make xfail instantiate_parametrized_tests TestLikeFuncs TestCase Test ones_like zeros_like empty_like full_like setUp super setUp data = Array scalars np array None np array f D arrays np arange dtype= f None np arange c D C-layout arrays np arange reshape None np arange reshape i D F-layout arrays np arange reshape order= F None np arange reshape order= F i D C-layout arrays np arange reshape None np arange reshape f D F-layout arrays np arange reshape order= F None np arange reshape order= F f D non-C F-layout arrays np arange reshape swapaxes None np arange reshape swapaxes shapes = compare_array_value dz value fill_value value None fill_value Conversion close what np full_like uses we may want convert directly future which may result errors where does z = np array value astype dz dtype assert_ np all dz == z assert_ np all dz == value check_like_function like_function value fill_value=False fill_value fill_kwarg = fill_value value fill_kwarg = d dtype data default K order dtype dz = like_function d dtype=dtype fill_kwarg assert_equal dz shape d shape assert_equal np array dz strides d dtype itemsize np array d strides dz dtype itemsize assert_equal d flags c_contiguous dz flags c_contiguous assert_equal d flags f_contiguous dz flags f_contiguous dtype None assert_equal dz dtype d dtype assert_equal dz dtype np dtype dtype compare_array_value dz value fill_value C order default dtype dz = like_function d order= C dtype=dtype fill_kwarg assert_equal dz shape d shape assert_ dz flags c_contiguous dtype None assert_equal dz dtype d dtype assert_equal dz dtype np dtype dtype compare_array_value dz value fill_value F order default dtype dz = like_function d order= F dtype=dtype fill_kwarg assert_equal dz shape d shape assert_ dz flags f_contiguous dtype None assert_equal dz dtype d dtype assert_equal dz dtype np dtype dtype compare_array_value dz value fill_value A order dz = like_function d order= A dtype=dtype fill_kwarg assert_equal dz shape d shape d flags f_contiguous assert_ dz flags f_contiguous assert_ dz flags c_contiguous dtype None assert_equal dz dtype d dtype assert_equal dz dtype np dtype dtype compare_array_value dz value fill_value Test shape parameter s shapes o CFA sz = like_function d dtype=dtype shape=s order=o fill_kwarg assert_equal sz shape s dtype None assert_equal sz dtype d dtype assert_equal sz dtype np dtype dtype o == C o == A d flags c_contiguous assert_ sz flags c_contiguous o == F o == A d flags f_contiguous assert_ sz flags f_contiguous compare_array_value sz value fill_value d ndim = len s assert_equal np argsort like_function d dtype=dtype shape=s order= K fill_kwarg strides np argsort np empty s dtype=dtype order= C strides assert_equal np argsort like_function d dtype=dtype shape=s order= K fill_kwarg strides np argsort d strides test_ones_like check_like_function np ones_like test_zeros_like check_like_function np zeros_like test_empty_like check_like_function np empty_like None test_filled_like check_like_function np full_like True check_like_function np full_like True check_like_function np full_like True check_like_function np full_like True Inf integer casts cause invalid-value errors ignore them check_like_function np full_like np inf True parametrize likefunc np empty_like np full_like np zeros_like np ones_like parametrize dtype str bytes test_dtype_str_bytes likefunc dtype Regression test gh- = np arange reshape b = Ensure b contiguous kwargs = fill_value likefunc == np full_like result = likefunc b dtype=dtype kwargs dtype str assert result strides == dtype bytes assert result strides == TestCorrelate TestCase _setup dt x = np array dtype=dt xs = np arange y = np array - - - dtype=dt z = np array - - - - - - - dtype=dt z _ = np array - - - - - - dtype=dt z r = np array - - - - - - - dtype=dt z = np array - - - - - - - dtype=dt z r = np array - - - - - - - dtype=dt zs = np array - - - - - - - - - dtype=dt test_float _setup float z = np correlate x y full assert_array_almost_equal z z z = np correlate x y - full assert_array_almost_equal z z _ z = np correlate y x full assert_array_almost_equal z z z = np correlate np flip x y full assert_array_almost_equal z z r z = np correlate y np flip x full assert_array_almost_equal z z r z = np correlate xs y full assert_array_almost_equal z zs test_no_overwrite d = np ones k = np ones np correlate d k assert_array_equal d np ones assert_array_equal k np ones test_complex x = np array + j dtype=complex y = np array - - j + j dtype=complex r_z = np array - j + j + j - + j - - j dtype=complex r_z = np flip r_z conjugate z = np correlate y x mode= full assert_array_almost_equal z r_z test_zero_size pytest raises ValueError RuntimeError np correlate np array np ones mode= full pytest raises ValueError RuntimeError np correlate np ones np array mode= full skip reason= do implement deprecated behavior test_mode d = np ones k = np ones default_mode = np correlate d k mode= valid assert_warns DeprecationWarning valid_mode = np correlate d k mode= v assert_array_equal valid_mode default_mode integer mode assert_raises ValueError np correlate d k mode=- assert_array_equal np correlate d k mode= valid_mode illegal arguments assert_raises TypeError np correlate d k mode=None TestConvolve TestCase test_object d = k = assert_array_almost_equal np convolve d k - np full test_no_overwrite d = np ones k = np ones np convolve d k assert_array_equal d np ones assert_array_equal k np ones skip reason= do implement deprecated behavior test_mode d = np ones k = np ones default_mode = np convolve d k mode= full assert_warns DeprecationWarning full_mode = np convolve d k mode= f assert_array_equal full_mode default_mode integer mode assert_raises ValueError np convolve d k mode=- assert_array_equal np convolve d k mode= full_mode illegal arguments assert_raises TypeError np convolve d k mode=None test_numpy_doc_examples conv = np convolve assert_allclose conv atol= e- conv = np convolve same assert_allclose conv atol= e- conv = np convolve valid assert_allclose conv atol= e- TestDtypePositional TestCase test_dtype_positional np empty bool instantiate_parametrized_tests TestArgwhere TestCase parametrize nd test_nd nd get nd array multiple elements every dimension x = np empty nd dtype=bool none x = False assert_equal np argwhere x shape nd only one x = False x ravel = True assert_equal np argwhere x shape nd all one x = True x ravel = False assert_equal np argwhere x shape x size - nd all x = True assert_equal np argwhere x shape x size nd test_ D x = np arange reshape assert_array_equal np argwhere x test_list assert_equal np argwhere xpassIfTorchDynamo_np reason= TODO TestStringFunction TestCase test_set_string_function = np array np set_string_function lambda x FOO repr=True assert_equal repr FOO np set_string_function None repr=True assert_equal repr array np set_string_function lambda x FOO repr=False assert_equal str FOO np set_string_function None repr=False assert_equal str TestRoll TestCase test_roll d x = np arange xr = np roll x assert_equal xr np array test_roll d x = np reshape np arange x r = np roll x assert_equal x r np array x r = np roll x axis= assert_equal x r np array x r = np roll x axis= assert_equal x r np array Roll multiple axes once x r = np roll x axis= assert_equal x r np array x r = np roll x axis= assert_equal x r np array x r = np roll x - axis= assert_equal x r np array x r = np roll x axis= assert_equal x r np array x r = np roll x - axis= assert_equal x r np array x r = np roll x axis= assert_equal x r np array x r = np roll x - - axis= assert_equal x r np array Roll same axis multiple times x r = np roll x axis= assert_equal x r np array x r = np roll x axis= assert_equal x r np array Roll more than one turn either direction x r = np roll x axis= assert_equal x r np array x r = np roll x - axis= assert_equal x r np array test_roll_empty x = np array assert_equal np roll x np array TestRollaxis TestCase expected shape indexed axis start array shape tgtshape = test_exceptions = np arange reshape assert_raises np AxisError np rollaxis - assert_raises np AxisError np rollaxis - assert_raises np AxisError np rollaxis assert_raises np AxisError np rollaxis xfail XXX ndarray attributes test_results = np arange reshape copy aind = np indices shape assert_ flags OWNDATA i j tgtshape positive axis positive start res = np rollaxis axis=i start=j i i i i = aind np array res shape - assert_ np all res i i i i == assert_ res shape == tgtshape i j str i j assert_ res flags OWNDATA negative axis positive start ip = i + res = np rollaxis axis=-ip start=j i i i i = aind np array res shape - assert_ np all res i i i i == assert_ res shape == tgtshape - ip j assert_ res flags OWNDATA positive axis negative start jp = j + j j res = np rollaxis axis=i start=-jp i i i i = aind np array res shape - assert_ np all res i i i i == assert_ res shape == tgtshape i - jp assert_ res flags OWNDATA negative axis negative start ip = i + jp = j + j j res = np rollaxis axis=-ip start=-jp i i i i = aind np array res shape - assert_ np all res i i i i == assert_ res shape == tgtshape - ip - jp assert_ res flags OWNDATA TestMoveaxis TestCase test_move_to_end x = np random randn source expected - actual = np moveaxis x source - shape assert_ actual expected test_move_new_position x = np random randn source destination expected - actual = np moveaxis x source destination shape assert_ actual expected test_preserve_order x = np zeros source destination - - - - range range actual = np moveaxis x source destination shape assert_ actual test_move_multiples x = np zeros source destination expected actual = np moveaxis x source destination shape assert_ actual expected test_errors x = np random randn assert_raises np AxisError np moveaxis x source out bounds assert_raises np AxisError np moveaxis x - source out bounds assert_raises np AxisError np moveaxis x destination out bounds assert_raises ValueError np moveaxis x repeated axis ` source ` assert_raises ValueError repeated axis ` destination ` np moveaxis x assert_raises ValueError RuntimeError must have same number np moveaxis x assert_raises ValueError RuntimeError must have same number np moveaxis x x = result = np moveaxis x assert_ x list result assert_ isinstance result np ndarray TestCross TestCase test_ x u = v = z = - cp = np cross u v assert_equal cp z cp = np cross v u assert_equal cp -z test_ x u = v = z = np array - - cp = np cross u v assert_equal cp z cp = np cross v u assert_equal cp -z test_ x u = v = z = np array - - cp = np cross u v assert_equal cp z cp = np cross v u assert_equal cp -z test_broadcasting Ticket Trac u = np tile v = np tile z = - assert_equal np cross u v z assert_equal np cross v u -z assert_equal np cross u u u = np tile T v = np tile z = np tile - - assert_equal np cross u v axisa= z assert_equal np cross v u T -z assert_equal np cross v v u = np tile T v = np tile T z = np tile - - assert_equal np cross u v axisa= axisb= z assert_equal np cross v T u T -z assert_equal np cross u T u T u = np tile v = np tile T z = np tile - - assert_equal np cross u v axisb= z assert_equal np cross v T u -z assert_equal np cross u u test_broadcasting_shapes u = np ones v = np ones assert_equal np cross u v shape u = np ones v = np ones assert_equal np cross u v axisa= axisb= shape assert_raises np AxisError np cross u v axisa= axisb= assert_raises np AxisError np cross u v axisa= axisb= u = np ones v = np ones assert_equal np cross u v axisa= axisc= shape assert_raises np AxisError np cross u v axisa=- axisb= assert_raises np AxisError np cross u v axisa= axisb=- gh- u = np ones axisc range - assert_equal np cross u u axisc=axisc shape skipif numpy __version__ reason= fix landed NumPy test_uint _int _mixed_dtypes regression test gh- u = np array np uint v = np array np int z = np array - dtype=np int assert_equal np cross v u z assert_equal np cross u v -z TestOuterMisc TestCase test_outer_out_param arr = np ones arr = np ones arr = np linspace - out = np empty shape= out = np empty shape= res = np outer arr arr out assert_equal res out assert_equal np outer arr arr out out instantiate_parametrized_tests TestIndices TestCase test_simple x y = np indices assert_array_equal x np array assert_array_equal y np array test_single_input x = np indices assert_array_equal x np array x = np indices sparse=True assert_array_equal x np array test_scalar_input assert_array_equal np indices assert_array_equal np indices sparse=True assert_array_equal np indices assert_array_equal np indices sparse=True test_sparse x y = np indices sparse=True assert_array_equal x np array assert_array_equal y np array parametrize dtype np int np int np float np float parametrize dims test_return_type dtype dims inds = np indices dims dtype=dtype assert_ inds dtype == dtype arr np indices dims dtype=dtype sparse=True assert_ arr dtype == dtype xpassIfTorchDynamo_np reason= TODO TestRequire TestCase flag_names = C C_CONTIGUOUS CONTIGUOUS F F_CONTIGUOUS FORTRAN A ALIGNED W WRITEABLE O OWNDATA generate_all_false dtype arr = np zeros junk i dtype arr setflags write=False = arr assert_ flags C assert_ flags F assert_ flags O assert_ flags W assert_ flags A set_and_check_flag flag dtype arr dtype None dtype = arr dtype b = np require arr dtype flag assert_ b flags flag assert_ b dtype == dtype further call np require ought same array unless OWNDATA specified c = np require b None flag flag = O assert_ c b assert_ c flags flag test_require_each id = f i fd = None f c idtype fdtype flag itertools product id fd flag_names = generate_all_false idtype set_and_check_flag flag fdtype test_unknown_requirement = generate_all_false f assert_raises KeyError np require None Q test_non_array_input = np require i C A O assert_ flags O assert_ flags C assert_ flags A assert_ dtype == i assert_equal test_C_and_F_simul = generate_all_false f assert_raises ValueError np require None C F xpassIfTorchDynamo_np reason= TODO TestBroadcast TestCase test_broadcast_in_args gh- arrs = np empty np empty np empty np empty mits = np broadcast arrs np broadcast np broadcast arrs np broadcast arrs np broadcast np broadcast arrs np broadcast arrs np broadcast np broadcast arrs np broadcast arrs np broadcast arrs np broadcast arrs - arrs - mit mits assert_equal mit shape assert_equal mit ndim assert_equal mit nd assert_equal mit numiter ia zip arrs mit iters assert_ ia base test_broadcast_single_arg gh- arrs = np empty mit = np broadcast arrs assert_equal mit shape assert_equal mit ndim assert_equal mit nd assert_equal mit numiter assert_ arrs mit iters base test_number_of_arguments arr = np empty j range arrs = arr j j assert_raises ValueError np broadcast arrs mit = np broadcast arrs assert_equal mit numiter j test_broadcast_error_kwargs gh- arrs = np empty mit = np broadcast arrs mit = np broadcast arrs noqa PIE assert_equal mit shape mit shape assert_equal mit ndim mit ndim assert_equal mit nd mit nd assert_equal mit numiter mit numiter assert_ mit iters base mit iters base assert_raises ValueError np broadcast x noqa PIE skip reason= error messages do match test_shape_mismatch_error_message assert_raises ValueError match=r arg shape \ \ arg shape \ \ np broadcast TestTensordot TestCase test_zero_dimension Test resolution issue = np zeros b = np zeros td = np tensordot b assert_array_equal td np dot b test_zero_dimension_einsum Test resolution issue = np zeros b = np zeros td = np tensordot b assert_array_equal td np einsum ij jk b test_zero_dimensional gh- arr_ d = np array ret = np tensordot arr_ d arr_ d contracting no axes well defined assert_array_equal ret arr_ d __name__ == __main__ run_tests