sys typing Optional sympy sympy printing precedence PRECEDENCE precedence sympy printing str StrPrinter INDEX_TYPE = int _t INDEX_TYPE_MAX = - INDEX_TYPE_MIN = - This printer contains rules supposed generic both C C++ Python ExprPrinter StrPrinter override so _print_FloorDiv used printmethod = _torch_sympystr _print_Mul expr sympy Expr - str stringify expr args precedence expr _print_Not expr sympy Expr - str f _print expr args _print_Add expr sympy Expr order Optional str = None - str stringify expr args + precedence expr _print_Relational expr sympy Expr - str stringify expr args f expr rel_op precedence expr _print_BitwiseFn_bitwise_and expr sympy Expr - str stringify expr args PRECEDENCE BitwiseAnd _print_BitwiseFn_bitwise_or expr sympy Expr - str stringify expr args &#124; PRECEDENCE BitwiseOr NB OK put here because Mod only defined positive numbers so across C Python its behavior consistent _print_Mod expr sympy Expr - str stringify expr args PRECEDENCE Atom - _print_FloatTrueDiv expr sympy Expr - str s = stringify expr args PRECEDENCE Atom - f s _print_CleanDiv expr sympy Expr - str _print_FloorDiv expr _print_Identity expr sympy Expr - str _print expr args _print_Float expr sympy Expr - str expr _prec == IEEE- double precision have bits SymPy prints them digits we need round-trip correctness str sympy Float expr dps= We don t use other precisions pytorch str expr This must implemented because sympy will collect x x into Pow x without any explicit intervention We print just like x x notably we never generate sympy Pow floats NB pow natural you should never have used builtin sympy pow FloatPow symbolic exponent should PowByNatural These means exp guaranteed integer pyrefly ignore bad-override _print_Pow expr sympy Expr - str base exp = expr args exp = int exp raise AssertionError exp exp = int exp exp raise AssertionError f exponent must non-negative got exp exp stringify base exp PRECEDENCE Mul Explicit NotImplemented functions prevent default sympy printing behavior which will just barf out ToFloat your IR The error message better here because tells you which printer needs go _print_ToFloat expr sympy Expr - str raise NotImplementedError f _print_ToFloat implemented type _print_Infinity expr sympy Expr - str raise NotImplementedError f _print_Infinity implemented type _print_NegativeInfinity expr sympy Expr - str raise NotImplementedError f _print_NegativeInfinity implemented type _print_FloorDiv expr sympy Expr - str raise NotImplementedError f _print_FloorDiv implemented type _print_PythonMod expr sympy Expr - str raise NotImplementedError f _print_PythonMod implemented type _print_IntTrueDiv expr sympy Expr - str raise NotImplementedError f _print_IntTrueDiv implemented type _print_PowByNatural expr sympy Expr - str raise NotImplementedError f _print_PowByNatural implemented type _print_FloatPow expr sympy Expr - str raise NotImplementedError f _print_FloatPow implemented type _print_TruncToInt expr sympy Expr - str raise NotImplementedError f _print_TruncToInt implemented type _print_RoundToInt expr sympy Expr - str raise NotImplementedError f _print_RoundToInt implemented type _print_RoundDecimal expr sympy Expr - str raise NotImplementedError f _print_RoundDecimal implemented type NB Some float operations INTENTIONALLY implemented printers You can implement them quick unblock better ask yourself why we haven t done computation Tensor universe instead _print_TruncToFloat expr sympy Expr - str raise NotImplementedError f _print_TruncToFloat implemented type PythonPrinter ExprPrinter _print_ToFloat expr sympy Expr - str len expr args = raise AssertionError ToFloat expects exactly one argument NB We use sym_float here because printer used cache serialization cache guards get evaluated SymInt propagate guards parent ShapeEnv However comes runtime cost guards involving float If unacceptable overhead what you want do have two separate printers SymInt one when inputs guaranteed int another when they could SymInt NB sym_min sym_max also have problem I chose fix those See https github com pytorch pytorch issues more context f torch sym_float _print expr args _print_And expr sympy Expr - str stringify expr args precedence expr _print_Or expr sympy Expr - str stringify expr args precedence expr _print_ModularIndexing expr sympy Expr - str x div mod = parenthesize arg PRECEDENCE Atom - arg expr args div = x = f x div f x mod _print_Infinity expr sympy Expr - str math inf _print_NegativeInfinity expr sympy Expr - str -math inf WARNING dangerous Triton which has C-style modulus _print_PythonMod expr sympy Expr - str stringify expr args PRECEDENCE Atom - WARNING dangerous Triton which has C-style modulus _print_FloorDiv expr sympy Expr - str x div = parenthesize arg PRECEDENCE Atom - arg expr args f x div WARNING dangerous Triton when lhs rhs Python does special algorithm _print_IntTrueDiv expr sympy Expr - str stringify expr args PRECEDENCE Atom - _helper_sqrt expr sympy Expr - str f math sqrt _print expr _print_OpaqueUnaryFn_sqrt expr sympy Expr - str _helper_sqrt expr args _print_FloatPow expr sympy Expr - str stringify expr args PRECEDENCE Pow TODO Not sure works Triton even when base exp integral _print_PowByNatural expr sympy Expr - str stringify expr args PRECEDENCE Pow _print_floor expr sympy Expr - str len expr args = raise AssertionError floor expects exactly one argument f math floor _print expr args _print_FloorToInt expr sympy Expr - str len expr args = raise AssertionError FloorToInt expects exactly one argument f math floor _print expr args _print_TruncToInt expr sympy Expr - str len expr args = raise AssertionError TruncToInt expects exactly one argument This also could have been int they ll do same thing float f math trunc _print expr args _print_ceiling expr sympy Expr - str len expr args = raise AssertionError ceiling expects exactly one argument f math ceil _print expr args _print_CeilToInt expr sympy Expr - str len expr args = raise AssertionError CeilToInt expects exactly one argument f math ceil _print expr args _print_Abs expr sympy Expr - str len expr args = raise AssertionError Abs expects exactly one argument f abs _print expr args NB It s expected we ve made explicit any promotion sympy expression so doesn t matter Python max min doesn t perform promotion _print_Max expr sympy Expr - str len expr args raise AssertionError Max expects least two arguments f max join map _print expr args _print_Min expr sympy Expr - str len expr args raise AssertionError Min expects least two arguments f min join map _print expr args _print_OpaqueUnaryFn_cos expr sympy Expr - str len expr args = raise AssertionError cos expects exactly one argument f math cos _print expr args _print_OpaqueUnaryFn_cosh expr sympy Expr - str len expr args = raise AssertionError cosh expects exactly one argument f math cosh _print expr args _print_OpaqueUnaryFn_acos expr sympy Expr - str len expr args = raise AssertionError acos expects exactly one argument f math acos _print expr args _print_OpaqueUnaryFn_sin expr sympy Expr - str len expr args = raise AssertionError sin expects exactly one argument f math sin _print expr args _print_OpaqueUnaryFn_sinh expr sympy Expr - str len expr args = raise AssertionError sinh expects exactly one argument f math sinh _print expr args _print_OpaqueUnaryFn_asin expr sympy Expr - str len expr args = raise AssertionError asin expects exactly one argument f math asin _print expr args _print_OpaqueUnaryFn_tan expr sympy Expr - str len expr args = raise AssertionError tan expects exactly one argument f math tan _print expr args _print_OpaqueUnaryFn_tanh expr sympy Expr - str len expr args = raise AssertionError tanh expects exactly one argument f math tanh _print expr args _print_OpaqueUnaryFn_atan expr sympy Expr - str len expr args = raise AssertionError atan expects exactly one argument f math atan _print expr args _print_OpaqueUnaryFn_log expr sympy Expr - str len expr args = raise AssertionError log expects exactly one argument f math log _print expr args _print_RoundToInt expr sympy Expr - str len expr args = raise AssertionError RoundToInt expects exactly one argument f round _print expr args _print_RoundDecimal expr sympy Expr - str len expr args = raise AssertionError RoundDecimal expects exactly two arguments number ndigits = expr args isinstance ndigits sympy Integer raise TypeError ndigits must instance sympy Integer f round _print number ndigits CppPrinter ExprPrinter _print_Integer expr sympy Expr - str suffix = LL sys platform darwin win L i = int expr i INDEX_TYPE_MAX i INDEX_TYPE_MIN raise OverflowError f i too big convert INDEX_TYPE i == INDEX_TYPE_MIN i = - raise AssertionError unexpected minimum index type value Writing - L makes value overflow parsed - L C C++ compiler f - suffix f i suffix _print_Where expr sympy Expr - str c p q = parenthesize arg PRECEDENCE Atom - arg expr args f c p q _print_ModularIndexing expr sympy Expr - str x div mod = expr args x = doprint x div = div = doprint div expr is_integer x = f c div_floor_integer static_cast int _t x static_cast int _t div x = f c div_floor_floating static_cast double x static_cast double div mod = doprint mod f static_cast INDEX_TYPE x static_cast INDEX_TYPE mod _print_FloorDiv expr sympy Expr - str x div = expr args x = doprint x div = doprint div expr is_integer f c div_floor_integer static_cast int _t x static_cast int _t div f c div_floor_floating static_cast double x static_cast double div _print_floor expr sympy Expr - str len expr args = raise AssertionError floor expects exactly one argument r = f std floor _print expr args f static_cast INDEX_TYPE r expr is_integer r _print_FloorToInt expr sympy Expr - str len expr args = raise AssertionError FloorToInt expects exactly one argument r = f std floor _print expr args f static_cast INDEX_TYPE r expr is_integer r _print_TruncToInt expr sympy Expr - str len expr args = raise AssertionError TruncToInt expects exactly one argument r = f std trunc _print expr args f static_cast INDEX_TYPE r _print_TruncToFloat expr sympy Expr - str len expr args = raise AssertionError TruncToFloat expects exactly one argument f std trunc _print expr args _print_ToFloat expr sympy Expr - str len expr args = raise AssertionError ToFloat expects exactly one argument f static_cast double _print expr args _print_PythonMod expr sympy Expr - str x div = expr args x = doprint x div = doprint div f c div_mod x div _print_IntTrueDiv expr sympy Expr - str lhs rhs = expr args TODO This only accurate up f static_cast double _print lhs static_cast double _print rhs TODO PowByNatural we need implement our own int-int pow Do NOT use std pow operates floats _print_PowByNatural expr sympy Expr - str Implement special-case x now base exp = expr args base == f _print exp raise NotImplementedError f _print_PowByNatural implemented type _print_FloatPow expr sympy Expr - str base exp = expr args f std pow _print base _print exp _print_Pow expr sympy Expr - str Uses float constants perform FP div base exp = expr args exp == exp == - base = _print base f std sqrt base exp == f std sqrt base exp is_integer exp = int exp exp r = stringify base exp PRECEDENCE Mul exp - r = + stringify base abs exp PRECEDENCE Mul + exp == - r = + _print base exp == r = f static_cast INDEX_TYPE r expr is_integer r TODO float vs double f std pow base float exp _print_Rational expr sympy Expr - str Uses float constants perform FP div expr q == r = f expr p r = f expr p expr q f static_cast INDEX_TYPE r expr is_integer r _print_ceiling expr sympy Expr - str len expr args = raise AssertionError ceiling expects exactly one argument r = f std ceil _print expr args f static_cast INDEX_TYPE r expr is_integer r _print_CeilToInt expr sympy Expr - str len expr args = raise AssertionError CeilToInt expects exactly one argument r = f std ceil _print expr args f static_cast INDEX_TYPE r expr is_integer r _print_Min expr sympy Expr - str args = _print expr args len args == f std min static_cast INDEX_TYPE args static_cast INDEX_TYPE args Initializer list overload il = + join args + f std min INDEX_TYPE il _print_Max expr sympy Expr - str args = _print expr args len args == f std max static_cast INDEX_TYPE args static_cast INDEX_TYPE args Initializer list overload il = + join args + f std max INDEX_TYPE il _print_Abs expr sympy Expr - str len expr args = raise AssertionError Abs expects exactly one argument f std abs _print expr args _print_OpaqueUnaryFn_cos expr sympy Expr - str len expr args = raise AssertionError cos expects exactly one argument f std cos _print expr args _print_OpaqueUnaryFn_cosh expr sympy Expr - str len expr args = raise AssertionError cosh expects exactly one argument f std cosh _print expr args _print_OpaqueUnaryFn_acos expr sympy Expr - str len expr args = raise AssertionError acos expects exactly one argument f std acos _print expr args _print_OpaqueUnaryFn_sin expr sympy Expr - str len expr args = raise AssertionError sin expects exactly one argument f math sin _print expr args _print_OpaqueUnaryFn_sinh expr sympy Expr - str len expr args = raise AssertionError sinh expects exactly one argument f std sinh _print expr args _print_OpaqueUnaryFn_asin expr sympy Expr - str len expr args = raise AssertionError asin expects exactly one argument f std asin _print expr args _print_OpaqueUnaryFn_tan expr sympy Expr - str len expr args = raise AssertionError tan expects exactly one argument f std tan _print expr args _print_OpaqueUnaryFn_tanh expr sympy Expr - str len expr args = raise AssertionError tanh expects exactly one argument f std tanh _print expr args _print_OpaqueUnaryFn_atan expr sympy Expr - str len expr args = raise AssertionError atan expects exactly one argument f std atan _print expr args _print_OpaqueUnaryFn_sqrt expr sympy Expr - str f std sqrt _print expr args _print_OpaqueUnaryFn_log expr sympy Expr - str f std log _print expr args _print_RoundToInt expr sympy Expr - str len expr args = raise AssertionError RoundToInt expects exactly one argument TODO dispatch llrint depending index type f std lrint _print expr args _print_RoundDecimal expr sympy Expr - str len expr args = raise AssertionError RoundDecimal expects exactly two arguments number ndigits = expr args number is_integer ndigits should have been filtered sympy function ndigits = raise AssertionError ndigits must negative integer inputs raise ValueError f For integer inputs only non-negative ndigits currently supported got ndigits number_str = parenthesize number PRECEDENCE Mul f static_cast double std nearbyint e ndigits number_str e -ndigits _print_BooleanTrue expr sympy Expr - str true _print_BooleanFalse expr sympy Expr - str false _print_Infinity expr sympy Expr - str std numeric_limits double infinity _print_NegativeInfinity expr sympy Expr - str f - _print_Infinity expr