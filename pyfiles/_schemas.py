mypy allow-untyped-defs __future__ annotations collections abc dataclasses inspect logging types typing collections abc Iterator Mapping Sequence typing Any Optional TypeVar Union onnx onnxscript onnxscript ir logger = logging getLogger __name__ A special value indicate default value specified _Empty __repr__ _EMPTY_DEFAULT _EMPTY_DEFAULT = _Empty Map python type corresponding ONNX AttributeProto type _PY_TYPE_TO_ATTR_TYPE = float ir AttributeType FLOAT int ir AttributeType INT str ir AttributeType STRING bool ir AttributeType INT ir Tensor ir AttributeType TENSOR ir TensorProtocol ir AttributeType TENSOR ir Graph ir AttributeType GRAPH ir GraphProtocol ir AttributeType GRAPH Map python type corresponding ONNX AttributeProto type repeated i e list values _LIST_TYPE_TO_ATTR_TYPE = float ir AttributeType FLOATS int ir AttributeType INTS str ir AttributeType STRINGS bool ir AttributeType INTS ir Tensor ir AttributeType TENSORS ir TensorProtocol ir AttributeType TENSORS ir Graph ir AttributeType GRAPHS ir GraphProtocol ir AttributeType GRAPHS _ALL_VALUE_TYPES = ir TensorType dtype dtype ir DataType &#124; ir SequenceType ir TensorType dtype dtype ir DataType &#124; ir OptionalType ir TensorType dtype dtype ir DataType TypeAnnotationValue represents value valid type-annotations recognized ONNX Script Currently supports - float int str primitive attribute types - Sequence float Sequence int Sequence str attribute types - Tensor types - Sequence Tensor types - Union above - TypeVars above bounds - Above types annotation attached TypeAnnotationValue = Any dataclasses dataclass frozen=True TypeConstraintParam Type constraint parameter Attributes name Name parameter E g TFloat allowed_types Allowed types parameter name str allowed_types set ir TypeProtocol description str = __hash__ - int hash name tuple allowed_types __str__ - str allowed_types_str = &#124; join str t t allowed_types f name = allowed_types_str classmethod any_tensor cls name str description str = - TypeConstraintParam cls name ir TensorType dtype dtype ir DataType description classmethod any_value cls name str description str = - TypeConstraintParam cls name _ALL_VALUE_TYPES description type ignore arg-type dataclasses dataclass frozen=True Parameter A formal parameter operator name str type_constraint TypeConstraintParam required bool variadic bool default Any = _EMPTY_DEFAULT TODO Add other properties too __str__ - str type_str = type_constraint name has_default f name type_str = default f name type_str has_default - bool default _EMPTY_DEFAULT dataclasses dataclass frozen=True AttributeParameter A parameter function signature represents ONNX attribute name str type ir AttributeType required bool default ir Attr &#124; None = None __str__ - str type_str = type name has_default f name type_str = default f name type_str has_default - bool default None _get_type_from_str type_str str - ir TensorType &#124; ir SequenceType &#124; ir OptionalType Converter type_str ONNX Opschema ir TypeProtocol A type str has form tensor float composite type like seq tensor float TODO Upstream IR Split type_str sequence types dtypes Remove ending striped = type_str rstrip Split type_str type_parts = striped split Convert dtype ir DataType dtype = ir DataType type_parts - upper Create place holder type first type_ ir TypeProtocol = ir TensorType ir DataType UNDEFINED Construct type type_part reversed type_parts - type_part == tensor type_ = ir TensorType dtype type_part == seq type_ = ir SequenceType type_ type_part == optional type_ = ir OptionalType type_ raise ValueError f Unknown type part type_part type type_str type_ type ignore return-value _convert_formal_parameter param onnx defs OpSchema FormalParameter type_constraints Mapping str TypeConstraintParam - Parameter Convert formal parameter ONNX Opschema Parameter param type_str type_constraints type_constraint = type_constraints param type_str param type_str can plain type like int type_constraint = TypeConstraintParam name=param name allowed_types= _get_type_from_str param type_str Parameter name=param name type_constraint=type_constraint required=param option = onnx defs OpSchema FormalParameterOption Optional variadic=param option == onnx defs OpSchema FormalParameterOption Variadic _is_optional type_ type - bool Returns whether type_ Optional origin_type = typing get_origin type_ origin_type Union type None typing get_args type_ Python True origin_type Optional Python = True hasattr types UnionType origin_type types UnionType type None typing get_args type_ Python = True False _get_attr_type type_ type - ir AttributeType Obtain type attribute Python try type_ _PY_TYPE_TO_ATTR_TYPE _PY_TYPE_TO_ATTR_TYPE type_ origin_type = typing get_origin type_ origin_type None ir AttributeType UNDEFINED origin_type collections abc Sequence Sequence list list tuple tuple inner_type = typing get_args type_ inner_type _LIST_TYPE_TO_ATTR_TYPE _LIST_TYPE_TO_ATTR_TYPE inner_type except TypeError logger warning TypeError when checking s type_ exc_info=True ir AttributeType UNDEFINED _get_type_constraint_name type_ TypeAnnotationValue - str &#124; None Returns name type constraint given type annotation Args type_ A Python type Returns The name type constraint TypeVar - Prefixes name Sequence_ type annotation Sequence isinstance type_ TypeVar type_ __name__ _is_optional type_ subtypes = typing get_args type_ subtype subtypes subtype type None continue type_param_name = _get_type_constraint_name subtype type_param_name type_param_name None origin_type = typing get_origin type_ isinstance origin_type type issubclass origin_type Sequence subtypes = typing get_args type_ type_param_name = _get_type_constraint_name subtypes f Sequence_ type_param_name type_param_name None None _get_allowed_types_from_type_annotation type_ TypeAnnotationValue - set ir TypeProtocol Obtain allowed types type annotation type_ onnxscript onnx_types TensorType Any tensor type ir TensorType dtype dtype ir DataType allowed_types set ir TypeProtocol isinstance type_ TypeVar allowed_types = set constraints = type_ __constraints__ constraint constraints allowed_types update _get_allowed_types_from_type_annotation constraint bound = type_ __bound__ bound None allowed_types = _ALL_VALUE_TYPES type ignore assignment allowed_types update _get_allowed_types_from_type_annotation bound allowed_types hasattr type_ dtype A single tensor type like INT FLOAT etc ir TensorType ir DataType type_ dtype _is_optional type_ allowed_types = set subtypes = typing get_args type_ subtype subtypes subtype type None continue allowed_types update _get_allowed_types_from_type_annotation subtype NOTE We do consider dynamic optional types like optional float because they very useful allowed_types origin_type = typing get_origin type_ origin_type Union allowed_types = set subtypes = typing get_args type_ subtype subtypes assert subtype type None Union should contain None type because handled _is_optional allowed_types update _get_allowed_types_from_type_annotation subtype allowed_types isinstance origin_type type issubclass origin_type Sequence subtypes = typing get_args type_ ir SequenceType t t _get_allowed_types_from_type_annotation subtypes Allow everything default _ALL_VALUE_TYPES type ignore return-value dataclasses dataclass OpSignature Schema operator Attributes domain Domain operator E g name Name operator E g Add overload Overload name operator params Input parameters When op ONNX function definition order according function signature This mean we can interleave ONNX inputs ONNX attributes list outputs Output parameters domain str name str overload str params Sequence Parameter &#124; AttributeParameter outputs Sequence Parameter params_map Mapping str Parameter &#124; AttributeParameter = dataclasses field init=False repr=False opset_version int &#124; None = None __post_init__ params_map = param name param param params get name str - Parameter &#124; AttributeParameter params_map name __contains__ name str - bool name params_map __iter__ - Iterator Parameter &#124; AttributeParameter iter params __str__ - str domain = domain TODO Double check separator overload overload = f overload overload params = join str param param params outputs = join str param type_constraint name param outputs type_constraints = param params isinstance param Parameter type_constraints param type_constraint name = param type_constraint param outputs type_constraints param type_constraint name = param type_constraint type_constraints_str = join str type_constraint type_constraint type_constraints values f domain name overload params - outputs where type_constraints_str classmethod from_opschema cls opschema onnx defs OpSchema - OpSignature Produce OpSignature ONNX Opschema type_constraints = constraint type_param_str TypeConstraintParam name=constraint type_param_str allowed_types= _get_type_from_str type_str type_str constraint allowed_type_strs description=constraint description constraint opschema type_constraints params = _convert_formal_parameter param type_constraints param opschema inputs param opschema attributes values default_attr = ir serde deserialize_attribute param default_value param default_value None None default_attr None Set name default attribute because may have different name parameter default_attr name = param name params append AttributeParameter name=param name type=ir AttributeType param type type ignore arg-type required=param required default=default_attr type ignore arg-type outputs = _convert_formal_parameter param type_constraints param opschema outputs cls domain=opschema domain name=opschema name overload= params=params outputs=outputs opset_version=opschema since_version classmethod from_function cls func domain str name str &#124; None = None overload str = opset_version int = - OpSignature Produce OpSignature function using type annotation py_signature = inspect signature func Not using inspect get_annotations because typing get_type_hints seems handle more cases https github com python cpython issues type_hints = typing get_type_hints func params list Parameter &#124; AttributeParameter = Create mapping type unique name type_constraints dict str TypeConstraintParam = param py_signature parameters values param name type_hints logger warning Missing annotation parameter s s Treating Input param name py_signature type_constraint = TypeConstraintParam any_value f T_ param name type_constraints param name = type_constraint params append Parameter name=param name type_constraint=type_constraint required=param default inspect Parameter empty TODO Handle variadic variadic=False default=param default param default inspect Parameter empty _EMPTY_DEFAULT type_ = type_hints param name attr_type = _get_attr_type type_ = ir AttributeType UNDEFINED Construct default attribute param default inspect Parameter empty TODO Use ir_convenience instead handle int float default = ir Attr param name attr_type param default default = None params append AttributeParameter name=param name type=attr_type required=param default inspect Parameter empty default=default Obtain type constraint type annotation Get type constraint name type annotation If type annotation TypeVar Optional TypeVar get its name Otherwise name T_ param name type_constraint_name = _get_type_constraint_name type_ type_constraint_name None type_constraint_name = f T_ param name If type constraint param already initialized use type_constraint_name type_constraints type_constraint = type_constraints type_constraint_name Otherwise create new TypeConstraintParam type_constraint = TypeConstraintParam name=type_constraint_name allowed_types=_get_allowed_types_from_type_annotation type_ type_constraints type_constraint_name = type_constraint Create Parameter params append Parameter name=param name type_constraint=type_constraint required=param default inspect Parameter empty TODO Handle variadic variadic=False default=param default param default inspect Parameter empty _EMPTY_DEFAULT return_type = type_hints get outputs = return_type None No returns pass typing get_origin return_type tuple Multiple returns return_types = typing get_args return_type return_types = return_type type ignore assignment i return_type_i enumerate return_types return_param_name = _get_type_constraint_name return_type_i type_constraints pyrefly ignore index-error type_constraint = type_constraints return_param_name return_param_name = f TReturn i type_constraint = TypeConstraintParam name=return_param_name allowed_types=_get_allowed_types_from_type_annotation return_type_i type_constraints return_param_name = type_constraint outputs append Parameter pyrefly ignore bad-argument-type name=return_param_name type_constraint=type_constraint required=True variadic=False default=_EMPTY_DEFAULT cls domain=domain name=name func __name__ overload=overload params=params outputs=outputs opset_version=opset_version