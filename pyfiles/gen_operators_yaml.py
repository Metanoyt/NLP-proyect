usr bin env python __future__ annotations argparse json sys typing Any yaml gen_op_registration_allowlist canonical_name gen_transitive_closure load_op_dep_graph torchgen selective_build operator merge_operator_dicts SelectiveBuildOperator torchgen selective_build selector merge_kernel_metadata Generate YAML file containing operators used specific PyTorch model ------------------------------------------------------------------------------ This binary responsible generating model_operators yaml file each model pt_operator_library BUCK macro invocation Output YAML file format ------------------------ BEGIN FILE CONTENTS include_all_non_op_selectives False include_all_operators False debug_info - model v - model v operators aten add is_root_operator Yes is_used_for_training Yes include_all_overloads No debug_info - model v - model v aten add int is_root_operator No is_used_for_training No include_all_overloads Yes kernel_metadata add_kernel - Int - UInt sub_kernel - Int - Float END FILE CONTENTS There few main inputs application ----------------------------------------------- Inference Root Operators -- root-ops Root operators called directly TorchScript used inference use-cases Training Root Operators -- training-root-ops Root operators used training use-cases Currently list list all operators used training just root operators All Training ops also considered inference so these merged into inference ops Operator Dependency Graph -- dep-graph-yaml-path A path operator dependency graph used determine which operators depend which other operators correct functioning This used generating transitive closure all operators used model based root operators when static selective build used For tracing based selective build we don t need perform transitive closure Model Metadata -- model-name -- model-versions -- model-assets -- model-backends Self-descriptive These used tell script which model operator lists fetch Model Build Metadata YAML files Model YAML files -- models-yaml-path These yaml files contains each model version asset backend set used root traced operators This used extract actual set operators needed included build canonical_opnames opnames list str - list str canonical_name opname opname opnames make_filter_from_options model_name str model_versions list str model_assets list str &#124; None model_backends list str &#124; None is_model_included model_info - bool model = model_info model model name = model_name False str model version model_versions False model_assets None model asset model_assets False TODO Handle backend later True is_model_included Returns specified rule new old style pt_operator_library is_new_style_rule model_name str model_versions list str &#124; None model_name None model_versions None Verifies specified model_name all specified versions assets appear least one model yaml Throws verification failed returns None success verify_all_specified_present model_assets list str &#124; None model_versions list str selected_models_yaml list dict str Any rule_name str model_name str new_style_rule bool - None find_missing_items model_items key selected_models_yaml missing_items = new_style_rule model_items missing_items item model_items found = False model selected_models_yaml str model model key == item found = True found missing_items append item missing_items missing_assets = find_missing_items model_assets asset selected_models_yaml missing_versions = find_missing_items model_versions version selected_models_yaml len missing_versions len missing_assets least one missing name_warning = len selected_models_yaml == name_warning = WARNING yaml s found target rule This could because + provided model name name incorrect Please check field well + assets versions format name=model_name raise RuntimeError Error From pt_operator_library rule Rule name least one entry + following fields expected -- Model model_name Expected Assets expected_assets Expected Versions + expected_versions name_warning In all_mobile_models yaml either no assets one + specified versions one specified assets present any specified + versions both Assets found missing_assets Versions found missing_versions + For questions please ask https fb workplace com groups format name=rule_name model_name=model_name expected_versions=model_versions expected_assets=model_assets model_assets All model assets present specified versions name_warning=name_warning missing_versions=missing_versions len missing_versions All specified versions had least one asset missing_assets=missing_assets len missing_assets All specified assets present least version Uses selected models configs then combines them into one dictionary formats them string places string into output top level debug_info create_debug_info_from_selected_models output dict str object selected_models list dict new_style_rule bool - None model_dict = asset_info maps asset name - dict asset metadata like hashes is_new_style_rule new_style_rule model selected_models model_info = model model asset = model_info asset hash = model_info md _hash asset_info = model_dict asset_info setdefault asset asset_info setdefault md _hash append hash Will later used gen_oplist generate model version asset checking output debug_info = json dumps model_dict fill_output output dict str object options object - None Populate output dict information required serialize YAML file used selective build dept_graph = load_op_dep_graph options dep_graph_yaml_path model_versions = options model_versions split options model_versions None model_assets = options model_assets split options model_assets None None all_models_yaml = options models_yaml_path yaml_path options models_yaml_path open yaml_path rb f all_models_yaml append yaml safe_load f model_filter_func = make_filter_from_options options model_name model_versions model_assets options model_backends selected_models_yaml = list filter model_filter_func all_models_yaml verify_all_specified_present model_assets=model_assets model_versions=model_versions selected_models_yaml=selected_models_yaml rule_name=options rule_name model_name=options model_name new_style_rule=is_new_style_rule options model_name options model_versions create_debug_info_from_selected_models output selected_models_yaml is_new_style_rule options model_name options model_versions initialize variables static build pt_operator_library rule options root_ops None static_root_ops = set filter lambda x len x options root_ops split static_root_ops = set static_training_root_ops = set filter lambda x len x options training_root_ops split len static_training_root_ops static_root_ops = static_root_ops &#124; static_training_root_ops end root_ops_unexpand = set traced_ops = set training_root_ops_unexpand = set traced_training_ops = set all_kernel_metadata = all_custom_classes = set all_build_features = set Go through each yaml file retrieve operator information model_info selected_models_yaml traced_operators model_info If YAML file doesn t specify any traced operators then using static analysis selective build approach finding transitively used operators we should update root_ops set root operators all whose overloads must included In addition these root_ops will further expanded using transitive closure operator dependencies static_root_ops = static_root_ops &#124; set model_info root_operators If YAML file specifies traced operators then using tracing based selective build approach finding used operators we should update root_ops_unexpand set root operators whose overloads don t need included In addition these root_ops_unexpand will NOT further expanded If train flag set then ops will used training so we put them separate set model_info train training_root_ops_unexpand = training_root_ops_unexpand &#124; set model_info root_operators traced_training_ops = traced_training_ops &#124; set model_info traced_operators root_ops_unexpand = root_ops_unexpand &#124; set model_info root_operators traced_ops = traced_ops &#124; set model_info traced_operators kernel_metadata model_info all_kernel_metadata append model_info kernel_metadata custom_classes model_info all_custom_classes = all_custom_classes &#124; set model_info custom_classes build_features model_info all_build_features = all_build_features &#124; set model_info build_features This following section transitive closure relevant static build only canonical_root_ops = canonical_opnames static_root_ops If no canonical_root_ops exist don t compute transitive closure otherwise we will include __BASE__ __ROOT__ ops mark them required inference len canonical_root_ops closure_op_list = gen_transitive_closure dept_graph canonical_root_ops closure_op_list = set canonical_training_root_ops = canonical_opnames static_training_root_ops If no canonical_training_root_ops exist don t compute transitive closure otherwise we will include __BASE__ __ROOT__ ops mark them required training len canonical_training_root_ops closure_training_op_list = gen_transitive_closure dept_graph canonical_training_root_ops train=True closure_training_op_list = set bucketed_ops holds sets operators correspond specific semantic buckets For example Root Operators used training w o full overload inclusion Root Operators used training w full overload inclusion Root Operators used training w o full overload inclusion Root Operators used training w full overload inclusion Non-root Operators used training w o full overload inclusion etc Basically each boolean conditional there options True False bucketed_ops = START STATIC BUILD OPS static_root_ops_bucket = op_name static_root_ops op = SelectiveBuildOperator from_yaml_dict op_name is_root_operator True is_used_for_training False include_all_overloads options not_include_all_overloads_static_root_ops debug_info options model_name static_root_ops_bucket op_name = op bucketed_ops append static_root_ops_bucket closure_ops_bucket = op_name closure_op_list op = SelectiveBuildOperator from_yaml_dict op_name is_root_operator False is_used_for_training False include_all_overloads options not_include_all_overloads_closure_ops debug_info options model_name closure_ops_bucket op_name = op bucketed_ops append closure_ops_bucket static_training_root_ops_bucket = op_name static_training_root_ops op = SelectiveBuildOperator from_yaml_dict op_name is_root_operator True is_used_for_training True include_all_overloads True debug_info options model_name static_training_root_ops_bucket op_name = op bucketed_ops append static_training_root_ops_bucket closure_training_ops_bucket = op_name closure_training_op_list op = SelectiveBuildOperator from_yaml_dict op_name is_root_operator False is_used_for_training True include_all_overloads True debug_info options model_name closure_training_ops_bucket op_name = op bucketed_ops append closure_training_ops_bucket END STATIC BUILD OPS START TRACING BASED BUILD OPS root_ops_unexpand_bucket = op_name root_ops_unexpand op = SelectiveBuildOperator from_yaml_dict op_name is_root_operator True is_used_for_training False include_all_overloads False debug_info options model_name root_ops_unexpand_bucket op_name = op bucketed_ops append root_ops_unexpand_bucket traced_ops_bucket = op_name traced_ops op = SelectiveBuildOperator from_yaml_dict op_name is_root_operator False is_used_for_training False include_all_overloads False debug_info options model_name traced_ops_bucket op_name = op bucketed_ops append traced_ops_bucket training_root_ops_unexpand_bucket = op_name training_root_ops_unexpand op = SelectiveBuildOperator from_yaml_dict op_name is_root_operator True is_used_for_training True include_all_overloads False debug_info options model_name training_root_ops_unexpand_bucket op_name = op bucketed_ops append training_root_ops_unexpand_bucket traced_training_ops_bucket = op_name traced_training_ops op = SelectiveBuildOperator from_yaml_dict op_name is_root_operator False is_used_for_training True include_all_overloads False debug_info options model_name traced_training_ops_bucket op_name = op bucketed_ops append traced_training_ops_bucket END TRACING BASED BUILD OPS Merge dictionaries together remove op duplication operators dict str SelectiveBuildOperator = ops_dict bucketed_ops operators = merge_operator_dicts operators ops_dict Loop over all operators any them specifies all overloads need included then set include_all_non_op_selectives True since indicates operator list came something other than traced operator list include_all_non_op_selectives = False op_name op_info operators items include_all_non_op_selectives = include_all_non_op_selectives op_info include_all_overloads operators_as_dict = k v operators items operators_as_dict k = v to_dict output operators = operators_as_dict output custom_classes = all_custom_classes output build_features = all_build_features output include_all_non_op_selectives = include_all_non_op_selectives len all_kernel_metadata kernel_metadata = kt all_kernel_metadata kernel_metadata = merge_kernel_metadata kernel_metadata kt output kernel_metadata = kernel_metadata add_arguments_parser parser argparse ArgumentParser - argparse ArgumentParser parser add_argument -- root-ops -- root_ops help= A comma separated list root operators used model required=False parser add_argument -- training-root-ops -- training_root_ops help= A comma separated list root operators used training required=False parser add_argument -- output-path -- output_path help= The location output yaml file required=True parser add_argument -- dep-graph-yaml-path -- dep_graph_yaml_path type=str help= A path Operator Dependency Graph YAML file required=True parser add_argument -- model-name -- model_name type=str help= The name model uses specified root operators required=True parser add_argument -- model-versions -- model_versions type=str help= A comma separated list model versions required=False parser add_argument -- model-assets -- model_assets type=str help= A comma separate list model asset names absent defaults all assets model required=False parser add_argument -- model-backends -- model_backends type=str default= CPU help= A comma separated list model backends required=False parser add_argument -- models-yaml-path -- models_yaml_path type=str help= The paths mobile model config YAML files required=False nargs= + parser add_argument -- include-all-operators -- include_all_operators action= store_true default=False help= Set flag request inclusion all operators i e build selective required=False parser add_argument -- rule-name -- rule_name type=str help= The name pt_operator_library rule resulting generation required=True parser add_argument -- not-include-all-overloads-static-root-ops -- not_include_all_overloads_static_root_ops action= store_true default=False help= Set flag include all overloaded operators static root ops bucket fill_output subroutine required=False parser add_argument -- not-include-all-overloads-closure-ops -- not_include_all_overloads_closure_ops action= store_true default=False help= Set flag include all overloaded operators closure ops bucket fill_output subroutine required=False parser parse_options parser argparse ArgumentParser - argparse Namespace parser parse_args get_parser_options parser argparse ArgumentParser - argparse Namespace parser = add_arguments_parser parser parse_options parser main argv - None parser = argparse ArgumentParser description= Generate used operators YAML options = get_parser_options parser model_dict = model_name options model_name asset_info is_new_style_rule False output = debug_info json dumps model_dict options include_all_operators output include_all_operators = True output operators = output kernel_metadata = fill_output output options open options output_path wb out_file out_file write yaml safe_dump output default_flow_style=False encode utf- __name__ == __main__ sys exit main sys argv