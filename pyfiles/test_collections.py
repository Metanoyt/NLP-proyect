======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_collections py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests __TestCase = CPythonTestCase ======= END DYNAMO PATCH ======= Unit tests collections py array collections copy doctest inspect operator pickle random choice randrange itertools product chain combinations string sys test support types unittest collections namedtuple Counter OrderedDict _count_elements collections UserDict UserString UserList collections ChainMap collections deque collections abc Awaitable Coroutine collections abc AsyncIterator AsyncIterable AsyncGenerator collections abc Hashable Iterable Iterator Generator Reversible collections abc Sized Container Callable Collection collections abc Set MutableSet collections abc Mapping MutableMapping KeysView ItemsView ValuesView collections abc Sequence MutableSequence collections abc ByteString Buffer TestUserObjects __TestCase _superset_test b assertGreaterEqual set dir set dir b should have all methods b format a=a __name__ b=b __name__ _copy_test obj Test internal copy obj_copy = obj copy assertIsNot obj data obj_copy data assertEqual obj data obj_copy data Test copy copy obj test = Make sure instance vars also copied obj_copy = copy copy obj assertIsNot obj data obj_copy data assertEqual obj data obj_copy data assertIs obj test obj_copy test test_str_protocol _superset_test UserString str test_list_protocol _superset_test UserList list test_dict_protocol _superset_test UserDict dict test_list_copy obj = UserList obj append _copy_test obj test_dict_copy obj = UserDict obj = abc _copy_test obj test_dict_missing torch _dynamo error_on_graph_break False A UserDict __missing__ key assertEqual A get ignores __missing__ dict assertIs A get None ################################################################################ ### ChainMap helper configparser string module ################################################################################ TestChainMap __TestCase test_basics c = ChainMap c = c b = d = c new_child d b = d c = assertEqual d maps b c b check internal state assertEqual d items dict a= b= c= items check items iter getitem assertEqual len d check len key abc check contains assertIn key d k v dict a= b= c= z= items check get assertEqual d get k v del d b unmask value assertEqual d maps c b check internal state assertEqual d items dict a= b= c= items check items iter getitem assertEqual len d check len key abc check contains assertIn key d k v dict a= b= c= z= items check get assertEqual d get k v assertIn repr d check repr type d __name__ + c b type d __name__ + c b e d copy copy copy d check shallow copies assertEqual d e assertEqual d maps e maps assertIsNot d e assertIsNot d maps e maps m m zip d maps e maps assertIs m m check deep copies proto range pickle HIGHEST_PROTOCOL + e = pickle loads pickle dumps d proto assertEqual d e assertEqual d maps e maps assertIsNot d e m m zip d maps e maps assertIsNot m m e e copy deepcopy d eval repr d assertEqual d e assertEqual d maps e maps assertIsNot d e m m zip d maps e maps assertIsNot m m e f = d new_child f b = assertEqual f maps b c b assertEqual f parents maps c b check parents assertEqual f b find first chain assertEqual f parents b look beyond maps test_ordering Combined order matches series dict updates last first This test relies ordering underlying dicts baseline = music bach art rembrandt adjustments = art van gogh opera carmen cm = ChainMap adjustments baseline combined = baseline copy combined update adjustments assertEqual list combined items list cm items test_constructor assertEqual ChainMap maps no-args -- one new dict assertEqual ChainMap maps arg -- list test_bool assertFalse ChainMap assertFalse ChainMap assertTrue ChainMap assertTrue ChainMap test_missing torch _dynamo error_on_graph_break False DefaultChainMap ChainMap __missing__ key d = DefaultChainMap dict a= b= dict b= c= k v dict a= b= c= d= items assertEqual d k v check __getitem__ w missing k v dict a= b= c= d= items assertEqual d get k v check get w missing k v dict a=True b=True c=True d=False items assertEqual k d v check __contains__ w missing assertEqual d pop d assertEqual d pop check pop w missing assertEqual d popitem b check popitem w missing assertRaises KeyError d popitem test_order_preservation d = ChainMap OrderedDict j= h= OrderedDict OrderedDict i= d= c= OrderedDict f= b= g= c= h= OrderedDict OrderedDict e= b= OrderedDict a= b= c= d= e= OrderedDict assertEqual join d abcdefghij assertEqual list d items b c d e f g h i j test_iter_not_calling_getitem_on_maps torch _dynamo error_on_graph_break False DictWithGetItem UserDict __init__ args kwds called = False UserDict __init__ args kwds __getitem__ item called = True UserDict __getitem__ item d = DictWithGetItem a= c = ChainMap d d called = False set c iterate over chain map assertFalse d called __getitem__ called test_dict_coercion d = ChainMap dict a= b= dict b= c= assertEqual dict d dict a= b= c= assertEqual dict d items dict a= b= c= test_new_child Tests changes issue c = ChainMap c = c b = m = b c d = c new_child m assertEqual d maps b c b check internal state assertIs m d maps Use different map than dict torch _dynamo error_on_graph_break False lowerdict dict __getitem__ key isinstance key str key = key lower dict __getitem__ key __contains__ key isinstance key str key = key lower dict __contains__ key c = ChainMap c = c b = m = lowerdict b= c= d = c new_child m assertIs m d maps key abc check contains assertIn key d k v dict a= B= C= z= items check get assertEqual d get k v c = ChainMap b d = c new_child b= c= assertEqual d maps b c b test_union_operators cm = ChainMap dict a= b= dict c= d= cm = ChainMap dict a= e= dict b= d= cm = cm copy d = dict a= c= pairs = c p tmp = cm &#124; cm testing between chainmaps assertEqual tmp maps cm maps &#124; dict cm cm maps cm &#124; = cm assertEqual tmp cm tmp = cm &#124; d testing between chainmap mapping assertEqual tmp maps cm maps &#124; d cm maps assertEqual d &#124; cm maps d &#124; dict cm cm &#124; = d assertEqual tmp cm testing behavior between chainmap iterable key-value pairs assertRaises TypeError cm &#124; pairs tmp = cm copy cm &#124; = pairs assertEqual cm maps tmp maps &#124; dict pairs tmp maps testing proper types ChainMap s subclasses Subclass ChainMap pass SubclassRor ChainMap __ror__ other super __ror__ other tmp = ChainMap &#124; ChainMap assertIs type tmp ChainMap assertIs type tmp maps dict tmp = ChainMap &#124; Subclass assertIs type tmp ChainMap assertIs type tmp maps dict tmp = Subclass &#124; ChainMap assertIs type tmp Subclass assertIs type tmp maps dict tmp = ChainMap &#124; SubclassRor assertIs type tmp SubclassRor assertIs type tmp maps dict ################################################################################ ### Named Tuples ################################################################################ TestNT = namedtuple TestNT x y z type used pickle tests TestNamedTuple __TestCase test_factory Point = namedtuple Point x y assertEqual Point __name__ Point assertEqual Point __slots__ assertEqual Point __module__ __name__ assertEqual Point __getitem__ tuple __getitem__ assertEqual Point _fields x y assertRaises ValueError namedtuple abc efg ghi type has non-alpha char assertRaises ValueError namedtuple efg ghi type has keyword assertRaises ValueError namedtuple abc efg ghi type starts digit assertRaises ValueError namedtuple abc efg g hi field non-alpha char assertRaises ValueError namedtuple abc abc field has keyword assertRaises ValueError namedtuple abc efg ghi field starts digit assertRaises ValueError namedtuple abc _efg ghi field leading underscore assertRaises ValueError namedtuple abc efg efg ghi duplicate field namedtuple Point x y Verify numbers allowed names namedtuple _ b c Test leading underscores typename nt = namedtuple nt quick brown fox check unicode input assertNotIn u repr nt _fields nt = namedtuple nt quick check unicode input assertNotIn u repr nt _fields assertRaises TypeError Point _make catch too few args assertRaises TypeError Point _make catch too many args test_defaults Point = namedtuple Point x y defaults= defaults assertEqual Point _field_defaults x y assertEqual Point assertEqual Point assertEqual Point Point = namedtuple Point x y defaults= default assertEqual Point _field_defaults y assertEqual Point assertEqual Point Point = namedtuple Point x y defaults= defaults assertEqual Point _field_defaults assertEqual Point assertRaises TypeError Point assertRaises TypeError catch too few args Point assertRaises TypeError catch too many args Point assertRaises TypeError too many defaults Point = namedtuple Point x y defaults= assertRaises TypeError non-iterable defaults Point = namedtuple Point x y defaults= assertRaises TypeError another non-iterable default Point = namedtuple Point x y defaults=False Point = namedtuple Point x y defaults=None default None assertEqual Point _field_defaults assertIsNone Point __new__ __defaults__ None assertEqual Point assertRaises TypeError catch too few args Point Point = namedtuple Point x y defaults= allow non-tuple iterable assertEqual Point _field_defaults x y assertEqual Point __new__ __defaults__ assertEqual Point assertEqual Point assertEqual Point Point = namedtuple Point x y defaults=iter allow plain iterator assertEqual Point _field_defaults x y assertEqual Point __new__ __defaults__ assertEqual Point assertEqual Point assertEqual Point test_readonly Point = namedtuple Point x y p = Point assertRaises AttributeError p x = assertRaises AttributeError del p x assertRaises TypeError p = assertRaises TypeError del p assertEqual p x assertEqual p unittest skipIf sys flags optimize = Docstrings omitted -O above test_factory_doc_attr Point = namedtuple Point x y assertEqual Point __doc__ Point x y Point __doc__ = D point assertEqual Point __doc__ D point unittest skipIf sys flags optimize = Docstrings omitted -O above test_field_doc Point = namedtuple Point x y assertEqual Point x __doc__ Alias field number assertEqual Point y __doc__ Alias field number Point x __doc__ = docstring Point x assertEqual Point x __doc__ docstring Point x namedtuple can mutate doc descriptors independently Vector = namedtuple Vector x y assertEqual Vector x __doc__ Alias field number Vector x __doc__ = docstring Vector x assertEqual Vector x __doc__ docstring Vector x support cpython_only unittest skipIf sys flags optimize = Docstrings omitted -O above test_field_doc_reuse P = namedtuple P m n Q = namedtuple Q o p assertIs P m __doc__ Q o __doc__ assertIs P n __doc__ Q p __doc__ support cpython_only test_field_repr Point = namedtuple Point x y assertEqual repr Point x _tuplegetter Alias field number assertEqual repr Point y _tuplegetter Alias field number Point x __doc__ = The x-coordinate Point y __doc__ = The y-coordinate assertEqual repr Point x _tuplegetter The x-coordinate assertEqual repr Point y _tuplegetter The y-coordinate test_name_fixer spec renamed efg g hi efg _ field non-alpha char abc abc _ field has keyword efg ghi _ _ field starts digit abc _efg abc _ field leading underscore abc efg efg ghi abc efg _ ghi duplicate field abc x abc _ x fieldname space assertEqual namedtuple NT spec rename=True _fields renamed test_module_parameter NT = namedtuple NT x y module=collections assertEqual NT __module__ collections test_instance Point = namedtuple Point x y p = Point assertEqual p Point x= y= assertEqual p Point y= assertEqual p Point y= x= assertEqual p Point assertEqual p Point dict x= y= assertRaises TypeError Point too few args assertRaises TypeError Point too many args assertRaises TypeError wrong keyword argument Point XXX= y= assertRaises TypeError missing keyword argument Point x= assertEqual repr p Point x= y= assertNotIn __weakref__ dir p assertEqual p Point _make test _make classmethod assertEqual p _fields x y test _fields attribute assertEqual p _replace x= test _replace method assertEqual p _asdict dict x= y= test _asdict method assertRaises TypeError p _replace x= error= verify field string can have commas Point = namedtuple Point x y p = Point x= y= assertEqual repr p Point x= y= verify fieldspec can non-string sequence Point = namedtuple Point x y p = Point x= y= assertEqual repr p Point x= y= test_tupleness Point = namedtuple Point x y p = Point assertIsInstance p tuple assertEqual p matches real tuple assertEqual tuple p coercible real tuple assertEqual list p coercible list assertEqual max p iterable assertEqual max p star-able x y = p assertEqual p x y unpacks like tuple assertEqual p p indexable like tuple assertRaises IndexError p assertEqual p - assertEqual hash p hash assertEqual p x x assertEqual p y y assertRaises AttributeError p z test_odd_sizes Zero = namedtuple Zero assertEqual Zero assertEqual Zero _make assertEqual repr Zero Zero assertEqual Zero _asdict assertEqual Zero _fields Dot = namedtuple Dot d assertEqual Dot assertEqual Dot _make assertEqual Dot d assertEqual repr Dot Dot d= assertEqual Dot _asdict d assertEqual Dot _replace d= assertEqual Dot _fields d support requires_resource cpu test_large_size n = support exceeds_recursion_limit names = list set join choice string ascii_letters j range i range n n = len names Big = namedtuple Big names b = Big range n assertEqual b tuple range n assertEqual Big _make range n tuple range n pos name enumerate names assertEqual getattr b name pos repr b make sure repr doesn t blow-up d = b _asdict d_expected = dict zip names range n assertEqual d d_expected b = b _replace dict names names - b _expected = list range n b _expected = b _expected - = assertEqual b tuple b _expected assertEqual b _fields tuple names test_pickle p = TestNT x= y= z= module pickle loads = getattr module loads dumps = getattr module dumps protocol range - module HIGHEST_PROTOCOL + q = loads dumps p protocol assertEqual p q assertEqual p _fields q _fields assertNotIn b OrderedDict dumps p protocol test_copy p = TestNT x= y= z= copier copy copy copy deepcopy q = copier p assertEqual p q assertEqual p _fields q _fields test_name_conflicts Some names like cls tuple itemgetter property failed when used field names Test make sure these now work T = namedtuple T itemgetter property cls tuple t = T assertEqual t newt = t _replace itemgetter= property= self= cls= tuple= assertEqual newt Broader test all interesting names taken code old template example words = Alias At AttributeError Build Bypass Create Encountered Expected Field For Got Helper IronPython Jython KeyError Make Modify Note OrderedDict Point Return Returns Type TypeError Used Validate ValueError Variables accessible add added all also arg_list args arguments automatically build builtins cannot class_namespace classmethod cls collections convert copy created creation d debugging defined dict dictionary doc docstring docstrings duplicate effect either enumerate environments error example exec f f_globals field field_names fields formatted frame function functions generate get getter got greater has help identifiers index indexable instance instantiate interning introspection isidentifier isinstance itemgetter iterable join keyword keywords kwds len like list map maps message metadata method methods module module_name must name named namedtuple namedtuple_ names namespace needs new nicely num_fields number object operator option p particular pickle pickling plain pop positional property r regular rename replace replacing repr repr_fmt representation result reuse_itemgetter s seen sequence set side specified split start startswith step str string strings subclass sys targets than their tuple tuple_new type typename underscore unexpected unpack up use used user valid values variable verbose where which work x y z zip T = namedtuple T words test __new__ values = tuple range len words t = T values assertEqual t values t = T dict zip T _fields values assertEqual t values test _make t = T _make values assertEqual t values exercise __repr__ repr t test _asdict assertEqual t _asdict dict zip T _fields values test _replace t = T _make values newvalues = tuple v v values newt = t _replace dict zip T _fields newvalues assertEqual newt newvalues test _fields assertEqual T _fields tuple words test __getnewargs__ assertEqual t __getnewargs__ values test_repr A = namedtuple A x assertEqual repr A A x= repr should show name subclass B A pass assertEqual repr B B x= test_keyword_only_arguments See issue assertRaises TypeError NT = namedtuple NT x y True NT = namedtuple NT abc rename=True assertEqual NT _fields abc _ assertRaises TypeError NT = namedtuple NT abc False True test_namedtuple_subclass_issue_ torch _dynamo error_on_graph_break False Point namedtuple _Point x y pass = Point assertEqual _asdict OrderedDict x y w = assertEqual __dict__ w support cpython_only test_field_descriptor Point = namedtuple Point x y p = Point assertTrue inspect isdatadescriptor Point x assertEqual Point x __get__ p assertRaises AttributeError Point x __set__ p assertRaises AttributeError Point x __delete__ p proto range pickle HIGHEST_PROTOCOL + subTest proto=proto NewPoint tuple x = pickle loads pickle dumps Point x proto y = pickle loads pickle dumps Point y proto np = NewPoint assertEqual np x assertEqual np y test_new_builtins_issue_ obj = namedtuple C new_func = obj __new__ assertEqual new_func __globals__ __builtins__ assertEqual new_func __builtins__ test_match_args Point = namedtuple Point x y assertEqual Point __match_args__ x y test_non_generic_subscript For backward compatibility subscription works arbitrary named tuple types Group = collections namedtuple Group key group A = Group int list int assertEqual A __origin__ Group assertEqual A __parameters__ assertEqual A __args__ int list int = A assertIs type Group assertEqual ################################################################################ ### Abstract Base Classes ################################################################################ ABCTestCase __TestCase validate_abstract_methods abc names methodstubs = dict fromkeys names lambda s args everything should work will all required methods present torch _dynamo error_on_graph_break False C = type C abc methodstubs C Dynamo raises hard error here we can t easily capture Commenting part would also fail eager user attempt run same code instantiation should fail required method missing name names stubs = methodstubs copy del stubs name C = type C abc stubs assertRaises TypeError C name validate_isinstance abc name stub = lambda s args C = type C object __hash__ None setattr C name stub assertIsInstance C abc assertTrue issubclass C abc C = type C object __hash__ None assertNotIsInstance C abc assertFalse issubclass C abc validate_comparison instance ops = lt gt le ge ne xor sub operators = op ops name = __ + op + __ operators name = getattr operator name Other __init__ right_side = False __eq__ other right_side = True True __lt__ = __eq__ __gt__ = __eq__ __le__ = __eq__ __ge__ = __eq__ __ne__ = __eq__ __ror__ = __eq__ __rand__ = __eq__ __rxor__ = __eq__ __rsub__ = __eq__ name op operators items hasattr instance name continue other = Other op instance other assertTrue other right_side Right side called s s type instance name _test_gen yield TestOneTrickPonyABCs ABCTestCase test_Awaitable gen yield types coroutine coro yield async new_coro pass Bar __await__ yield MinimalCoro Coroutine send value value throw typ val=None tb=None super throw typ val tb __await__ yield validate_abstract_methods Awaitable __await__ non_samples = None int gen object x non_samples assertNotIsInstance x Awaitable assertFalse issubclass type x Awaitable repr type x samples = Bar MinimalCoro x samples assertIsInstance x Awaitable assertTrue issubclass type x Awaitable c = coro Iterable coroutines generators CO_ITERABLE_COROUTINE flag don t have __await__ method hence can t instances Awaitable Use inspect isawaitable detect them assertNotIsInstance c Awaitable c = new_coro assertIsInstance c Awaitable c close avoid RuntimeWarning coro awaited CoroLike pass Coroutine register CoroLike assertTrue isinstance CoroLike Awaitable assertTrue issubclass CoroLike Awaitable CoroLike = None support gc_collect Kill CoroLike clean-up ABCMeta cache test_Coroutine gen yield types coroutine coro yield async new_coro pass Bar __await__ yield MinimalCoro Coroutine send value value throw typ val=None tb=None super throw typ val tb __await__ yield validate_abstract_methods Coroutine __await__ send throw non_samples = None int gen object Bar x non_samples assertNotIsInstance x Coroutine assertFalse issubclass type x Coroutine repr type x samples = MinimalCoro x samples assertIsInstance x Awaitable assertTrue issubclass type x Awaitable c = coro Iterable coroutines generators CO_ITERABLE_COROUTINE flag don t have __await__ method hence can t instances Coroutine Use inspect isawaitable detect them assertNotIsInstance c Coroutine c = new_coro assertIsInstance c Coroutine c close avoid RuntimeWarning coro awaited CoroLike send value pass throw typ val=None tb=None pass close pass __await__ pass assertTrue isinstance CoroLike Coroutine assertTrue issubclass CoroLike Coroutine CoroLike send value pass close pass __await__ pass assertFalse isinstance CoroLike Coroutine assertFalse issubclass CoroLike Coroutine test_Hashable Check some non-hashables non_samples = bytearray list set dict x non_samples assertNotIsInstance x Hashable assertFalse issubclass type x Hashable repr type x Check some hashables samples = None int float complex str tuple frozenset int list object type bytes x samples assertIsInstance x Hashable assertTrue issubclass type x Hashable repr type x assertRaises TypeError Hashable Check direct subclassing H Hashable __hash__ super __hash__ assertEqual hash H assertFalse issubclass int H validate_abstract_methods Hashable __hash__ validate_isinstance Hashable __hash__ test_AsyncIterable AI __aiter__ assertTrue isinstance AI AsyncIterable assertTrue issubclass AI AsyncIterable Check some non-iterables non_samples = None object x non_samples assertNotIsInstance x AsyncIterable assertFalse issubclass type x AsyncIterable repr type x validate_abstract_methods AsyncIterable __aiter__ validate_isinstance AsyncIterable __aiter__ test_AsyncIterator AI __aiter__ async __anext__ raise StopAsyncIteration assertTrue isinstance AI AsyncIterator assertTrue issubclass AI AsyncIterator non_samples = None object Check some non-iterables x non_samples assertNotIsInstance x AsyncIterator assertFalse issubclass type x AsyncIterator repr type x Similarly regular iterators see issue AnextOnly async __anext__ raise StopAsyncIteration assertNotIsInstance AnextOnly AsyncIterator validate_abstract_methods AsyncIterator __anext__ __aiter__ test_Iterable Check some non-iterables non_samples = None j x non_samples assertNotIsInstance x Iterable assertFalse issubclass type x Iterable repr type x Check some iterables samples = bytes str tuple list set frozenset dict dict keys dict items dict values _test_gen x x x samples assertIsInstance x Iterable assertTrue issubclass type x Iterable repr type x torch _dynamo error_on_graph_break False Check direct subclassing I Iterable __iter__ super __iter__ assertEqual list I assertFalse issubclass str I validate_abstract_methods Iterable __iter__ validate_isinstance Iterable __iter__ torch _dynamo error_on_graph_break False Check None blocking It __iter__ iter ItBlocked It __iter__ = None assertTrue issubclass It Iterable assertTrue isinstance It Iterable assertFalse issubclass ItBlocked Iterable assertFalse isinstance ItBlocked Iterable test_Reversible Check some non-reversibles non_samples = None j set frozenset x non_samples assertNotIsInstance x Reversible assertFalse issubclass type x Reversible repr type x Check some non-reversible iterables non_reversibles = _test_gen x x iter reversed x non_reversibles assertNotIsInstance x Reversible assertFalse issubclass type x Reversible repr type x Check some reversible iterables samples = bytes str tuple list OrderedDict OrderedDict keys OrderedDict items OrderedDict values Counter Counter keys Counter items Counter values dict dict keys dict items dict values x samples assertIsInstance x Reversible assertTrue issubclass type x Reversible repr type x Check also Mapping MutableMapping Sequence assertTrue issubclass Sequence Reversible repr Sequence assertFalse issubclass Mapping Reversible repr Mapping assertFalse issubclass MutableMapping Reversible repr MutableMapping torch _dynamo error_on_graph_break False Check direct subclassing R Reversible __iter__ iter list __reversed__ iter list assertEqual list reversed R assertFalse issubclass float R validate_abstract_methods Reversible __reversed__ __iter__ torch _dynamo error_on_graph_break False Check reversible non-iterable which Reversible RevNoIter __reversed__ reversed RevPlusIter RevNoIter __iter__ iter assertFalse issubclass RevNoIter Reversible assertFalse isinstance RevNoIter Reversible assertTrue issubclass RevPlusIter Reversible assertTrue isinstance RevPlusIter Reversible torch _dynamo error_on_graph_break False Check None blocking Rev __iter__ iter __reversed__ reversed RevItBlocked Rev __iter__ = None RevRevBlocked Rev __reversed__ = None assertTrue issubclass Rev Reversible assertTrue isinstance Rev Reversible assertFalse issubclass RevItBlocked Reversible assertFalse isinstance RevItBlocked Reversible assertFalse issubclass RevRevBlocked Reversible assertFalse isinstance RevRevBlocked Reversible test_Collection Check some non-collections non_collections = None j lambda x x x non_collections assertNotIsInstance x Collection assertFalse issubclass type x Collection repr type x Check some non-collection iterables non_col_iterables = _test_gen iter b iter bytearray x x x non_col_iterables assertNotIsInstance x Collection assertFalse issubclass type x Collection repr type x Check some collections samples = set frozenset dict bytes str tuple list dict keys dict items dict values x samples assertIsInstance x Collection assertTrue issubclass type x Collection repr type x Check also Mapping MutableMapping etc assertTrue issubclass Sequence Collection repr Sequence assertTrue issubclass Mapping Collection repr Mapping assertTrue issubclass MutableMapping Collection repr MutableMapping assertTrue issubclass Set Collection repr Set assertTrue issubclass MutableSet Collection repr MutableSet assertTrue issubclass Sequence Collection repr MutableSet torch _dynamo error_on_graph_break False Check direct subclassing Col Collection __iter__ iter list __len__ __contains__ item False DerCol Col pass assertEqual list iter Col assertFalse issubclass list Col assertFalse issubclass set Col assertFalse issubclass float Col assertEqual list iter DerCol assertFalse issubclass list DerCol assertFalse issubclass set DerCol assertFalse issubclass float DerCol validate_abstract_methods Collection __len__ __iter__ __contains__ Check sized container non-iterable which Collection etc torch _dynamo error_on_graph_break False ColNoIter __len__ __contains__ item False ColNoSize __iter__ iter __contains__ item False ColNoCont __iter__ iter __len__ assertFalse issubclass ColNoIter Collection assertFalse isinstance ColNoIter Collection assertFalse issubclass ColNoSize Collection assertFalse isinstance ColNoSize Collection assertFalse issubclass ColNoCont Collection assertFalse isinstance ColNoCont Collection torch _dynamo error_on_graph_break False Check None blocking SizeBlock __iter__ iter __contains__ False __len__ = None IterBlock __len__ __contains__ True __iter__ = None assertFalse issubclass SizeBlock Collection assertFalse isinstance SizeBlock Collection assertFalse issubclass IterBlock Collection assertFalse isinstance IterBlock Collection torch _dynamo error_on_graph_break False Check None blocking subclass ColImpl __iter__ iter list __len__ __contains__ item False NonCol ColImpl __contains__ = None assertFalse issubclass NonCol Collection assertFalse isinstance NonCol Collection test_Iterator non_samples = None j b set x non_samples assertNotIsInstance x Iterator assertFalse issubclass type x Iterator repr type x samples = iter bytes iter str iter tuple iter list iter dict iter set iter frozenset iter dict keys iter dict items iter dict values _test_gen x x x samples assertIsInstance x Iterator assertTrue issubclass type x Iterator repr type x validate_abstract_methods Iterator __next__ __iter__ torch _dynamo error_on_graph_break False Issue NextOnly __next__ yield assertNotIsInstance NextOnly Iterator test_Generator torch _dynamo error_on_graph_break False NonGen __iter__ __next__ None close pass throw typ val=None tb=None pass NonGen __iter__ __next__ None close pass send value value NonGen close pass send value value throw typ val=None tb=None pass non_samples = None j b set iter iter NonGen NonGen NonGen x non_samples assertNotIsInstance x Generator assertFalse issubclass type x Generator repr type x torch _dynamo error_on_graph_break False Gen __iter__ __next__ None close pass send value value throw typ val=None tb=None pass MinimalGen Generator send value value throw typ val=None tb=None super throw typ val tb gen yield samples = gen lambda yield Gen MinimalGen x samples assertIsInstance x Iterator assertIsInstance x Generator assertTrue issubclass type x Generator repr type x validate_abstract_methods Generator send throw mixin tests mgen = MinimalGen assertIs mgen iter mgen assertIs mgen send None next mgen assertEqual mgen send assertIsNone mgen close assertRaises ValueError mgen throw ValueError assertRaisesRegex ValueError ^huhu$ mgen throw ValueError ValueError huhu assertRaises StopIteration mgen throw StopIteration torch _dynamo error_on_graph_break False FailOnClose Generator send value value throw args raise ValueError assertRaises ValueError FailOnClose close torch _dynamo error_on_graph_break False IgnoreGeneratorExit Generator send value value throw args pass assertRaises RuntimeError IgnoreGeneratorExit close test_AsyncGenerator NonAGen __aiter__ __anext__ None aclose pass athrow typ val=None tb=None pass NonAGen __aiter__ __anext__ None aclose pass asend value value NonAGen aclose pass asend value value athrow typ val=None tb=None pass non_samples = None j b set iter iter NonAGen NonAGen NonAGen x non_samples assertNotIsInstance x AsyncGenerator assertFalse issubclass type x AsyncGenerator repr type x Gen __aiter__ async __anext__ None async aclose pass async asend value value async athrow typ val=None tb=None pass MinimalAGen AsyncGenerator async asend value value async athrow typ val=None tb=None await super athrow typ val tb async gen yield samples = gen Gen MinimalAGen x samples assertIsInstance x AsyncIterator assertIsInstance x AsyncGenerator assertTrue issubclass type x AsyncGenerator repr type x validate_abstract_methods AsyncGenerator asend athrow run_async coro result = None while True try coro send None except StopIteration ex result = ex args ex args None break result mixin tests mgen = MinimalAGen assertIs mgen mgen __aiter__ assertIs run_async mgen asend None run_async mgen __anext__ assertEqual run_async mgen asend assertIsNone run_async mgen aclose assertRaises ValueError run_async mgen athrow ValueError FailOnClose AsyncGenerator async asend value value async athrow args raise ValueError assertRaises ValueError run_async FailOnClose aclose IgnoreGeneratorExit AsyncGenerator async asend value value async athrow args pass assertRaises RuntimeError run_async IgnoreGeneratorExit aclose test_Sized non_samples = None j _test_gen x x x non_samples assertNotIsInstance x Sized assertFalse issubclass type x Sized repr type x samples = bytes str tuple list set frozenset dict dict keys dict items dict values x samples assertIsInstance x Sized assertTrue issubclass type x Sized repr type x validate_abstract_methods Sized __len__ validate_isinstance Sized __len__ test_Container non_samples = None j _test_gen x x x non_samples assertNotIsInstance x Container assertFalse issubclass type x Container repr type x samples = bytes str tuple list set frozenset dict dict keys dict items x samples assertIsInstance x Container assertTrue issubclass type x Container repr type x validate_abstract_methods Container __contains__ validate_isinstance Container __contains__ test_Callable non_samples = None j b set _test_gen x x x non_samples assertNotIsInstance x Callable assertFalse issubclass type x Callable repr type x samples = lambda None type int object len list append append x samples assertIsInstance x Callable assertTrue issubclass type x Callable repr type x validate_abstract_methods Callable __call__ validate_isinstance Callable __call__ test_direct_subclassing B Hashable Iterable Iterator Reversible Sized Container Callable torch _dynamo error_on_graph_break False C B pass assertTrue issubclass C B assertFalse issubclass int C test_registration B Hashable Iterable Iterator Reversible Sized Container Callable torch _dynamo error_on_graph_break False C __hash__ = None Make sure isn t hashable default assertFalse issubclass C B B __name__ B register C assertTrue issubclass C B WithSet MutableSet __init__ it= data = set __len__ len data __iter__ iter data __contains__ item item data add item data add item discard item data discard item TestCollectionABCs ABCTestCase XXX For now we only test some virtual inheritance properties We should also test proper behavior collection ABCs real base classes mix-in classes test_Set sample set frozenset assertIsInstance sample Set assertTrue issubclass sample Set validate_abstract_methods Set __contains__ __iter__ __len__ torch _dynamo error_on_graph_break False MySet Set __contains__ x False __len__ __iter__ iter validate_comparison MySet test_hash_Set OneTwoThreeSet Set __init__ contents = __contains__ x x contents __len__ len contents __iter__ iter contents __hash__ _hash b = OneTwoThreeSet OneTwoThreeSet assertTrue hash == hash b test_isdisjoint_Set torch _dynamo error_on_graph_break False MySet Set __init__ itr contents = itr __contains__ x x contents __iter__ iter contents __len__ len x x contents s = MySet s = MySet s = MySet assertTrue s isdisjoint s assertFalse s isdisjoint s test_equality_Set torch _dynamo error_on_graph_break False MySet Set __init__ itr contents = itr __contains__ x x contents __iter__ iter contents __len__ len x x contents s = MySet s = MySet s = MySet s = MySet assertTrue s s assertTrue s s assertFalse s = s assertFalse s = s assertFalse s = s assertEqual s s assertNotEqual s s test_arithmetic_Set torch _dynamo error_on_graph_break False MySet Set __init__ itr contents = itr __contains__ x x contents __iter__ iter contents __len__ len x x contents s = MySet s = MySet s = s s assertEqual s MySet test_MutableSet assertIsInstance set MutableSet assertTrue issubclass set MutableSet assertNotIsInstance frozenset MutableSet assertFalse issubclass frozenset MutableSet validate_abstract_methods MutableSet __contains__ __iter__ __len__ add discard test_issue_ MutableSet __iand__ mutated set during iteration s = WithSet abcd s = WithSet cdef This used fail assertEqual set s set cd test_issue_ MutableSet pop method did work torch _dynamo error_on_graph_break False MySet MutableSet __slots__= __s __init__ items=None items None items= __s=set items __contains__ v v __s __iter__ iter __s __len__ len __s add v result=v __s __s add v result discard v result=v __s __s discard v result __repr__ MySet s repr list items = s = MySet items r = s pop assertEqual len s len items - assertNotIn r s assertIn r items test_issue empty = WithSet full = WithSet range s = WithSet full s -= s assertEqual s empty s = WithSet full s ^= s assertEqual s empty s = WithSet full s = s assertEqual s full s &#124; = s assertEqual s full test_issue Recursion error comparing comparable noncomparable Set instances torch _dynamo error_on_graph_break False MyComparableSet Set __contains__ x False __len__ __iter__ iter MyNonComparableSet Set __contains__ x False __len__ __iter__ iter __le__ x NotImplemented __lt__ x NotImplemented cs = MyComparableSet ncs = MyNonComparableSet assertFalse ncs cs assertTrue ncs = cs assertFalse ncs cs assertTrue ncs = cs test_issue Container membership test should check identity first torch _dynamo error_on_graph_break False CustomSequence Sequence __init__ seq _seq = seq __getitem__ index _seq index __len__ len _seq nan = float nan obj = support NEVER_EQ seq = CustomSequence nan obj nan containers = seq ItemsView nan obj KeysView nan obj ValuesView nan obj container containers elem container assertIn elem container assertEqual seq index nan assertEqual seq index obj assertEqual seq count nan assertEqual seq count obj assertSameSet s s coerce both real set then check equality assertSetEqual set s set s test_Set_from_iterable Verify _from_iterable overridden instance method works torch _dynamo error_on_graph_break False SetUsingInstanceFromIterable MutableSet __init__ values created_by created_by raise ValueError created_by must specified created_by = created_by _values = set values _from_iterable values type values from_iterable __contains__ value value _values __iter__ yield _values __len__ len _values add value _values add value discard value _values discard value impl = SetUsingInstanceFromIterable test actual = impl - assertIsInstance actual SetUsingInstanceFromIterable assertEqual from_iterable actual created_by assertEqual actual actual = impl &#124; assertIsInstance actual SetUsingInstanceFromIterable assertEqual from_iterable actual created_by assertEqual actual actual = impl assertIsInstance actual SetUsingInstanceFromIterable assertEqual from_iterable actual created_by assertEqual actual actual = impl ^ assertIsInstance actual SetUsingInstanceFromIterable assertEqual from_iterable actual created_by assertEqual actual NOTE ixor ing list important here internally __ixor__ only calls _from_iterable other value isn t already Set impl ^= assertIsInstance impl SetUsingInstanceFromIterable assertEqual test impl created_by assertEqual impl test_Set_interoperability_with_real_sets Issue torch _dynamo error_on_graph_break False ListSet Set __init__ elements= data = elem elements elem data data append elem __contains__ elem elem data __iter__ iter data __len__ len data __repr__ Set r format data r = set abc r = set bcd r = set abcde f = ListSet abc f = ListSet bcd f = ListSet abcde l = list abccba l = list bcddcb l = list abcdeedcba target = r r assertSameSet f f target assertSameSet f r target assertSameSet r f target assertSameSet f l target target = r &#124; r assertSameSet f &#124; f target assertSameSet f &#124; r target assertSameSet r &#124; f target assertSameSet f &#124; l target fwd_target = r - r rev_target = r - r assertSameSet f - f fwd_target assertSameSet f - f rev_target assertSameSet f - r fwd_target assertSameSet f - r rev_target assertSameSet r - f fwd_target assertSameSet r - f rev_target assertSameSet f - l fwd_target assertSameSet f - l rev_target target = r ^ r assertSameSet f ^ f target assertSameSet f ^ r target assertSameSet r ^ f target assertSameSet f ^ l target Don t change following use assertLess other more specific unittest assertions The current assertTrue assertFalse style makes pattern test case combinations clear allows us know sure exact operator being invoked proper subset assertTrue f f assertFalse f f assertFalse f f assertTrue r f assertFalse r f assertFalse r f assertTrue r r assertFalse r r assertFalse r r assertRaises TypeError f l assertRaises TypeError f l assertRaises TypeError f l any subset assertTrue f = f assertTrue f = f assertFalse f = f assertTrue r = f assertTrue r = f assertFalse r = f assertTrue r = r assertTrue r = r assertFalse r = r assertRaises TypeError f = l assertRaises TypeError f = l assertRaises TypeError f = l proper superset assertTrue f f assertFalse f f assertFalse f f assertTrue r r assertFalse f r assertFalse f r assertTrue r r assertFalse r r assertFalse r r assertRaises TypeError f l assertRaises TypeError f l assertRaises TypeError f l any superset assertTrue f = f assertTrue f = f assertFalse f = f assertTrue r = r assertTrue f = r assertFalse f = r assertTrue r = r assertTrue r = r assertFalse r = r assertRaises TypeError f = l assertRaises TypeError f =l assertRaises TypeError f = l equality assertTrue f == f assertTrue r == f assertTrue f == r assertFalse f == f assertFalse r == f assertFalse f == r assertFalse f == l assertFalse f == l assertFalse f == l inequality assertFalse f = f assertFalse r = f assertFalse f = r assertTrue f = f assertTrue r = f assertTrue f = r assertTrue f = l assertTrue f = l assertTrue f = l test_Set_hash_matches_frozenset sets = None - abc b ab False True object object object float nan frozenset range range - range sys maxsize - sys maxsize + s sets fs = frozenset s assertEqual hash fs Set _hash fs msg=s test_Mapping sample dict assertIsInstance sample Mapping assertTrue issubclass sample Mapping validate_abstract_methods Mapping __contains__ __iter__ __len__ __getitem__ torch _dynamo error_on_graph_break False MyMapping Mapping __len__ __getitem__ i raise IndexError __iter__ iter validate_comparison MyMapping assertRaises TypeError reversed MyMapping test_MutableMapping sample dict assertIsInstance sample MutableMapping assertTrue issubclass sample MutableMapping validate_abstract_methods MutableMapping __iter__ __len__ __getitem__ __setitem__ __delitem__ test_MutableMapping_subclass Test issue mymap = UserDict mymap red = assertIsInstance mymap keys Set assertIsInstance mymap keys KeysView assertIsInstance mymap values Collection assertIsInstance mymap values ValuesView assertIsInstance mymap items Set assertIsInstance mymap items ItemsView mymap = UserDict mymap red = z = mymap keys &#124; orange assertIsInstance z set list z mymap blue = Shouldn t affect z assertEqual sorted z orange red mymap = UserDict mymap red = z = mymap items &#124; orange assertIsInstance z set list z mymap blue = Shouldn t affect z assertEqual z orange red test_Sequence sample tuple list bytes str assertIsInstance sample Sequence assertTrue issubclass sample Sequence assertIsInstance range Sequence assertTrue issubclass range Sequence assertIsInstance memoryview b Sequence assertTrue issubclass memoryview Sequence assertTrue issubclass str Sequence validate_abstract_methods Sequence __contains__ __iter__ __len__ __getitem__ test_Sequence_mixins torch _dynamo error_on_graph_break False SequenceSubclass Sequence __init__ seq= seq = seq __getitem__ index seq index __len__ len seq Compare Sequence index behavior list &#124; str index behavior assert_index_same seq seq index_args try expected = seq index index_args except ValueError assertRaises ValueError seq index index_args actual = seq index index_args assertEqual actual expected r index s seq index_args ty list str nativeseq = ty abracadabra indexes = - - + list range - len nativeseq + seqseq = SequenceSubclass nativeseq letter set nativeseq &#124; z assert_index_same nativeseq seqseq letter start range - len nativeseq + assert_index_same nativeseq seqseq letter start stop range - len nativeseq + assert_index_same nativeseq seqseq letter start stop test_ByteString sample bytes bytearray assertWarns DeprecationWarning assertIsInstance sample ByteString assertTrue issubclass sample ByteString sample str list tuple assertWarns DeprecationWarning assertNotIsInstance sample ByteString assertFalse issubclass sample ByteString assertWarns DeprecationWarning assertNotIsInstance memoryview b ByteString assertFalse issubclass memoryview ByteString assertWarns DeprecationWarning validate_abstract_methods ByteString __getitem__ __len__ assertWarns DeprecationWarning X ByteString pass assertWarns DeprecationWarning No metaclass conflict Z ByteString Awaitable pass test_Buffer sample bytes bytearray memoryview assertIsInstance sample b x Buffer assertTrue issubclass sample Buffer sample str list tuple assertNotIsInstance sample Buffer assertFalse issubclass sample Buffer validate_abstract_methods Buffer __buffer__ test_MutableSequence sample tuple str bytes assertNotIsInstance sample MutableSequence assertFalse issubclass sample MutableSequence sample list bytearray deque assertIsInstance sample MutableSequence assertTrue issubclass sample MutableSequence assertTrue issubclass array array MutableSequence assertFalse issubclass str MutableSequence validate_abstract_methods MutableSequence __contains__ __iter__ __len__ __getitem__ __setitem__ __delitem__ insert test_MutableSequence_mixins Test mixins MutableSequence creating minimal concrete inherited torch _dynamo error_on_graph_break False MutableSequenceSubclass MutableSequence __init__ lst = __setitem__ index value lst index = value __getitem__ index lst index __len__ len lst __delitem__ index del lst index insert index value lst insert index value mss = MutableSequenceSubclass mss append mss extend assertEqual len mss assertEqual mss mss reverse assertEqual mss mss pop assertEqual len mss mss remove assertEqual len mss mss += assertEqual len mss assertEqual mss - mss clear assertEqual len mss issue extending should cause infinite loop items = ABCD mss = MutableSequenceSubclass mss extend items + items mss clear mss extend items mss extend mss assertEqual len mss len mss assertEqual list mss list mss test_illegal_patma_flags assertRaises TypeError Both Collection __abc_tpflags__ = Sequence __flags__ &#124; Mapping __flags__ ################################################################################ ### Counter ################################################################################ CounterSubclassWithSetItem Counter Test counter subclass overrides __setitem__ __init__ args kwds called = False Counter __init__ args kwds __setitem__ key value called = True Counter __setitem__ key value CounterSubclassWithGet Counter Test counter subclass overrides get __init__ args kwds called = False Counter __init__ args kwds get key default called = True Counter get key default TestCounter __TestCase test_basics c = Counter abcaba assertEqual c Counter b c assertEqual c Counter a= b= c= assertIsInstance c dict assertIsInstance c Mapping assertTrue issubclass Counter dict assertTrue issubclass Counter Mapping assertEqual len c assertEqual sum c values assertEqual list c values assertEqual list c keys b c assertEqual list c b c assertEqual list c items b c assertEqual c b assertEqual c z assertEqual c __contains__ c True assertEqual c __contains__ z False assertEqual c get b assertEqual c get z assertEqual c dict a= b= c= assertEqual repr c Counter b c assertEqual c most_common b c i range assertEqual c most_common i b c i assertEqual join c elements aaabbc c += increment existing value c b -= sub existing value zero del c c remove entry del c c make sure del doesn t raise KeyError c d -= sub missing value c e = - directly assign missing value c f += add missing value assertEqual c dict a= b= d=- e=- f= assertEqual join c elements aaaaffff assertEqual c pop f assertNotIn f c i range elem cnt = c popitem assertNotIn elem c c clear assertEqual c assertEqual repr c Counter assertRaises NotImplementedError Counter fromkeys abc assertRaises TypeError hash c c update dict a= b= c update c= c update Counter + b c update test case no args c __init__ + b c __init__ cdc c __init__ assertEqual c dict a= b= c= d= assertEqual c setdefault d assertEqual c d assertEqual c setdefault e assertEqual c e test_init assertEqual list Counter self= items assertEqual list Counter iterable= items iterable assertEqual list Counter iterable=None items iterable None assertRaises TypeError Counter assertRaises TypeError Counter assertRaises TypeError Counter __init__ test_total c = Counter a= b= c= assertEqual c total test_order_preservation Input order dictates items order assertEqual list Counter abracadabra items b r c d letters same count ^ ---------- ^ ^ --------- ^ Verify retention order even when all counts equal assertEqual list Counter xyzpdqqdpzyx items x y z p d q Input order dictates elements order assertEqual list Counter abracadabra simsalabim elements b b b r r c d s s i i m m l Math operations order first order encountered left operand then order encountered right operand ps = aaabbcdddeefggghhijjjkkl qs = abbcccdeefffhkkllllmmnno order = letter i i letter enumerate dict fromkeys ps + qs correctly_ordered seq Return true letters occur expected order positions = order letter letter seq positions == sorted positions p q = Counter ps Counter qs assertTrue correctly_ordered +p assertTrue correctly_ordered -p assertTrue correctly_ordered p + q assertTrue correctly_ordered p - q assertTrue correctly_ordered p &#124; q assertTrue correctly_ordered p q p q = Counter ps Counter qs p += q assertTrue correctly_ordered p p q = Counter ps Counter qs p -= q assertTrue correctly_ordered p p q = Counter ps Counter qs p &#124; = q assertTrue correctly_ordered p p q = Counter ps Counter qs p = q assertTrue correctly_ordered p p q = Counter ps Counter qs p update q assertTrue correctly_ordered p p q = Counter ps Counter qs p subtract q assertTrue correctly_ordered p test_update c = Counter c update self= assertEqual list c items c = Counter c update iterable= assertEqual list c items iterable c = Counter c update iterable=None assertEqual list c items iterable None assertRaises TypeError Counter update assertRaises TypeError Counter update assertRaises TypeError Counter update test_copying Check counters copyable deepcopyable picklable #have repr eval round-trip words = Counter which witch had which witches wrist watch split check dup msg = \ncopy s\nwords s dup words assertIsNot dup words msg assertEqual dup words check words copy check copy copy words check copy deepcopy words proto range pickle HIGHEST_PROTOCOL + subTest proto=proto check pickle loads pickle dumps words proto check eval repr words update_test = Counter update_test update words check update_test check Counter words test_copy_subclass torch _dynamo error_on_graph_break False MyCounter Counter pass c = MyCounter slartibartfast d = c copy assertEqual d c assertEqual len d len c assertEqual type d type c test_conversions Convert set list dict s = she sells sea shells sea shore assertEqual sorted Counter s elements sorted s assertEqual sorted Counter s sorted set s assertEqual dict Counter s dict Counter s items assertEqual set Counter s set s test_invariant_for_the_in_operator c = Counter a= b=- c= elem c assertTrue elem c assertIn elem c test_multiset_operations Verify adding zero counter will strip zeros negatives c = Counter a= b=- c= + Counter assertEqual dict c dict a= elements = abcd i range test random pairs multisets p = Counter dict elem randrange - elem elements p update e= f=- g= q = Counter dict elem randrange - elem elements q update h= i=- j= counterop numberop Counter __add__ lambda x y max x+y Counter __sub__ lambda x y max x-y Counter __or__ lambda x y max x y Counter __and__ lambda x y max min x y result = counterop p q x elements assertEqual numberop p x q x result x counterop x p q verify results exclude non-positive counts assertTrue x x result values elements = abcdef i range verify random multisets no repeats exactly like sets p = Counter dict elem randrange elem elements q = Counter dict elem randrange elem elements counterop setop Counter __sub__ set __sub__ Counter __or__ set __or__ Counter __and__ set __and__ counter_result = counterop p q set_result = setop set p elements set q elements assertEqual counter_result dict fromkeys set_result test_inplace_operations elements = abcd i range test random pairs multisets p = Counter dict elem randrange - elem elements p update e= f=- g= q = Counter dict elem randrange - elem elements q update h= i=- j= inplace_op regular_op Counter __iadd__ Counter __add__ Counter __isub__ Counter __sub__ Counter __ior__ Counter __or__ Counter __iand__ Counter __and__ c = p copy c_id = id c regular_result = regular_op c q inplace_result = inplace_op c q assertEqual inplace_result regular_result assertEqual id inplace_result c_id test_subtract c = Counter a=- b= c= d= e= g= c subtract a= b= c=- d= e= f= h=- assertEqual c Counter a=- b=- c= d= e=- f=- g= h= c = Counter a=- b= c= d= e= g= c subtract Counter a= b= c=- d= e= f= h=- assertEqual c Counter a=- b=- c= d= e=- f=- g= h= c = Counter aaabbcd c subtract aaaabbcce assertEqual c Counter a=- b= c=- d= e=- c = Counter c subtract self= assertEqual list c items - c = Counter c subtract iterable= assertEqual list c items iterable - assertRaises TypeError Counter subtract assertRaises TypeError Counter subtract assertRaises TypeError Counter subtract test_unary c = Counter a=- b= c= d= e= g= assertEqual dict +c dict c= d= e= g= assertEqual dict -c dict a= test_repr_nonsortable c = Counter a= b=None r = repr c assertIn r assertIn b None r test_helper_function two paths one real dicts one other mappings elems = list abracadabra d = dict _count_elements d elems assertEqual d r b c d m = OrderedDict _count_elements m elems assertEqual m OrderedDict b r c d test fidelity pure python version c = CounterSubclassWithSetItem abracadabra assertTrue c called assertEqual dict c b c d r c = CounterSubclassWithGet abracadabra assertTrue c called assertEqual dict c b c d r test_multiset_operations_equivalent_to_set_operations When multiplicities all zero one multiset operations guaranteed equivalent corresponding operations regular sets s = list product b c range powerset = chain from_iterable combinations s r r range len s + counters = Counter dict groups groups powerset cp cq product counters repeat= sp = set cp elements sq = set cq elements assertEqual set cp + cq sp &#124; sq assertEqual set cp - cq sp - sq assertEqual set cp &#124; cq sp &#124; sq assertEqual set cp cq sp sq assertEqual cp == cq sp == sq assertEqual cp = cq sp = sq assertEqual cp = cq sp = sq assertEqual cp = cq sp = sq assertEqual cp cq sp sq assertEqual cp cq sp sq test_eq assertEqual Counter a= b= c= Counter ababa assertNotEqual Counter a= b= Counter babab test_le assertTrue Counter a= b= c= = Counter ababa assertFalse Counter a= b= = Counter babab test_lt assertTrue Counter a= b= c= Counter ababa assertFalse Counter a= b= c= Counter ababa test_ge assertTrue Counter a= b= c= = Counter aab assertFalse Counter a= b= c= = Counter aabd test_gt assertTrue Counter a= b= c= Counter aab assertFalse Counter a= b= c= Counter aab __name__ == __main__ run_tests