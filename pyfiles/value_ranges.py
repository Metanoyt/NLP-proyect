mypy allow-untyped-defs __future__ annotations dataclasses functools itertools logging math operator collections abc Callable typing Generic Optional overload SupportsFloat TYPE_CHECKING TypeGuard TypeVar Union sympy sympy logic boolalg Boolean SympyBoolean BooleanAtom torch torch _logging LazyString torch _prims_common dtype_to_type functions _keep_float FloatTrueDiv FloorDiv IntTrueDiv OpaqueUnaryFn_exp OpaqueUnaryFn_log OpaqueUnaryFn_log OpaqueUnaryFn_sqrt PowByNatural RoundDecimal RoundToInt safe_pow ToFloat TruncToFloat TruncToInt interp sympy_interp numbers int_oo IntInfinity NegativeIntInfinity log = logging getLogger __name__ __all__ = ValueRanges bound_sympy _T = TypeVar _T sympy Expr SympyBoolean ValueRangeError RuntimeError pass Like sympify supports less stuff also ensures direct sympy expressions don t have free variables simple_sympify e isinstance e bool sympy true e sympy false isinstance e int sympy Integer e isinstance e float infinity special we use bracket integers well math isinf e sympy oo e -sympy oo sympy Float e isinstance e sympy Expr getattr e is_number False raise AssertionError e NaNs can occur when doing things like sympy oo better operator notices takes care because sometimes NaN inappropriate example ints -oo oo range should go zero when multiplied e == sympy nan raise AssertionError sympy expression NaN e isinstance e BooleanAtom e raise AssertionError f simple sympy type type e e Sympy atomics only Unlike = also works Sympy bools sympy_generic_le lower upper isinstance lower sympy Expr isinstance upper sympy Expr raise AssertionError upper must sympy Expr when lower sympy Expr instead lower = upper we do upper = lower since upper mostly int_oo we have better code paths there upper = lower only negative condition True False isinstance lower SympyBoolean isinstance upper SympyBoolean raise AssertionError lower upper lower upper vr_is_bool vr ValueRanges _T - TypeGuard ValueRanges SympyBoolean vr is_bool vr_is_expr vr ValueRanges _T - TypeGuard ValueRanges sympy Expr vr is_bool ExprIn = Union int float sympy Expr BoolIn = Union bool SympyBoolean AllIn = Union ExprIn BoolIn ExprFn = Callable sympy Expr sympy Expr ExprFn = Callable sympy Expr sympy Expr sympy Expr BoolFn = Callable SympyBoolean SympyBoolean BoolFn = Callable SympyBoolean SympyBoolean SympyBoolean AllFn = Union ExprFn BoolFn AllFn = Union ExprFn BoolFn dataclasses dataclass frozen=True ValueRanges Generic _T TYPE_CHECKING ruff doesn t understand circular references mypy does pyrefly ignore unbound-name ExprVR = ValueRanges sympy Expr noqa F pyrefly ignore unbound-name BoolVR = ValueRanges SympyBoolean noqa F AllVR = Union ExprVR BoolVR Although type signature here suggests you can pass any sympy expression practice analysis here only works constant sympy expressions lower _T upper _T is_bool bool is_int bool is_float bool __repr__ - str f VR lower upper overload __init__ ValueRanges sympy Expr lower ExprIn upper ExprIn - None overload __init__ type ignore misc ValueRanges SympyBoolean lower BoolIn upper BoolIn - None __init__ lower AllIn upper AllIn - None lower = simple_sympify lower upper = simple_sympify upper TODO when bounds have free variables may nontrivial actually verify try sympy_generic_le lower upper raise ValueRangeError f Invalid ranges lower upper except TypeError e raise TypeError f Could compare lower = upper e is_bool_lower = isinstance lower SympyBoolean is_bool_upper = isinstance upper SympyBoolean is_bool_lower = is_bool_upper raise AssertionError lower upper Warning is_int is_float best effort We do pretty well Dynamo Inductor these attributes often wrong because we very rigorous dtype analysis This also why we need flexible analysis is_int sometimes sympy oo pops integer bound I would like us do s too hard push invariant through right now isinstance lower sympy Integer upper == sympy oo upper = int_oo isinstance upper sympy Integer lower == -sympy oo lower = -int_oo NB -int_oo -int_oo int_oo int_oo allowed integer_types = sympy Integer NegativeIntInfinity IntInfinity is_int_lower = isinstance lower integer_types is_int_upper = isinstance upper integer_types Because frozen object __setattr__ lower lower object __setattr__ upper upper Unlike bool int Python we don t report bools ints NB is_bool_lower == is_bool_upper so we only need check one object __setattr__ is_bool is_bool_lower object __setattr__ is_int is_bool is_int_lower is_int_upper This assert just impossible right now too many sympy bugs is_int NB sympy will sometimes randomly lose float-ness zero so we also need account assertion here See also https github com sympy sympy issues assert isinstance lower sympy Integer lower -sympy oo lower upper assert isinstance upper sympy Integer upper sympy oo lower upper NB -oo oo always advertises float object __setattr__ is_float is_bool is_int is_bool is_int is_float raise AssertionError lower upper boolify - ValueRanges SympyBoolean vr_is_bool == ValueRanges unknown ValueRanges unknown_bool raise AssertionError f bool like __contains__ x AllIn - bool ValueRanges wrap x issubset issubset other other unknown_int True sympy_generic_le other lower lower sympy_generic_le upper other upper tighten other - ValueRanges Given two ValueRanges returns their intersection other Intersection overload __and__ ValueRanges sympy Expr other ValueRanges sympy Expr - ValueRanges sympy Expr overload __and__ type ignore misc ValueRanges SympyBoolean other ValueRanges SympyBoolean - ValueRanges SympyBoolean __and__ AllVR other AllVR - AllVR other ValueRanges unknown ValueRanges unknown_int ValueRanges unknown ValueRanges unknown_int other is_bool = other is_bool raise AssertionError other is_int = other is_int raise AssertionError other is_float = other is_float raise AssertionError other is_bool ValueRanges sympy Or lower other lower sympy And upper other upper ValueRanges sympy Max lower other lower sympy Min upper other upper Union overload __or__ ValueRanges sympy Expr other ValueRanges sympy Expr - ValueRanges sympy Expr overload __or__ type ignore misc ValueRanges SympyBoolean other ValueRanges SympyBoolean - ValueRanges SympyBoolean __or__ AllVR other AllVR - AllVR ValueRanges unknown other ValueRanges unknown is_bool = other is_bool raise AssertionError other is_int = other is_int raise AssertionError other is_float = other is_float raise AssertionError other is_bool ValueRanges sympy And lower other lower sympy Or upper other upper ValueRanges sympy Min lower other lower sympy Max upper other upper is_singleton - bool lower == upper staticmethod functools cache unknown - ValueRanges sympy Expr ValueRanges -sympy oo sympy oo staticmethod functools cache unknown_int - ValueRanges sympy Expr ValueRanges -int_oo int_oo staticmethod functools cache unknown_bool - ValueRanges SympyBoolean ValueRanges sympy false sympy true overload staticmethod work around fact bool int overlap wrap arg Union ExprIn ExprVR - ExprVR type ignore overload-overlap overload staticmethod wrap arg Union BoolIn BoolVR - BoolVR type ignore misc staticmethod wrap arg Union AllIn AllVR - AllVR isinstance arg ValueRanges arg isinstance arg float math isnan arg ValueRanges unknown arg either ExprIn BoolIn we don t know here ValueRanges arg arg type ignore arg-type staticmethod increasing_map x Union ExprIn ExprVR fn ExprFn - ExprVR Increasing x = y = f x = f y x = ValueRanges wrap x ValueRanges fn x lower fn x upper overload staticmethod decreasing_map x Union ExprIn ExprVR fn ExprFn - ExprVR overload staticmethod decreasing_map x Union BoolIn BoolVR fn BoolFn - BoolVR type ignore misc staticmethod decreasing_map x Union AllIn AllVR fn AllFn - AllVR Decreasing x = y = f x = f y x = ValueRanges wrap x consistently either Expr Bool we don t know here ValueRanges fn x upper fn x lower type ignore arg-type staticmethod monotone_map x Union ExprIn ExprVR fn ExprFn - ExprVR It s increasing decreasing x = ValueRanges wrap x l = fn x lower u = fn x upper ValueRanges min l u max l u staticmethod convex_min_zero_map x Union ExprIn ExprVR fn ExprFn - ExprVR Fn convex has minimum x = ValueRanges wrap x x upper = max fn x lower fn x upper upper = simple_sympify upper isinstance upper sympy Float upper == sympy oo ValueRanges upper ValueRanges upper ValueRanges monotone_map x fn overload staticmethod coordinatewise_increasing_map x Union ExprIn ExprVR y Union ExprIn ExprVR fn ExprFn - ExprVR overload staticmethod coordinatewise_increasing_map type ignore misc x Union BoolIn BoolVR y Union BoolIn BoolVR fn BoolFn - BoolVR staticmethod coordinatewise_increasing_map x Union AllIn AllVR y Union AllIn AllVR fn AllFn - AllVR It s increasing each coordinate Mathematically For every = i = n x_i = y_i we have f x xn = f x yi xn x y = ValueRanges wrap x ValueRanges wrap y ValueRanges fn x lower y lower type ignore arg-type fn x upper y upper type ignore arg-type classmethod coordinatewise_monotone_map cls x y fn It s increasing decreasing each coordinate x y = cls wrap x cls wrap y products = fn b b itertools product x lower x upper y lower y upper ValueRanges min products max products SymPyValueRangeAnalysis It gives bounds SymPy operator given bounds its arguments See function ` bound_sympy ` function applies logic full SymPy expression staticmethod constant value dtype isinstance value ValueRanges value is_singleton raise AssertionError ValueRanges must singleton constant value = value lower NB value NOT sympy expression s constant is_python = isinstance value int float bool is_python isinstance value BooleanAtom sympy Integer sympy Number raise AssertionError f supported constant type type value using nan makes subsequent computation throw purposes optimization returning -math inf - math inf equivalent giving up isinstance value SupportsFloat math isnan value dtype == torch bool ValueRanges unknown_bool dtype is_floating_point ValueRanges unknown ValueRanges unknown_int is_python type_ = dtype_to_type dtype value = type_ value We do type check best-effort basis We don t want force cast sympy Float value Rational avoid losing precision dtype == torch bool isinstance value BooleanAtom raise AssertionError expected BooleanAtom bool dtype dtype is_floating_point value is_finite value is_real raise AssertionError expected float-like sympy value float dtype dtype intXX getattr value is_integer False raise AssertionError expected integer sympy value int dtype r = ValueRanges wrap value r staticmethod to_dtype dtype src_dtype=None dtype == torch float pyrefly ignore bad-argument-type ValueRanges increasing_map ToFloat dtype == torch bool ValueRanges unknown_bool dtype is_floating_point ValueRanges unknown_int ValueRanges unknown staticmethod trunc_to_int dtype pyrefly ignore bad-argument-type ValueRanges increasing_map TruncToInt staticmethod not_ = ValueRanges wrap = boolify is_bool raise AssertionError not_ expects boolean ValueRanges ValueRanges decreasing_map sympy Not staticmethod or_ b ValueRanges coordinatewise_increasing_map b sympy Or staticmethod and_ b ValueRanges coordinatewise_increasing_map b sympy And staticmethod _bool_to_int x x is_singleton ValueRanges wrap sympy Integer x lower ValueRanges sympy Integer sympy Integer classmethod bitwise_and cls b b = ValueRanges wrap ValueRanges wrap b is_bool b is_bool cls and_ b is_bool = cls _bool_to_int b is_bool b = cls _bool_to_int b lower = min lower b lower lower lower = -sympy oo lower = -int_oo If both lower bounds negative then bits start like so smallest possible value Thus we need find next smallest power inclusive try lower = - int -lower - bit_length except Exception lower = -int_oo lower = ValueRanges lower max upper b upper classmethod bitwise_or cls b b = ValueRanges wrap ValueRanges wrap b is_bool b is_bool cls or_ b is_bool = cls _bool_to_int b is_bool b = cls _bool_to_int b upper = max upper b upper upper == upper = upper upper = sympy oo upper = int_oo If both upper bounds positive then largest possible value so we need find next largest power exclusive minus try upper = int upper bit_length - except Exception upper = int_oo upper upper = - ValueRanges min lower b lower upper staticmethod eq b = ValueRanges wrap b = ValueRanges wrap b is_singleton b is_singleton lower == b lower ValueRanges wrap sympy true lower b upper b lower upper ranges disjoint ValueRanges wrap sympy false ValueRanges sympy false sympy true classmethod ne cls b cls not_ cls eq b classmethod identity cls ValueRanges wrap classmethod lt cls b = ValueRanges wrap b = ValueRanges wrap b is_bool = b is_bool raise AssertionError operands must both boolean ValueRanges both non-boolean is_bool cls and_ cls not_ b upper b lower ValueRanges wrap sympy true lower = b upper ValueRanges wrap sympy false ValueRanges sympy false sympy true classmethod gt cls b cls lt b classmethod le cls b cls not_ cls gt b classmethod ge cls b cls not_ cls lt b staticmethod add b ValueRanges coordinatewise_increasing_map b _keep_float operator add classmethod mul cls b = ValueRanges wrap b = ValueRanges wrap b is_bool = b is_bool raise AssertionError operands must both boolean ValueRanges both non-boolean is_bool cls and_ b safe_mul b Make unknown wrap == wrap == == b == b == b b ValueRanges coordinatewise_monotone_map b _keep_float safe_mul staticmethod int_truediv b = ValueRanges wrap b = ValueRanges wrap b b -int_oo int_oo -int_oo b int_oo b ValueRanges unknown ValueRanges coordinatewise_monotone_map b pyrefly ignore bad-argument-type _keep_float IntTrueDiv staticmethod truediv b = ValueRanges wrap b = ValueRanges wrap b b -sympy oo sympy oo -sympy oo b sympy oo b ValueRanges unknown ValueRanges coordinatewise_monotone_map b pyrefly ignore bad-argument-type _keep_float FloatTrueDiv staticmethod floordiv b = ValueRanges wrap b = ValueRanges wrap b b ValueRanges unknown_int products = x y itertools product lower upper b lower b upper r = FloorDiv x y r sympy nan products append sympy sign x sympy sign y int_oo products append r ValueRanges min products max products classmethod mod cls x y x = ValueRanges wrap x y = ValueRanges wrap y nb We implement C semantics c_mod b ret = abs abs b ret = - ret c_div b x = b sympy Integer x x is_finite x int_oo -int_oo x y ValueRanges unknown_int y is_singleton y_val = abs y lower If wraps we need take whole interval The function locally linear they same c_div x lower y_val == c_div x upper y_val ValueRanges increasing_map x lambda u c_mod u y_val x upper Negative case ValueRanges -y_val + x lower Positive case ValueRanges y_val - Mixed case lower = max -y_val + x lower upper = min y_val - x upper ValueRanges lower upper Too difficult we bail out upper = cls abs y upper - ValueRanges -upper upper classmethod modular_indexing cls b c cls mod cls floordiv b c classmethod is_non_overlapping_and_dense_indicator cls args ValueRanges unknown_int classmethod pow_by_natural cls b = ValueRanges wrap b = ValueRanges wrap b is_singleton b is_singleton ValueRanges wrap safe_pow lower b lower NB Exclude zero because zero special lower = We should know b = we may have forgotten fact due replacements so don t assert DO clamp prevent degenerate problems pyrefly ignore no-matching-overload ValueRanges coordinatewise_increasing_map b ValueRanges int_oo PowByNatural b is_singleton b lower == x^n where n even ValueRanges convex_min_zero_map lambda x safe_pow x b lower x^n where n odd ValueRanges increasing_map lambda x safe_pow x b lower potentially negative we don t know exponent even odd So just conservatively set upper lower bound based what maximum absolute value could both directions max_base = max upper -a lower ValueRanges - safe_pow max_base b upper safe_pow max_base b upper classmethod pow cls b ValueRanges unknown We could implement all floating point pow there really point = ValueRanges wrap b = ValueRanges wrap b Not implemented yet It s bit tricky If you want implement compute partial derivatives b check ranges where function increasing decreasing Another non-tight way doing defaulting doing noting b == exp b log If second option implemented carefult about types possible infinities here there b is_singleton ValueRanges unknown b = b lower is_singleton = lower r = b r is_finite ValueRanges unknown ValueRanges wrap r b == lower is_finite ValueRanges unknown ValueRanges wrap b = cls reciprocal b = -b == ValueRanges unknown ValueRanges unknown If base positive then we re good otherwise nothing s defined lower = ValueRanges increasing_map lambda x x b ValueRanges unknown staticmethod reciprocal x Needed s used pow won t appear SymPy expression x = ValueRanges wrap x x ValueRanges unknown ValueRanges decreasing_map x lambda y FloatTrueDiv y type ignore operator staticmethod abs x ValueRanges convex_min_zero_map x abs staticmethod exp x ValueRanges increasing_map x OpaqueUnaryFn_exp staticmethod log x x = ValueRanges wrap x x lower = ValueRanges unknown ValueRanges increasing_map x OpaqueUnaryFn_log staticmethod log x x = ValueRanges wrap x x lower = ValueRanges unknown ValueRanges increasing_map x OpaqueUnaryFn_log classmethod minimum cls b cls min_or_max b sympy Min classmethod maximum cls b cls min_or_max b sympy Max staticmethod min_or_max b fn = ValueRanges wrap b = ValueRanges wrap b ValueRanges coordinatewise_increasing_map b fn classmethod floor_to_int cls x dtype ValueRanges increasing_map x sympy functions elementary integers floor classmethod ceil_to_int cls x dtype ValueRanges increasing_map x sympy functions elementary integers ceiling I think these implementations sound The hazard here sympy will carry out floor ceil too high precision then something bad will happen when we convert float For truncation implementation clearly sound because desired target float always exactly representable since you re just chopping off bits mantissa But what about ceil floor The important constraint here we re defining floor arbitrary real numbers only representable float numbers So we can take advantage fact before we reach first unrepresentable integer floating point space we have range numbers corresponding exponent zero all integers no fractional amounts floor ceil identity operation case In range below here representable floating point numbers spaced exactly apart notably both floor ceil defined floating point numbers There no gap you step up next exponent classmethod floor cls x ValueRanges increasing_map x _keep_float sympy functions elementary integers floor classmethod ceil cls x ValueRanges increasing_map x _keep_float sympy functions elementary integers ceiling classmethod round_decimal cls number ndigits ndigits is_singleton ValueRanges unknown ndigits = ndigits lower We can t use functools partial here since sympy doesn t support keyword arguments we have bind second parameter fn = lambda number RoundDecimal number ndigits type ignore misc assignment noqa E ValueRanges increasing_map number fn classmethod round_to_int cls number dtype pyrefly ignore bad-argument-type ValueRanges increasing_map number RoundToInt It s used some models symints staticmethod sqrt x x = ValueRanges wrap x x lower ValueRanges unknown ValueRanges increasing_map x OpaqueUnaryFn_sqrt staticmethod where b c b = ValueRanges wrap b c = ValueRanges wrap c = boolify We sometimes write unknown without specifying type correctly In particular we do when initialising bounds loads bounds py b is_bool = c is_bool ValueRanges unknown b c raise AssertionError where requires b c have same boolean-ness allow unknown b is_bool ValueRanges sympy And b lower c lower sympy Or b upper c upper ValueRanges sympy Min b lower c lower sympy Max b upper c upper expr_cond_pair used represent single expr condition pair piecewise We just value range expression its corresponding condition tuple defer analysis piecewise staticmethod expr_cond_pair b b = b boolify b piecewise function can used convert SymBool SymInt int_expr = Piecewise bool_expr True evaluates when sym_bool True otherwise ranges sequence expr_range condition_range pairs The range pair constructed expr_cond_pair The ValueRange Piecewise just union all expr ranges whose condition expr can True staticmethod piecewise ranges init_range = None expr_range cond_range ranges sympy true cond_range init_range None init_range = expr_range init_range = init_range &#124; expr_range init_range staticmethod cos x TODO We should tighten value ranges If input range span pi + pi k then output range - otherwise minimum value function extremes ValueRanges - staticmethod cosh x ValueRanges sympy oo x = ValueRanges wrap x x lower ValueRanges increasing_map x OpaqueUnaryFn_cosh x upper ValueRanges decreasing_map x OpaqueUnaryFn_cosh ValueRanges sympy oo staticmethod sin x TODO We should tighten value ranges See details cos ValueRanges - staticmethod sinh x ValueRanges increasing_map x OpaqueUnaryFn_sinh ValueRanges -sympy oo sympy oo staticmethod tan x ValueRanges -sympy oo sympy oo staticmethod tanh x ValueRanges increasing_map x OpaqueUnaryFn_tanh ValueRanges -sympy oo sympy oo staticmethod asin x ValueRanges -sympy oo sympy oo x = ValueRanges wrap x - = x lower x upper = ValueRanges increasing_map x OpaqueUnaryFn_asinh ValueRanges unknown staticmethod acos x ValueRanges -sympy oo sympy oo x = ValueRanges wrap x - = x lower x upper = ValueRanges decreasing_map x OpaqueUnaryFn_acos ValueRanges unknown staticmethod atan x ValueRanges -sympy oo sympy oo ValueRanges increasing_map x OpaqueUnaryFn_atan staticmethod trunc x pyrefly ignore bad-argument-type ValueRanges increasing_map x TruncToFloat bound_sympy expr sympy Expr ranges Optional dict sympy Symbol ValueRanges = None - ValueRanges log debug bound_sympy s s expr LazyString lambda \n + \n join f k r k r ranges items k expr free_symbols ranges isinstance expr sympy Number ValueRanges wrap expr ranges = ranges If there s tracing context augment available constrained ranges context = torch _guards TracingContext try_get context context fake_mode context fake_mode shape_env ranges ranges = context fake_mode shape_env var_to_range ranges ranges = context fake_mode shape_env var_to_range missing_handler s s is_integer type ignore attr-defined s is_positive type ignore attr-defined vr = ValueRanges int_oo s is_nonnegative type ignore attr-defined vr = ValueRanges int_oo vr = ValueRanges unknown_int Don t bother trying very hard here vr = ValueRanges unknown vr sympy_interp SymPyValueRangeAnalysis ranges expr missing_handler=missing_handler