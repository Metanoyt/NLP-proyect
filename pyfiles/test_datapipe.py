mypy ignore-errors Owner s module dataloader copy itertools importlib util os os path pickle pydoc random tempfile warnings functools partial typing Any Optional TypeVar Union collections abc Awaitable Iterator operator unittest skipIf numpy np torch torch nn nn torch utils data datapipes dp torch utils data graph torch utils data graph_settings torch testing _internal common_utils run_tests skipIfNoDill skipIfTorchDynamo suppress_warnings TEST_DILL TestCase torch utils _import_utils import_dill torch utils data argument_validation DataChunk DataLoader IterDataPipe MapDataPipe RandomSampler runtime_validation runtime_validation_disabled torch utils data datapipes dataframe CaptureDataFrame dataframe_wrapper df_wrapper torch utils data datapipes iter sharding SHARDING_PRIORITIES torch utils data datapipes utils common StreamWrapper torch utils data datapipes utils decoder basichandlers decoder_basichandlers torch utils data datapipes utils snapshot _simple_graph_snapshot_restoration torch utils data graph traverse_dps dill = import_dill HAS_DILL = TEST_DILL HAS_PANDAS bool = importlib util find_spec pandas None skipIfNoDataFrames = skipIf HAS_PANDAS no dataframes pandas skipTyping = skipIf True TODO Fix typing bug T_co = TypeVar T_co covariant=True create_temp_dir_and_files The temp dir files within will released deleted tearDown Adding ` noqa P ` avoid mypy s warning releasing dir handle within function temp_dir = tempfile TemporaryDirectory noqa P temp_dir_path = temp_dir name tempfile NamedTemporaryFile dir=temp_dir_path delete=False suffix= txt f temp_file _name = f name tempfile NamedTemporaryFile dir=temp_dir_path delete=False suffix= byte f temp_file _name = f name tempfile NamedTemporaryFile dir=temp_dir_path delete=False suffix= empty f temp_file _name = f name open temp_file _name w f f write abcdef open temp_file _name wb f f write b abcdef temp_sub_dir = tempfile TemporaryDirectory dir=temp_dir_path noqa P temp_sub_dir_path = temp_sub_dir name tempfile NamedTemporaryFile dir=temp_sub_dir_path delete=False suffix= txt f temp_sub_file _name = f name tempfile NamedTemporaryFile dir=temp_sub_dir_path delete=False suffix= byte f temp_sub_file _name = f name open temp_sub_file _name w f f write abcdef open temp_sub_file _name wb f f write b abcdef temp_dir temp_file _name temp_file _name temp_file _name temp_sub_dir temp_sub_file _name temp_sub_file _name reset_after_n_next_calls datapipe Union IterDataPipe T_co MapDataPipe T_co n int - tuple list T_co list T_co Given DataPipe integer n iterate DataPipe n elements store elements into list Then reset DataPipe tuple two lists A list elements yielded before reset A list all elements DataPipe after reset = iter datapipe res_before_reset = _ range n res_before_reset append next res_before_reset list datapipe odd_or_even x int - int x TestDataChunk TestCase setUp elements = list range random shuffle elements chunk DataChunk int = DataChunk elements test_getitem i range assertEqual elements i chunk i test_iter ele dc zip elements iter chunk assertEqual ele dc test_len assertEqual len elements len chunk test_as_string assertEqual str chunk str elements batch = elements chunks list DataChunk int = DataChunk elements assertEqual str batch str chunks test_sort chunk DataChunk int = DataChunk elements chunk sort assertTrue isinstance chunk DataChunk i d enumerate chunk assertEqual i d test_reverse chunk DataChunk int = DataChunk elements chunk reverse assertTrue isinstance chunk DataChunk i range assertEqual chunk i elements - i test_random_shuffle elements = list range chunk DataChunk int = DataChunk elements rng = random Random rng shuffle chunk rng = random Random rng shuffle elements assertEqual chunk elements TestStreamWrapper TestCase _FakeFD __init__ filepath filepath = filepath opened = False closed = False open opened = True read opened join raise OSError Cannot read un-opened file descriptor __iter__ i range yield str i close opened opened = False closed = True __repr__ FakeFD test_dir fd = TestStreamWrapper _FakeFD wrap_fd = StreamWrapper fd s = set dir wrap_fd api open read close assertTrue api s skipIfTorchDynamo test_api fd = TestStreamWrapper _FakeFD wrap_fd = StreamWrapper fd assertFalse fd opened assertFalse fd closed assertRaisesRegex IOError Cannot read wrap_fd read wrap_fd open assertTrue fd opened assertEqual wrap_fd read del wrap_fd assertFalse fd opened assertTrue fd closed test_pickle tempfile TemporaryFile f assertRaises TypeError ctx pickle dumps f wrap_f = StreamWrapper f assertRaises TypeError ctx pickle dumps wrap_f Same exception when pickle assertEqual str ctx exception str ctx exception fd = TestStreamWrapper _FakeFD wrap_fd = StreamWrapper fd _ = pickle loads pickle dumps wrap_fd test_repr fd = TestStreamWrapper _FakeFD wrap_fd = StreamWrapper fd assertEqual str wrap_fd StreamWrapper FakeFD tempfile TemporaryFile f wrap_f = StreamWrapper f assertEqual str wrap_f StreamWrapper + str f + TestIterableDataPipeBasic TestCase setUp ret = create_temp_dir_and_files temp_dir = ret temp_files = ret temp_sub_dir = ret temp_sub_files = ret tearDown try temp_sub_dir cleanup temp_dir cleanup except Exception e warnings warn f TestIterableDatasetBasic able cleanup temp dir due str e test_listdirfiles_iterable_datapipe temp_dir = temp_dir name datapipe IterDataPipe = dp iter FileLister temp_dir count = pathname datapipe count = count + assertTrue pathname temp_files assertEqual count len temp_files count = datapipe = dp iter FileLister temp_dir recursive=True pathname datapipe count = count + assertTrue pathname temp_files pathname temp_sub_files assertEqual count len temp_files + len temp_sub_files temp_files = temp_files datapipe = dp iter FileLister temp_dir temp_files count = pathname datapipe count += assertTrue pathname temp_files assertEqual count len temp_files test functional API datapipe = datapipe list_files count = pathname datapipe count += assertTrue pathname temp_files assertEqual count len temp_files test_listdirfilesdeterministic_iterable_datapipe temp_dir = temp_dir name datapipe = dp iter FileLister temp_dir The output order should always same assertEqual list datapipe list datapipe datapipe = dp iter FileLister temp_dir recursive=True The output order should always same assertEqual list datapipe list datapipe test_openfilesfromdisk_iterable_datapipe test datapipe directly torch utils data datapipes iter FileLister FileOpener temp_dir = temp_dir name datapipe = FileLister temp_dir datapipe = FileOpener datapipe mode= b count = rec datapipe count = count + assertTrue rec temp_files open rec rb f assertEqual rec read f read rec close assertEqual count len temp_files functional API datapipe = datapipe open_files mode= b count = rec datapipe count = count + assertTrue rec temp_files open rec rb f assertEqual rec read f read rec close assertEqual count len temp_files __len__ Test assertRaises TypeError len datapipe test_routeddecoder_iterable_datapipe temp_dir = temp_dir name temp_pngfile_pathname = os path join temp_dir test_png png png_data = np array dtype=np single np save temp_pngfile_pathname png_data datapipe = dp iter FileLister temp_dir png txt datapipe = dp iter FileOpener datapipe mode= b _png_decoder extension data extension = png None np load data _helper prior_dp dp channel_first=False Byte stream closed inp prior_dp assertFalse inp closed inp rec zip prior_dp dp ext = os path splitext rec ext == png expected = np array dtype=np single channel_first expected = expected transpose assertEqual rec expected open rec rb f assertEqual rec f read decode utf- Corresponding byte stream closed Decoder assertTrue inp closed cached = list datapipe warnings catch_warnings record=True datapipe = dp iter RoutedDecoder cached _png_decoder datapipe add_handler decoder_basichandlers _helper cached datapipe cached = list datapipe warnings catch_warnings record=True datapipe = dp iter RoutedDecoder cached decoder_basichandlers datapipe add_handler _png_decoder _helper cached datapipe channel_first=True test_groupby_iterable_datapipe file_list = png b png c json json c png b json d png d json e png f json g png f png g json e json h txt h json io datapipe = dp iter IterableWrapper filename io BytesIO b abcde filename file_list group_fn data filepath _ = data os path basename filepath split datapipe = dp iter Grouper datapipe group_key_fn=group_fn group_size= order_fn data data sort key=lambda f f reverse=True data datapipe = dp iter Mapper datapipe fn=order_fn type ignore var-annotated expected_result = png json c png c json b png b json d png d json f png f json g png g json e png e json h txt h json count = rec expected zip datapipe expected_result count = count + assertEqual os path basename rec expected assertEqual os path basename rec expected i assertEqual rec i read b abcde rec i close assertEqual count testing keep_key option datapipe = dp iter Grouper datapipe group_key_fn=group_fn keep_key=True group_size= order_fn data data sort key=lambda f f reverse=True data datapipe = dp iter Mapper datapipe fn=order_fn type ignore var-annotated expected_result = png json c c png c json b b png b json d d png d json f f png f json g g png g json e e png e json h h txt h json count = rec expected zip datapipe expected_result count = count + assertEqual rec expected assertEqual rec expected assertEqual rec expected i assertEqual rec i read b abcde rec i close assertEqual count test_demux_mux_datapipe numbers = NumbersDataset n n = numbers demux lambda x x assertEqual list n assertEqual list n Functional Test demux mux works sequentially expected numbers = NumbersDataset n n n = numbers demux lambda x x n = n mux n n assertEqual list range list n Functional Test Uneven DataPipes source_numbers = list range + numbers_dp = dp iter IterableWrapper source_numbers n n = numbers_dp demux lambda x x assertEqual list n assertEqual list n n = n mux n assertEqual list range list n suppress_warnings Suppress warning lambda fn test_map_with_col_file_handle_datapipe temp_dir = temp_dir name datapipe = dp iter FileLister temp_dir datapipe = dp iter FileOpener datapipe _helper datapipe dp = datapipe map lambda x x read input_col= dp = datapipe map lambda x x x read assertEqual list dp list dp tuple _helper datapipe list datapipe = datapipe map lambda x list x _helper datapipe skipIfNoDataFrames TestCaptureDataFrame TestCase get_new_df df_wrapper create_dataframe columns= b compare_capture_and_eager operations cdf = CaptureDataFrame cdf = operations cdf df = get_new_df cdf = cdf apply_ops df df = get_new_df df = operations df assertTrue df equals cdf test_basic_capture operations df df c = df b + df somehow swallows pandas UserWarning when ` df c = df b + df ` df compare_capture_and_eager operations TestDataFramesPipes TestCase Most test will fail pandas installed no dill available Need rework them avoid multiple skips _get_datapipe range= dataframe_size= NumbersDataset range map lambda i i i _get_dataframes_pipe range= dataframe_size= NumbersDataset range map lambda i i i _to_dataframes_pipe columns= i j dataframe_size=dataframe_size skipIfNoDataFrames skipIfNoDill TODO VitalyFedyunin Decouple tests dill avoiding lambdas map test_capture dp_numbers = _get_datapipe map lambda x x x x + x df_numbers = _get_dataframes_pipe df_numbers k = df_numbers j + df_numbers i expected = list dp_numbers actual = list df_numbers assertEqual expected actual skipIfNoDataFrames skipIfNoDill test_shuffle With non-zero extremely low probability when shuffle do nothing test fails so feel free restart df_numbers = _get_dataframes_pipe range= shuffle dp_numbers = _get_datapipe range= df_result = tuple item item df_numbers assertNotEqual list dp_numbers df_result assertEqual list dp_numbers sorted df_result skipIfNoDataFrames skipIfNoDill test_batch df_numbers = _get_dataframes_pipe range= batch df_numbers_list = list df_numbers last_batch = df_numbers_list - assertEqual len last_batch unpacked_batch = tuple row row last_batch assertEqual unpacked_batch skipIfNoDataFrames skipIfNoDill test_unbatch df_numbers = _get_dataframes_pipe range= batch batch dp_numbers = _get_datapipe range= assertEqual list dp_numbers list df_numbers unbatch skipIfNoDataFrames skipIfNoDill test_filter df_numbers = _get_dataframes_pipe range= filter lambda x x i actual = list df_numbers assertEqual actual skipIfNoDataFrames skipIfNoDill test_collate collate_i column column sum collate_j column column prod df_numbers = _get_dataframes_pipe range= batch df_numbers = df_numbers collate j collate_j i collate_i expected_i = actual_i = i _ df_numbers actual_i append i assertEqual expected_i actual_i actual_i = item df_numbers actual_i append item i assertEqual expected_i actual_i IDP_NoLen IterDataPipe __init__ input_dp super __init__ input_dp = input_dp Prevent in-place modification __iter__ input_dp = input_dp isinstance input_dp IterDataPipe copy deepcopy input_dp yield input_dp _fake_fn data data _fake_add constant data constant + data _fake_filter_fn data True _simple_filter_fn data data = _fake_filter_fn_constant constant data data = constant _mul_ x x _mod_ _test x x == _to_list x x lambda_fn = lambda x x noqa E lambda_fn = lambda x x noqa E lambda_fn = lambda x x = noqa E Add Module nn Module forward x x + Add Callable __call__ x x + TestFunctionalIterDataPipe TestCase _serialization_test_helper datapipe use_dill use_dill serialized_dp = dill dumps datapipe deserialized_dp = dill loads serialized_dp serialized_dp = pickle dumps datapipe deserialized_dp = pickle loads serialized_dp try assertEqual list datapipe list deserialized_dp except AssertionError e print f datapipe failing raise e _serialization_test_for_single_dp dp use_dill=False Testing serialization before any iteration starts _serialization_test_helper dp use_dill Testing serialization after DataPipe partially read = iter dp _ = next _serialization_test_helper dp use_dill Testing serialization after DataPipe fully read = iter dp _ = list _serialization_test_helper dp use_dill _serialization_test_for_dp_with_children dp dp use_dill=False Testing serialization before any iteration starts _serialization_test_helper dp use_dill _serialization_test_helper dp use_dill Testing serialization after DataPipe partially read = iter dp iter dp _ _ = next next Catch ` fork ` ` demux ` some child DataPipes exhausted warning warnings catch_warnings record=True _serialization_test_helper dp use_dill _serialization_test_helper dp use_dill Testing serialization after one child DataPipe fully read Only DataPipes children DataPipes = iter dp _ = list fully read one child Catch ` fork ` ` demux ` some child DataPipes exhausted warning warnings catch_warnings record=True _serialization_test_helper dp use_dill _serialization_test_helper dp use_dill Testing serialization after DataPipe fully read = iter dp _ = list fully read other child _serialization_test_helper dp use_dill _serialization_test_helper dp use_dill test_serializable picklable_datapipes list = dp iter Batcher None True dp iter Collator None _fake_fn dp iter Concater None dp iter IterableWrapper range dp iter Demultiplexer None _simple_filter_fn dp iter FileLister dp iter FileOpener None dp iter Filter None _fake_filter_fn dp iter Filter None partial _fake_filter_fn_constant dp iter Forker None dp iter Forker None copy shallow dp iter Grouper None _fake_filter_fn group_size dp iter IterableWrapper range dp iter Mapper None _fake_fn dp iter Mapper None partial _fake_add dp iter Multiplexer None dp iter IterableWrapper range dp iter Sampler None dp iter Shuffler dp iter IterableWrapper dp iter StreamReader None dp iter UnBatcher None dp iter Zipper None dp iter IterableWrapper range Skipping comparison these DataPipes dp_skip_comparison = dp iter FileOpener dp iter StreamReader These DataPipes produce multiple DataPipes outputs those should compared dp_compare_children = dp iter Demultiplexer dp iter Forker dpipe custom_input dp_args dp_kwargs picklable_datapipes custom_input None custom_input = dp iter IterableWrapper range dpipe dp_skip_comparison Merely make sure they picklable loadable no value comparison datapipe = dpipe custom_input dp_args dp_kwargs type ignore call-arg serialized_dp = pickle dumps datapipe _ = pickle loads serialized_dp dpipe dp_compare_children DataPipes have children dp dp = dpipe custom_input dp_args dp_kwargs type ignore call-arg _serialization_test_for_dp_with_children dp dp Single DataPipe requires comparison datapipe = dpipe custom_input dp_args dp_kwargs type ignore call-arg _serialization_test_for_single_dp datapipe skipIfTorchDynamo Dict function keys test_serializable_with_dill Only DataPipes take function argument input_dp = dp iter IterableWrapper range datapipes_with_lambda_fn list tuple type IterDataPipe tuple dict str Any = dp iter Collator lambda_fn dp iter Demultiplexer lambda_fn dp iter Filter lambda_fn dp iter Grouper lambda_fn dp iter Mapper lambda_fn _local_fns _fn x x _fn x x _fn x x = _fn _fn _fn fn fn fn = _local_fns datapipes_with_local_fn list tuple type IterDataPipe tuple dict str Any = dp iter Collator fn dp iter Demultiplexer fn dp iter Filter fn dp iter Grouper fn dp iter Mapper fn dp_compare_children = dp iter Demultiplexer HAS_DILL dpipe dp_args dp_kwargs datapipes_with_lambda_fn + datapipes_with_local_fn dpipe dp_compare_children dp dp = dpipe input_dp dp_args dp_kwargs type ignore call-arg _serialization_test_for_dp_with_children dp dp use_dill=True datapipe = dpipe input_dp dp_args dp_kwargs type ignore call-arg _serialization_test_for_single_dp datapipe use_dill=True msgs = r ^Lambda function supported pickle r ^Local function supported pickle dps msg zip datapipes_with_lambda_fn datapipes_with_local_fn msgs dpipe dp_args dp_kwargs dps assertWarnsRegex UserWarning msg datapipe = dpipe input_dp dp_args dp_kwargs type ignore call-arg assertRaises pickle PicklingError AttributeError pickle dumps datapipe test_docstring Ensure functional form IterDataPipe has correct docstring form Regression test https github com pytorch data issues input_dp = dp iter IterableWrapper range dp_funcname batch collate concat demux filter fork map mux read_from_stream sampler shuffle unbatch zip docstring = pydoc render_doc thing=getattr input_dp dp_funcname forceload=True assert f functional name ` ` dp_funcname ` ` docstring assert Args docstring assert Example docstring Examples docstring test_iterable_wrapper_datapipe input_ls = list range input_dp = dp iter IterableWrapper input_ls Functional Test values unchanged same order assertEqual input_ls list input_dp Functional Test deep copy default when iterator initialized first element read = iter input_dp assertEqual next The deep copy only happens when first element read input_ls append assertEqual list range list Functional Test shallow copy input_ls = input_dp_shallow = dp iter IterableWrapper input_ls deepcopy=False input_ls append assertEqual list input_dp_shallow Reset Test reset DataPipe input_ls = list range input_dp = dp iter IterableWrapper input_ls n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls input_dp n_elements_before_reset assertEqual input_ls n_elements_before_reset res_before_reset assertEqual input_ls res_after_reset __len__ Test inherits length sequence assertEqual len input_ls len input_dp test_concat_iterdatapipe input_dp = dp iter IterableWrapper range input_dp = dp iter IterableWrapper range Functional Test Raises exception empty input assertRaisesRegex ValueError r Expected least one DataPipe dp iter Concater Functional Test Raises exception non-IterDataPipe input assertRaisesRegex TypeError r Expected all inputs ` IterDataPipe ` dp iter Concater input_dp type ignore arg-type Functional Test Concatenate DataPipes expected concat_dp = input_dp concat input_dp assertEqual len concat_dp assertEqual list concat_dp list range + list range Reset Test reset DataPipe n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls concat_dp n_elements_before_reset assertEqual list range res_before_reset assertEqual list range + list range res_after_reset __len__ Test inherits length source DataPipe input_dp_nl = IDP_NoLen range concat_dp = input_dp concat input_dp_nl assertRaisesRegex TypeError r instance doesn t have valid length$ len concat_dp assertEqual list concat_dp list range + list range test_fork_iterdatapipe input_dp = dp iter IterableWrapper range assertRaises ValueError input_dp fork num_instances= dp = input_dp fork num_instances= buffer_size= assertEqual dp input_dp Functional Test making sure all child DataPipe shares same reference dp dp dp = input_dp fork num_instances= assertTrue all n n n n n n n zip dp dp dp Functional Test one child DataPipe yields all value time output output output = list dp list dp list dp assertEqual list range output assertEqual list range output assertEqual list range output Functional Test two child DataPipes yield value together dp dp = input_dp fork num_instances= output = n n zip dp dp output append n n assertEqual i i i range output Functional Test one child DataPipe yields all value first buffer_size = being too small dp dp = input_dp fork num_instances= buffer_size= = iter dp _ range next assertRaises BufferError next assertRaises BufferError list dp dp dp = input_dp fork num_instances= buffer_size= assertRaises BufferError list dp Functional Test one child DataPipe yields all value first unlimited buffer warnings catch_warnings record=True wa dp dp = input_dp fork num_instances= buffer_size=- assertEqual len wa assertRegex str wa message r Unlimited buffer size set l l = list dp list dp d d zip l l assertEqual d d Functional Test two child DataPipes yield value together buffer size dp dp = input_dp fork num_instances= buffer_size= output = n n zip dp dp output append n n assertEqual i i i range output Functional Test two child DataPipes yield shallow copies copy equals shallow dp dp = input_dp map _to_list fork num_instances= copy= shallow n n zip dp dp assertIsNot n n assertEqual n n Functional Test two child DataPipes yield deep copies copy equals deep dp dp = input_dp map _to_list map _to_list fork num_instances= copy= deep n n zip dp dp assertIsNot n n assertEqual n n Functional Test fork DataPipe raises error unknown copy method assertRaises ValueError input_dp fork num_instances= copy= unknown Functional Test make sure logic related slowest_ptr working properly dp dp dp = input_dp fork num_instances= output output output = i n n enumerate zip dp dp output append n output append n i == yield all dp when halfway through dp dp output = list dp break assertEqual list range output assertEqual list range output assertEqual list range output Reset Test DataPipe resets when new iterator created even datapipe hasn t been read dp dp = input_dp fork num_instances= _ = iter dp output = assertRaisesRegex RuntimeError r iterator has been invalidated i n enumerate dp output append n i == warnings catch_warnings record=True wa _ = iter dp This will reset all child DataPipes assertEqual len wa assertRegex str wa message r child DataPipes exhausted assertEqual list range output Reset Test DataPipe resets when some has been read dp dp = input_dp fork num_instances= output output = i n n enumerate zip dp dp output append n output append n i == warnings catch_warnings record=True wa _ = iter dp Reset both all child DataPipe assertEqual len wa assertRegex str wa message r Some child DataPipes exhausted break warnings catch_warnings record=True wa i n n enumerate zip dp dp output append n output append n assertEqual len wa assertRegex str wa message r child DataPipes exhausted assertEqual list range + list range output assertEqual list range + list range output Reset Test DataPipe reset even when some other child DataPipes read dp dp dp = input_dp fork num_instances= output output = list dp list dp assertEqual list range output assertEqual list range output warnings catch_warnings record=True wa assertEqual list range list dp Resets even though dp has been read assertEqual len wa assertRegex str wa message r Some child DataPipes exhausted output = i n enumerate dp output append n i == warnings catch_warnings record=True wa output = list dp Resets even though dp only partially read assertEqual len wa assertRegex str wa message r Some child DataPipes exhausted assertEqual list range output assertEqual list range output break assertEqual list range list dp dp has read start again __len__ Test Each DataPipe inherits source datapipe s length dp dp dp = input_dp fork num_instances= assertEqual len input_dp len dp assertEqual len input_dp len dp assertEqual len input_dp len dp Pickle Test dp dp dp = input_dp fork num_instances= traverse_dps dp This should raise any error _ zip dp dp dp pass traverse_dps dp This should raise any error either test_mux_iterdatapipe Functional Test Elements yielded one time each DataPipe until they all exhausted input_dp = dp iter IterableWrapper range input_dp = dp iter IterableWrapper range input_dp = dp iter IterableWrapper range output_dp = input_dp mux input_dp input_dp expected_output = assertEqual len expected_output len output_dp assertEqual expected_output list output_dp Functional Test Uneven input Data Pipes input_dp = dp iter IterableWrapper input_dp = dp iter IterableWrapper input_dp = dp iter IterableWrapper output_dp = input_dp mux input_dp input_dp expected_output = assertEqual len expected_output len output_dp assertEqual expected_output list output_dp Functional Test Empty Data Pipe input_dp = dp iter IterableWrapper input_dp = dp iter IterableWrapper output_dp = input_dp mux input_dp assertEqual len input_dp len output_dp assertEqual list input_dp list output_dp __len__ Test raises TypeError when __len__ called input doesn t have __len__ input_dp = dp iter IterableWrapper range input_dp_no_len = IDP_NoLen range output_dp = input_dp mux input_dp_no_len assertRaises TypeError len output_dp test_demux_iterdatapipe input_dp = dp iter IterableWrapper range assertRaises ValueError input_dp demux num_instances= classifier_fn=lambda x Functional Test split into DataPipes output them one time dp dp = input_dp demux num_instances= classifier_fn=lambda x x output output = list dp list dp assertEqual list range output assertEqual list range output Functional Test split into DataPipes output them together dp dp = input_dp demux num_instances= classifier_fn=lambda x x output = n n zip dp dp output append n n assertEqual i i + i range output Functional Test values same classification lumped together buffer_size = being too small dp dp = input_dp demux num_instances= classifier_fn=lambda x x = buffer_size= = iter dp assertRaises BufferError next Buffer raises because first elements all belong different child assertRaises BufferError list dp Functional Test values same classification lumped together buffer_size = just enough dp dp = input_dp demux num_instances= classifier_fn=lambda x x = buffer_size= output output = list dp list dp assertEqual list range output assertEqual list range output Functional Test values same classification lumped together unlimited buffer warnings catch_warnings record=True wa dp dp = input_dp demux num_instances= classifier_fn=lambda x x = buffer_size=- exp_l = HAS_DILL assertEqual len wa exp_l assertRegex str wa - message r Unlimited buffer size set output output = list dp list dp assertEqual list range output assertEqual list range output Functional Test classifier returns value outside num_instance - dp = input_dp demux num_instances= classifier_fn=lambda x x = iter dp assertRaises ValueError next next Reset Test DataPipe resets when new iterator created even datapipe hasn t been read dp dp = input_dp demux num_instances= classifier_fn=lambda x x _ = iter dp output = assertRaisesRegex RuntimeError r iterator has been invalidated i n enumerate dp output append n i == warnings catch_warnings record=True wa _ = iter dp This will reset all child DataPipes assertEqual len wa assertRegex str wa message r child DataPipes exhausted assertEqual list range output Reset Test DataPipe resets when some has been read dp dp = input_dp demux num_instances= classifier_fn=lambda x x output output = n n zip dp dp output append n output append n n == break warnings catch_warnings record=True wa iter dp Reset all child DataPipes assertEqual len wa assertRegex str wa message r Some child DataPipes exhausted n n zip dp dp output append n output append n assertEqual + list range output assertEqual + list range output assertEqual len wa assertRegex str wa message r child DataPipes exhausted Reset Test DataPipe reset even when all child DataPipes exhausted dp dp = input_dp demux num_instances= classifier_fn=lambda x x output = list dp assertEqual list range output warnings catch_warnings record=True wa assertEqual list range list dp Reset even when dp read assertEqual len wa assertRegex str wa message r Some child DataPipes exhausted output = i n enumerate dp output append n i == assertEqual list range output warnings catch_warnings record=True wa assertEqual list range list dp Can reset even when dp partially read assertEqual len wa assertRegex str wa message r Some child DataPipes exhausted break output = list dp output has read beginning again assertEqual list range output Functional Test drop_none = True dp dp = input_dp demux num_instances= classifier_fn=lambda x x x = None drop_none=True assertEqual list dp assertEqual list dp Functional Test drop_none = False dp dp = input_dp demux num_instances= classifier_fn=lambda x x x = None drop_none=False = iter dp assertRaises ValueError next __len__ Test __len__ implemented dp dp = input_dp demux num_instances= classifier_fn=lambda x x assertRaises TypeError len dp It implemented we do know length each child advance assertRaises TypeError len dp Pickle Test dp dp = input_dp demux num_instances= classifier_fn=odd_or_even traverse_dps dp This should raise any error _ zip dp dp pass traverse_dps dp This should raise any error either test_map_iterdatapipe target_length = input_dp = dp iter IterableWrapper range target_length fn item dtype=torch float sum=False data = torch tensor item dtype=dtype data sum data sum Functional Test apply each element correctly map_dp = input_dp map fn assertEqual target_length len map_dp x y zip map_dp range target_length assertEqual x torch tensor y dtype=torch float Functional Test works partial function map_dp = input_dp map partial fn dtype=torch int sum=True x y zip map_dp range target_length assertEqual x torch tensor y dtype=torch int sum __len__ Test inherits length source DataPipe assertEqual target_length len map_dp input_dp_nl = IDP_NoLen range target_length map_dp_nl = input_dp_nl map lambda x x x y zip map_dp_nl range target_length assertEqual x torch tensor y dtype=torch float __len__ Test inherits length source DataPipe - raises error when invalid assertRaisesRegex TypeError r instance doesn t have valid length$ len map_dp_nl Reset Test DataPipe resets properly n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls map_dp n_elements_before_reset assertEqual list range n_elements_before_reset res_before_reset assertEqual list range res_after_reset suppress_warnings Suppress warning lambda fn test_map_tuple_list_with_col_iterdatapipe fn_ d -d fn_ n d -d d fn_n d d d + d fn_nn d d -d -d d + d fn_n _def d d = d + d fn_n _kwargs d d kwargs d + d fn_n _pos d d args d + d fn_n _sep_pos d args d d + d fn_cmplx d d = args d kwargs d + d p_fn_n = partial fn_n d = p_fn_cmplx = partial fn_cmplx d = p_fn_cmplx_large_arg = partial fn_cmplx d = i list range i i range _ _helper ref_fn fn input_col=None output_col=None error=None constr list tuple datapipe = dp iter IterableWrapper constr constr constr ref_fn None assertRaises error res_dp = datapipe map fn input_col output_col list res_dp res_dp = datapipe map fn input_col output_col ref_dp = datapipe map ref_fn assertEqual list res_dp list ref_dp Reset assertEqual list res_dp list ref_dp _helper lambda data data fn_n _def _helper lambda data data data data + data fn_n _def _helper lambda data data p_fn_n _helper lambda data data p_fn_cmplx _helper lambda data data p_fn_cmplx_large_arg _helper lambda data data data data + data p_fn_cmplx _helper lambda data data + data fn_n _pos Replacing one input column default output column _helper lambda data data -data data fn_ _helper lambda data data -data data data fn_ n The index input column out range _helper None fn_ n error=IndexError Unmatched input columns fn arguments _helper None fn_n error=ValueError _helper None fn_n error=ValueError _helper None operator add error=ValueError _helper None operator add error=ValueError _helper None fn_cmplx ValueError _helper None fn_n _pos error=ValueError _helper None fn_n _def error=ValueError _helper None p_fn_n error=ValueError _helper None fn_ n error=ValueError _helper None p_fn_cmplx error=ValueError _helper None fn_n _sep_pos error=ValueError Fn has keyword-only arguments _helper None fn_n _kwargs error=ValueError _helper None fn_cmplx ValueError Replacing multiple input columns default output column left-most input column _helper lambda data data data + data fn_n _helper lambda data data -data -data data + data fn_nn output_col can only specified when input_col None _helper None fn_n None error=ValueError output_col can only single-element list tuple _helper None fn_n None error=ValueError Single-element list output_col _helper lambda data -data data data fn_ Replacing one input column single specified output column _helper lambda data -data data data fn_ _helper lambda data data data -data data fn_ n The index output column out range _helper None fn_ n error=IndexError _helper lambda data data data + data data fn_n _helper lambda data -data -data data + data data data fn_nn Appending output end _helper lambda data data -data fn_ - _helper lambda data data -data data fn_ n - _helper lambda data data data + data fn_n - _helper lambda data data -data -data data + data fn_nn - Handling built-in functions e g ` dict ` ` iter ` ` int ` ` str ` whose signatures cannot inspected _helper lambda data str data data data str _helper lambda data data data int data int Handle nn Module Callable without __name__ implemented _helper lambda data data + data data Add Module _helper lambda data data + data data Add Callable suppress_warnings Suppress warning lambda fn skipIfTorchDynamo test_map_dict_with_col_iterdatapipe fn_ d -d fn_ n d -d d fn_n d d d + d fn_nn d d -d -d d + d fn_n _def d d = d + d p_fn_n = partial fn_n d = fn_n _pos d d args d + d fn_n _kwargs d d kwargs d + d fn_kwonly d d d + d fn_has_nondefault_kwonly d d d + d fn_cmplx d d = args d kwargs d + d p_fn_cmplx = partial fn_cmplx d = p_fn_cmplx_large_arg = partial fn_cmplx d = i list range i i range _ Prevent modification in-place support resetting _dict_update data newdata remove_idx=None _data = dict data _data update newdata remove_idx idx remove_idx del _data idx _data _helper ref_fn fn input_col=None output_col=None error=None datapipe = dp iter IterableWrapper x y z x y z x y z ref_fn None assertRaises error res_dp = datapipe map fn input_col output_col list res_dp res_dp = datapipe map fn input_col output_col ref_dp = datapipe map ref_fn assertEqual list res_dp list ref_dp Reset assertEqual list res_dp list ref_dp _helper lambda data data fn_n _def x y _helper lambda data data p_fn_n x y _helper lambda data data p_fn_cmplx x y _helper lambda data data p_fn_cmplx_large_arg x y _helper lambda data _dict_update data z data x + data y p_fn_cmplx x y z z _helper lambda data _dict_update data z data x + data y fn_n _def x y z _helper None fn_n _pos x error=ValueError _helper None fn_n _kwargs x error=ValueError non-default kw-only args _helper None fn_kwonly x y error=ValueError _helper None fn_has_nondefault_kwonly x y error=ValueError _helper None fn_cmplx x y error=ValueError Replacing one input column default output column _helper lambda data _dict_update data y -data y fn_ y _helper lambda data _dict_update data y -data y data y fn_ n y The key input column dict _helper None fn_ n error=KeyError Unmatched input columns fn arguments _helper None fn_n y error=ValueError _helper None fn_ n x y error=ValueError _helper None fn_n _def x y z error=ValueError _helper None p_fn_n x y error=ValueError _helper None fn_n _kwargs x y z error=ValueError Replacing multiple input columns default output column left-most input column _helper lambda data _dict_update data z data x + data z x fn_n z x _helper lambda data _dict_update data z -data z -data y data y + data z y fn_nn z y output_col can only specified when input_col None _helper None fn_n None x error=ValueError output_col can only single-element list tuple _helper None fn_n None x y error=ValueError Single-element list output_col _helper lambda data _dict_update data x -data y fn_ y x Replacing one input column single specified output column _helper lambda data _dict_update data x -data y fn_ y x _helper lambda data _dict_update data z -data y data y fn_ n y z _helper lambda data _dict_update data y data x + data z fn_n x z y _helper lambda data _dict_update data x -data y -data z data y + data z fn_nn y z x Adding new key dict output _helper lambda data _dict_update data -data y fn_ y _helper lambda data _dict_update data -data y data y fn_ n y _helper lambda data _dict_update data data x + data z fn_n x z _helper lambda data _dict_update data -data y -data z data y + data z fn_nn y z test_collate_iterdatapipe arrs = input_dp = dp iter IterableWrapper arrs _collate_fn batch default_type=torch float torch tensor sum batch dtype=default_type Functional Test defaults default collate function when custom one specified collate_dp = input_dp collate x y zip arrs collate_dp assertEqual torch tensor x y Functional Test custom collate function collate_dp = input_dp collate collate_fn=_collate_fn x y zip arrs collate_dp assertEqual torch tensor sum x dtype=torch float y Functional Test custom partial collate function collate_dp = input_dp collate partial _collate_fn default_type=torch int x y zip arrs collate_dp assertEqual torch tensor sum x dtype=torch int y Reset Test reset DataPipe results still correct n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls collate_dp n_elements_before_reset assertEqual torch tensor dtype=torch int res_before_reset x y zip arrs res_after_reset assertEqual torch tensor sum x dtype=torch int y __len__ Test __len__ inherited assertEqual len input_dp len collate_dp __len__ Test verify has no valid __len__ when source doesn t have input_dp_nl = IDP_NoLen arrs collate_dp_nl = input_dp_nl collate assertRaisesRegex TypeError r instance doesn t have valid length$ len collate_dp_nl x y zip arrs collate_dp_nl assertEqual torch tensor x y test_batch_iterdatapipe arrs = list range input_dp = dp iter IterableWrapper arrs Functional Test raise error when input argument ` batch_size = ` assertRaises AssertionError input_dp batch batch_size= Functional Test default do drop last batch bs = batch_dp = input_dp batch batch_size=bs assertEqual len batch_dp i batch enumerate batch_dp assertEqual len batch i == bs assertEqual batch arrs i bs i bs + len batch Functional Test Drop last batch when specified bs = batch_dp = input_dp batch batch_size=bs drop_last=True i batch enumerate batch_dp assertEqual batch arrs i bs i bs + len batch __len__ test verifying overall length each batch correct i batch enumerate batch_dp assertEqual len batch bs __len__ Test length missing source DataPipe doesn t have length assertEqual len batch_dp input_dp_nl = IDP_NoLen range batch_dp_nl = input_dp_nl batch batch_size= assertRaisesRegex TypeError r instance doesn t have valid length$ len batch_dp_nl Reset Test Ensures DataPipe can properly reset n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls batch_dp n_elements_before_reset assertEqual res_before_reset assertEqual res_after_reset test_unbatch_iterdatapipe target_length = prebatch_dp = dp iter IterableWrapper range target_length Functional Test Unbatch DataPipe should same pre-batch DataPipe input_dp = prebatch_dp batch unbatch_dp = input_dp unbatch assertEqual len list unbatch_dp target_length __len__ expected i res zip range target_length unbatch_dp assertEqual i res Functional Test unbatch works input nested levels input_dp = dp iter IterableWrapper unbatch_dp = input_dp unbatch assertEqual len list unbatch_dp target_length i res zip range target_length unbatch_dp assertEqual i res input_dp = dp iter IterableWrapper Functional Test unbatch works input nested levels unbatch_dp = input_dp unbatch expected_dp = assertEqual len list unbatch_dp j res zip expected_dp unbatch_dp assertEqual j res Functional Test unbatching multiple levels same time unbatch_dp = input_dp unbatch unbatch_level= expected_dp = assertEqual len list unbatch_dp i res zip expected_dp unbatch_dp assertEqual i res Functional Test unbatching all levels same time unbatch_dp = input_dp unbatch unbatch_level=- assertEqual len list unbatch_dp i res zip expected_dp unbatch_dp assertEqual i res Functional Test raises error when input unbatch_level less than - input_dp = dp iter IterableWrapper assertRaises ValueError unbatch_dp = input_dp unbatch unbatch_level=- i unbatch_dp print i Functional Test raises error when input unbatch_level too high assertRaises IndexError unbatch_dp = input_dp unbatch unbatch_level= i unbatch_dp print i Reset Test unbatch_dp resets properly input_dp = dp iter IterableWrapper unbatch_dp = input_dp unbatch unbatch_level=- n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls unbatch_dp n_elements_before_reset assertEqual res_before_reset assertEqual res_after_reset test_filter_datapipe input_ds = dp iter IterableWrapper range _filter_fn data val data = val Functional Test filter works partial function filter_dp = input_ds filter partial _filter_fn val= assertEqual list filter_dp list range _non_bool_fn data Functional Test filter function must bool filter_dp = input_ds filter filter_fn=_non_bool_fn assertRaises ValueError list filter_dp Functional Test Specify input_col tuple_input_ds = dp iter IterableWrapper d - d d + d range Single input_col input_col_ _dp = tuple_input_ds filter partial _filter_fn val= input_col= assertEqual list input_col_ _dp d - d d + d range Multiple input_col _mul_filter_fn b + b input_col_ _dp = tuple_input_ds filter _mul_filter_fn input_col= assertEqual list input_col_ _dp d - d d + d range invalid input col assertRaises ValueError tuple_input_ds filter _mul_filter_fn input_col= p_mul_filter_fn = partial _mul_filter_fn b= out = tuple_input_ds filter p_mul_filter_fn input_col= assertEqual list out d - d d + d range _mul_filter_fn_with_defaults b= + b out = tuple_input_ds filter _mul_filter_fn_with_defaults input_col= assertEqual list out d - d d + d range _mul_filter_fn_with_kw_only b + b assertRaises ValueError tuple_input_ds filter _mul_filter_fn_with_kw_only input_col= _mul_filter_fn_with_kw_only_ _default b= + b assertRaises ValueError tuple_input_ds filter _mul_filter_fn_with_kw_only_ _default input_col= __len__ Test DataPipe has no valid len assertRaisesRegex TypeError r has no len len filter_dp Reset Test DataPipe resets correctly filter_dp = input_ds filter partial _filter_fn val= n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls filter_dp n_elements_before_reset assertEqual list range n_elements_before_reset res_before_reset assertEqual list range res_after_reset test_sampler_iterdatapipe input_dp = dp iter IterableWrapper range Default SequentialSampler sampled_dp = dp iter Sampler input_dp type ignore var-annotated assertEqual len sampled_dp i x enumerate sampled_dp assertEqual x i RandomSampler dp iter Sampler input_dp sampler=RandomSampler sampler_kwargs= replacement True Requires ` __len__ ` build SamplerDataPipe input_dp_nolen = IDP_NoLen range assertRaises AssertionError sampled_dp = dp iter Sampler input_dp_nolen test_stream_reader_iterdatapipe io StringIO input_dp = dp iter IterableWrapper f StringIO abcde f StringIO bcdef expected_res = abcde bcdef Functional Test Read full chunk dp = input_dp read_from_stream assertEqual d d dp expected_res Functional Test Read full chunk dp = input_dp read_from_stream chunk= assertEqual d d dp c s expected_res c s ` __len__ ` Test assertRaises TypeError len dp test_shuffler_iterdatapipe input_dp = dp iter IterableWrapper list range assertRaises AssertionError input_dp shuffle buffer_size= Functional Test No seed shuffler_dp = input_dp shuffle assertEqual set range set shuffler_dp Functional Test With global seed torch manual_seed shuffler_dp = input_dp shuffle res = list shuffler_dp torch manual_seed assertEqual list shuffler_dp res Functional Test Set seed shuffler_dp = input_dp shuffle set_seed res = list shuffler_dp shuffler_dp set_seed assertEqual list shuffler_dp res Functional Test deactivate shuffling via set_shuffle unshuffled_dp = input_dp shuffle set_shuffle False assertEqual list unshuffled_dp list input_dp Reset Test shuffler_dp = input_dp shuffle n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls shuffler_dp n_elements_before_reset assertEqual len res_before_reset x res_before_reset assertTrue x set range assertEqual set range set res_after_reset __len__ Test returns length input DataPipe shuffler_dp = input_dp shuffle assertEqual len shuffler_dp Serialization Test torch utils data datapipes _hook_iterator _SnapshotState _serialization_helper bs shuffler_dp = input_dp shuffle buffer_size=bs = iter shuffler_dp _ range next shuffler_dp_copy = pickle loads pickle dumps shuffler_dp _simple_graph_snapshot_restoration shuffler_dp_copy datapipe shuffler_dp datapipe _number_of_samples_yielded exp = list shuffler_dp_copy _snapshot_state = _SnapshotState Restored assertEqual exp list shuffler_dp_copy buffer_sizes = bs buffer_sizes _serialization_helper bs test_zip_iterdatapipe Functional Test raises TypeError when input type ` IterDataPipe ` assertRaises TypeError dp iter Zipper dp iter IterableWrapper range list range type ignore arg-type Functional Test raises TypeError when input does have valid length zipped_dp = dp iter Zipper dp iter IterableWrapper range IDP_NoLen range type ignore var-annotated assertRaisesRegex TypeError r instance doesn t have valid length$ len zipped_dp Functional Test zips results properly exp = i i i range assertEqual list zipped_dp exp Functional Test zips inputs properly even when lengths different zips shortest zipped_dp = dp iter Zipper dp iter IterableWrapper range dp iter IterableWrapper range __len__ Test length matches length shortest input assertEqual len zipped_dp Reset Test n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls zipped_dp n_elements_before_reset expected_res = i i i range assertEqual expected_res n_elements_before_reset res_before_reset assertEqual expected_res res_after_reset TestFunctionalMapDataPipe TestCase _serialization_test_helper datapipe use_dill use_dill serialized_dp = dill dumps datapipe deserialized_dp = dill loads serialized_dp serialized_dp = pickle dumps datapipe deserialized_dp = pickle loads serialized_dp try assertEqual list datapipe list deserialized_dp except AssertionError e print f datapipe failing raise e _serialization_test_for_single_dp dp use_dill=False Testing serialization before any iteration starts _serialization_test_helper dp use_dill Testing serialization after DataPipe partially read = iter dp _ = next _serialization_test_helper dp use_dill Testing serialization after DataPipe fully read _ = list dp _serialization_test_helper dp use_dill test_serializable picklable_datapipes list = dp map Batcher None dp map Concater None dp map SequenceWrapper range dp map Mapper None dp map Mapper None _fake_fn dp map Mapper None partial _fake_add dp map SequenceWrapper range dp map Shuffler dp map SequenceWrapper dp map Zipper None dp map SequenceWrapper range dpipe custom_input dp_args dp_kwargs picklable_datapipes custom_input None custom_input = dp map SequenceWrapper range datapipe = dpipe custom_input dp_args dp_kwargs type ignore call-arg _serialization_test_for_single_dp datapipe test_serializable_with_dill Only DataPipes take function argument input_dp = dp map SequenceWrapper range datapipes_with_lambda_fn list tuple type MapDataPipe tuple dict str Any = dp map Mapper lambda_fn _local_fns _fn x x _fn fn = _local_fns datapipes_with_local_fn list tuple type MapDataPipe tuple dict str Any = dp map Mapper fn HAS_DILL dpipe dp_args dp_kwargs datapipes_with_lambda_fn + datapipes_with_local_fn _ = dill dumps dpipe input_dp dp_args dp_kwargs type ignore call-arg msgs = r ^Lambda function supported pickle r ^Local function supported pickle dps msg zip datapipes_with_lambda_fn datapipes_with_local_fn msgs dpipe dp_args dp_kwargs dps assertWarnsRegex UserWarning msg datapipe = dpipe input_dp dp_args dp_kwargs type ignore call-arg assertRaises pickle PicklingError AttributeError pickle dumps datapipe test_docstring Ensure functional form MapDataPipe has correct docstring form Regression test https github com pytorch data issues input_dp = dp map SequenceWrapper range dp_funcname batch concat map shuffle zip docstring = pydoc render_doc thing=getattr input_dp dp_funcname forceload=True assert f functional name ` ` dp_funcname ` ` docstring assert Args docstring assert Example docstring Examples docstring test_sequence_wrapper_datapipe seq = list range input_dp = dp map SequenceWrapper seq Functional Test all elements equal same order assertEqual seq list input_dp Functional Test confirm deepcopy works default seq append assertEqual list range list input_dp input_dp shouldn t have Functional Test non-deepcopy version working seq = input_dp_non_deep = dp map SequenceWrapper seq deepcopy=False seq append assertEqual list seq list input_dp_non_deep should have Reset Test reset DataPipe seq = list range n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls input_dp n_elements_before_reset assertEqual list range res_before_reset assertEqual seq res_after_reset __len__ Test inherits length sequence assertEqual len seq len input_dp test_concat_mapdatapipe input_dp = dp map SequenceWrapper range input_dp = dp map SequenceWrapper range assertRaisesRegex ValueError r Expected least one DataPipe dp map Concater assertRaisesRegex TypeError r Expected all inputs ` MapDataPipe ` dp map Concater input_dp type ignore arg-type concat_dp = input_dp concat input_dp assertEqual len concat_dp index range assertEqual concat_dp index list range + list range index assertEqual list concat_dp list range + list range test_zip_mapdatapipe input_dp = dp map SequenceWrapper range input_dp = dp map SequenceWrapper range input_dp = dp map SequenceWrapper range Functional Test requires least one input DataPipe assertRaisesRegex ValueError r Expected least one DataPipe dp map Zipper Functional Test all inputs must MapDataPipes assertRaisesRegex TypeError r Expected all inputs ` MapDataPipe ` dp map Zipper input_dp type ignore arg-type Functional Test Zip elements up tuples zip_dp = input_dp zip input_dp input_dp assertEqual i i i i range zip_dp i i range Functional Test Raise IndexError when index equal exceed length shortest DataPipe assertRaisesRegex IndexError r out range input_dp zip input_dp input_dp Functional Test Ensure ` zip ` can combine ` Batcher ` others dp = dp map SequenceWrapper range shuffle_dp = dp batch dp = dp map SequenceWrapper range shuffle_dp = dp batch zip_dp = shuffle_dp zip shuffle_dp assertEqual len list zip_dp zip_dp = shuffle_dp zip dp assertEqual len list zip_dp __len__ Test returns length shortest DataPipe zip_dp = input_dp zip input_dp input_dp assertEqual len zip_dp test_shuffler_mapdatapipe input_dp = dp map SequenceWrapper range input_dp = dp map SequenceWrapper b c d e Functional Test Assumes -index when indices given shuffler_dp = input_dp shuffle assertEqual set range set shuffler_dp Functional Test Custom indices working shuffler_dp = input_dp shuffle indices= b c d e assertEqual set range set shuffler_dp Functional Test With global seed torch manual_seed shuffler_dp = input_dp shuffle res = list shuffler_dp torch manual_seed assertEqual list shuffler_dp res Functional Test Set seed shuffler_dp = input_dp shuffle set_seed res = list shuffler_dp shuffler_dp set_seed assertEqual list shuffler_dp res Functional Test deactivate shuffling via set_shuffle unshuffled_dp = input_dp shuffle set_shuffle False assertEqual list unshuffled_dp list input_dp Reset Test shuffler_dp = input_dp shuffle n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls shuffler_dp n_elements_before_reset assertEqual len res_before_reset x res_before_reset assertTrue x set range assertEqual set range set res_after_reset __len__ Test returns length input DataPipe shuffler_dp = input_dp shuffle assertEqual len shuffler_dp Serialization Test torch utils data datapipes _hook_iterator _SnapshotState shuffler_dp = input_dp shuffle = iter shuffler_dp _ range next shuffler_dp_copy = pickle loads pickle dumps shuffler_dp exp = list shuffler_dp_copy _snapshot_state = _SnapshotState Restored assertEqual exp list shuffler_dp_copy test_map_mapdatapipe arr = range input_dp = dp map SequenceWrapper arr fn item dtype=torch float sum=False data = torch tensor item dtype=dtype data sum data sum map_dp = input_dp map fn assertEqual len input_dp len map_dp index arr assertEqual map_dp index torch tensor input_dp index dtype=torch float map_dp = input_dp map partial fn dtype=torch int sum=True assertEqual len input_dp len map_dp index arr assertEqual map_dp index torch tensor input_dp index dtype=torch int sum test_batch_mapdatapipe arr = list range input_dp = dp map SequenceWrapper arr Functional Test batches top level default batch_dp = dp map Batcher input_dp batch_size= assertEqual list batch_dp Functional Test drop_last command batch_dp = dp map Batcher input_dp batch_size= drop_last=True assertEqual list batch_dp Functional Test nested batching batch_dp_ = batch_dp batch batch_size= assertEqual list batch_dp_ Reset Test n_elements_before_reset = res_before_reset res_after_reset = reset_after_n_next_calls batch_dp n_elements_before_reset assertEqual res_before_reset assertEqual res_after_reset __len__ Test assertEqual len batch_dp assertEqual len batch_dp_ TestTyping TestCase test_isinstance A IterDataPipe pass B IterDataPipe pass = A assertTrue isinstance A assertFalse isinstance B test_protocol try typing Protocol type ignore attr-defined except ImportError typing _Protocol type ignore attr-defined Protocol = _Protocol P Protocol pass A IterDataPipe P pass skipTyping test_subtype torch utils data datapipes _typing issubtype basic_type = int str bool float complex list tuple dict set T_co t basic_type assertTrue issubtype t t assertTrue issubtype t Any t == T_co assertTrue issubtype Any t assertFalse issubtype Any t t t itertools product basic_type basic_type t == t t == T_co assertTrue issubtype t t assertFalse issubtype t t T = TypeVar T int str S = TypeVar S bool Union str int tuple int T type ignore valid-type types = int Optional int list Union int list tuple int str S tuple int str tuple T S S T_co T Union S set sub par types assertTrue issubtype sub par assertFalse issubtype par sub subscriptable_types = list tuple use parameters set dict subscript_type n subscriptable_types items ts itertools combinations types n subs pars = zip ts sub = subscript_type subs type ignore index par = subscript_type pars type ignore index assertTrue issubtype sub par assertFalse issubtype par sub Non-recursive check assertTrue issubtype par sub recursive=False skipTyping test_issubinstance torch utils data datapipes _typing issubinstance basic_data = True complex basic_type = int str bool float complex S = TypeVar S bool Union str int d basic_data assertTrue issubinstance d Any assertTrue issubinstance d T_co type d bool int str assertTrue issubinstance d S assertFalse issubinstance d S t basic_type type d t assertTrue issubinstance d t assertFalse issubinstance d t list set dt = list set set d t dt assertTrue issubinstance d t assertTrue issubinstance d t T_co type ignore index assertFalse issubinstance d t int type ignore index dict d = assertTrue issubinstance d dict assertTrue issubinstance d dict str T_co assertFalse issubinstance d dict str int tuple d = assertTrue issubinstance d tuple assertTrue issubinstance d tuple int str T_co assertFalse issubinstance d tuple int Any assertFalse issubinstance d tuple int int int Static checking annotation skipTyping test_compile_time assertRaisesRegex TypeError r Expected Iterator InvalidDP IterDataPipe int __iter__ - str type ignore misc override yield assertRaisesRegex TypeError r Expected type __iter__ InvalidDP IterDataPipe tuple __iter__ - Iterator int type ignore override yield assertRaisesRegex TypeError r Expected type __iter__ InvalidDP IterDataPipe tuple int str __iter__ - Iterator tuple type ignore override yield DP IterDataPipe tuple int str __init__ length length = length __iter__ - Iterator tuple int str d range length yield d str d assertTrue issubclass DP IterDataPipe dp = DP assertTrue DP type issubtype dp type dp type issubtype DP type type ignore attr-defined dp _ = DP assertEqual dp type dp _ type assertRaisesRegex TypeError r generic InvalidDP DP tuple type ignore type-arg __iter__ - Iterator tuple type ignore override yield DP IterDataPipe T_co __iter__ - Iterator T_co yield range type ignore misc assertTrue issubclass DP IterDataPipe dp = DP type ignore var-annotated assertTrue DP type issubtype dp type dp type issubtype DP type type ignore attr-defined dp _ = DP type ignore var-annotated assertEqual dp type dp _ type DP IterDataPipe tuple T_co str r DataPipe without fixed type __init__ function __init__ datasource datasource = datasource __iter__ - Iterator tuple T_co str d datasource yield d str d assertTrue issubclass DP IterDataPipe dp = DP range type ignore var-annotated assertTrue DP type issubtype dp type dp type issubtype DP type type ignore attr-defined dp _ = DP type ignore var-annotated assertEqual dp type dp _ type DP IterDataPipe tuple r DataPipe without __iter__ annotation __iter__ raise NotImplementedError assertTrue issubclass DP IterDataPipe dp = DP assertTrue dp type param tuple DP IterDataPipe r DataPipe without type annotation __iter__ - Iterator str raise NotImplementedError assertTrue issubclass DP IterDataPipe dp = DP torch utils data datapipes _typing issubtype assertTrue issubtype dp type param Any issubtype Any dp type param DP IterDataPipe int r DataPipe plain Iterator __iter__ - Iterator raise NotImplementedError assertTrue issubclass DP IterDataPipe dp = DP assertTrue dp type param int DP IterDataPipe Awaitable T_co r DataPipe abstract base assertTrue issubclass DP IterDataPipe assertTrue DP type param == Awaitable T_co type ignore attr-defined DP DP str r DataPipe subclass DataPipe abc type assertTrue issubclass DP IterDataPipe assertTrue DP type param == Awaitable str type ignore attr-defined skipTyping test_construct_time DP IterDataPipe tuple argument_validation __init__ dp IterDataPipe dp = dp __iter__ - Iterator tuple d dp yield d str d DP IterDataPipe int argument_validation __init__ dp IterDataPipe tuple int str dp = dp __iter__ - Iterator int _ dp yield Non-DataPipe input DataPipe hint datasource = assertRaisesRegex TypeError r Expected argument dp IterDataPipe dp = DP datasource dp = DP dp iter IterableWrapper range assertRaisesRegex TypeError r Expected type argument dp subtype DP dp skipTyping test_runtime DP IterDataPipe tuple int T_co __init__ datasource ds = datasource runtime_validation __iter__ - Iterator tuple int T_co yield ds dss = ds dss dp = DP ds type ignore var-annotated assertEqual list dp ds Reset __iter__ assertEqual list dp ds dss = type ignore assignment list-item type ignore list-item ds dss dp = DP ds assertRaisesRegex RuntimeError r Expected instance subtype list dp runtime_validation_disabled assertEqual list dp ds runtime_validation_disabled assertEqual list dp ds assertRaisesRegex RuntimeError r Expected instance subtype list dp skipTyping test_reinforce T = TypeVar T int str DP IterDataPipe T __init__ ds ds = ds runtime_validation __iter__ - Iterator T yield ds ds = list range Valid type reinforcement dp = DP ds reinforce_type int assertTrue dp type int assertEqual list dp ds Invalid type assertRaisesRegex TypeError r expected_type must type DP ds reinforce_type Type subtype assertRaisesRegex TypeError r Expected expected_type subtype DP ds reinforce_type float Invalid data runtime dp = DP ds reinforce_type str assertRaisesRegex RuntimeError r Expected instance subtype list dp Context Manager disable runtime validation runtime_validation_disabled assertEqual list dp ds NumbersDataset IterDataPipe __init__ size= size = size __iter__ yield range size __len__ size TestGraph TestCase CustomIterDataPipe IterDataPipe add_v x x + v __init__ source_dp v= _dp = source_dp map add_v v = __iter__ yield _dp __hash__ raise NotImplementedError test_simple_traverse numbers_dp = NumbersDataset size= shuffled_dp = numbers_dp shuffle sharded_dp = shuffled_dp sharding_filter mapped_dp = sharded_dp map lambda x x graph = traverse_dps mapped_dp expected dict Any Any = id mapped_dp mapped_dp id sharded_dp sharded_dp id shuffled_dp shuffled_dp id numbers_dp numbers_dp assertEqual expected graph dps = torch utils data graph_settings get_all_graph_pipes graph assertEqual len dps datapipe numbers_dp shuffled_dp sharded_dp mapped_dp assertTrue datapipe dps test_traverse_forked numbers_dp = NumbersDataset size= dp dp dp = numbers_dp fork num_instances= dp _upd = dp map lambda x x dp _upd = dp filter lambda x x == combined_dp = dp _upd mux dp _upd dp graph = traverse_dps combined_dp expected = id combined_dp combined_dp id dp _upd dp _upd id dp dp id dp main_datapipe dp main_datapipe id dp main_datapipe main_datapipe dp main_datapipe main_datapipe id dp _upd dp _upd id dp dp id dp main_datapipe dp main_datapipe id dp main_datapipe main_datapipe dp main_datapipe main_datapipe id dp dp id dp main_datapipe dp main_datapipe id dp main_datapipe main_datapipe dp main_datapipe main_datapipe assertEqual expected graph dps = torch utils data graph_settings get_all_graph_pipes graph assertEqual len dps _dp numbers_dp dp main_datapipe dp dp dp dp _upd dp _upd combined_dp assertTrue _dp dps test_traverse_mapdatapipe source_dp = dp map SequenceWrapper range map_dp = source_dp map partial _fake_add graph = traverse_dps map_dp expected dict Any Any = id map_dp map_dp id source_dp source_dp assertEqual expected graph test_traverse_mixdatapipe source_map_dp = dp map SequenceWrapper range iter_dp = dp iter IterableWrapper source_map_dp graph = traverse_dps iter_dp expected dict Any Any = id iter_dp iter_dp id source_map_dp source_map_dp assertEqual expected graph test_traverse_circular_datapipe source_iter_dp = dp iter IterableWrapper list range circular_dp = TestGraph CustomIterDataPipe source_iter_dp graph = traverse_dps circular_dp See issue https github com pytorch data issues expected dict Any Any = id circular_dp circular_dp id circular_dp _dp circular_dp _dp id source_iter_dp source_iter_dp assertEqual expected graph dps = torch utils data graph_settings get_all_graph_pipes graph assertEqual len dps _dp circular_dp circular_dp _dp source_iter_dp assertTrue _dp dps test_traverse_unhashable_datapipe source_iter_dp = dp iter IterableWrapper list range unhashable_dp = TestGraph CustomIterDataPipe source_iter_dp graph = traverse_dps unhashable_dp assertRaises NotImplementedError hash unhashable_dp expected dict Any Any = id unhashable_dp unhashable_dp id unhashable_dp _dp unhashable_dp _dp id source_iter_dp source_iter_dp assertEqual expected graph unbatch x x TestSerialization TestCase skipIfNoDill test_spawn_lambdas_iter idp = dp iter IterableWrapper range map lambda x x + shuffle dl = DataLoader idp num_workers= shuffle=True multiprocessing_context= spawn collate_fn=unbatch batch_size= result = list dl assertEqual sorted result skipIfNoDill test_spawn_lambdas_map mdp = dp map SequenceWrapper range map lambda x x + shuffle dl = DataLoader mdp num_workers= shuffle=True multiprocessing_context= spawn collate_fn=unbatch batch_size= result = list dl assertEqual sorted result TestCircularSerialization TestCase CustomIterDataPipe IterDataPipe staticmethod add_one x x + classmethod classify cls x add_v x x + v __init__ fn source_dp=None fn = fn source_dp = source_dp source_dp dp iter IterableWrapper _dp = source_dp map add_one map add_v demux classify v = __iter__ yield _dp test_circular_serialization_with_pickle Test circular reference issue pickle dp = TestCircularSerialization CustomIterDataPipe fn=_fake_fn assertTrue list dp == list pickle loads pickle dumps dp child_ = dp _dp dm_ = child_ main_datapipe m _ = dm_ main_datapipe m _ = m _ datapipe src_ = m _ datapipe res = traverse_dps dp exp_res_ = id dp dp id src_ src_ id child_ child_ id dm_ dm_ id m _ m _ id m _ m _ id src_ src_ assertEqual res exp_res_ dp = TestCircularSerialization CustomIterDataPipe fn=_fake_fn source_dp=dp assertTrue list dp == list pickle loads pickle dumps dp child_ = dp _dp dm_ = child_ main_datapipe m _ = dm_ main_datapipe m _ = m _ datapipe res = traverse_dps dp exp_res_ = id dp dp id dp dp id src_ src_ id child_ child_ id dm_ dm_ id m _ m _ id m _ m _ id src_ src_ id child_ child_ id dm_ dm_ id m _ m _ id m _ m _ id dp dp id src_ src_ id child_ child_ id dm_ dm_ id m _ m _ id m _ m _ id src_ src_ assertEqual res exp_res_ LambdaIterDataPipe CustomIterDataPipe __init__ fn source_dp=None super __init__ fn source_dp container = lambda x x + lambda_fn = lambda x x + _dp = source_dp map add_one map lambda_fn map add_v demux classify skipIfNoDill skipIf True Dill Tests test_circular_serialization_with_dill Test circular reference issue dill dp = TestCircularSerialization LambdaIterDataPipe lambda x x + assertTrue list dp == list dill loads dill dumps dp child_ = dp _dp dm_ = child_ main_datapipe m _ = dm_ main_datapipe m _ = m _ datapipe src_ = m _ datapipe res = traverse_dps dp exp_res_ = id dp dp id src_ src_ id child_ child_ id dm_ dm_ id m _ m _ id m _ m _ id src_ src_ assertEqual res exp_res_ dp = TestCircularSerialization LambdaIterDataPipe fn=_fake_fn source_dp=dp assertTrue list dp == list dill loads dill dumps dp child_ = dp _dp dm_ = child_ main_datapipe m _ = dm_ main_datapipe m _ = m _ datapipe res = traverse_dps dp exp_res_ = id dp dp id dp dp id src_ src_ id child_ child_ id dm_ dm_ id m _ m _ id m _ m _ id src_ src_ id child_ child_ id dm_ dm_ id m _ m _ id m _ m _ id dp dp id src_ src_ id child_ child_ id dm_ dm_ id m _ m _ id m _ m _ id src_ src_ assertEqual res exp_res_ CustomShardingIterDataPipe IterDataPipe __init__ dp dp = dp num_of_instances = instance_id = apply_sharding num_of_instances instance_id num_of_instances = num_of_instances instance_id = instance_id __iter__ i d enumerate dp i num_of_instances == instance_id yield d TestSharding TestCase _get_pipeline numbers_dp = NumbersDataset size= dp dp = numbers_dp fork num_instances= dp _upd = dp map _mul_ dp _upd = dp filter _mod_ _test combined_dp = dp _upd mux dp _upd combined_dp _get_dill_pipeline numbers_dp = NumbersDataset size= dp dp = numbers_dp fork num_instances= dp _upd = dp map lambda x x dp _upd = dp filter lambda x x == combined_dp = dp _upd mux dp _upd combined_dp test_simple_sharding sharded_dp = _get_pipeline sharding_filter torch utils data graph_settings apply_sharding sharded_dp items = list sharded_dp assertEqual items all_items = items = i range sharded_dp = _get_pipeline sharding_filter torch utils data graph_settings apply_sharding sharded_dp i items += list sharded_dp assertEqual sorted all_items sorted items test_sharding_groups construct_sharded_pipe sharding_pipes = dp = NumbersDataset size= dp = dp sharding_filter sharding_group_filter=SHARDING_PRIORITIES DISTRIBUTED sharding_pipes append dp dp = dp sharding_filter sharding_group_filter=SHARDING_PRIORITIES MULTIPROCESSING sharding_pipes append dp dp = dp sharding_filter sharding_group_filter= sharding_pipes append dp dp sharding_pipes dp sharding_pipes = construct_sharded_pipe pipe sharding_pipes pipe apply_sharding sharding_group=SHARDING_PRIORITIES DISTRIBUTED pipe apply_sharding sharding_group=SHARDING_PRIORITIES MULTIPROCESSING pipe apply_sharding sharding_group= actual = list dp expected = assertEqual expected actual assertEqual len dp dp _ = construct_sharded_pipe dp apply_sharding sharding_group=SHARDING_PRIORITIES DEFAULT assertRaises Exception dp apply_sharding sharding_group=SHARDING_PRIORITIES MULTIPROCESSING dp _ = construct_sharded_pipe dp apply_sharding sharding_group=SHARDING_PRIORITIES MULTIPROCESSING assertRaises Exception dp apply_sharding sharding_group=SHARDING_PRIORITIES DEFAULT test_legacy_custom_sharding dp = _get_pipeline sharded_dp = CustomShardingIterDataPipe dp torch utils data graph_settings apply_sharding sharded_dp items = list sharded_dp assertEqual items test_sharding_length numbers_dp = dp iter IterableWrapper range sharded_dp = numbers_dp sharding_filter torch utils data graph_settings apply_sharding sharded_dp sharded_dp = numbers_dp sharding_filter torch utils data graph_settings apply_sharding sharded_dp sharded_dp = numbers_dp sharding_filter torch utils data graph_settings apply_sharding sharded_dp assertEqual len numbers_dp assertEqual len sharded_dp assertEqual len sharded_dp assertEqual len sharded_dp numbers_dp = dp iter IterableWrapper range sharded_dp = numbers_dp sharding_filter torch utils data graph_settings apply_sharding sharded_dp sharded_dp = numbers_dp sharding_filter torch utils data graph_settings apply_sharding sharded_dp assertEqual len sharded_dp assertEqual len sharded_dp test_old_dataloader dp = _get_pipeline expected = list dp dp = _get_pipeline sharding_filter dl = DataLoader dp batch_size= shuffle=False num_workers= items = list dl assertEqual sorted expected sorted items test_legacy_custom_sharding_with_old_dataloader dp = _get_pipeline expected = list dp dp = _get_pipeline dp = CustomShardingIterDataPipe dp dl = DataLoader dp batch_size= shuffle=False num_workers= items = list dl assertEqual sorted expected sorted items test_multi_sharding Raises Error when multiple sharding single branch numbers_dp = dp iter IterableWrapper range sharded_dp = numbers_dp sharding_filter sharded_dp = sharded_dp sharding_filter assertRaisesRegex RuntimeError Sharding twice single pipeline torch utils data graph_settings apply_sharding sharded_dp Raises Error when sharding both data source branch numbers_dp = dp iter IterableWrapper range sharding_filter dp dp = numbers_dp fork sharded_dp = dp sharding_filter zip_dp = dp zip sharded_dp assertRaisesRegex RuntimeError Sharding twice single pipeline torch utils data graph_settings apply_sharding zip_dp Raises Error when multiple sharding branch end numbers_dp = dp iter IterableWrapper range dp dp = numbers_dp fork sharded_dp = dp sharding_filter zip_dp = dp zip sharded_dp sharding_filter assertRaisesRegex RuntimeError Sharding twice single pipeline torch utils data graph_settings apply_sharding zip_dp Single sharding_filter data source numbers_dp = dp iter IterableWrapper range sharding_filter dp dp = numbers_dp fork zip_dp = dp zip dp torch utils data graph_settings apply_sharding zip_dp assertEqual list zip_dp i i i range + Single sharding_filter per branch numbers_dp = dp iter IterableWrapper range dp dp = numbers_dp fork sharded_dp = dp sharding_filter sharded_dp = dp sharding_filter zip_dp = sharded_dp zip sharded_dp torch utils data graph_settings apply_sharding zip_dp assertEqual list zip_dp i i i range + TestIterDataPipeSingletonConstraint TestCase r Each ` IterDataPipe ` can only have one active iterator Whenever new iterator created older iterators invalidated These tests aim ensure ` IterDataPipe ` follows behavior _check_single_iterator_invalidation_logic source_dp IterDataPipe r Given IterDataPipe verifies iterator can read reset creation second iterator invalidates first one = iter source_dp assertEqual list range list = iter source_dp assertEqual list range list A fresh iterator can read full again = iter source_dp assertEqual next = iter source_dp This should invalidate ` ` assertEqual next Should read beginning again assertRaisesRegex RuntimeError This iterator has been invalidated next test_iterdatapipe_singleton_generator r Testing case where IterDataPipe s ` __iter__ ` generator function Functional Test Check invalidation logic correct source_dp IterDataPipe = dp iter IterableWrapper range _check_single_iterator_invalidation_logic source_dp Functional Test extend test pipeline dps = source_dp map _fake_fn filter _fake_filter_fn _check_single_iterator_invalidation_logic dps Functional Test multiple simultaneous references same DataPipe fails assertRaisesRegex RuntimeError This iterator has been invalidated _ zip source_dp source_dp pass Function Test sequential references work _ zip list source_dp list source_dp pass test_iterdatapipe_singleton_self_next r Testing case where IterDataPipe s ` __iter__ ` returns ` ` there ` __next__ ` method Note following DataPipe singleton default because ` __iter__ ` returns ` ` _CustomIterDP_Self IterDataPipe __init__ iterable source = iterable iterable = iter iterable __iter__ reset __next__ next iterable reset iterable = iter source Functional Test Check every ` __iter__ ` call returns same object source_dp = _CustomIterDP_Self range res = list source_dp = iter source_dp assertEqual res list Functional Test Check invalidation logic correct source_dp = _CustomIterDP_Self range _check_single_iterator_invalidation_logic source_dp assertEqual next source_dp ` source_dp ` still valid can read Functional Test extend test pipeline source_dp = _CustomIterDP_Self dp iter IterableWrapper range map _fake_fn filter _fake_filter_fn _check_single_iterator_invalidation_logic source_dp assertEqual next source_dp ` source_dp ` still valid can read Functional Test multiple simultaneous references same DataPipe fails assertRaisesRegex RuntimeError This iterator has been invalidated _ zip source_dp source_dp pass test_iterdatapipe_singleton_new_object r Testing case where IterDataPipe s ` __iter__ ` isn t generator nor returns ` ` there isn t ` __next__ ` method _CustomIterDP IterDataPipe __init__ iterable iterable = iter iterable __iter__ Note doesn t reset iterable Intentionally returning ` ` Functional Test Check invalidation logic correct source_dp = _CustomIterDP range = iter source_dp assertEqual next = iter source_dp assertEqual next assertRaisesRegex RuntimeError This iterator has been invalidated next Functional Test extend test pipeline source_dp = _CustomIterDP dp iter IterableWrapper range map _fake_fn filter _fake_filter_fn = iter source_dp assertEqual next = iter source_dp assertEqual next assertRaisesRegex RuntimeError This iterator has been invalidated next Functional Test multiple simultaneous references same DataPipe fails assertRaisesRegex RuntimeError This iterator has been invalidated _ zip source_dp source_dp pass test_iterdatapipe_singleton_buggy r Buggy test case case where IterDataPipe s ` __iter__ ` returns new object also has ` __next__ ` method _CustomIterDP IterDataPipe __init__ iterable source = iterable iterable = iter iterable __iter__ iter source Intentionally returning ` ` __next__ next iterable Functional Test Check invalidation logic correct source_dp = _CustomIterDP range _check_single_iterator_invalidation_logic source_dp assertEqual next source_dp ` __next__ ` unrelated ` __iter__ ` Functional Test Special case show ` __next__ ` unrelated ` __iter__ ` source_dp = _CustomIterDP range assertEqual next source_dp = iter source_dp assertEqual next assertEqual next source_dp = iter source_dp invalidates both ` ` assertRaisesRegex RuntimeError This iterator has been invalidated next assertEqual next source_dp impacted creation ` ` assertEqual list range list ` ` still works because new object test_iterdatapipe_singleton_constraint_multiple_outputs r Testing case where IterDataPipe has multiple child DataPipes outputs Functional Test all previous related iterators should invalidated when new iterator created ChildDataPipe source_dp IterDataPipe = dp iter IterableWrapper range cdp cdp = source_dp fork num_instances= = iter cdp iter cdp assertEqual list range list assertEqual list range list = iter cdp iter cdp warnings catch_warnings record=True wa = iter cdp This should invalidate ` ` ` ` assertEqual len wa assertRegex str wa message r child DataPipes exhausted assertRaisesRegex RuntimeError This iterator has been invalidated next assertRaisesRegex RuntimeError This iterator has been invalidated next assertEqual next The next line should invalidate anything there no new iterator created ` cdp ` after ` ` invalidated = iter cdp assertEqual next An error shouldn t raised here assertEqual list range list Functional Test invalidation when new iterator created ` source_dp ` source_dp = dp iter IterableWrapper range cdp cdp = source_dp fork num_instances= = iter cdp iter cdp assertEqual list range list assertEqual list range list = iter cdp iter cdp assertEqual next assertEqual next = iter source_dp note new iterator created ` source_dp ` assertEqual next ` ` should invalidate ` ` ` ` since they both use ` source_dp ` assertRaisesRegex RuntimeError This iterator has been invalidated next assertEqual next Function Test Extending test pipeline source_dp = dp iter IterableWrapper range map _fake_fn filter _fake_filter_fn cdp cdp = source_dp fork num_instances= = iter cdp iter cdp assertEqual list range list assertEqual list range list = iter cdp iter cdp warnings catch_warnings record=True wa = iter cdp This should invalidate ` ` ` ` assertEqual len wa assertRegex str wa message r child DataPipes exhausted assertRaisesRegex RuntimeError This iterator has been invalidated next assertRaisesRegex RuntimeError This iterator has been invalidated next warnings catch_warnings record=True wa = iter cdp iter cdp assertEqual len wa assertRegex str wa message r child DataPipes exhausted assertEqual next assertEqual next = iter source_dp note new iterator created ` source_dp ` assertEqual next ` ` should invalidate ` ` ` ` since they both use ` source_dp ` assertRaisesRegex RuntimeError This iterator has been invalidated next assertEqual next TestIterDataPipeCountSampleYielded TestCase _yield_count_test_helper datapipe n_expected_samples Functional Test Check number samples yielded expected res = list datapipe assertEqual len res datapipe _number_of_samples_yielded Functional Test Check count correct when DataPipe partially read = iter datapipe res = i value enumerate res append value i == n_expected_samples - break assertEqual n_expected_samples datapipe _number_of_samples_yielded Functional Test Check reset behavior iterator also works = iter datapipe reset DataPipe res = list assertEqual len res datapipe _number_of_samples_yielded test_iterdatapipe_sample_yielded_generator_function Functional Test ` __iter__ ` generator function datapipe IterDataPipe = dp iter IterableWrapper range _yield_count_test_helper datapipe n_expected_samples= test_iterdatapipe_sample_yielded_generator_function_exception Functional Test ` __iter__ ` custom generator function exception _CustomGeneratorFnDataPipe IterDataPipe This s ` __iter__ ` has Runtime Error __iter__ yield yield yield raise RuntimeError Custom test error after yielding elements yield Functional Test Ensure count correct even when exception raised datapipe IterDataPipe = _CustomGeneratorFnDataPipe assertRaisesRegex RuntimeError Custom test error after yielding elements list datapipe assertEqual datapipe _number_of_samples_yielded Functional Test Check reset behavior iterator also works = iter datapipe reset DataPipe assertRaisesRegex RuntimeError Custom test error after yielding elements list assertEqual datapipe _number_of_samples_yielded test_iterdatapipe_sample_yielded_return_self _CustomGeneratorDataPipe IterDataPipe This s ` __iter__ ` generator function __init__ - None source = iter range __iter__ source reset source = iter range datapipe IterDataPipe = _CustomGeneratorDataPipe _yield_count_test_helper datapipe n_expected_samples= test_iterdatapipe_sample_yielded_next _CustomNextDataPipe IterDataPipe This s ` __iter__ ` returns ` ` has ` __next__ ` __init__ - None source = iter range __iter__ __next__ next source reset source = iter range datapipe IterDataPipe = _CustomNextDataPipe _yield_count_test_helper datapipe n_expected_samples= test_iterdatapipe_sample_yielded_next_exception _CustomNextDataPipe IterDataPipe This s ` __iter__ ` returns ` ` has ` __next__ ` __init__ - None source = iter range count = __iter__ __next__ count == raise RuntimeError Custom test error after yielding elements count += next source reset count = source = iter range Functional Test Ensure count correct even when exception raised datapipe IterDataPipe = _CustomNextDataPipe assertRaisesRegex RuntimeError Custom test error after yielding elements list datapipe assertEqual datapipe _number_of_samples_yielded Functional Test Check reset behavior iterator also works = iter datapipe reset DataPipe assertRaisesRegex RuntimeError Custom test error after yielding elements list assertEqual datapipe _number_of_samples_yielded _CustomNonGeneratorTestDataPipe IterDataPipe __init__ - None n = source = list range n This s ` __iter__ ` generator function __iter__ iter source __len__ n _CustomSelfNextTestDataPipe IterDataPipe __init__ - None n = iter = iter range n __iter__ __next__ next iter reset iter = iter range n __len__ n TestIterDataPipeGraphFastForward TestCase _fast_forward_graph_test_helper datapipe fast_forward_fn expected_res n_iterations= rng=None rng None rng = torch Generator rng = rng manual_seed torch utils data graph_settings apply_random_seed datapipe rng Test Case fast forward works list rng manual_seed fast_forward_fn datapipe n_iterations rng actual_res = list datapipe assertEqual len datapipe - n_iterations len actual_res assertEqual expected_res n_iterations actual_res Test Case fast forward works iterator rng manual_seed fast_forward_fn datapipe n_iterations rng = iter datapipe actual_res = list assertEqual len datapipe - n_iterations len actual_res assertEqual expected_res n_iterations actual_res assertRaises StopIteration next test_simple_snapshot_graph graph = dp iter IterableWrapper range res = list range _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=res graph = graph map _mul_ res = x x res _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=res rng = torch Generator graph = graph shuffle rng manual_seed torch utils data graph_settings apply_random_seed graph rng res = list graph _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=res graph = graph map _mul_ res = x x res _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=res batch_size = graph = graph batch batch_size res = res i i + batch_size i range len res batch_size batch _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=res With ` fork ` ` zip ` cdp cdp = graph fork graph = cdp zip cdp rng = rng manual_seed torch utils data graph_settings apply_random_seed graph rng res = x x x res _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=res With ` fork ` ` concat ` graph = cdp concat cdp res = res _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=res Raises exception graph has already been restored assertRaisesRegex RuntimeError Snapshot restoration cannot applied _simple_graph_snapshot_restoration graph _simple_graph_snapshot_restoration graph test_simple_snapshot_custom_non_generator graph = _CustomNonGeneratorTestDataPipe _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=range test_simple_snapshot_custom_self_next graph = _CustomSelfNextTestDataPipe _fast_forward_graph_test_helper graph _simple_graph_snapshot_restoration expected_res=range _snapshot_test_helper datapipe expected_res n_iter= rng=None Extend previous test serialization deserialization test rng None rng = torch Generator rng manual_seed torch utils data graph_settings apply_random_seed datapipe rng = iter datapipe _ range n_iter next serialized_graph = pickle dumps datapipe deserialized_graph = pickle loads serialized_graph assertEqual n_iter datapipe _number_of_samples_yielded assertEqual n_iter deserialized_graph _number_of_samples_yielded rng_for_deserialized = torch Generator rng_for_deserialized manual_seed _simple_graph_snapshot_restoration deserialized_graph n_iter rng=rng_for_deserialized assertEqual expected_res n_iter list assertEqual expected_res n_iter list deserialized_graph test_simple_snapshot_graph_with_serialization graph = dp iter IterableWrapper range res = list range _snapshot_test_helper graph expected_res=res graph = graph map _mul_ res = x x res _snapshot_test_helper graph expected_res=res rng = torch Generator graph = graph shuffle rng manual_seed torch utils data graph_settings apply_random_seed graph rng res = list graph _snapshot_test_helper graph expected_res=res graph = graph map _mul_ res = x x res _snapshot_test_helper graph expected_res=res batch_size = graph = graph batch batch_size res = res i i + batch_size i range len res batch_size batch _snapshot_test_helper graph expected_res=res With ` fork ` ` zip ` cdp cdp = graph fork graph = cdp zip cdp res = x x x res _snapshot_test_helper graph expected_res=res With ` fork ` ` concat ` graph = cdp concat cdp res = res _snapshot_test_helper graph expected_res=res test_simple_snapshot_graph_repeated cdp cdp = dp iter IterableWrapper range map _mul_ shuffle map _mul_ map _mul_ fork graph = cdp zip cdp rng = torch Generator rng manual_seed torch utils data graph_settings apply_random_seed graph rng Get expected result expected_res = list graph rng manual_seed torch utils data graph_settings apply_random_seed graph rng = iter graph n_iter = _ range n_iter next First serialization deserialization serialized_graph = pickle dumps graph deserialized_graph = pickle loads serialized_graph rng_for_deserialized = torch Generator rng_for_deserialized manual_seed _simple_graph_snapshot_restoration deserialized_graph deserialized_graph _number_of_samples_yielded rng=rng_for_deserialized = iter deserialized_graph Get next element ensure expected assertEqual expected_res next Serializalize Deserialize fast-forward again after ensure works serialized_graph = pickle dumps deserialized_graph deserialized_graph = pickle loads serialized_graph rng_for_deserialized = torch Generator rng_for_deserialized manual_seed _simple_graph_snapshot_restoration deserialized_graph deserialized_graph _number_of_samples_yielded rng=rng_for_deserialized Get next element ensure expected assertEqual expected_res list deserialized_graph __name__ == __main__ run_tests