mypy allow-untyped-defs This file exports ONNX ops opset Note ONNX Operators added updated opset ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ https github com onnx onnx blob main docs Changelog md#version- -of-the-default-onnx-operator-set New operators GridSample https github com onnx onnx pull Updated operators Identity If LeakyRelu Loop PRelu RoiAlign Scan ScatterElements ScatterND Where GreaterOrEqual LessOrEqual EDITING THIS FILE READ THIS FIRST see Note Edit Symbolic Files README md functools torch torch nn functional GRID_SAMPLE_INTERPOLATION_MODES GRID_SAMPLE_PADDING_MODES torch onnx errors torch onnx _internal torchscript_exporter _type_utils jit_utils registration symbolic_helper utils _onnx_symbolic = functools partial registration onnx_symbolic opset= note mkozuki Why ` grid_sampler ` instead ` grid_sample ` Because ` torch nn functional grid_sample ` calls ` torch grid_sampler ` _onnx_symbolic aten grid_sampler symbolic_helper parse_args v v i i b grid_sampler g jit_utils GraphContext input grid mode_enum padding_mode_enum align_corners Check input grid tensor rank beforehand symbolic_helper _get_tensor_rank input == symbolic_helper _onnx_unsupported GridSample D volumetric input mode_s = v k k v GRID_SAMPLE_INTERPOLATION_MODES items mode_enum type ignore call-arg padding_mode_s = v k k v GRID_SAMPLE_PADDING_MODES items type ignore call-arg padding_mode_enum g op GridSample input grid align_corners_i=int align_corners mode_s=mode_s padding_mode_s=padding_mode_s _onnx_symbolic aten scatter_add symbolic_helper parse_args v i v v scatter_add g jit_utils GraphContext dim index src src_type = _type_utils JitScalarType from_value src _type_utils JitScalarType UNDEFINED src_sizes = symbolic_helper _get_tensor_sizes src index_sizes = symbolic_helper _get_tensor_sizes index len src_sizes = len index_sizes symbolic_helper _unimplemented scatter_add f ` index ` index_sizes should have same dimensionality ` src ` src_sizes PyTorch only allows index shape = src shape so we can only consider taking index subset size src like PyTorch does When sizes src index matched there dynamic axes we take index shape slice src accommodate src_sizes = index_sizes None index_sizes adjusted_shape = g op Shape index starts = g op Constant value_t=torch tensor len index_sizes src = g op Slice src starts adjusted_shape src = symbolic_helper _maybe_get_scalar src symbolic_helper _is_value src g op ScatterElements index src axis_i=dim reduction_s= add Check scalar src has same type PyTorch allows different type scalar src when src tensor If insert Cast node _type_utils JitScalarType from_value = src_type src = g op Cast src to_i=_type_utils JitScalarType from_value onnx_type g op ScatterElements index src axis_i=dim reduction_s= add _onnx_symbolic aten scatter_reduce symbolic_helper parse_args v i v v s b scatter_reduce g jit_utils GraphContext torch _C Value dim int index torch _C Value src torch _C Value reduce str include_self bool reduce == mean raise errors OnnxExporterError ONNX does support mean reduction scatter_reduce include_self raise errors OnnxExporterError ONNX does support include_self=False scatter_reduce reduce_mode = convert torch string name onnx string name mean none mean doesn t support ONNX definition sum add prod mul amin min amax max onnx_reduce = reduce_mode reduce self_rank = g op Size g op Shape self_rank == assert index_rank == rank_src == self_rank_is_zero = g op Equal self_rank g op Constant value_t=torch tensor dtype=torch int if_op if_context else_context _ = jit_utils add_op_with_blocks g If self_rank_is_zero n_blocks= outputs= neg_ = if_context op Constant value_t=torch tensor - dtype=torch int self_reshape = if_context op Reshape neg_ utils _add_output_to_block if_context block self_reshape index_reshape = if_context op Reshape index neg_ utils _add_output_to_block if_context block index_reshape src_reshape = if_context op Reshape src neg_ utils _add_output_to_block if_context block src_reshape self_identity = else_context op Identity utils _add_output_to_block else_context block self_identity index_identitye = else_context op Identity index utils _add_output_to_block else_context block index_identitye src_identity = else_context op Identity src utils _add_output_to_block else_context block src_identity result = g op ScatterElements if_op axis_i=dim reduction_s=onnx_reduce self_rank == if_op if_context else_context _ = jit_utils add_op_with_blocks g If self_rank_is_zero n_blocks= outputs= result_squeezed = if_context op Squeeze result utils _add_output_to_block if_context block result_squeezed result_identity = else_context op Identity result utils _add_output_to_block else_context block result_identity result_final = if_op node output result_final