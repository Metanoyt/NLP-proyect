mypy allow-untyped-defs __future__ annotations contextlib copy operator typing TYPE_CHECKING torch utils node_replace_ nodes_map TYPE_CHECKING collections abc Callable torch _ops HigherOrderOperator torch export graph_signature ExportGraphSignature _replace_with_hop_helper node torch fx Node enter_block_node torch fx Node wrap_hoo HigherOrderOperator - None graph torch fx Graph = node graph assert graph owning_module None gm torch fx GraphModule = graph owning_module assert isinstance node target str sub_gm = getattr gm node target set_hoo_node_meta call_func_node call_func_node meta nn_module_stack = copy copy enter_block_node meta get nn_module_stack call_func_node meta torch_fn = f wrap_hoo __name__ pyrefly ignore missing-attribute f wrap_hoo __class__ __name__ wrap_hoo __name__ isinstance output_args tuple list call_func_node meta val = tuple arg meta val arg output_args isinstance output_args torch fx Node call_func_node meta val = output_args meta val graph inserting_before node get_attr_node = graph get_attr node target get_attr_node meta nn_module_stack = copy copy enter_block_node meta get nn_module_stack output_node = next iter reversed sub_gm graph nodes None Split_module pass intentionally doesn t add output node graph doesn t anything TODO tmanlaibaatar Figure out right behaviour split_module isinstance output_node torch fx Node output_node op = output output_node = None output_node None assert len output_node args == output_args = output_node args enter_block_node_args = enter_block_node args isinstance output_args tuple list call_func_node = graph call_function wrap_hoo enter_block_node_args get_attr_node node args Create metadata set_hoo_node_meta call_func_node node_replace_ node call_func_node Rename name getitem nodes actual name its contents passing verifier better readability also propagate metadata get_item_node call_func_node users keys idx int = get_item_node args type ignore assignment output_node = output_args idx get_item_node _rename output_node name get_item_node meta = output_node meta isinstance output_args torch fx Node call_func_node = graph create_node call_function wrap_hoo enter_block_node_args get_attr_node node args output_args name Modify subgraph output singleton list output_node args = output_args Add extra ` getitem wrap_hoo ` node toplevel graph get_item_node = graph create_node call_function operator getitem call_func_node Create metadata get_item_node meta = output_args meta set_hoo_node_meta call_func_node node_replace_ node get_item_node raise NotImplementedError f replace_with_hop_pass doesn t support output type type output_args TODO shangdiy remove line since export graph can non-functional node graph erase_node node _sequential_split_and_maybe_inline_subgraphs_helper new_gm torch fx GraphModule graph_signature ExportGraphSignature &#124; None maybe_inline_or_replace_with_hop Callable torch fx Node None - tuple torch fx GraphModule ExportGraphSignature &#124; None Helper function replacing graph nodse higher order nodes For each subgraph ` new_gm ` decides whether construct HOO subgraph inline calls back into parent graph module depending ` maybe_inline_or_replace_with_hop ` new_gm new graph module could have different output args names We need fix graph signature replace_ctx = contextlib nullcontext new_signature = None graph_signature None Cannot deep copy real ScriptObject which referenced FakeScriptObject Copy should good enough guard against accidental mutation original graph_signature new_signature = copy copy graph_signature new_gm_out_node = next reversed new_gm graph find_nodes op= output assert new_gm_out_node op == output len new_gm_out_node args == len new_signature output_specs arg_node out_spec zip new_gm_out_node args new_signature output_specs arg_node None assert out_spec arg value None type ignore union-attr isinstance arg_node torch fx Node out_spec arg name = arg_node name out_spec arg name = arg_node name replace_ctx = new_gm _set_replace_hook new_signature get_replace_hook type ignore assignment replace_ctx nodes_map list new_gm graph nodes lambda node maybe_inline_or_replace_with_hop node node op == call_module node new_gm recompile new_gm graph lint new_gm new_signature _replace_with_hop_pass_helper gm torch fx GraphModule graph_signature ExportGraphSignature &#124; None sequential_split_and_maybe_inline_subgraphs Callable torch fx GraphModule ExportGraphSignature &#124; None tuple torch fx GraphModule ExportGraphSignature &#124; None - tuple torch fx GraphModule ExportGraphSignature &#124; None Split gm into sub-graph-modules using ` sequential_split_and_maybe_inline_subgraphs ` then recursively call itself each submodules new_gm new_signature = sequential_split_and_maybe_inline_subgraphs gm graph_signature recursively call node new_gm graph nodes node op == get_attr subgm = getattr new_gm node target isinstance subgm torch fx GraphModule continue new_subgm _ = _replace_with_hop_pass_helper subgm None sequential_split_and_maybe_inline_subgraphs setattr new_gm node target new_subgm new_gm recompile new_gm graph lint new_gm new_signature