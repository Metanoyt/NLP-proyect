mypy allow-untyped-defs copy dataclasses dataclass field typing Optional Union torch fx torch fx _compatibility compatibility torch fx graph map_arg torch fx passes utils HolderModule lift_subgraph_as_module tools_common NodeList __all__ = getattr_recursive setattr_recursive Component split_by_tags compatibility is_backward_compatible=False getattr_recursive obj name layer name split isinstance obj torch nn ModuleList hasattr obj _modules layer obj _modules obj = obj _modules layer None hasattr obj layer obj = getattr obj layer None obj compatibility is_backward_compatible=False setattr_recursive obj attr value attr setattr obj attr value layer = attr split setattr_recursive getattr obj layer join layer value compatibility is_backward_compatible=False dataclass Component A component serves container subgraph we want create afterwards graph torch fx Graph order int name str Stores placeholder nodes ` graph ` input_placeholders list = field default_factory=list Store nodes original graph placeholder ` graph ` orig_inputs list = field default_factory=list Store nodes original graph outputs ` graph ` orig_outputs list = field default_factory=list Mapping get_attr node original graph get_attr node ` graph ` getattr_maps dict torch fx Node torch fx Node = field default_factory=dict constructor_args list str = field default_factory=list gm Optional torch fx GraphModule = None compatibility is_backward_compatible=False split_by_tags gm torch fx GraphModule tags list str return_fqn_mapping bool = False return_tuple bool = False GraphModuleCls type torch fx GraphModule = torch fx GraphModule - Union torch fx GraphModule tuple torch fx GraphModule dict str str Splits GraphModule using tags its graph nodes We honor order tags For example we have tags = b c function will create initial submodules order b c To set tag gm graph nodes idx tag = mytag This will result all nodes same tag being extracted placed their own submodule For placeholder output get_attr node tag ignored placeholder output nodes created when needed while get_attr nodes get copied submodules where they used Given following module SimpleModule torch nn Module __init__ - None super __init__ linear = torch nn Linear linear = torch nn Linear linear = torch nn Linear forward r = linear r = linear r = torch cat r r linear r Marking node corresponding tag sc REQUEST_ONLY lower results following split ro forward = root linear = linear linear main forward linear = root linear = linear cat_ = torch cat linear linear linear = linear cat_ linear main forward = root ro_ = ro_ main_ = main_ ro_ main_ Returns split_gm torch fx graph after split orig_to_split_fqn_mapping map between original fqn fqn after split call_module get_attr flatten x torch fx node Argument - NodeList Stores nodes x list returns list r NodeList = map_arg x r append r Mapping node original module node created submodule node_remapping dict torch fx Node torch fx Node = Mapping node original module created submodules corresponding component node_to_component dict torch fx Node Component = Mapping tag corresponding component tag_to_component dict str Component = Stores all components all_components list Component = Stores nodes will used main graph used_in_main dict torch fx Node None = Main graph after split main_g = torch fx Graph Mapping node original module node main graph after split main_remapping dict torch fx Node torch fx Node = Output node original module output_node Optional torch fx Node = None Create component each tag we don t expect create other components afterwards tag tags comp = Component torch fx Graph len all_components f tag all_components append comp tag_to_component tag = comp Traverse nodes original graph take care them node gm graph nodes node op == output output_node None raise RuntimeError Multiple output nodes graph output_node = node continue Placeholders original graph get copied main graph node op == placeholder main_remapping node = main_g placeholder node name type_expr=node type main_remapping node meta = copy copy node meta continue Get_attr nodes ignored because we tagging them Instead we copy them directly submodules use them afterwards node op == get_attr continue Now we process callable nodes which nodes op call_module call_function call_method Every callable nodes should tagged assert hasattr node tag f Node does have tag node format_node upstream_components = node_to_component x x flatten node args + flatten node kwargs x op placeholder get_attr comp = tag_to_component node tag node_to_component node = comp Max order upperstream components mx = max c order c upstream_components default= Expect component ` node ` has higher order then its upstream components assert comp order = mx f Component comp name order must = max its upstream components order= comp order max= mx Map input ` node ` nodes component s graph remap_func x If input get_attr node copy current component s graph Returns get_attr node current component s graph x op == get_attr x comp getattr_maps comp getattr_maps x = comp graph get_attr x target type_expr=x type comp getattr_maps x meta = copy copy x meta comp getattr_maps x If input placeholder should have been put into component already If s current component then we corresponding node component x op = placeholder node_to_component x == comp node_remapping x If input placeholder s other components we want make placeholder current component s graph x comp orig_inputs comp orig_inputs append x placeholder = comp graph placeholder x name type_expr=x type placeholder meta = copy copy x meta comp input_placeholders append placeholder used_in_main x = None comp input_placeholders comp orig_inputs index x n = comp graph node_copy node remap_func n tag = node tag type ignore attr-defined node_remapping node = n node_to_component n = comp output_node None raise RuntimeError Graph had no output node x flatten output_node args x op == get_attr We don t need components mapping nodes type get_attr consumed output Only need make sure we create corresponding counterparts resulting graph main_remapping x = main_g get_attr x name type_expr=x type All component results consumed output node should marked used main used_in_main x = None If node used main graph then we mark output component belongs n used_in_main n op = placeholder node_to_component n orig_outputs append n Now we create graphmodule each component orig_to_split_fqn_mapping dict str str = comp all_components outs = tuple map node_remapping __getitem__ comp orig_outputs return_tuple comp graph output outs Take care args FX output node If there s single output then output node args like output_single there re multiple outputs then output node args like output_ output_ comp graph output outs len outs == outs comp gm comp_orig_to_split_fqn_mapping = lift_subgraph_as_module gm subgraph=comp graph comp_name=comp name orig_to_split_fqn_mapping update comp_orig_to_split_fqn_mapping Create call_module node main graph main_node = main_g call_module comp name args=tuple map main_remapping __getitem__ comp orig_inputs kwargs=None len outs == return_tuple main_remapping comp orig_outputs = main_node i o enumerate comp orig_outputs Use Proxy record getitem access main_remapping o = torch fx Proxy main_node i node type ignore index main_g output map_arg output_node args main_remapping __getitem__ main_root = HolderModule comp name comp gm comp all_components main_g _codegen = gm graph _codegen If output nodes consumes get_attr directly original graph then we need make sure get_attr copied new graph x flatten output_node args x op == get_attr setattr main_root x name getattr_recursive gm x target type ignore arg-type result_gm = GraphModuleCls main_root main_g return_fqn_mapping result_gm orig_to_split_fqn_mapping result_gm