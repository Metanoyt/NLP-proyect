Owner s oncall jit os sys typing List torch torch testing FileCheck Make helper files test importable pytorch_test_dir = os path dirname os path dirname os path realpath __file__ sys path append pytorch_test_dir torch testing _internal common_utils raise_on_run_directly torch testing _internal jit_utils freeze_rng_state JitTestCase TestRemoveMutation JitTestCase test_aten_inplace test_not_new_alias x y = x y add_ y fn = torch jit script test_not_new_alias graph = fn graph run_pass remove_mutation graph FileCheck check aten add_ run graph assertEqual fn torch ones test_not_new_alias torch ones test_no_lowering x = torch tensor x = x there no functional equivalent x = fn = torch jit script test_no_lowering graph = fn graph run_pass remove_mutation graph FileCheck check aten copy_ run graph assertEqual fn test_no_lowering test_move_before_not_valid y = torch tensor z = y + y add_ y z fn = torch jit script test_move_before_not_valid graph = fn graph run_pass remove_mutation graph FileCheck check aten add_ run graph assertEqual fn test_move_before_not_valid test_successful x = torch tensor x add_ x add_ y = x + x y fn = torch jit script test_successful graph = fn graph run_pass remove_mutation graph FileCheck check_not aten add_ run graph assertEqual test_successful fn test_intermediary_use x = torch tensor x add_ y = x + x add_ x y fn = torch jit script test_intermediary_use graph = fn graph FileCheck check_count aten add_ run graph run_pass remove_mutation graph Unable remove second add_ because y = x + use In future we could duplicating value x temporary replacing its intermediary use so long aliasing safe FileCheck check_count aten add_ run graph assertEqual test_intermediary_use fn test_if_output foo x cond bool cond y = x + y = x + y add_ y out_eager = foo torch tensor True foo_script = torch jit script foo FileCheck check aten add_ run foo_script graph run_pass remove_mutation foo_script graph FileCheck check_not aten add_ run foo_script graph assertEqual out_eager foo_script torch tensor True test_if_output_fail torch jit script foo cond bool li = cond x = torch tensor li append x x = torch tensor y = x add_ y li run_pass inline foo graph run_pass remove_mutation foo graph FileCheck check aten add_ run foo graph torch jit script foo cond bool y cond x = y x = torch tensor z = x add_ z run_pass inline foo graph run_pass remove_mutation foo graph FileCheck check aten add_ run foo graph test_special_mapped_op test_successful x = torch tensor y = torch tensor x zero_ y fill_ x y fn = torch jit script test_successful graph = fn graph run_pass remove_mutation graph FileCheck check_not aten zero_ check_not aten fill_ run graph assertEqual test_successful fn full_like implemented tensor fill value test_successful x = torch tensor y = torch tensor x fill_ y x + x fn = torch jit script test_successful graph = fn graph run_pass remove_mutation graph FileCheck check_not aten fill_ run graph normal NOTE For some unknown reason ` torch _C _jit_pass_remove_mutation ` call within ` run_pass ` replaces ` torch randn dtype=None normal_ ` ` aten normal ` call dtype double even default dtype float So we must explicitly set dtype here torch rand dtype=torch float normal_ fn = torch jit script normal graph = fn graph run_pass remove_mutation graph FileCheck check_not normal_ run graph freeze_rng_state out_eager = normal freeze_rng_state out_script = fn assertEqual out_eager out_script test_lists_append successful_remove i i range noqa C fn = torch jit script successful_remove graph = fn graph run_pass loop_unrolling graph run_pass remove_mutation graph run_pass constant_propagation graph FileCheck check graph check_next Constant check_next run graph assertEqual successful_remove successful_remove intermediary_use = b = len noqa F append fn = torch jit script intermediary_use graph = fn graph FileCheck check append run graph run_pass remove_mutation graph possible remove append here don t currently have logic FileCheck check_not append run graph assertEqual intermediary_use fn test_lists_insert successful_remove List int = insert insert insert - insert - insert fn = torch jit script successful_remove graph = fn graph torch _C _jit_pass_remove_mutation graph torch _C _jit_pass_constant_propagation graph FileCheck check graph check_next Constant check_next run graph assertEqual successful_remove fn test_list_indexing_removal torch jit script out_of_bounds x = x = x torch _C _jit_pass_remove_mutation out_of_bounds graph FileCheck check set_item run out_of_bounds graph torch jit script unknown y int x = x y = x torch _C _jit_pass_remove_mutation out_of_bounds graph FileCheck check set_item run out_of_bounds graph successful x = x = x - = x scripted_fn = torch jit script successful torch _C _jit_pass_remove_mutation scripted_fn graph FileCheck check_not set_item run scripted_fn graph checkScript successful successful x = x = x - = x scripted_fn = torch jit script successful torch _C _jit_pass_remove_mutation scripted_fn graph FileCheck check_not set_item run scripted_fn graph checkScript successful successful x = x - = x scripted_fn = torch jit script successful torch _C _jit_pass_remove_mutation scripted_fn graph FileCheck check_not set_item run scripted_fn graph checkScript successful test_common_pytorch_list_ops op cat stack vstack hstack dstack OpMod torch nn Module __init__ op super __init__ op = torch_op forward x = torch tensor x add_ y = x x op y + torch_op = getattr torch op mod = OpMod torch_op mod_script = torch jit script mod run_pass remove_mutation mod_script forward graph FileCheck check_not aten add_ run mod_script forward graph assertEqual mod mod_script test output doesnt alias input inputs torch rand torch rand _ range result = torch_op inputs sums = ten sum ten result inp inputs inp fill_ assertEqual sums ten sum ten result torch jit script test_multiple_uses x = torch tensor x add_ y = x x torch cat y y run_pass remove_mutation mod_script forward graph FileCheck check aten add_ run test_multiple_uses graph __name__ == __main__ raise_on_run_directly test test_jit py