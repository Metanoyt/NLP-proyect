mypy ignore-errors Variable tracking implementations list-like data structures Dynamo This module provides specialized variable tracking various collection types - Lists list subclasses including torch nn ModuleList ParameterList - Tuples named tuples - Ranges slices - Collections deque - torch Size special proxy handling The implementations support both mutable immutable collections iteration common sequence operations Each collection type has dedicated Variable handles its unique behaviors while integrating Dynamo s variable tracking system collections inspect operator sys typing Optional TYPE_CHECKING torch torch fx graph_break_hints polyfills variables bytecode_transformation create_build_tuple create_call_function create_instruction create_rot_n exc raise_observed_exception unimplemented_v source AttrSource NamedTupleFieldsSource utils cmp_name_to_op_mapping cmp_name_to_op_str_mapping get_fake_value guard_if_dyn iter_contains Lit namedtuple_fields odict_values raise_args_mismatch range_iterator set_example_value base ValueMutationNew VariableTracker constant ConstantVariable functions UserFunctionVariable UserMethodVariable iter IteratorVariable TYPE_CHECKING torch _dynamo codegen PyCodegen torch _dynamo symbolic_convert InstructionTranslator BaseListVariable VariableTracker staticmethod cls_for_instance obj BaseListVariable cls_for type obj staticmethod cls_for obj iter ListIteratorVariable list ListVariable slice SliceVariable torch Size SizeVariable tuple TupleVariable odict_values ListVariable torch nn ParameterList ListVariable torch nn ModuleList ListVariable collections deque DequeVariable obj __init__ items list VariableTracker kwargs - None super __init__ kwargs assert isinstance items list assert all isinstance x VariableTracker x items items list VariableTracker = items _as_proxy x as_proxy x items modified items kwargs type items kwargs property value as_python_constant debug_repr_helper prefix suffix prefix + join i debug_repr i items + suffix as_python_constant python_type x as_python_constant x items as_proxy assert python_type SizeVariable python_type _as_proxy getitem_const tx InstructionTranslator arg VariableTracker tensor SymNodeVariable isinstance arg SymNodeVariable index = arg sym_num index = arg as_python_constant isinstance index slice index step == msg = ConstantVariable create slice step cannot zero raise_observed_exception ValueError tx args= msg Set source None because slicing list gives new local clone items=self items index source=None mutation_type=ValueMutationNew mutation_type None assert isinstance index int torch SymInt try items index except IndexError raise_observed_exception IndexError tx args= list index out range unpack_var_sequence tx list items call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __getitem__ tensor TensorVariable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs isinstance args TensorVariable value = get_fake_value args as_proxy node tx value constant None value constant numel == value = variables ConstantVariable create value constant item unimplemented_v gb_type= Indexing list non-scalar tensor context=f call_method name args kwargs explanation= Attempted index list-like object tensor element hints= graph_break_hints USER_ERROR value = args value python_type int slice msg = f indices must integers slices value python_type raise_observed_exception TypeError tx args= ConstantVariable msg getitem_const tx value name == __contains__ kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs iter_contains unpack_var_sequence tx args tx name == index len args raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs tx inline_user_function_return VariableTracker build tx polyfills index + list args kwargs name == count len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs VariableTracker build tx operator countOf call_function tx args kwargs name __add__ __iadd__ kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs type type args tp_name = python_type_name other = args python_type_name msg = ConstantVariable create f can only concatenate tp_name other tp_name raise_observed_exception TypeError tx args= msg name == __add__ type items + args items source=self source items += args items name __mul__ __imul__ kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs args is_python_constant args python_type int msg = ConstantVariable create f can t multiply sequence non-int type args python_type_name raise_observed_exception TypeError tx args= msg val = args as_python_constant name == __mul__ type items val source=self source items = val name cmp_name_to_op_mapping len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs left = right = args TODO type check logic mirrors following https github com python cpython blob c d c bcf d edf e ad f b f Objects object c#L -L But we should probably move up stack so we don t need duplicate different VTs isinstance left BaseListVariable isinstance right BaseListVariable name == __eq__ variables BuiltinVariable operator is_ call_function tx left right name == __ne__ variables BuiltinVariable operator is_not call_function tx left right op_str = cmp_name_to_op_str_mapping name left_ty = left python_type_name right_ty = right python_type_name msg = f op_str supported between instances left_ty right_ty raise_observed_exception TypeError tx args= msg variables UserFunctionVariable polyfills list_cmp call_function tx variables BuiltinVariable cmp_name_to_op_mapping name left right name == __iter__ ListIteratorVariable items mutation_type=ValueMutationNew super call_method tx name args kwargs RangeVariable BaseListVariable __init__ items kwargs - None items_to_map = items start = variables ConstantVariable create stop = None step = variables ConstantVariable create len items_to_map == stop = items_to_map len items_to_map == start stop = items_to_map len items_to_map == start stop step = items_to_map raise AssertionError maybe_as_int x ConstantVariable int x value isinstance x ConstantVariable x cast each argument integer start = maybe_as_int start step = maybe_as_int step stop = maybe_as_int stop assert stop None super __init__ start stop step kwargs debug_repr debug_repr_helper range python_type range start items as_python_constant stop items as_python_constant step items as_python_constant range_length lo = start hi = stop step = step assert step = step lo hi + hi - - lo step step lo hi + lo - - hi - step _get_slice_indices length slice step_is_negative = slice step None step = step_is_negative = False step = slice step step_is_negative = slice step Find lower upper bounds start stop step_is_negative lower = - upper = length + lower lower = upper = length Compute start slice start None start = upper step_is_negative lower start = slice start start start += length start lower start = lower start upper start = upper Compute stop slice stop None stop = lower step_is_negative upper stop = slice stop stop stop += length stop lower stop = lower stop upper stop = upper start stop step apply_index index length = range_length index index = length + index index index = length tx = torch _dynamo symbolic_convert InstructionTranslator current_tx raise_observed_exception IndexError tx args= ConstantVariable range object index out range variables ConstantVariable create start + index step apply_slice slice slice_start slice_stop slice_step = _get_slice_indices range_length slice compute_item index start + index step sub_step = step slice_step sub_start = compute_item slice_start sub_stop = compute_item slice_stop result = RangeVariable variables ConstantVariable create x x sub_start sub_stop sub_step mutation_type=ValueMutationNew mutation_type None result as_python_constant range x as_python_constant x items getitem_const tx InstructionTranslator arg VariableTracker implementations mimics https github com python cpython blob main Objects rangeobject c index = arg as_python_constant isinstance index slice apply_slice index isinstance index int apply_index index msg = ConstantVariable range indices must integers slices raise_observed_exception TypeError tx args= msg as_proxy python_type _as_proxy unpack_var_sequence tx=None variables ConstantVariable create x x as_python_constant reconstruct codegen PyCodegen - None assert range codegen tx f_globals codegen add_push_null lambda codegen append_output codegen create_load_python_module range codegen foreach items codegen extend_output create_call_function False call_obj_hasattr tx InstructionTranslator name str - VariableTracker python_type range variables ConstantVariable create name range __dict__ super call_obj_hasattr tx name range_equals other RangeVariable r r = other range_length = r range_length range_length == r start = r start False len r == True r step == r step range_count x VariableTracker Based CPython https github com guilhermeleobas cpython blob baefaa cba d efd f cdc bca c b Objects rangeobject c#L -L x = x as_python_constant type x bool int float start stop step = start stop step step == in_range = start = x stop step stop x = start in_range re = x - start step == int re call_method tx name args kwargs name == __iter__ all var is_python_constant var items Can t represent ` range_iterator ` without well defined bounds variables misc DelayGraphBreakVariable msg= Cannot create range_iterator bounds start stop step must fully defined concrete constants RangeIteratorVariable start stop step range_length name == __len__ length = range_length length sys maxsize raise_observed_exception OverflowError tx ConstantVariable create range_length name count __contains__ ConstantVariable range_count args name == __getitem__ getitem_const tx args name cmp_name_to_op_mapping other = args pt = other python_type name __eq__ __ne__ ranges only comparable other ranges msg = f name supported between instances range pt raise_observed_exception TypeError tx args= ConstantVariable create msg pt range ConstantVariable create NotImplemented cmp = range_equals other Two ranges equal they produce same sequence values name == __eq__ ConstantVariable cmp ConstantVariable cmp super call_method tx name args kwargs var_getattr tx InstructionTranslator name fields = start stop step name fields items fields index name super var_getattr tx name CommonListMethodsVariable BaseListVariable Implement methods common List other List-like things call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker tensor SymNodeVariable name == append is_mutable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs arg = args tx output side_effects mutation items append arg ConstantVariable create None name == extend is_mutable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs args has_force_unpack_var_sequence tx msg = ConstantVariable create f type args object iterable raise_observed_exception TypeError tx args= msg arg = args arg force_apply_to_var_sequence tx lambda item call_method tx append item ConstantVariable create None name == insert is_mutable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs idx value = args isinstance idx SymNodeVariable const_idx = idx evaluate_expr const_idx = idx as_python_constant tx output side_effects mutation items insert const_idx value ConstantVariable create None name == pop is_mutable kwargs len args raise_args_mismatch tx name most args kwargs f len args args len kwargs kwargs len items == msg = ConstantVariable create pop empty list raise_observed_exception IndexError tx args= msg len args idx = args as_python_constant idx len items msg = ConstantVariable create pop index out range raise_observed_exception IndexError tx args= msg tx output side_effects mutation items pop as_python_constant args name == clear is_mutable args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs tx output side_effects mutation items clear ConstantVariable create None name == __setitem__ is_mutable args args is_python_constant isinstance args SymNodeVariable isinstance args SliceVariable all s is_python_constant isinstance s SymNodeVariable s args items kwargs raise_args_mismatch tx name kwargs f len kwargs kwargs key value = args tx output side_effects mutation isinstance key SymNodeVariable items key evaluate_expr = value isinstance key SliceVariable key is_python_constant items key as_python_constant = list value items items = slice s evaluate_expr isinstance s SymNodeVariable s as_python_constant s key items items items = list value items items key as_python_constant = value ConstantVariable create None name == __delitem__ is_mutable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs tx output side_effects mutation args is_python_constant isinstance args as_python_constant int slice isinstance args SymNodeVariable idx = args evaluate_expr idx = args as_python_constant try items __delitem__ idx except IndexError ValueError exc raise_observed_exception type exc tx args=list map ConstantVariable create exc args msg = ConstantVariable create f list indices must integers slices args python_type_name raise_observed_exception TypeError tx args= msg ConstantVariable create None name == copy List copy doesn t have args kwargs args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs items = list items modified items mutation_type=ValueMutationNew name == reverse is_mutable args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs items reverse tx output side_effects mutation ConstantVariable create None name == remove is_mutable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs idx = call_method tx index args kwargs call_method tx pop idx ConstantVariable create None super call_method tx name args kwargs ListVariable CommonListMethodsVariable python_type list __repr__ - str f __class__ __name__ length= len items debug_repr debug_repr_helper reconstruct codegen PyCodegen - None codegen foreach items codegen append_output create_instruction BUILD_LIST arg=len items call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker tensor SymNodeVariable name == __setitem__ is_mutable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs key value = args key is_python_constant probably will graph-break super call_method tx name args kwargs tx output side_effects mutation isinstance key SliceVariable value has_force_unpack_var_sequence tx msg = ConstantVariable create can only assign iterable raise_observed_exception TypeError tx args= msg key = key as_python_constant key step == msg = ConstantVariable create slice step cannot zero raise_observed_exception ValueError tx args= msg value = value force_unpack_var_sequence tx try items key = value except Exception exc raise_observed_exception type exc tx args=list map ConstantVariable create exc args isinstance key SymNodeVariable key = key evaluate_expr key = key as_python_constant try items key = value except IndexError TypeError e raise_observed_exception type e tx args=list map ConstantVariable create e args ConstantVariable create None name == sort is_mutable len args = raise_args_mismatch tx name args f len args args key_fn_var = kwargs pop key ConstantVariable create None reverse = kwargs pop reverse ConstantVariable create False as_python_constant len kwargs = raise_args_mismatch tx name kwargs f len kwargs kwargs key_fn_var is_python_constant key_fn_var as_python_constant None keys = items copy keys = key_fn_var call_function tx x x items all k is_python_constant k keys first_non_constant_key = None k keys k is_python_constant first_non_constant_key = k assert first_non_constant_key None try python_type = first_non_constant_key python_type except NotImplementedError python_type = unknown unimplemented_v gb_type= sort non-constant keys context=str first_non_constant_key explanation= f Cannot perform sort non-constant key f First non-constant key type python_type f Most notably we cannot sort Tensor SymInt keys we can f sort ints hints= Use something key tx output side_effects mutation sorted_items_with_keys = sorted x k as_python_constant -i reverse i extra key ensure stable sort i k x enumerate zip keys items key=operator itemgetter reverse=reverse items = x x _ sorted_items_with_keys ConstantVariable create None name == __init__ is_mutable kwargs raise_args_mismatch tx name kwargs f len kwargs kwargs len args == ConstantVariable create None len args == args has_force_unpack_var_sequence tx arg = args tx output side_effects mutation items = arg force_unpack_var_sequence tx ConstantVariable create None super call_method tx name args kwargs var_getattr tx name name == __class__ source = AttrSource source name source None class_type = python_type class_type list variables BuiltinVariable class_type source=source variables UserDefinedClassVariable class_type source=source super var_getattr tx name call_obj_hasattr tx InstructionTranslator name str - VariableTracker python_type list super call_obj_hasattr tx name variables ConstantVariable create hasattr name DequeVariable CommonListMethodsVariable __init__ items maxlen=None kwargs - None maxlen None maxlen = ConstantVariable create None assert maxlen is_python_constant f maxlen must constant got maxlen debug_repr maxlen = maxlen items = list items maxlen as_python_constant None items = items -maxlen as_python_constant super __init__ items kwargs python_type collections deque debug_repr maxlen as_python_constant None debug_repr_helper deque maxlen= + maxlen debug_repr + debug_repr_helper deque as_python_constant python_type x as_python_constant x items maxlen=self maxlen as_python_constant reconstruct codegen PyCodegen - None codegen add_push_null lambda codegen append_output codegen create_load_python_module collections deque codegen foreach items codegen extend_output create_instruction BUILD_LIST arg=len items codegen maxlen codegen extend_output codegen create_call_function_kw maxlen False var_getattr tx InstructionTranslator name name == maxlen maxlen super var_getattr tx name call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __setitem__ is_mutable args args is_python_constant kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs key value = args assert key is_python_constant assert isinstance key as_python_constant int tx output side_effects mutation items key as_python_constant = value ConstantVariable create None maxlen = maxlen as_python_constant maxlen None slice_within_maxlen = slice -maxlen None slice_within_maxlen = None name == extendleft is_mutable len args args has_force_unpack_var_sequence tx kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs NOTE inefficient alternative represent items deque which more intrusive change args force_apply_to_var_sequence tx lambda item call_method tx appendleft item slice_within_maxlen = slice None maxlen result = ConstantVariable create None name == popleft is_mutable kwargs len args raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs tx output side_effects mutation result items = items name == appendleft len args is_mutable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs tx output side_effects mutation items = args items slice_within_maxlen = slice None maxlen result = ConstantVariable create None name == insert len args is_mutable kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs maxlen None len items == maxlen raise_observed_exception IndexError tx args= deque already its maximum size result = super call_method tx name args kwargs result = super call_method tx name args kwargs slice_within_maxlen None maxlen None len items maxlen items = items slice_within_maxlen result call_obj_hasattr tx InstructionTranslator name str - VariableTracker python_type collections deque variables ConstantVariable create name collections deque __dict__ super call_obj_hasattr tx name TupleVariable BaseListVariable python_type tuple __repr__ - str f __class__ __name__ length= len items debug_repr debug_repr_helper reconstruct codegen PyCodegen - None codegen foreach items codegen append_output create_build_tuple len items call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker super call_method tx name args kwargs var_getattr tx name name == __class__ source = AttrSource source name source None class_type = python_type class_type tuple variables BuiltinVariable class_type source=source variables UserDefinedClassVariable class_type source=source super var_getattr tx name call_obj_hasattr tx InstructionTranslator name str - VariableTracker python_type tuple super call_obj_hasattr tx name variables ConstantVariable create hasattr name SizeVariable TupleVariable torch Size _nonvar_fields = proxy TupleVariable _nonvar_fields __init__ items list VariableTracker proxy Optional torch fx Proxy = None kwargs - None proxy = proxy super __init__ items kwargs debug_repr debug_repr_helper torch Size python_type torch Size as_proxy proxy None proxy torch Size needs special handling Normally we pun list-like container directly contain Proxy Node objects FX FX knows look inside containers via map_aggregate But torch Size weird although subclasses tuple doesn t allow members which aren t int-like rejecting Proxy Node This means we can t use normal representation trick torch Size proxy proxy I looked into seeing I could relax torch Size PyTorch proper torch Size constructor sees type doesn t recognize will try call __index__ so there no BC way actually change behavior though occurs me I could have just added YOLO no checking alternate constructor To work around problem I represent torch Size proxy straight up proxy would have been constructed taking constituent proxies arguments This trick can generally used any construct we need proxy we can t directly represent aggregate I don t see very many examples torchdynamo though Look proxy If there none do legacy behavior tracer = None proxies = _as_proxy proxy proxies isinstance proxy torch fx Proxy tracer = proxy tracer break tracer None torch Size proxies proxy = tracer create_proxy call_function torch Size proxies set_example_value proxy node torch Size p node meta example_value isinstance p int p p proxies proxy reconstruct codegen PyCodegen - None codegen add_push_null lambda codegen load_import_from torch Size codegen foreach items build_torch_size = create_build_tuple len items + create_call_function False codegen extend_output build_torch_size unpack_var_sequence tx list items numel tx builtin BuiltinVariable tensor SymNodeVariable const_result = sym_sizes = v items isinstance v ConstantVariable const_result = v value assert isinstance v SymNodeVariable type v Delay proxy calls until we know will necessary sym_sizes append v result = ConstantVariable create const_result sym_sizes const_result == Skip multiplying result sym_sizes = sym_sizes sym_sizes const_result == result mul = BuiltinVariable operator mul v sym_sizes result = mul call_function tx result v result call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __getitem__ kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs out = get_item_dyn tx args out name == numel args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs numel tx super call_method tx name args kwargs get_item_dyn tx InstructionTranslator arg VariableTracker tensor SymNodeVariable isinstance arg SymNodeVariable index = arg sym_num index = arg as_python_constant isinstance index slice SizeVariable items index assert isinstance index int torch SymInt items index call_obj_hasattr tx InstructionTranslator name str - VariableTracker variables ConstantVariable create hasattr torch Size name NamedTupleVariable TupleVariable _nonvar_fields = tuple_cls dynamic_attributes TupleVariable _nonvar_fields __init__ items tuple_cls dynamic_attributes=None kwargs - None super __init__ items kwargs tuple_cls = tuple_cls dynamic_attributes = dynamic_attributes dynamic_attributes is_namedtuple isinstance getattr tuple_cls _fields None tuple callable getattr tuple_cls _make None is_structseq is_namedtuple fields namedtuple_fields tuple_cls debug_repr is_structseq StructSequenceType iterable repr tuple_cls Lit x debug_repr x items NamedTupleType iterable repr tuple_cls Lit x debug_repr x items python_type tuple_cls as_python_constant is_structseq StructSequenceType iterable result = python_type x as_python_constant x items NamedTupleType iterable result = python_type x as_python_constant x items Apply dynamic attributes any set dynamic_attributes attr_name attr_value dynamic_attributes items Convert VariableTracker Python constant needed hasattr attr_value as_python_constant python_value = attr_value as_python_constant raise NotImplementedError Can convert dynamic attribute without python constant value python constant setattr result attr_name python_value result as_proxy assert python_type SizeVariable is_structseq StructSequenceType iterable python_type _as_proxy NamedTupleType iterable python_type _as_proxy reconstruct codegen PyCodegen - None Always reconstruct NamedTuple normally first Constructors StructSequenceType iterable NamedTupleType iterable NamedTupleType _make iterable create_fn = tuple_cls is_structseq tuple_cls _make codegen add_push_null lambda codegen append_output codegen create_load_const_unchecked create_fn codegen foreach items codegen extend_output create_build_tuple len items + create_call_function False name value dynamic_attributes items codegen dup_top codegen value codegen extend_output create_rot_n codegen store_attr name _is_method_overridden method_name str - bool Checks method overridden NamedTuple subclass Args method_name str The name method check Returns bool True method overridden subclass False otherwise Raises ValueError If NamedTuple does inherit both Tuple Object len tuple_cls __mro__ raise ValueError NamedTuple should inherit Tuple Object getattr tuple_cls method_name None == getattr tuple_cls __mro__ - method_name None False True call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __setattr__ kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs attr value = args attr = attr as_python_constant structseq immutable is_structseq namedtuple directly created ` collections namedtuple ` immutable tuple_cls __bases__ == tuple fields immutable attr fields raise_observed_exception AttributeError tx Subclass namedtuple type can have dynamic attributes tx output side_effects mutation source tx output side_effects store_attr attr value dynamic_attributes attr = value ConstantVariable create None name == _replace NamedTuple _replace should create new instance replaced fields args raise_args_mismatch tx name args f len args args Get field names validation fields = fields Start current items copy them new_items = list items Replace fields specified kwargs field_name new_value kwargs items field_name fields raise_observed_exception ValueError tx args= ConstantVariable create f Got unexpected field name field_name Replace item field s index field_index = fields index field_name new_items field_index = new_value NamedTupleVariable new_items tuple_cls super call_method tx name args kwargs getitem_const tx InstructionTranslator arg VariableTracker isinstance arg SliceVariable slicing namedtuple produces tuple TupleVariable items arg as_python_constant source=None super getitem_const tx arg var_getattr tx InstructionTranslator name check_and_create_method method = inspect getattr_static tuple_cls name None isinstance method classmethod We need unbounded cls method avoid inline __self__ UserMethodVariable method __func__ variables UserDefinedClassVariable tuple_cls isinstance method staticmethod UserFunctionVariable method __func__ inspect isfunction method UserMethodVariable method None Avoid UserMethodVariable fallback precisely when methods NamedTuple methods have been overwritten name == _replace _is_method_overridden _replace _is_method_overridden __getattr__ Return BuiltinVariable _replace method Get actual _replace method tuple actual_replace_method = getattr tuple_cls _replace None actual_replace_method source AttrSource source = AttrSource source name source None variables GetAttrVariable name source=source Fallback _replace doesn t exist shouldn t happen proper NamedTuples super var_getattr tx name name == _fields source = NamedTupleFieldsSource source source None VariableTracker build tx fields source=source name dynamic_attributes dynamic_attributes name fields = fields name fields method = check_and_create_method method super var_getattr tx name method items fields index name call_obj_hasattr tx InstructionTranslator name str - VariableTracker variables ConstantVariable create name dynamic_attributes hasattr tuple_cls name SliceVariable VariableTracker __init__ items tx=None kwargs - None items_to_map = items start stop step = variables ConstantVariable create None len items_to_map == stop = items_to_map len items_to_map == start stop = items_to_map len items_to_map == start stop step = items_to_map raise AssertionError Convert TensorVariable SymIntVariable calling item This decomposes t u=t item u dynamo level isinstance start variables TensorVariable assert tx None tx required when slice indices TensorVariables start = start call_method tx item isinstance stop variables TensorVariable assert tx None tx required when slice indices TensorVariables stop = stop call_method tx item isinstance step variables TensorVariable assert tx None tx required when slice indices TensorVariables step = step call_method tx item items = start stop step super __init__ kwargs debug_repr debug_repr_helper slice as_proxy slice x as_proxy x items python_type slice as_python_constant slice guard_if_dyn x x items reconstruct codegen PyCodegen - None codegen foreach items codegen append_output create_instruction BUILD_SLICE arg=len items var_getattr tx InstructionTranslator name name cmp_name_to_op_mapping variables GetAttrVariable name fields = start stop step name fields unimplemented_v gb_type= Unsupported attribute slice object context=f var_getattr name explanation=f Expected attribute one join fields f got name hints= graph_break_hints USER_ERROR items fields index name ListIteratorVariable IteratorVariable _nonvar_fields = index IteratorVariable _nonvar_fields __init__ items index int = kwargs - None super __init__ kwargs assert isinstance items list Removing check slows things down too much https github com pytorch pytorch pull #issuecomment- assert all isinstance x VariableTracker x items items = items index = index is_exhausted = False __repr__ - str f __class__ __name__ length= len items index= repr index next_variable tx assert is_mutable old_index = index old_index = len items is_exhausted is_exhausted = True raise_observed_exception StopIteration tx tx output side_effects mutation index += items old_index call_obj_hasattr tx name variables ConstantVariable create hasattr iter name python_type type iter as_python_constant index raise NotImplementedError iter x as_python_constant x items has_unpack_var_sequence tx True unpack_var_sequence tx is_exhausted is_exhausted = True list items index force_unpack_var_sequence tx - list VariableTracker unpack_var_sequence tx reconstruct codegen PyCodegen - None is_exhausted remaining_items = items index remaining_items = codegen foreach remaining_items codegen extend_output create_build_tuple len remaining_items create_instruction GET_ITER TupleIteratorVariable ListIteratorVariable pass RangeIteratorVariable IteratorVariable only needed isinstance range_iterator work _nonvar_fields = iter_obj __init__ start int stop int step int len_ int kwargs super __init__ kwargs start = start stop = stop step = step len = len_ call_method tx name args kwargs name == __next__ next_variable tx name == __iter__ super call_method tx name args kwargs call_obj_hasattr tx name python_type range_iterator ri = iter range ConstantVariable hasattr ri name super call_obj_hasattr tx name next_variable tx len = raise_observed_exception StopIteration tx len -= current = start start += step ConstantVariable create current python_type range_iterator reconstruct codegen PyCodegen codegen add_push_null lambda codegen append_output codegen create_load_python_module range codegen append_output codegen create_load_const start codegen append_output codegen create_load_const stop codegen append_output codegen create_load_const step codegen extend_output create_call_function False codegen append_output create_instruction GET_ITER