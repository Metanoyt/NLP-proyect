Owner s oncall distributed copy itertools sys unittest torch _dynamo variables distributed PlacementClassVariable torch distributed tensor placement_types _StridedShard Partial Replicate Shard torch testing _internal common_utils run_tests TestCase Basic functionality test Placement types PlacementTypesTestCase TestCase test_type_identification shard = Shard strided_shard = _StridedShard dim= split_factor= partial_sum = Partial sum partial_max = Partial max replicate = Replicate ident_tests = shard True False False strided_shard True False False partial_sum False True False partial_max False True False replicate False False True do_deepcopy False True placement is_shard is_partial is_replicate ident_tests do_deepcopy placement = copy deepcopy placement assertEqual placement is_shard is_shard assertEqual placement is_partial is_partial assertEqual placement is_replicate is_replicate test_equality equivalence_classes = Shard _StridedShard dim= split_factor= Shard _StridedShard dim= split_factor= Replicate Partial sum Partial max eq_class equivalence_classes Each item equivalence should equal every other item its lhs rhs itertools product eq_class eq_class assertEqual lhs rhs Each item equivalence should equal any item any other other_class equivalence_classes other_class eq_class continue lhs rhs itertools product eq_class other_class assertNotEqual lhs rhs Testing case doesn t seem fit neatly into above equivalence framework assertNotEqual _StridedShard dim= split_factor= _StridedShard dim= split_factor= unittest skipIf sys version_info kw_only only available python = test_strided_shard_kwonly_argument assertRaises TypeError _StridedShard _StridedShard split_factor= test_strided_shard_isinstance_shard assert isinstance _StridedShard dim= split_factor= Shard test_dynamo_can_identify_placement_classes cls Replicate Shard _StridedShard Partial assertTrue PlacementClassVariable is_placement_type cls msg=f failed cls __name__ == __main__ run_tests