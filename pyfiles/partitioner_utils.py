mypy allow-untyped-defs enum Enum typing NamedTuple torch fx node map_arg Node Partition Partition contains all information about individual partition It also provides necessary methods manipulation partition __init__ partition_id int - None nodes set Node = set partition_id = partition_id parents set Partition = set children set Partition = set bfs_level int = - used_mem_bytes int = logical_device_ids list int = __str__ str partition_id recalculate_mem_size used_mem_bytes = node nodes used_mem_bytes += get_extra_size_of node nodes add_node node input_nodes dict Node None = map_arg node args input_nodes setdefault map_arg node kwargs input_nodes setdefault Add current node s input nodes they placeholder constants n input_nodes n op placeholder get_attr nodes add n nodes add node recalculate_mem_size remove_node node Remove node only node partition node nodes nodes remove node Collect node s input nodes input_nodes dict Node None = map_arg node args input_nodes setdefault map_arg node kwargs input_nodes setdefault Check input node placeholder get_attr input node used some other nodes partition remove input node input_node input_nodes all n nodes n input_node users input_node op placeholder get_attr nodes remove input_node recalculate_mem_size Device NamedTuple name str available_mem_bytes int logical_id int NodeLatency NamedTuple Latency due memory bandwidth mem_latency_sec float Latency due computation computer_latency_sec float PartitionLatency NamedTuple Sum all nodes memory latency critical path mem_latency_sec float Sum all nodes compute latency critical path computer_latency_sec float Latency critical path overall_latency_sec float PartitionMode Enum size_based = sparse_nn = cost_aware = kl_based = aot_based = PartitionerConfig NamedTuple devices list Device mode PartitionMode = PartitionMode size_based transfer_rate_bytes_per_sec float = node_to_latency_mapping dict Node NodeLatency = node_to_partition_mapping dict Node int = partition_to_logical_device_mapping dict int list int = Saturate host replicating partitions remaining idle devices saturate_host bool = False get_extra_size_of node Node nodes set Node - int Given node set nodes function extra size needed node included set Find all its input nodes input_nodes dict Node None = map_arg node args input_nodes setdefault map_arg node kwargs input_nodes setdefault Calculate total size related nodes total_size_of_input_nodes = n input_nodes Make sure node hasn t been set yet n nodes size_bytes = getattr n size_bytes None size_bytes total_size_of_input_nodes += size_bytes output_size raise RuntimeError node has no size_bytes attr Don t forget op node itself size_bytes = getattr node size_bytes None size_bytes total_size_of_input_nodes += size_bytes total_size raise RuntimeError node has no size_bytes attr total_size_of_input_nodes get_latency_of_one_partition partition Partition node_to_latency_mapping dict Node NodeLatency - PartitionLatency Given partition its nodes latency PartitionLatency partition get_top_nodes partition Partition - list Node Given partition list nodes top bfs level top_nodes list Node = node partition nodes Skip placeholder get_attr nodes node op placeholder get_attr continue input_nodes dict Node None = map_arg node args input_nodes setdefault map_arg node kwargs input_nodes setdefault If node has no input nodes partition its input nodes partition placeholders get_attrs node top bfs level partition any n partition nodes n op placeholder get_attr n input_nodes top_nodes append node top_nodes dfs_helper node Node partition_latency - PartitionLatency Given top node partition function returns latency critical path partition node_latency = node_to_latency_mapping node Calculate current overall latency partition overall_latency_sec = partition_latency overall_latency_sec + max node_latency computer_latency_sec node_latency mem_latency_sec Update mem latency path mem_latency_sec = partition_latency mem_latency_sec + node_latency mem_latency_sec Update compute latency path computer_latency_sec = partition_latency computer_latency_sec + node_latency computer_latency_sec Get all users node partition users = set node users intersection partition nodes users max_latency = PartitionLatency mem_latency_sec= computer_latency_sec= overall_latency_sec= n users Get new partition latency recursively new_partition_latency = dfs_helper n PartitionLatency mem_latency_sec computer_latency_sec overall_latency_sec new_partition_latency overall_latency_sec max_latency overall_latency_sec max_latency = new_partition_latency max_latency If there no user node bottom partition PartitionLatency mem_latency_sec computer_latency_sec overall_latency_sec Main part starts Get all top level nodes partition top_nodes = get_top_nodes partition critical_path_latency = PartitionLatency mem_latency_sec= computer_latency_sec= overall_latency_sec= Go through all top nodes find largest latency critical pass latency node top_nodes partition_latency = dfs_helper node PartitionLatency mem_latency_sec= computer_latency_sec= overall_latency_sec= partition_latency overall_latency_sec critical_path_latency overall_latency_sec critical_path_latency = partition_latency critical_path_latency get_partition_to_latency_mapping partitions list Partition node_to_latency_mapping dict Node NodeLatency - dict Partition PartitionLatency Given all partitions node_to_latency_mapping dictionary mapping dictionary each partition its overall latency partition_to_latency_mapping dict Partition PartitionLatency = Go through each partition get its latency partition partitions partition_latency = get_latency_of_one_partition partition node_to_latency_mapping partition_to_latency_mapping partition = partition_latency partition_to_latency_mapping get_comm_latency_between parent_partition Partition child_partition Partition transfer_rate_bytes_per_sec float Given two partitions parent child calculate communication latency between two If two partitions same device comm latency parent_partition logical_device_ids = child_partition logical_device_ids = parent_partition logical_device_ids == child_partition logical_device_ids Keep tracking communication size between parent child comm_size = Keep tracking all counted node visited_nodes = set Go through all nodes child partition If node has input nodes parent partition output size those input nodes will counted added comm_size node child_partition nodes input_nodes dict Node None = map_arg node args input_nodes setdefault map_arg node kwargs input_nodes setdefault n input_nodes n parent_partition nodes n visited_nodes size_bytes = getattr n size_bytes None size_bytes None comm_size += size_bytes output_size visited_nodes add n comm_size transfer_rate_bytes_per_sec get_latency_of_partitioned_graph partitions list Partition partition_to_latency_mapping dict Partition PartitionLatency transfer_rate_bytes_per_sec float Given all partitions graph find critical path among all partitions its latency latency whole graph dfs_helper partition Partition latency_so_far_sec float - float This function helps recursively get latency path partitions Update latency adding current partition s latency latency_so_far_sec += partition_to_latency_mapping partition overall_latency_sec partition children max_latency_sec = child partition children Calculate latency between comm_latency_sec = get_comm_latency_between partition child transfer_rate_bytes_per_sec new_latency_sec = dfs_helper child latency_so_far_sec + comm_latency_sec new_latency_sec max_latency_sec max_latency_sec = new_latency_sec max_latency_sec latency_so_far_sec get_top_partitions partitions list Partition - list Partition This function all partitions without parents starting points all paths If partition has no parents then top partition top_partitions = partition partition partitions len partition parents == top_partitions top_partitions = get_top_partitions partitions critical_path_latency_sec = partition top_partitions latency_sec = dfs_helper partition latency_sec critical_path_latency_sec critical_path_latency_sec = latency_sec critical_path_latency_sec