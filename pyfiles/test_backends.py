Owner s oncall jit io os sys unittest torch torch _C torch jit mobile _load_for_lite_interpreter torch testing FileCheck torch testing _internal common_utils find_library_location IS_FBCODE IS_MACOS IS_SANDCASTLE IS_WINDOWS raise_on_run_directly torch testing _internal jit_utils JitTestCase Make helper files test importable pytorch_test_dir = os path dirname os path dirname os path realpath __file__ sys path append pytorch_test_dir to_test_backend module method_compile_spec torch _C _jit_to_backend test_backend module forward method_compile_spec to_test_backend_multi module method_compile_spec torch _C _jit_to_backend test_backend module method_compile_spec to_test_backend_selective module method_compile_spec submodules _to_test_backend module to_test_backend module method_compile_spec torch _C _jit_to_backend_selective module _to_test_backend submodules BasicModule torch nn Module A simple Module used test to_backend lowering machinery forward x h accum x h sub_accum x h accum x h x + h sub_accum x h x - h This ignored IS_WINDOWS IS_MACOS cases Hence we need one TestBackends unittest skipIf IS_SANDCASTLE IS_WINDOWS IS_MACOS IS_FBCODE Non-portable load_library call used test JitBackendTestCase JitTestCase A common base JIT backend tests contains common utility functions output comparison serialization deserialization setUp super setUp lib_file_path = find_library_location libjitbackend_test so torch ops load_library str lib_file_path Subclasses expected set up three variables their setUp methods module - regular Python version module being tested scripted_module - scripted version module lowered_module - version module lowered backend check_function function_name input Check function named function_name produces same output using Python regular JIT backend given input Get handles Python JIT backend methods python_method = module __getattribute__ function_name jit_method = scripted_module __getattr__ function_name backend_method = lowered_module __getattr__ function_name Run methods python_output = python_method input jit_output = jit_method input backend_output = backend_method input The answers returned Python JIT to_backend should all match assertEqual python_output backend_output assertEqual jit_output backend_output save_load Save load lowered module lowered_module = getExportImportCopy lowered_module test_execution Stub correctness tests test_save_load Stub serialization tests test_errors Stub testing error checking BasicModuleTest JitBackendTestCase Tests BasicModule setUp super setUp Create Python JIT backend versions BasicModule module = BasicModule scripted_module = torch jit script BasicModule lowered_module = to_test_backend_multi scripted_module accum sub_accum forward test_execution Test execution backend against Python JIT input = torch randn Test all three module methods check_function accum input input check_function sub_accum input input check_function forward input input test_save_load Lowered module should produce same outputs test_execution Save compile spec compare against version retrieved after loading pre_compile_spec = lowered_module __getattr__ __loweredModule__ __getattr__ __method_compile_spec Save load lowered module save_load Get compile spec after loading post_compile_spec = lowered_module __getattr__ __loweredModule__ __getattr__ __method_compile_spec Compile specs should match assertEqual pre_compile_spec post_compile_spec Loaded module should produce same outputs test_execution BasicModuleUnavailableTest JitBackendTestCase Tests BasicModule backend available Fundamentally _jit_to_backend successful Execution fails exception Saving successful Loading fails exception setUp super setUp Create Python JIT backend versions BasicModule module = BasicModule scripted_module = torch jit script BasicModule lowered_module = torch _C _jit_to_backend test_backend_unavailable scripted_module forward test_execution Test execution backend fails because backend available input = torch randn Test exception thrown assertRaisesRegexWithHighlight Exception r Backend available raise Exception Backend available backend_method = lowered_module __getattr__ forward backend_method input input test_save_load Test saving lowered module OK loading fails because backend available buffer = io BytesIO torch jit save lowered_module buffer buffer seek assertRaisesRegexWithHighlight Exception r Backend available raise Exception Backend available torch jit load buffer NestedModuleTest JitBackendTestCase Tests NestedModule check module lowered backend can used submodule NestedModule torch nn Module A Module one submodule used test lowered Modules can used submodules __init__ submodule super __init__ submodule = submodule forward x h submodule forward x h setUp super setUp Create Python JIT backend versions NestedModule Both modules module regular Python modules module = NestedModuleTest NestedModule BasicModule Both modules scripted_module ScriptModules scripted_module = torch jit script NestedModuleTest NestedModule BasicModule First script another instance NestedModule share_types=False so can selectively lowered without modifying type scripted_module lowered_module = to_test_backend_multi torch jit script BasicModule accum sub_accum forward lowered_module ScriptModule its submodule lowered module lowered_module = torch jit script NestedModuleTest NestedModule lowered_module test_execution Test execution backend against Python JIT input = torch randn Test forward check_function forward input input test_save_load Lowered module should produce same outputs test_execution Save load lowered module save_load Loaded module should produce same outputs test_execution SelectiveLoweringTest JitBackendTestCase Tests selective lowering API OuterModule torch nn Module __init__ sub sub other super __init__ sub = sub sub = sub other = other forward x y Call module will lowered directly test type remapping modules its parent b = sub submodule forward x y c d = sub forward x y e f = other forward x y + c + e b + d + f MiddleModule torch nn Module __init__ submodule super __init__ submodule = submodule forward x y submodule forward x y setUp super setUp OuterModule = SelectiveLoweringTest OuterModule MiddleModule = SelectiveLoweringTest MiddleModule script_without_type_sharing mod torch jit _recursive create_script_module mod torch jit _recursive infer_methods_to_compile share_types=False Create Python JIT backend versions hierarchy looks like --------- OuterModule -------- &#124; &#124; &#124; MiddleModule MiddleModule MiddleModule &#124; &#124; &#124; BasicModule BasicModule BasicModule Two BasicModules will lowered third will module = OuterModule MiddleModule BasicModule MiddleModule BasicModule MiddleModule BasicModule scripted_module = script_without_type_sharing OuterModule MiddleModule BasicModule MiddleModule BasicModule MiddleModule BasicModule lowered_module = script_without_type_sharing OuterModule MiddleModule BasicModule MiddleModule BasicModule MiddleModule BasicModule lowered_module = to_test_backend_selective lowered_module forward sub submodule sub submodule test_execution input = torch randn check_function forward input input test_selective_lowering_type_remap test_save_load test_execution save_load test_execution test_selective_lowering_type_remap test_selective_lowering_type_remap Check type remapping replacement occurred during selective lowering Check lowered_module lowered does contain test_backendLoweredModule due calling lowered module directly FileCheck check OuterModule check BasicModule run scripted_module graph FileCheck check OuterModule check_not __torch__ torch classes __backends__ test_backend check LoweredWrapper test_backend run lowered_module graph Check lowered_module sub sub lowered BasicModule has been replaced their graphs FileCheck check MiddleModule check BasicModule check_not LoweredWrapper test_backend run scripted_module sub graph FileCheck check MiddleModule check_not __torch__ torch classes __backends__ test_backend check LoweredWrapper test_backend run lowered_module sub graph FileCheck check MiddleModule check BasicModule check_not LoweredWrapper test_backend run scripted_module sub graph FileCheck check MiddleModule check_not __torch__ torch classes __backends__ test_backend check LoweredWrapper test_backend run lowered_module sub graph Check lowered_module sub sub submodule lowered They should have new attribute __loweredModule__ whose graph should mention __torch__ torch classes __backends__ test_backend TorchBind executing functions test JIT backend FileCheck check LoweredModule test_backend check __torch__ torch classes __backends__ test_backend run lowered_module sub submodule __loweredModule__ graph FileCheck check LoweredModule test_backend check __torch__ torch classes __backends__ test_backend run lowered_module sub submodule __loweredModule__ graph Check other other submodule have been left untouched selective lowering process FileCheck check MiddleModule check BasicModule check_not __torch__ torch classes __backends__ test_backend check_not LoweredWrapper test_backend run scripted_module other graph FileCheck check BasicModule check_not __torch__ torch classes __backends__ test_backend check_not LoweredModule test_backend run scripted_module other submodule graph test_errors Check errors associated selective lowering Check error messages thrown when attempting lower something ScriptModule assertRaisesRegexWithHighlight RuntimeError r Object ScriptModule to_test_backend_selective torch nn ReLU forward submodule MiddleModule = SelectiveLoweringTest MiddleModule mod = MiddleModule BasicModule mod new_attr = assertRaisesRegexWithHighlight RuntimeError r Attribute named new_attr Module to_test_backend_selective torch jit script mod forward new_attr Check error message thrown when module hierarchy doesn t have unique types OuterModule = SelectiveLoweringTest OuterModule mod = OuterModule MiddleModule BasicModule MiddleModule BasicModule MiddleModule BasicModule assertRaisesRegexWithHighlight RuntimeError r Selective lowering only supported module hierarchies unique types to_test_backend_selective torch jit script mod forward sub submodule This needed IS_WINDOWS IS_MACOS skip tests unittest skipIf IS_SANDCASTLE IS_WINDOWS IS_MACOS IS_FBCODE Non-portable load_library call used test TestBackends JitTestCase This wraps invokes all subclasses JitBackendTestCase so each one does have individually imported test_jit py __init__ name super __init__ name basic_module_test = BasicModuleTest name basic_module_unavailable_test = BasicModuleUnavailableTest name nested_module_test = NestedModuleTest name selective_lowering_test = SelectiveLoweringTest name setUp super setUp basic_module_test setUp basic_module_unavailable_test setUp nested_module_test setUp selective_lowering_test setUp test_execution basic_module_test test_execution basic_module_unavailable_test test_execution nested_module_test test_execution selective_lowering_test test_execution test_save_load basic_module_test test_save_load basic_module_unavailable_test test_save_load nested_module_test test_save_load selective_lowering_test test_save_load test_errors selective_lowering_test test_errors Unit Tests backend compiler This test case existing TestBackends separate because they cover different aspects The actual backend implementation test different It has simple demo compiler test end-to-end flow mobile However test cannot cover selective_lowering now which covered TestBackends BasicModuleAdd torch nn Module A simple add Module used test to_backend lowering machinery forward x h x + h This ignored IS_WINDOWS IS_MACOS cases Hence we need one TestBackends unittest skipIf IS_SANDCASTLE IS_WINDOWS IS_MACOS IS_FBCODE Non-portable load_library call used test JitBackendTestCaseWithCompiler JitTestCase A common base JIT backend tests compilers contains common utility functions output comparison setUp super setUp lib_file_path = find_library_location libbackend_with_compiler so torch ops load_library str lib_file_path Subclasses expected set up four variables their setUp methods module - regular Python version module being tested scripted_module - scripted version module lowered_module - version module lowered backend mobile_module - module format Pytorch Mobile can execute check_forward input Check forward function produces same output using Python regular JIT backend mobile given input Get outputs forward python_output = module forward input jit_output = scripted_module forward input backend_output = lowered_module input mobile_output = mobile_module input The answers returned Python JIT to_backend mobile should all match assertEqual python_output backend_output assertEqual jit_output backend_output assertEqual mobile_output backend_output test_execution Stub correctness tests test_errors Stub testing error checking BasicModuleTestWithCompiler JitBackendTestCaseWithCompiler Tests BasicModuleAdd setUp super setUp Create Python JIT backend versions BasicModuleAdd module = BasicModuleAdd scripted_module = torch jit script BasicModuleAdd compile_spec = forward input_shapes some_other_option True lowered_module = torch _C _jit_to_backend backend_with_compiler_demo scripted_module compile_spec Create mobile version BasicModuleAdd buffer = io BytesIO lowered_module _save_to_buffer_for_lite_interpreter buffer seek mobile_module = _load_for_lite_interpreter buffer test_execution Test execution backend against Python JIT input = torch ones dtype=torch float check_forward input input ErrorMessagesWithCompiler JitBackendTestCase Tests errors occur compiler specifically operator supported backend ModuleNotSupported torch nn Module A module operator supported forward x h x h _loweredmodule forward test_errors scripted_module_n = torch jit script ErrorMessagesWithCompiler ModuleNotSupported Test exception thrown when lowering module unsupported operator assertRaisesRegexWithHighlight RuntimeError Special escape characters replaced r The node aten mul supported compiler forward x h x h ~~~~~ --- HERE _loweredmodule forward torch _C _jit_to_backend backend_with_compiler_demo scripted_module_n forward CompModuleTestWithCompiler JitBackendTestCase Tests CompModule which module two lowered submodules BasicModuleSub torch nn Module A simple subtraction Module used CompModule forward x h x - h CompModule torch nn Module A module two lowered submodules __init__ addmodule submodule super __init__ lowered_add = addmodule lowered_sub = submodule forward b s c = lowered_add forward b d = lowered_sub forward b y = s c d y setUp super setUp Create Python JIT versions CompModule lowered submodules compile_spec = forward input_shapes some_other_option True lowered_add = torch _C _jit_to_backend backend_with_compiler_demo torch jit script BasicModuleAdd compile_spec lowered_sub = torch _C _jit_to_backend backend_with_compiler_demo torch jit script CompModuleTestWithCompiler BasicModuleSub forward module = CompModuleTestWithCompiler CompModule lowered_add lowered_sub scripted_module = torch jit script CompModuleTestWithCompiler CompModule lowered_add lowered_sub No backend version CompModule currently so filler lowered_module = scripted_module Create mobile version CompModule JIT version buffer = io BytesIO scripted_module _save_to_buffer_for_lite_interpreter buffer seek mobile_module = _load_for_lite_interpreter buffer test_execution Test execution backend against Python JIT input = torch ones dtype=torch float input = torch ones dtype=torch float Test forward check_function forward input input input This needed IS_WINDOWS IS_MACOS skip tests unittest skipIf IS_SANDCASTLE IS_WINDOWS IS_MACOS IS_FBCODE Non-portable load_library call used test TestBackendsWithCompiler JitTestCase This wraps invokes all subclasses JitBackendTestCaseWithCompiler so each one does have individually imported test_jit py __init__ name super __init__ name basic_module_compiler_test = BasicModuleTestWithCompiler name error_module_compiler_test = ErrorMessagesWithCompiler name comp_module_compiler_test = CompModuleTestWithCompiler name setUp super setUp basic_module_compiler_test setUp error_module_compiler_test setUp comp_module_compiler_test setUp test_execution basic_module_compiler_test test_execution comp_module_compiler_test test_execution test_errors error_module_compiler_test test_errors CompModuleTestSameNameWithCompiler JitBackendTestCase Tests CompModule which module two lowered submodules same module name ModuleAdd torch nn Module A simple Module used test to_backend lowering machinery forward x h x + h CompModule torch nn Module A module two lowered submodules __init__ - None super __init__ compile_spec = forward some_other_option True add = torch _C _jit_to_backend backend_with_compiler_demo torch jit script ModuleAdd noqa F compile_spec sub = torch _C _jit_to_backend backend_with_compiler_demo torch jit script ModuleAdd noqa F compile_spec forward b s int c = add forward b d = sub forward b y = s c d y setUp super setUp module = CompModule noqa F scripted_module = torch jit script module buffer = io BytesIO scripted_module _save_to_buffer_for_lite_interpreter buffer seek mobile_module = _load_for_lite_interpreter buffer test_execution = torch ones b = torch ones s = Test forward check_function forward b s AddedAttributesTest JitBackendTestCase Tests adding attributes model after lowering setUp super setUp Create Python JIT backend versions BasicModule module = BasicModule scripted_module = torch jit script BasicModule lowered_module = to_test_backend_multi scripted_module accum sub_accum forward test_attribute input = torch ones pre_bundled = lowered_module input Attach bundled inputs which adds several attributes functions model lowered_module = torch utils bundled_inputs augment_model_with_bundled_inputs lowered_module noqa F input post_bundled = lowered_module lowered_module get_all_bundled_inputs Save load lowered module save_load Use bundled after save load prove its preserved post_load = lowered_module lowered_module get_all_bundled_inputs assertEqual pre_bundled post_bundled assertEqual post_bundled post_load __name__ == __main__ raise_on_run_directly test test_jit py