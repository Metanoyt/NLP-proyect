mypy ignore-errors This module contains variable classes handling user-defined objects Dynamo s tracing system The key classes - UserDefinedVariable Base representing custom Python objects - UserDefinedClassVariable Handles Python objects types - UserDefinedObjectVariable Fallback instance objects support method calls attribute access other Python object behaviors - Specialized subclasses common patterns - UserDefinedDictVariable For dict subclasses - UserDefinedSetVariable For set subclasses - UserDefinedTupleVariable For tuple subclasses - UserDefinedExceptionObjectVariable For exception subclasses - FrozenDataClassVariable Special handling frozen dataclasses - MutableMappingVariable For collections abc MutableMapping subclasses Dynamo specializes VariableTracker subclasses like FrozenDataClassVariable available no subclass qualifies falls back UserDefinedObjectVariable These classes help Dynamo track handle arbitrary Python objects during tracing maintaining proper semantics while enabling optimizations where possible _collections builtins collections contextlib dataclasses enum functools inspect itertools random sys threading types warnings weakref typing TYPE_CHECKING typing_extensions is_typeddict torch _dynamo config torch nn torch _guards TracingContext torch utils _python_dispatch is_traceable_wrapper_subclass_type graph_break_hints polyfills variables bytecode_transformation create_call_function create_parameter_op do_not_convert_to_tracable_parameter exc handle_observed_exception ObservedAttributeError ObservedKeyError ObservedTypeError ObservedUserStopIteration raise_observed_exception unimplemented_v graph_bytecode_inputs get_external_object_by_index guards GuardBuilder install_guard source AttrSource CallFunctionNoArgsSource DataclassFieldsSource DictGetItemSource GetItemSource RandomValueSource TypeDictSource TypeMROSource TypeSource UnspecializedParamBufferSource utils check_constant_args cmp_name_to_op_mapping dict_methods frozenset_methods get_custom_getattr has_torch_function is_frozen_dataclass is_lru_cache_wrapped_function is_namedtuple_cls is_wrapper_or_member_descriptor istype list_methods namedtuple_fields object_has_getattribute proxy_args_kwargs raise_args_mismatch set_methods tensortype_to_dtype tuple_methods unpatched_nn_module_getattr base raise_type_error_exc ValueMutationNew VariableTracker dicts ConstDictVariable DefaultDictVariable lists SizeVariable try numpy np except ModuleNotFoundError np = None try torch utils _cxx_pytree PyTreeSpec except ImportError PyTreeSpec = type None TYPE_CHECKING torch _dynamo codegen PyCodegen torch _dynamo symbolic_convert InstructionTranslator is_standard_setattr val val object __setattr__ BaseException __setattr__ is_standard_delattr val val object __delattr__ BaseException __delattr__ is_forbidden_context_manager ctx f_ctxs = try _pytest python_api RaisesContext _pytest recwarn WarningsChecker f_ctxs append RaisesContext f_ctxs append WarningsChecker except ImportError pass m = sys modules get torch testing _internal jit_utils f_ctxs append m _AssertRaisesRegexWithHighlightContext ctx f_ctxs is_cython_function obj callable obj hasattr type obj __name__ type obj __name__ == cython_function_or_method UserDefinedVariable VariableTracker value object UserDefinedClassVariable UserDefinedVariable value type object __init__ value kwargs - None super __init__ kwargs value = value Used when we materialize __dict__ MappingProxyObject In case we don t want allow mutation because there no way reflect created MappingProxyVariable ban_mutation = False as_python_constant value as_proxy value __repr__ - str f __class__ __name__ value staticmethod functools cache _constant_fold_classes torch device torch finfo torch iinfo torch Size staticmethod functools cache _in_graph_classes _in_graph_class_list = torch Tensor torch cuda FloatTensor torch cuda DoubleTensor torch cuda HalfTensor torch cuda BFloat Tensor torch cuda ByteTensor torch cuda CharTensor torch cuda IntTensor torch cuda ShortTensor torch cuda LongTensor torch Stream torch Event torch cuda Stream torch cuda Event torch xpu Stream torch xpu Event hasattr torch hpu _in_graph_class_list update torch hpu Stream torch hpu Event set tensortype_to_dtype keys &#124; _in_graph_class_list staticmethod functools cache supported_c_new_functions exceptions = getattr builtins name __new__ name dir builtins isinstance getattr builtins name type issubclass getattr builtins name BaseException object __new__ dict __new__ set __new__ frozenset __new__ tuple __new__ list __new__ union exceptions staticmethod is_supported_new_method value TODO anijain - Extend support objects default tp_new functions value UserDefinedClassVariable supported_c_new_functions can_constant_fold_through value _constant_fold_classes has_key_in_generic_dict tx InstructionTranslator key tx output side_effects has_pending_mutation_of_attr key mutated_attr = tx output side_effects load_attr key deleted_ok=True isinstance mutated_attr variables DeletedVariable key value __dict__ var_getattr tx InstructionTranslator name str - VariableTracker ConstantVariable EnumVariable source = AttrSource source name source None None name == __name__ ConstantVariable create value __name__ name == __qualname__ ConstantVariable create value __qualname__ name == __dict__ options = source source variables GetAttrVariable name options name == __mro__ attr_source = source TypeMROSource source VariableTracker build tx value __mro__ attr_source Special handling collections OrderedDict fromkeys Wrap GetAttrVariable collections OrderedDict fromkeys make consistent collections defaultdict both will handled UserDefinedClassVariable call_method Otherwise would wrapped UserDefinedObjectVariable collections OrderedDict fromkeys we need duplicate code handle both cases value collections OrderedDict collections defaultdict name == fromkeys super var_getattr tx name try obj = inspect getattr_static value name except AttributeError type value type raise_observed_exception AttributeError tx msg=f type object value __name__ has no attribute name Cannot reason about classes custom metaclass See test_functions test_getattr_metaclass obj = None name == __new__ UserDefinedClassVariable is_supported_new_method obj super var_getattr tx name name cmp_name_to_op_mapping isinstance obj types FunctionType variables GetAttrVariable name source=source isinstance obj staticmethod VariableTracker build tx obj __get__ value source isinstance obj classmethod isinstance obj __func__ property fget_vt = VariableTracker build tx obj __func__ fget fget_vt call_function tx variables UserMethodVariable obj __func__ source=source isinstance obj types ClassMethodDescriptorType e g inspect getattr_static dict fromkeys inspect getattr_static itertools chain from_iterable func = obj __get__ None value VariableTracker build tx func source source inspect ismemberdescriptor obj VariableTracker build tx obj __get__ value source ConstantVariable is_literal obj ConstantVariable create obj isinstance obj enum Enum EnumVariable obj value collections OrderedDict variables GetAttrVariable name name getattr value __dict__ value __module__ startswith torch value __module__ == torch source VariableTracker build tx obj source source inspect ismethoddescriptor obj is_wrapper_or_member_descriptor obj VariableTracker build tx obj source super var_getattr tx name _call_cross_entropy_loss tx InstructionTranslator args kwargs functional input target weight=None size_average=None ignore_index=- reduce=None reduction= mean label_smoothing= non functional ctor weight=None size_average=None ignore_index=- reduce=None reduction= mean label_smoothing= non functional loss call input target optional_output ConstantVariable normalize_args weight=ConstantVariable create None size_average=ConstantVariable create None ignore_index=ConstantVariable create - reduce=ConstantVariable create None reduction=ConstantVariable create mean label_smoothing=ConstantVariable create weight size_average ignore_index reduce reduction label_smoothing weight size_average ignore_index reduce_arg reduction label_smoothing = normalize_args args kwargs fake_cross_entropy_loss input target builder wrap_fx_proxy wrap_fx_proxy tx=tx proxy=tx output create_proxy call_function torch nn functional cross_entropy proxy_args_kwargs input target weight size_average ignore_index reduce_arg reduction label_smoothing variables LambdaVariable fake_cross_entropy_loss call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __subclasses__ len args == kwargs __subclasses__ value __dict__ source = source source source = AttrSource source __subclasses__ source = CallFunctionNoArgsSource source VariableTracker build tx value __subclasses__ source value collections OrderedDict collections defaultdict name == fromkeys builtin BuiltinVariable BuiltinVariable call_custom_dict_fromkeys tx value args kwargs value collections OrderedDict name == move_to_end args call_method tx name args kwargs name == __eq__ len args == hasattr args value variables ConstantVariable value == args value name == __ne__ len args == hasattr args value variables ConstantVariable value = args value issubclass value dict name = __new__ __new__ handled below variables BuiltinVariable dict call_method tx name args kwargs issubclass value set frozenset name = __new__ __new__ handled below variables BuiltinVariable set call_method tx name args kwargs name == __new__ value collections OrderedDict isinstance args UserDefinedClassVariable args value collections OrderedDict kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs variables ConstDictVariable collections OrderedDict mutation_type=ValueMutationNew name == __new__ UserDefinedClassVariable is_supported_new_method value __new__ tx output side_effects track_new_user_defined_object args args name == __setattr__ ban_mutation unimplemented_v gb_type= Class attribute mutation when __dict__ already materialized context=str value explanation= Dyanmo does support tracing mutations when its __dict__ materialized hints=graph_break_hints SUPPORTABLE super call_method tx name args kwargs call_function tx InstructionTranslator args list VariableTracker kwargs dict str VariableTracker - VariableTracker side_effects SideEffects builder wrap_fx_proxy constant_args = check_constant_args args kwargs can_constant_fold_through constant_args constant fold variables ConstantVariable create as_python_constant x as_python_constant x args k v as_python_constant k v kwargs items value torch nn CrossEntropyLoss _call_cross_entropy_loss tx args kwargs value contextlib nullcontext here avoid circular dependency ctx_manager NullContextVariable NullContextVariable args kwargs value collections OrderedDict tx inline_user_function_return VariableTracker build tx polyfills construct_dict args kwargs value collections defaultdict len args = DefaultDictVariable is_supported_arg args DefaultDictVariable collections defaultdict args mutation_type=ValueMutationNew is_typeddict value value __optional_keys__ unimplemented_v gb_type= TypedDict optional keys context=str value explanation= Dyanmo does support tracing TypedDict optional keys hints= Avoid using TypedDict optional keys graph_break_hints SUPPORTABLE variables BuiltinVariable dict call_dict tx args kwargs value collections deque maxlen = variables ConstantVariable create None deque_signature iterable=None maxlen=None pass try bound_args = inspect signature deque_signature bind args kwargs except TypeError e unimplemented_v gb_type= collections deque bad arguments context=f args= args kwargs= kwargs explanation= Detected call collections deque bad arguments hints= Fix call collections deque graph_break_hints USER_ERROR from_exc=e iterable bound_args arguments bound_args arguments iterable has_force_unpack_var_sequence tx unimplemented_v gb_type= collections deque bad iterable argument context=f args= args kwargs= kwargs explanation= Call collections deque has iterable argument Dynamo cannot convert list hints= Use simpler sequence type Dynamo can convert list e g list tuple list iterator etc graph_break_hints USER_ERROR items = bound_args arguments iterable force_unpack_var_sequence tx items = maxlen bound_args arguments maxlen = bound_args arguments maxlen variables lists DequeVariable items maxlen=maxlen mutation_type=ValueMutationNew value weakref ref len args callback = args callback = variables ConstantVariable create None variables WeakRefVariable args callback value functools partial args unimplemented_v gb_type= missing args functools partial context= explanation= functools partial requires least one argument hints= Fix functools partial call graph_break_hints USER_ERROR The first arg callable ctor below will assert types fn = args rest_args = args guards produced FunctoolsPartialVariable installed FunctoolsPartialVariable ctor args keywords variables functions FunctoolsPartialVariable fn args=rest_args keywords=kwargs value warnings catch_warnings args variables CatchWarningsCtxManagerVariable create tx kwargs value torch cuda device kwargs len args == args is_python_constant raise_type_error_exc tx torch cuda device requires constant argument variables CUDADeviceVariable create tx args as_python_constant issubclass type value type hasattr value __enter__ TODO voz These can invoke user code hasattr value __exit__ TODO voz These can invoke user code is_standard_new SideEffects cls_supports_mutation_side_effects value source is_forbidden_context_manager value TorchCtxManagerClassVariable functions BaseUserFunctionVariable FunctionDecoratedByContextlibContextManagerVariable graph break any contextlib contextlib contextmanager Some APIs below supported because they rely features Dynamo doesn t play well today i e contextlib suppress value contextlib _AsyncGeneratorContextManager contextlib closing contextlib redirect_stdout contextlib redirect_stderr contextlib suppress contextlib ExitStack contextlib AsyncExitStack We changing behavior Dynamo these function already ignored trace_rules py before landed unimplemented_v gb_type= unsupported contextlib API context=f value explanation=f value supported This may due its use context-specific operations supported Dynamo yet i e Exception handling hints= graph_break_hints SUPPORTABLE value contextlib _GeneratorContextManager isinstance args BaseUserFunctionVariable TorchCtxManagerClassVariable torch _dynamo config enable_trace_contextlib unimplemented_v gb_type= attempted trace contextlib contextmanager context=f args= args explanation= Tracing contextlib contextmanager disabled hints= Set torch _dynamo config enable_trace_contextlib = True Special treatments certain context managers created via contextlib because we pytorch own their impls s tedious trace through them so we effectively allow graph them without sacrificing soundness We would typically reach here via either instance construction ` ctx_manager ` https github com python cpython blob Lib contextlib py#L calling function decorated context manager https github com python cpython blob Lib contextlib py#L So we basically trace through surface part contextlib code then special case shared remaining logic actual context manager instance construction usage later isinstance args TorchCtxManagerClassVariable fn_var = args args_list = args items kwargs_dict = args keys_as_python_constant fn_var call_function tx args_list kwargs_dict Wrap UserFunctionVariable FunctionDecoratedByContextlibContextManagerVariable function annotated contextlib contextmanager This shouldn t necessary once generator functions fully supported dynamo args = FunctionDecoratedByContextlibContextManagerVariable args source=args source + args cm_obj = tx output side_effects track_new_user_defined_object variables BuiltinVariable object args cm_obj call_method tx __init__ args kwargs cm_obj is_namedtuple_cls value fields = namedtuple_fields value check quasi-namedtuple real one value __module__ == torch return_types kwargs len args = raise_args_mismatch tx torch return_types args kwargs f len args args len kwargs kwargs items = args force_unpack_var_sequence tx field_defaults = value _field_defaults items = list args items extend None len fields - len items var_tracker_kwargs = field_name var_tracker zip fields items var_tracker None field_name kwargs field_var = kwargs field_name assert field_name field_defaults field_var = VariableTracker build tx field_defaults field_name var_tracker_kwargs field_name = field_var name value var_tracker_kwargs items assert name fields items fields index name = value assert all x None x items Modify mutability namedtuple sourcelesss instantiations base AttributeMutationNew variables NamedTupleVariable items value mutation_type=AttributeMutationNew value torch Size This simulates ` THPSize_pynew ` C impl ` Size __new__ ` tup = variables BuiltinVariable tuple call_function tx args kwargs SizeVariable tup items is_frozen_dataclass value is_standard_new fields = dataclasses fields value fields_source = DataclassFieldsSource source items = list args items extend None len fields - len items default_kwargs = ind field var_tracker zip itertools count fields items var_tracker None field name kwargs var_tracker = kwargs field name field init continue field default dataclasses MISSING var_tracker = VariableTracker build tx field default source=AttrSource GetItemSource fields_source ind default field default_factory dataclasses MISSING factory_fn = VariableTracker build tx field default_factory var_tracker = factory_fn call_function tx we subclass constructor could possibly missing args continue default_kwargs field name = var_tracker kwargs update default_kwargs var = tx output side_effects track_new_user_defined_object variables BuiltinVariable object args var call_method tx __init__ args kwargs var value _in_graph_classes is_traceable_wrapper_subclass_type value torch LongTensor cannot accept list FakeTensors So we stack list FakeTensors instead np value tensortype_to_dtype len args == isinstance args variables ListVariable len args items all isinstance x variables TensorVariable x args items Stack FakeTensor stacked = wrap_fx_proxy tx=tx proxy=tx output create_proxy call_function torch stack proxy_args_kwargs args kwargs args = stacked issubclass value torch Stream constant ConstantVariable lists TupleVariable Register newly created stream reconstruction var_kwargs = ConstDictVariable ConstantVariable k v k v kwargs items var_args = TupleVariable list args stream = value var_args as_python_constant var_kwargs as_python_constant graph_bytecode_inputs register_graph_created_object streams StreamVariable ind = register_graph_created_object stream StreamVariable make_construct_in_graph_stream_fn var_args var_kwargs tensor_variable = wrap_fx_proxy tx=tx proxy=tx output create_proxy call_function get_external_object_by_index ind user_obj_index=ind tensor_variable = wrap_fx_proxy tx=tx proxy=tx output create_proxy call_function value proxy_args_kwargs args kwargs tensor_variable value random Random len args == isinstance args variables ConstantVariable seed = args value seed = None random_object = random Random seed RandomVariable random_object value types MappingProxyType len args == isinstance args variables ConstDictVariable types MappingProxyType read-only proxy dict If original dict changes changes reflected proxy well variables MappingProxyVariable args SideEffects cls_supports_mutation_side_effects value source do_not_convert_to_tracable_parameter tx inline_user_function_return VariableTracker build tx polyfills instantiate_user_defined_class_object args kwargs super call_function tx args kwargs is_standard_new Check __new__ being overridden new_fn = inspect getattr_static value __new__ None isinstance new_fn staticmethod new_fn = new_fn __func__ new_fn object __new__ call_obj_hasattr tx InstructionTranslator name str - VariableTracker source source = AttrSource source name install_guard source make_guard GuardBuilder HASATTR variables ConstantVariable hasattr value name super call_obj_hasattr tx name const_getattr tx InstructionTranslator name name == __name__ value __name__ super const_getattr tx name UserDefinedExceptionClassVariable UserDefinedClassVariable property fn value NO_SUCH_SUBOBJ pass call_random_fn tx fn args kwargs builder VariableBuilder args = x as_python_constant x args kwargs = k v as_python_constant k v kwargs items random_call_index = len tx output random_calls example_value = fn args kwargs source = RandomValueSource random_call_index tx output random_calls append fn args kwargs TODO arguably should route wrap_symint wrap_symfloat currently hypothetical I m going poke my hand nest now VariableBuilder tx source wrap_unspecialized_primitive example_value UserDefinedObjectVariable UserDefinedVariable Mostly objects defined type Catch-all something where we only know type _nonvar_fields = value value_type attrs_directly_modifed_on_dict UserDefinedVariable _nonvar_fields __init__ value value_type=None cls_source=None base_cls_vt=None init_args=None kwargs - None super __init__ kwargs value = value value_type = value_type type value assert type value value_type This used __new__ when new object sourceless user can sourceful cls_source = cls_source cls_source None source None cls_source = TypeSource source These attributes used reconstruct user defined object The pseudo code looks like Builtin C __new__ do support kwargs so init_args sufficient obj = base_cls __new__ user_cls args base_cls_vt = base_cls_vt init_args = init_args This records names attributes modified via instance ` __dict__ ` directly rather than normal setattr path TODO consider emulating ` obj __dict__ ` ` ConstDictVariable ` get rid these workarounds here ` GetAttrVariable ` attrs_directly_modifed_on_dict = set __str__ - str inner = value_type __name__ inner builtin_function_or_method getset_descriptor method_descriptor method inner = str getattr value __name__ None f __class__ __name__ inner __repr__ - str f __class__ __name__ value_type __name__ is_underlying_vt_modified side_effects False python_type value_type as_python_constant torch utils _pytree pytree pytree is_constant_class value_type source None install_guard source make_guard GuardBuilder EQUALS_MATCH value TODO try reconstructing object e g leveraging side effects ` as_python_constant ` super as_python_constant guard_as_python_constant source install_guard source make_guard GuardBuilder ID_MATCH value super guard_as_python_constant torch_function_check assert has_torch_function f calling torch function object without __torch_function__ get_torch_fn tx torch_function_check torch_function get_torch_function_fn get_torch_function_fn tx call_torch_function tx InstructionTranslator fn types args kwargs torch_function_check torch_function call_torch_function call_torch_function tx get_torch_fn tx fn types args kwargs staticmethod functools cache _supported_random_functions fns = random random random randint random randrange random uniform fns _maybe_get_baseclass_method name name getattr value __dict__ try inspect getattr_static type value name except AttributeError pass None call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker ConstantVariable UserMethodVariable method = _maybe_get_baseclass_method name method None method object __init__ ConstantVariable create None is_standard_setattr method isinstance value threading local method_setattr_standard tx args kwargs is_standard_delattr method method_setattr_standard tx args variables DeletedVariable method object __eq__ len args == kwargs other = args isinstance other UserDefinedObjectVariable variables ConstantVariable create NotImplemented TODO anijain - Identity checking should already part cmp_eq polyfill function ConstantVariable create value other value torch _dynamo config enable_faithful_generator_behavior isinstance value types GeneratorType unimplemented_v gb_type= call_method generator context=f object= value method= name args= args kwargs= kwargs explanation= Detected method call user-defined generator object This fully supported hints= Set ` torch _dynamo config enable_faithful_generator_behavior = False ` Note may cause silent incorrectness since we will eagerly unpack generators instead lazily evaluating them check methods implemented C++ isinstance method types FunctionType source = source source_fn = None source source_fn = get_source_by_walking_mro name TODO jansel add guard check monkey patching mutation_guard unpatched_nn_module_init method torch nn Module __init__ method = unpatched_nn_module_init UserMethodVariable method source_fn=source_fn source=source call_function tx args kwargs method list __len__ source args kwargs install_guard source make_guard GuardBuilder SEQUENCE_LENGTH ConstantVariable len value super call_method tx name args kwargs method_setattr_standard tx InstructionTranslator name value directly_update_dict=False try name = name as_python_constant except NotImplementedError unimplemented_v gb_type= non-const setattr name user-defined object context=f object= name= name value= value explanation= Detected call ` setattr ` user-defined object non-constant name hints= Ensure name string assert tx output side_effects is_attribute_mutation Attempted setattr user-defined object does have AttributeMutation mutation_type directly_update_dict attrs_directly_modifed_on_dict add name tmp = try_get_descritor_and_setter_py_func name tmp descriptor setter = tmp Emulate https github com python cpython blob Objects object c#L -L desc_source = None func_source = None cls_source desc_source = get_source_by_walking_mro name use ` type ` ignore instance attrs func_source = AttrSource TypeSource desc_source __set__ desc_var = VariableTracker build tx descriptor desc_source func_var = VariableTracker build tx setter func_source args = desc_var value func_var call_function tx args NOTE we assume descriptor any has side-effect-free ` __set__ ` far Dynamo tracing concerned Emulate standard setattr instance dict tx output side_effects store_attr name value variables ConstantVariable None needs_slow_setattr is_standard_setattr inspect getattr_static value __setattr__ None isinstance value threading local unpack_var_sequence tx source _maybe_get_baseclass_method __iter__ list __iter__ _maybe_get_baseclass_method __len__ list __len__ _maybe_get_baseclass_method __getitem__ list __getitem__ install_guard source make_guard GuardBuilder SEQUENCE_LENGTH variables LazyVariableTracker create value k source=GetItemSource source k k range len value super unpack_var_sequence tx has_force_unpack_var_sequence tx InstructionTranslator - bool try variables BuiltinVariable iter call_function tx True except ObservedTypeError handle_observed_exception tx False force_unpack_var_sequence tx result = iter_ = variables BuiltinVariable iter call_function tx while True try r = iter_ next_variable tx result append r except ObservedUserStopIteration handle_observed_exception tx break result next_variable tx call_method tx __next__ is_supported_random try value _supported_random_functions except TypeError TypeError unhashable type False call_function tx InstructionTranslator args list VariableTracker kwargs dict str VariableTracker - VariableTracker is_supported_random all k is_python_constant k args all v is_python_constant v kwargs values call_random_fn tx value args kwargs istype value types MethodType func = value __func__ obj = value __self__ func torch utils _contextlib _DecoratorContextManager clone variables TorchCtxManagerClassVariable is_matching_cls obj __class__ args kwargs variables TorchCtxManagerClassVariable obj __class__ call_function tx args kwargs func torch autograd grad_mode inference_mode clone obj __class__ torch autograd grad_mode inference_mode simulate inference_mode clone implementation var = variables ConstantVariable obj mode variables TorchCtxManagerClassVariable obj __class__ call_function tx var kwargs source None unimplemented_v gb_type= attempted call sourceless user-defined object method context=f object= value function= func args= args kwargs= kwargs explanation= Dynamo does support hints= f Ensure user-defined object value constructed outside compiled region func_src = AttrSource source __func__ func_var = VariableTracker build tx func func_src obj_src = AttrSource source __self__ obj_var = VariableTracker build tx obj obj_src func_var call_function tx obj_var + args kwargs callable value source source = AttrSource cls_source __call__ install_guard source make_guard GuardBuilder CLOSURE_MATCH call_method tx __call__ args kwargs super call_function tx args kwargs _check_for_getattr get_custom_getattr value _is_c_defined_property subobj isinstance subobj property False pybind def_readwrite implemented via PyCFunction At python level visible property whose fget instancemethod wrapper - https docs python org c-api method html#c PyInstanceMethod_Check If we have PyCFunction we make assumption there no side effect isinstance subobj fget types BuiltinFunctionType torch _C _dynamo utils is_instancemethod subobj fget _getattr_static name subobj = inspect getattr_static value name NO_SUCH_SUBOBJ In some cases we have do dynamic lookup because getattr_static enough For example threading local has side-effect free __getattribute__ attribute visible without dynamic lookup NOTE we assume following descriptors side-effect-free far Dynamo tracing concerned object_has_getattribute value subobj NO_SUCH_SUBOBJ e g threading local inspect ismemberdescriptor subobj e g __slots__ inspect isgetsetdescriptor subobj e g __dict__ _is_c_defined_property subobj Call __getattribute__ we have already checked overridden side-effect free We don t want call getattr because can user-overridden subobj = type value __getattribute__ value name object_has_getattribute value subobj NO_SUCH_SUBOBJ If object has overridden getattribute method Dynamo has already tried tracing encountered AttributeError We call getattr_static only when __getattribute__ tracing fails check var_getattr impl So safe here raise AttributeError raise AttributeError subobj should_skip_descriptor_setter attr_name Check ` attr_name ` corresponds descriptor descriptor = inspect getattr_static type value attr_name None setter = inspect getattr_static type descriptor __set__ None setter Skip ` __set__ ` traceable no need redo side effect inspect isfunction setter True For untraceable ` __set__ ` we should still skip attribute mutated via instance ` __dict__ ` attr_name attrs_directly_modifed_on_dict True False try_get_descritor_and_setter_py_func attr_name descriptor = inspect getattr_static type value attr_name None setter = inspect getattr_static type descriptor __set__ None inspect isfunction setter descriptor setter None has_key_in_generic_dict tx InstructionTranslator key tx output side_effects has_pending_mutation_of_attr key mutated_attr = tx output side_effects load_attr key deleted_ok=True isinstance mutated_attr variables DeletedVariable key value __dict__ get_source_by_walking_mro name assert cls_source None idx klass enumerate type value __mro__ name klass __dict__ idx = mro_source = TypeMROSource cls_source klass_source = GetItemSource mro_source idx klass_source = cls_source dict_source = TypeDictSource klass_source out_source = DictGetItemSource dict_source name absent_idx range idx Insert guard name present mro hierarchy mro_source = TypeMROSource cls_source klass_source = GetItemSource mro_source absent_idx dict_source = TypeDictSource klass_source install_guard dict_source make_guard functools partial GuardBuilder DICT_CONTAINS key=name invert=True Insert guard name present object __dict__ source hasattr value __dict__ name value __dict__ install_guard source make_guard functools partial GuardBuilder NOT_PRESENT_IN_GENERIC_DICT attr=name out_source unimplemented_v gb_type= could find name object s mro context=f name= name object type= type value mro= type value __mro__ explanation=f Could find name ` name ` mro type value __mro__ hints= f Ensure name ` name ` defined somewhere value s type hierarchy graph_break_hints USER_ERROR var_getattr tx InstructionTranslator name ConstantVariable source = AttrSource source name source None object_has_getattribute value getattribute_fn = inspect getattr_static type value __getattribute__ source new_source = AttrSource source __getattribute__ try variables UserMethodVariable getattribute_fn source=new_source call_function tx ConstantVariable create name except ObservedAttributeError Pass through __getattr__ __getattribute__ fails handle_observed_exception tx tx output side_effects has_pending_mutation_of_attr name result = tx output side_effects load_attr name deleted_ok=True isinstance result variables DeletedVariable raise_observed_exception AttributeError tx msg=f type value __name__ object has no attribute name result name == __dict__ options = source source variables GetAttrVariable name options TODO anijain - Investigate we need specialization more dunder attrs inspect getattr_static does correct value them name == __class__ cls_source = source cls_source None cls_source = cls_source options = source cls_source UserDefinedClassVariable type value options try subobj = _getattr_static name except AttributeError subobj = NO_SUCH_SUBOBJ getattr_fn = _check_for_getattr isinstance getattr_fn types FunctionType Dynamo going trace __getattr__ function args=name Set source accordingly getattr_fn unpatched_nn_module_getattr isinstance variables UnspecializedNNModuleVariable prevent against overwriting params buffers submodules istype value _parameters dict istype value _buffers dict istype value _modules dict Manually trace out nn module __getattr__ avoid large compilation latency out = manually_trace_nn_module_getattr tx name new_source = None source new_source = AttrSource source __getattr__ out = variables UserMethodVariable getattr_fn source=new_source call_function tx ConstantVariable create name source getattr_fn torch nn Module __getattr__ isinstance out variables UnspecializedNNModuleVariable variables NNModuleVariable nn_module_stack source BC surface area Ensure mod _modules linear reflected mod linear nn_module_stack out set_nn_module_stack_source AttrSource get_nn_module_stack_source name out getattr_fn None unimplemented_v gb_type= User-defined object non-function __getattr__ context=f object= value name= name getattr_fn= getattr_fn explanation=f Found non-function __getattr__ getattr_fn user-defined object value f when attempting getattr ` name ` hints= Ensure object s __getattr__ function type mutation_guard unpatched_nn_module_init subobj torch nn Module __init__ subobj = unpatched_nn_module_init subobj_from_class = inspect getattr_static value __class__ name NO_SUCH_SUBOBJ is_accessible_from_type_mro = subobj_from_class subobj cls_source None source None hasattr value __dict__ name value __dict__ isinstance subobj property source Read attribute reach property source = get_source_by_walking_mro name Get getter function source = AttrSource source fget fget_vt = VariableTracker build tx subobj fget source=source fget_vt call_function tx isinstance subobj _collections _tuplegetter namedtuple fields represented _tuplegetter here we emulate its ` __get__ ` which implemented C _ idx _ = subobj __reduce__ Don t go through ` __getitem__ ` method anymore see https github com python cpython blob f b f b f Modules _collectionsmodule c#L assert isinstance UserDefinedTupleVariable _tuple_vt items idx isinstance subobj staticmethod Safe because ` staticmethod __get__ ` basically won t trigger user code just returns underlying ` __func__ ` https github com python cpython blob Objects funcobject c#L -L is_accessible_from_type_mro Accessing __dict__ does resolve descriptor returns staticmethod object so access __func__ attribute get actual function source = AttrSource get_source_by_walking_mro name __func__ func = subobj __get__ value VariableTracker build tx func source isinstance subobj classmethod source_fn = None is_accessible_from_type_mro Accessing __dict__ does resolve descriptor returns classmethod object so access __func__ attribute get actual function source_fn = AttrSource get_source_by_walking_mro name __func__ variables UserMethodVariable subobj __func__ var_getattr tx __class__ source_fn=source_fn source=source isinstance subobj types ClassMethodDescriptorType e g inspect getattr_static fromkeys func = subobj __get__ value None VariableTracker build tx func source is_lru_cache_wrapped_function subobj getattr_static returns lru_wrapped function we cannot extract underlying method wrapped function To handle manually create wrapped user method vt variables WrapperUserMethodVariable subobj __wrapped__ source=source inspect getattr_static type subobj __get__ NO_SUCH_SUBOBJ NO_SUCH_SUBOBJ is_wrapper_or_member_descriptor type subobj __get__ Emulate https github com python cpython blob Objects object c#L -L Attribute has __get__ method Create user defined object vt subobj then trace __get__ method descriptor_source = None descriptor_get_source = None cls_source To access method descriptor udf object w o using inspect getattr_static we can look into mro descriptor_source = get_source_by_walking_mro name descriptor_get_source = AttrSource TypeSource descriptor_source __get__ descriptor_var = VariableTracker build tx subobj descriptor_source Sourceless Builder does support user defined objects descriptor_var = UserDefinedObjectVariable subobj The arguments __get__ function instance owner - descriptor_var instance - instance represented here owner - object owner_var = UserDefinedClassVariable type value variables UserMethodVariable subobj __get__ __func__ descriptor_var source=descriptor_get_source call_function tx owner_var isinstance subobj types FunctionType isinstance subobj types MethodType isinstance value torch nn Module Since we get subobj via _getattr_static which may trigger dynamic lookup Static lookup can t tell us s method function correctly so we trigger dynamic lookup here get correct type dynamic_subobj = getattr value name while dynamic_subobj subobj hasattr subobj _torchdynamo_inline subobj = subobj _torchdynamo_inline dynamic_subobj = subobj source = AttrSource source _torchdynamo_inline source None isinstance subobj types MethodType dynamic_subobj __self__ value isinstance dynamic_subobj __func__ types FunctionType unimplemented_v gb_type= User-defined object method non-function __func__ context=f object= value name= name method= dynamic_subobj f method __self__= dynamic_subobj __self__ method __func__= dynamic_subobj __func__ explanation=f Method dynamic_subobj name= name user-defined object value has f __func__ dynamic_subobj __func__ function type hints= Ensure method s __func__ function type Use __self__ attribute method find source new object self_source = None source None self_source = AttrSource source __self__ object_vt = VariableTracker build tx dynamic_subobj __self__ self_source variables UserMethodVariable dynamic_subobj __func__ object_vt func = subobj __func__ assert isinstance subobj types FunctionType func = subobj inspect ismethod dynamic_subobj source_fn = None is_accessible_from_type_mro source_fn = get_source_by_walking_mro name variables UserMethodVariable func source_fn=source_fn source=source inspect isfunction dynamic_subobj VariableTracker build tx func source wrap source only inline_inbuilt_nn_modules set fsdp modules This temporary solution keep Dynamo behavior compatible no inlining there will some delay turn flag fbcode torch _dynamo config inline_inbuilt_nn_modules isinstance variables FSDPManagedNNModuleVariable source isinstance variables UnspecializedNNModuleVariable export has some awkwardness around specialized unspecialized modules Skip wrapping source export usecase now tx output export torch _dynamo config install_free_tensors Recalculate source params buffers name _buffers _parameters source = UnspecializedParamBufferSource source name source = _wrap_source source subobj NO_SUCH_SUBOBJ is_wrapper_or_member_descriptor subobj torch _C _dynamo utils is_instancemethod subobj is_cython_function subobj options = source source variables GetAttrVariable name options source is_accessible_from_type_mro source = get_source_by_walking_mro name variables LazyVariableTracker create subobj source Check subobj accessible itself If source known we can create sourceful variable tracker cls_source None subobj_from_class = inspect getattr_static value __class__ name NO_SUCH_SUBOBJ subobj_from_class subobj src_from_class = AttrSource cls_source name variables LazyVariableTracker create subobj_from_class src_from_class VariableTracker build tx subobj Earlier we returning GetAttrVariable its incorrect In absence attr Python raises AttributeError raise_observed_exception AttributeError tx msg=f type value __name__ object has no attribute name call_obj_hasattr tx InstructionTranslator name str - VariableTracker source install_guard AttrSource source name make_guard GuardBuilder HASATTR try var_vt = var_getattr tx name variables ConstantVariable create isinstance var_vt variables DeletedVariable except ObservedAttributeError handle_observed_exception tx variables ConstantVariable create False FrozenDataClassVariable UserDefinedObjectVariable HashWrapper This hashed dataclass used key dict It s necessary avoid side effects calling __init__ dataclass when hashing __init__ c fields cls = c fields = tuple fields items __eq__ other type type other cls == other cls fields == other fields __hash__ hash cls fields staticmethod create tx value source dataclasses fields assert is_frozen_dataclass value field_map = field fields value hasattr value field name field_map field name = VariableTracker build tx getattr value field name source AttrSource source field name FrozenDataClassVariable value fields=field_map source=source __init__ value fields=None kwargs - None super __init__ value kwargs fields None fields = fields = fields as_python_constant NOTE intentionally limited version ` as_python_constant ` ` nonstrict_trace ` implementation dataclasses fields torch utils _pytree pytree istype value pytree TreeSpec pytree LeafSpec pytree ConstantNode TODO loosen restriction fix ` as_proxy ` raise NotImplementedError currently can t reconstruct arbitrary frozen dataclass instances args = kwargs = field fields value field init data = fields field name as_python_constant getattr field kw_only False kwargs field name = data args append data This safe because we know TreeSpec classes constructors don t have external side effects ctor = python_type ctor args kwargs as_proxy dataclasses fields args = kwargs = field fields value proxy = fields field name as_proxy hasattr field kw_only field kw_only kwargs field name = proxy args append proxy TODO isn t really safe because could invoke user defined ` __post_init__ ` could invoke user defined ` __init__ ` _subclasses_ frozen dataclass Either above could end up mutating external state ctor = python_type ctor args kwargs reconstruct codegen PyCodegen - None Handle specific pytree classes torch utils _pytree pytree value_type pytree LeafSpec Create new LeafSpec instance calling constructor codegen add_push_null lambda codegen load_import_from torch utils _pytree LeafSpec codegen extend_output create_call_function False For other frozen dataclasses fall back base behavior super reconstruct codegen NB This called during __init__ frozen dataclass use accumulate most up-to-date field values method_setattr_standard tx InstructionTranslator name value fields name as_python_constant = value super method_setattr_standard tx name value __repr__ - str f __class__ __name__ value_type __name__ SourcelessGraphModuleVariable UserDefinedObjectVariable __init__ value kwargs - None super __init__ value kwargs call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker fn_variable = VariableTracker build tx value forward __func__ args = + args tx inline_user_function_return fn_variable args kwargs UserDefinedExceptionObjectVariable UserDefinedObjectVariable __init__ value kwargs super __init__ value kwargs exc_vt = variables ExceptionVariable value_type property fn value_type call_method tx name args kwargs name == __init__ method = _maybe_get_baseclass_method name inspect ismethoddescriptor method len kwargs == exc_vt args = args value args = args variables ConstantVariable None name == __setattr__ len args == isinstance args variables ConstantVariable args value __cause__ __context__ __suppress_context__ __traceback__ exc_vt call_setattr tx args args name == with_traceback exc_vt call_method tx name args kwargs super call_method tx name args kwargs property __context__ exc_vt __context__ property args exc_vt args set_context context variables ExceptionVariable exc_vt set_context context property exc_type exc_vt exc_type KeyedJaggedTensorVariable UserDefinedObjectVariable staticmethod is_matching_object obj mod = sys modules get torchrec sparse jagged_tensor mod None type obj mod KeyedJaggedTensor __init__ value kwargs - None torchrec sparse jagged_tensor KeyedJaggedTensor assert type value KeyedJaggedTensor super __init__ value kwargs var_getattr tx InstructionTranslator name torch _dynamo config force_unspec_int_unbacked_size_like_on_torchrec_kjt source None name _length_per_key _offset_per_key TracingContext patch force_unspec_int_unbacked_size_like=True super var_getattr tx name super var_getattr tx name IntWrapperVariable UserDefinedObjectVariable Dummy check object IntWrapper turn into symint staticmethod is_matching_object obj mod = sys modules get torch export dynamic_shapes mod None type obj mod _IntWrapper RemovableHandleClass Dummy pass python_type RemovableHandleVariable Useful isinstance check hooks pass RemovableHandleVariable VariableTracker REMOVED = - __init__ mutation_type=None index registration side_effects owned register_hook handle list used during removal idx=None kwargs - None super __init__ kwargs mutation_type = mutation_type idx = idx call_method tx InstructionTranslator method_name args kwargs method_name == remove idx = REMOVED tx output side_effects remove_hook idx idx = REMOVED variables ConstantVariable create None super call_method tx method_name args kwargs reconstruct codegen PyCodegen idx == REMOVED Hook has already been removed dummy handle codegen add_push_null lambda codegen load_import_from torch _dynamo utils invalid_removeable_handle codegen extend_output create_call_function False unreachable due codegen add_cache when hook installed super reconstruct codegen python_type RemovableHandleClass UserDefinedDictVariable UserDefinedObjectVariable Represents user defined objects subclasses dict OrderedDict Internally uses ConstDictVariable represent dict part variable tracker For everything falls back UserDefinedObjectVariable _nonvar_fields = UserDefinedObjectVariable _nonvar_fields __init__ value dict_vt=None kwargs super __init__ value kwargs _dict_vt = dict_vt _dict_vt None assert source None dict_vt must constructed builder py when source present _dict_vt = variables ConstDictVariable type value mutation_type=ValueMutationNew _dict_methods = dict_methods call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker method = _maybe_get_baseclass_method name method _dict_methods Dict subclasses can override __missing__ provide fallback behavior instead raising KeyError This used example collections Counter try _dict_vt call_method tx name args kwargs except ObservedKeyError name == __getitem__ issubclass python_type dict _maybe_get_baseclass_method __missing__ call_method tx __missing__ args kwargs raise super call_method tx name args kwargs unpack_var_sequence tx type value __iter__ dict __iter__ collections OrderedDict __iter__ _dict_vt unpack_var_sequence tx raise NotImplementedError is_underlying_vt_modified side_effects side_effects is_modified _dict_vt property user_cls _dict_vt user_cls property items _dict_vt items install_dict_keys_match_guard _dict_vt install_dict_keys_match_guard install_dict_contains_guard _dict_vt install_dict_contains_guard UserDefinedSetVariable UserDefinedObjectVariable Represents user defined objects subclasses set Internally uses SetVariable represent set part variable tracker For everything falls back UserDefinedObjectVariable _nonvar_fields = UserDefinedObjectVariable _nonvar_fields __init__ value set_vt=None kwargs super __init__ value kwargs _set_vt = set_vt python_type = set isinstance value set frozenset _set_methods = set_methods python_type set frozenset_methods _set_vt None assert source None set_vt must constructed builder py when source present python_type set set initialized later _set_vt = variables SetVariable mutation_type=ValueMutationNew init_args = kwargs get init_args tx = torch _dynamo symbolic_convert InstructionTranslator current_tx _set_vt = variables BuiltinVariable python_type call_function tx init_args call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker method = _maybe_get_baseclass_method name method _set_methods _set_vt call_method tx name args kwargs super call_method tx name args kwargs as_python_constant _set_vt as_python_constant unpack_var_sequence tx inspect getattr_static value __iter__ set __iter__ frozenset __iter__ _set_vt unpack_var_sequence tx raise NotImplementedError property set_items _set_vt set_items property items _set_vt items is_underlying_vt_modified side_effects side_effects is_modified _set_vt install_dict_keys_match_guard _set_vt install_dict_keys_match_guard install_dict_contains_guard _set_vt install_dict_contains_guard UserDefinedListVariable UserDefinedObjectVariable Represents user defined objects subclasses lists Internally uses ListVariable represent list part variable tracker For everything falls back UserDefinedObjectVariable _nonvar_fields = UserDefinedObjectVariable _nonvar_fields __init__ value list_vt=None kwargs super __init__ value kwargs _list_vt = list_vt _list_vt None assert source None list_vt must constructed builder py when source present _list_vt = variables ListVariable mutation_type=ValueMutationNew call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker assert _list_vt None method = _maybe_get_baseclass_method name method list_methods _list_vt call_method tx name args kwargs super call_method tx name args kwargs unpack_var_sequence tx assert _list_vt None type value __iter__ list __iter__ _list_vt unpack_var_sequence tx raise NotImplementedError is_underlying_vt_modified side_effects side_effects is_modified _list_vt UserDefinedTupleVariable UserDefinedObjectVariable Represents user defined objects subclasses tuple Internally uses TupleVariable represent tuple part variable tracker For everything falls back UserDefinedObjectVariable _nonvar_fields = UserDefinedObjectVariable _nonvar_fields __init__ value tuple_vt=None init_args=None kwargs super __init__ value init_args=init_args kwargs _tuple_vt = tuple_vt _tuple_vt None assert source None tuple_vt must constructed builder py when source present Emulate ` tuple __new__ ` https github com python cpython blob Objects tupleobject c#L -L TODO duplicates logic ` BuiltinVariable tuple ` torch _dynamo symbolic_convert InstructionTranslator tx = InstructionTranslator current_tx elems = init_args force_unpack_var_sequence tx _tuple_vt = variables TupleVariable elems mutation_type=ValueMutationNew call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker assert _tuple_vt None method = _maybe_get_baseclass_method name method tuple_methods _tuple_vt call_method tx name args kwargs super call_method tx name args kwargs unpack_var_sequence tx assert _tuple_vt None type value __iter__ tuple __iter__ _tuple_vt unpack_var_sequence tx raise NotImplementedError MutableMappingVariable UserDefinedObjectVariable _nonvar_fields = UserDefinedObjectVariable _nonvar_fields __init__ value kwargs super __init__ value kwargs generic_dict_vt = variables ConstDictVariable var_getattr tx InstructionTranslator name str - VariableTracker A common pattern init code MutableMapping objects update __dict__ attribute To prevent graph break we directly ConstDictVariable __dict__attr However users can try add new attribute using __dict__ attribute To catch we save ConstDictVariable __dict__ then lookup into vt each attr lookup name == get type value get collections abc Mapping get dict get variables UserMethodVariable polyfills mapping_get name == __dict__ source generic_dict_vt = variables LazyVariableTracker create value __dict__ AttrSource source __dict__ generic_dict_vt out = generic_dict_vt maybe_getitem_const variables ConstantVariable name out super var_getattr tx name RandomVariable UserDefinedObjectVariable pass