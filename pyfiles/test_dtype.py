Owner s module dynamo functools operator pickle types itertools permutations typing Any unittest skipIf skipif pytest pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests subtest TEST_WITH_TORCHDYNAMO TestCase xfailIfTorchDynamo xpassIfTorchDynamo_np skip = functools partial skipif True TEST_WITH_TORCHDYNAMO numpy np numpy testing assert_ assert_equal torch _numpy np torch _numpy testing assert_ assert_equal numpy assert_dtype_equal b assert_equal b assert_equal hash hash b two equivalent types do hash same value assert_dtype_not_equal b assert_ = b assert_ hash = hash b two different types hash same value instantiate_parametrized_tests TestBuiltin TestCase parametrize t int float complex np int test_run t Only test hash runs all dt = np dtype t hash dt test_equivalent_dtype_hashing Make sure equivalent dtypes different type num hash equal intp = np dtype np intp intp itemsize == left = intp right = np dtype np int left = intp right = np dtype np int assert_ left == right assert_ hash left == hash right xfailIfTorchDynamo TypeError - InternalTorchDynamoError test_invalid_types Make sure invalid type strings raise error assert_raises TypeError np dtype O assert_raises TypeError np dtype O assert_raises TypeError np dtype O assert_raises TypeError np dtype b assert_raises TypeError np dtype h assert_raises TypeError np dtype I assert_raises TypeError np dtype e assert_raises TypeError np dtype f np dtype l itemsize == assert_raises TypeError np dtype l assert_raises TypeError np dtype L assert_raises TypeError np dtype l assert_raises TypeError np dtype L XXX what q my -bit ubuntu matching s int same l np dtype q itemsize == assert_raises TypeError np dtype q assert_raises TypeError np dtype Q assert_raises TypeError np dtype q assert_raises TypeError np dtype Q test_richcompare_invalid_dtype_equality Make sure objects cannot converted valid dtypes results False True when compared valid dtypes Here cannot converted dtype No exceptions should raised assert np dtype np int = dtype richcompare failed == assert np dtype np int = dtype richcompare failed = parametrize operation operator le operator lt operator ge operator gt test_richcompare_invalid_dtype_comparison operation Make sure TypeError raised comparison operators invalid dtypes Here invalid dtype pytest raises TypeError operation np dtype np int skipif numpy __version__ reason= older numpies emit DeprecatioWarnings instead parametrize dtype Bool Bytes Complex Complex Datetime Float Float Float Int Int Int Int Object Str Timedelta UInt UInt Uint UInt Uint UInt Void Float Complex test_numeric_style_types_are_invalid dtype assert_raises TypeError np dtype dtype skip reason= dtype attributes yet implemented TestDtypeAttributeDeletion TestCase test_dtype_non_writable_attributes_deletion dt = np dtype np double attr = subdtype descr str name base shape isbuiltin isnative isalignedstruct fields metadata hasobject s attr assert_raises AttributeError delattr dt s test_dtype_writable_attributes_deletion dt = np dtype np double attr = names s attr assert_raises AttributeError delattr dt s instantiate_parametrized_tests TestPickling TestCase check_pickling dtype proto range pickle HIGHEST_PROTOCOL + buf = pickle dumps dtype proto The dtype pickling itself pickles ` np dtype ` pickled singleton ` dtype ` should stored buffer assert b _DType_reconstruct buf assert b dtype buf pickled = pickle loads buf assert_equal pickled dtype XXX out dtypes do have descr assert_equal pickled descr dtype descr dtype metadata None assert_equal pickled metadata dtype metadata Check reconstructed dtype functional x = np zeros dtype=dtype y = np zeros dtype=pickled assert_equal x y assert_equal x y parametrize t int float complex np int bool test_builtin t check_pickling np dtype t parametrize DType subtest type np dtype t name=f np dtype t name _ i i t enumerate np typecodes All + np dtype test_pickle_types DType Check DTypes classes types roundtrip when pickling proto range pickle HIGHEST_PROTOCOL + roundtrip_DType = pickle loads pickle dumps DType proto assert roundtrip_DType DType skip reason= XXX value-based promotions we don t have instantiate_parametrized_tests TestPromotion TestCase Test cases related more complex DType promotions Further promotion tests defined ` test_numeric py ` parametrize other expected expected_weak - np complex None - np complex np complex subtest np float np complex None name= float _complex _None subtest np float np complex None name= float _complex _None repeat complex scalars subtest np complex np complex None name= complex _complex _None test_complex_other_value_based weak_promotion other expected expected_weak weak_promotion expected_weak None expected = expected_weak This would change we modify value based promotion min_complex = np dtype np complex res = np result_type other min_complex assert res == expected Check same simple ufunc call uses same logic res = np minimum other np ones dtype=min_complex dtype assert res == expected parametrize other expected np bool_ np complex np int np complex np float np complex np float np complex np float np complex np complex np complex np complex np complex test_complex_scalar_value_based other expected This would change we modify value based promotion complex_scalar = j res = np result_type other complex_scalar assert res == expected Check same simple ufunc call uses same logic res = np minimum np ones dtype=other complex_scalar dtype assert res == expected parametrize val test_python_integer_promotion val If we only path scalars mainly python ones result must take into account integer may considered int int uint object depending input value So test those paths expected_dtype = np result_type np array val dtype np array dtype assert np result_type val == expected_dtype For completeness sake also check NumPy scalar second arg assert np result_type val np int == expected_dtype parametrize dtypes expected These promotions associative commutative np int np float np float np int np float np float np uint np int np float np float The following promotions ambiguous cover code paths abstract promotion no particular logic being tested np float np float np complex np complex j np float np complex np int np float j np float np complex j j np float np complex True np bool_ np int_ test_permutations_do_not_influence_result dtypes expected Tests most permutations do influence result In above some uint int combinations promote larger integer type which would then promote larger than necessary float perm permutations dtypes assert np result_type perm == expected TestMisc TestCase test_dtypes_are_true test gh- assert bool np dtype f assert bool np dtype i xpassIfTorchDynamo_np reason= No keyword arg dtype ctor test_keyword_argument test https github com numpy numpy pull #issuecomment- assert np dtype dtype=np float == np dtype np float TestFromDTypeAttribute TestCase test_simple dt dtype = np dtype f assert np dtype dt == np float assert np dtype dt == np float skip reason= We simply require name attribute so fails AttributeError test_recursion dt pass dt dtype = dt pytest raises RecursionError np dtype dt dt_instance = dt dt_instance dtype = dt pytest raises RecursionError np dtype dt_instance skip reason= Parameteric dtypes our stuff simpler instantiate_parametrized_tests TestClassGetItem TestCase test_dtype - None alias = np dtype Any assert isinstance alias types GenericAlias assert alias __origin__ np dtype parametrize code np typecodes All test_dtype_subclass code str - None cls = type np dtype code alias = cls Any assert isinstance alias types GenericAlias assert alias __origin__ cls parametrize arg_len range test_subscript_tuple arg_len int - None arg_tup = Any arg_len arg_len == assert np dtype arg_tup pytest raises TypeError np dtype arg_tup test_subscript_scalar - None assert np dtype Any __name__ == __main__ run_tests