Contains utility functions working nested python data structures A pytree Python nested data structure It tree sense nodes Python collections e g list tuple dict leaves Python values Furthermore pytree should contain reference cycles pytrees useful working nested collections Tensors For example one can use ` tree_map ` map function over all Tensors inside some nested collection Tensors ` tree_leaves ` get flat list all Tensors inside some nested collection pytrees helpful implementing nested collection support PyTorch APIs This pytree implementation very performant due Python overhead To improve performance we can move parts implementation C++ dataclasses functools importlib importlib metadata json threading types warnings collections defaultdict deque namedtuple OrderedDict collections abc Callable Hashable Iterable Mapping Sequence enum Enum typing Any cast ClassVar Final Generic NoReturn Optional overload Protocol TypeVar Union typing_extensions deprecated NamedTuple Self TypeAlias torch torch_version TorchVersion _TorchVersion __all__ = PyTree Context FlattenFunc UnflattenFunc DumpableContext ToDumpableContextFn FromDumpableContextFn PyTreeSpec TreeSpec LeafSpec keystr key_get register_pytree_node tree_is_leaf tree_flatten tree_flatten_with_path tree_unflatten tree_iter tree_leaves tree_leaves_with_path tree_structure tree_map tree_map_with_path tree_map_ tree_map_only tree_map_only_ tree_all tree_any tree_all_only tree_any_only treespec_dumps treespec_loads treespec_pprint is_namedtuple is_namedtuple_class is_namedtuple_instance is_structseq is_structseq_class is_structseq_instance T = TypeVar T S = TypeVar S U = TypeVar U R = TypeVar R DEFAULT_TREESPEC_SERIALIZATION_PROTOCOL = NO_SERIALIZED_TYPE_NAME_FOUND = NO_SERIALIZED_TYPE_NAME_FOUND KeyEntry Protocol __hash__ - int __eq__ other object - bool __str__ - str get parent Any - Any EnumEncoder json JSONEncoder default obj object - Union str dict str Any isinstance obj Enum __enum__ True fqn f obj __class__ __module__ obj __class__ __qualname__ name obj name cast str super default obj Context = Any PyTree = Any FlattenFunc = Callable PyTree tuple list Any Context UnflattenFunc = Callable Iterable Any Context PyTree DumpableContext = Any Any json dumpable text ToDumpableContextFn = Callable Context DumpableContext FromDumpableContextFn = Callable DumpableContext Context ToStrFunc = Callable TreeSpec list str str MaybeFromStrFunc = Callable str Optional tuple Any Context str KeyPath = tuple KeyEntry FlattenWithKeysFunc = Callable PyTree tuple list tuple KeyEntry Any Any A NodeDef holds two callables - flatten_fn should take collection flat list values It can also some context used reconstructing collection - unflatten_fn should take flat list values some context returned flatten_fn It returns collection reconstructing list context - flatten_with_keys_fn which callable takes pytree returns list keypath value pairs context NodeDef NamedTuple type type Any flatten_fn FlattenFunc unflatten_fn UnflattenFunc flatten_with_keys_fn Optional FlattenWithKeysFunc _NODE_REGISTRY_LOCK = threading RLock SUPPORTED_NODES dict type Any NodeDef = _SerializeNodeDef holds following - typ type node e g Dict List etc - serialized_type_name fully qualified name type e g collections OrderedDict - to_dumpable_context takes TreeSpec returns serialized string format context version number - from_dumpable_context takes string representation context version returns deserialized context _SerializeNodeDef NamedTuple typ type Any serialized_type_name str to_dumpable_context Optional ToDumpableContextFn from_dumpable_context Optional FromDumpableContextFn SUPPORTED_SERIALIZED_TYPES dict type Any _SerializeNodeDef = SERIALIZED_TYPE_TO_PYTHON_TYPE dict str type Any = NB we try really hard _cxx_pytree which depends optree much possible This isolation user who using C++ pytree shouldn t pay helps makes things like cpython upgrades easier _optree_minimum_version = _TorchVersion try _optree_version = importlib metadata version optree except importlib metadata PackageNotFoundError No optree package found _cxx_pytree_dynamo_traceable = _cxx_pytree_exists = False _optree_version = _TorchVersion _optree_version = _TorchVersion _optree_version _optree_version _optree_minimum_version optree package less than our required minimum version Pretend optree package doesn t exist NB We will raise ImportError user directly tries ` torch utils _cxx_pytree ` look file check _cxx_pytree_dynamo_traceable = _cxx_pytree_exists = False _cxx_pytree_dynamo_traceable = _cxx_pytree_exists = True _cxx_pytree_imported = False _cxx_pytree_pending_imports list Any = register_pytree_node cls type Any flatten_fn FlattenFunc unflatten_fn UnflattenFunc serialized_type_name Optional str = None to_dumpable_context Optional ToDumpableContextFn = None from_dumpable_context Optional FromDumpableContextFn = None flatten_with_keys_fn Optional FlattenWithKeysFunc = None - None Register container-like type pytree node Note func ` register_dataclass ` simpler way registering container-like type pytree node Args cls type register flatten_fn A callable takes pytree returns flattened representation pytree additional context represent flattened pytree unflatten_fn A callable takes flattened version pytree additional context returns unflattened pytree serialized_type_name A keyword argument used specify fully qualified name used when serializing tree spec to_dumpable_context An optional keyword argument custom specify how convert context pytree custom json dumpable representation This used json serialization which being used torch export right now from_dumpable_context An optional keyword argument custom specify how convert custom json dumpable representation context back original context This used json deserialization which being used torch export right now flatten_with_keys_fn An optional keyword argument specify how access each pytree leaf s keypath when flattening tree-mapping Like ` ` flatten_fn ` ` place List leaf should List keypath leaf _NODE_REGISTRY_LOCK cls SUPPORTED_NODES raise ValueError f cls already registered pytree node _private_register_pytree_node cls flatten_fn unflatten_fn serialized_type_name=serialized_type_name to_dumpable_context=to_dumpable_context from_dumpable_context=from_dumpable_context flatten_with_keys_fn=flatten_with_keys_fn _cxx_pytree_exists _cxx_pytree_imported _cxx_pytree cxx cxx _private_register_pytree_node cls flatten_fn unflatten_fn serialized_type_name=serialized_type_name to_dumpable_context=to_dumpable_context from_dumpable_context=from_dumpable_context args = cls flatten_fn unflatten_fn kwargs = serialized_type_name serialized_type_name to_dumpable_context to_dumpable_context from_dumpable_context from_dumpable_context _cxx_pytree_pending_imports append args kwargs register_dataclass cls type Any field_names Optional list str = None drop_field_names Optional list str = None serialized_type_name Optional str = None - None Registers type has semantics ` ` dataclasses dataclass ` ` type pytree node This simpler API than func ` register_pytree_node ` registering dataclass custom semantics dataclass Args cls The python type register The must have semantics dataclass particular must constructed passing fields field_names Optional List str A list field names correspond non-constant data This list must contain all fields used initialize This argument optional ` ` cls ` ` dataclass which case fields will taken ` ` dataclasses fields ` ` drop_field_names Optional List str A list field names should included pytree serialized_type_name A keyword argument used specify fully qualified name used when serializing tree spec This only needed serializing treespec torch export Example torch Tensor dataclasses dataclass torch utils _pytree pytree dataclass Point x Tensor y Tensor pytree register_dataclass Point point = Point torch tensor torch tensor point = pytree tree_map lambda x x + point assert torch allclose point x torch tensor assert torch allclose point y torch tensor drop_field_names = drop_field_names dataclasses is_dataclass cls field_names None raise ValueError field_names must specified list all fields used f initialize cls dataclass field_names None field_names = f name f dataclasses fields cls f init dataclass_init_fields = f name f dataclasses fields cls f init dataclass_init_fields difference_update drop_field_names dataclass_init_fields = set field_names error_msg = field_names does include all dataclass fields \n missing = dataclass_init_fields - set field_names error_msg += f Missing fields ` field_names ` missing If you want include these fields pytree please add them ` field_names ` otherwise please add them ` drop_field_names ` \n unexpected = set field_names - dataclass_init_fields error_msg += f Unexpected fields ` field_names ` unexpected Please remove these fields add them ` drop_field_names ` \n raise ValueError error_msg _flatten_fn obj Any - tuple list Any Context flattened = flat_names = none_names = name field_names val = getattr obj name val None flattened append val flat_names append name none_names append name flattened flat_names none_names _unflatten_fn values Iterable Any context Context - Any flat_names none_names = context cls dict zip flat_names values strict=True dict fromkeys none_names _flatten_fn_with_keys obj Any - tuple list Any Context flattened flat_names _none_names = _flatten_fn obj type ignore misc GetAttrKey k v k v zip flat_names flattened strict=True flat_names _private_register_pytree_node cls _flatten_fn _unflatten_fn serialized_type_name=serialized_type_name flatten_with_keys_fn=_flatten_fn_with_keys CONSTANT_NODES set type = set register_constant cls type Any - None Registers type pytree node no leaves In func ` torch compile ` region instances these types get passed func ` torch _dynamo nonstrict_trace ` -ed function they treated constant sometimes referred static instance object existed before func ` torch compile ` region we _assume_ no mutation will happen inside func ` torch compile ` region require has non-default ` __eq__ ` ` __hash__ ` methods we guard instance based its ` __eq__ ` method i e new instance fails match any instances previous compilations func ` torch compile ` will recompile function using new instance instance object created inside func ` torch compile ` region we currently don t support using func ` torch _dynamo nonstrict_trace ` -ed function In general your holds Tensors dynamic int float bool values may change run-to-run function being compiled then you probably do want register constant Otherwise you want pass instance func ` torch _dynamo nonstrict_trace ` -ed function you either can t use func ` register_pytree_node ` constant enough you don t want bother using func ` register_pytree_node ` you should consider using function Args cls type register constant This type must hashable Example dataclasses dataclass torch utils _pytree pytree dataclass frozen=True Config norm str pytree register_constant Config config = Config l values spec = pytree tree_flatten config assert len values == cls __eq__ object __eq__ type ignore comparison-overlap raise TypeError register_constant cls expects ` cls ` have non-default ` __eq__ ` implementation Class custom ` __eq__ ` without ` __hash__ ` won t inherit default ` __hash__ ` object see https stackoverflow com cls __hash__ None type ignore comparison-overlap raise TypeError register_constant cls expects ` cls ` have non-default ` __hash__ ` implementation _flatten x type ignore no-untyped-def ConstantNode x _unflatten _ context type ignore no-untyped-def context value _flatten_with_keys x type ignore no-untyped-def ConstantNode x _NODE_REGISTRY_LOCK _private_register_pytree_node cls _flatten _unflatten flatten_with_keys_fn=_flatten_with_keys CONSTANT_NODES add cls is_constant_class cls type Any - bool isinstance cls type cls CONSTANT_NODES dataclasses dataclass frozen=True ConstantNode value Any _is_constant_holder spec TreeSpec - bool Checks spec pytree registered register_constant isinstance spec _context ConstantNode _retrieve_constant spec TreeSpec - Any Given spec pytree registered register_constant retrieves constant _is_constant_holder spec raise AssertionError spec does correspond registered constant pytree tree_unflatten spec _register_namedtuple cls type Any serialized_type_name str - None Registers namedtuple valid pytree node By default namedtuples valid pytree nodes they serializable This API provides argument ` serialized_type_name ` which allows these namedtuples serialized Args cls dataclass type register serialized_type_name The serialized name dataclass This required you want serialize pytree TreeSpec containing namedtuple _private_register_pytree_node cls _namedtuple_flatten _namedtuple_unflatten serialized_type_name=serialized_type_name to_dumpable_context=_namedtuple_serialize from_dumpable_context=_namedtuple_deserialize flatten_with_keys_fn=_namedtuple_flatten_with_keys deprecated ` torch utils _pytree _register_pytree_node ` deprecated Please use ` torch utils _pytree register_pytree_node ` instead category=FutureWarning _register_pytree_node cls type Any flatten_fn FlattenFunc unflatten_fn UnflattenFunc to_str_fn Optional ToStrFunc = None deprecated maybe_from_str_fn Optional MaybeFromStrFunc = None deprecated serialized_type_name Optional str = None to_dumpable_context Optional ToDumpableContextFn = None from_dumpable_context Optional FromDumpableContextFn = None flatten_with_keys_fn Optional FlattenWithKeysFunc = None - None Register container-like type pytree node Python pytree only Args cls type register flatten_fn A callable takes pytree returns flattened representation pytree additional context represent flattened pytree unflatten_fn A callable takes flattened version pytree additional context returns unflattened pytree serialized_type_name A keyword argument used specify fully qualified name used when serializing tree spec to_dumpable_context An optional keyword argument custom specify how convert context pytree custom json dumpable representation This used json serialization which being used torch export right now from_dumpable_context An optional keyword argument custom specify how convert custom json dumpable representation context back original context This used json deserialization which being used torch export right now flatten_with_keys_fn An optional keyword argument specify how access each pytree leaf s keypath when flattening tree-mapping Like ` ` flatten_fn ` ` place List leaf should List keypath leaf to_str_fn None maybe_from_str_fn None warnings warn ` to_str_fn ` ` maybe_from_str_fn ` deprecated Please use ` to_dumpable_context ` ` from_dumpable_context ` instead FutureWarning stacklevel= _private_register_pytree_node cls flatten_fn unflatten_fn serialized_type_name=serialized_type_name to_dumpable_context=to_dumpable_context from_dumpable_context=from_dumpable_context flatten_with_keys_fn=flatten_with_keys_fn _deregister_pytree_node cls type Any - None This internal function used deregister pytree node type Python pytree only This should only used inside PyTorch _NODE_REGISTRY_LOCK del SUPPORTED_NODES cls node_def = SUPPORTED_SERIALIZED_TYPES cls del SERIALIZED_TYPE_TO_PYTHON_TYPE node_def serialized_type_name del SUPPORTED_SERIALIZED_TYPES cls CONSTANT_NODES discard cls _private_register_pytree_node cls type Any flatten_fn FlattenFunc unflatten_fn UnflattenFunc serialized_type_name Optional str = None to_dumpable_context Optional ToDumpableContextFn = None from_dumpable_context Optional FromDumpableContextFn = None flatten_with_keys_fn Optional FlattenWithKeysFunc = None - None This internal function used register pytree node type Python pytree only End-users should use func ` register_pytree_node ` instead _NODE_REGISTRY_LOCK cls SUPPORTED_NODES TODO change warning error after OSS internal stabilize warnings warn f cls already registered pytree node Overwriting previous registration stacklevel= node_def = NodeDef cls flatten_fn unflatten_fn flatten_with_keys_fn SUPPORTED_NODES cls = node_def to_dumpable_context None ^ from_dumpable_context None raise ValueError f Both to_dumpable_context from_dumpable_context cls must None registered serialized_type_name None serialized_type_name = NO_SERIALIZED_TYPE_NAME_FOUND serialize_node_def = _SerializeNodeDef cls serialized_type_name to_dumpable_context from_dumpable_context SUPPORTED_SERIALIZED_TYPES cls = serialize_node_def SERIALIZED_TYPE_TO_PYTHON_TYPE serialized_type_name = cls dataclasses dataclass frozen=True SequenceKey Generic T idx int __str__ - str f idx r get sequence Sequence T - T sequence idx K = TypeVar K bound=Hashable dataclasses dataclass frozen=True MappingKey Generic K T key K __str__ - str f key r get mapping Mapping K T - T mapping key dataclasses dataclass frozen=True GetAttrKey name str __str__ - str f name get obj Any - Any getattr obj name Reference https github com metaopt optree blob main optree typing py is_namedtuple obj Union object type - bool Return whether object instance namedtuple subclass namedtuple cls = obj isinstance obj type type obj is_namedtuple_class cls Reference https github com metaopt optree blob main optree typing py is_namedtuple_class cls type - bool Return whether subclass namedtuple isinstance cls type issubclass cls tuple isinstance getattr cls _fields None tuple all type field str field cls _fields type ignore attr-defined callable getattr cls _make None callable getattr cls _asdict None Reference https github com metaopt optree blob main optree typing py is_namedtuple_instance obj object - bool Return whether object instance namedtuple is_namedtuple_class type obj _T_co = TypeVar _T_co covariant=True Reference https github com metaopt optree blob main optree typing py structseq tuple _T_co A generic type stub CPython s ` ` PyStructSequence ` ` type __slots__ ClassVar tuple = n_fields Final int type ignore misc n_sequence_fields Final int type ignore misc n_unnamed_fields Final int type ignore misc __init_subclass__ cls - NoReturn Prohibit subclassing raise TypeError type structseq acceptable base type __new__ cls type Self sequence Iterable _T_co pyrefly ignore bad-function-definition dict dict str Any = - Self raise NotImplementedError Reference https github com metaopt optree blob main optree typing py is_structseq obj Union object type - bool Return whether object instance PyStructSequence PyStructSequence cls = obj isinstance obj type type obj is_structseq_class cls Set type allows subclassing see CPython s Include object h Py_TPFLAGS_BASETYPE int = Reference https github com metaopt optree blob main optree typing py is_structseq_class cls type - bool Return whether PyStructSequence isinstance cls type Check direct inheritance ` tuple ` rather than ` issubclass cls tuple ` cls __bases__ == tuple Check PyStructSequence members isinstance getattr cls n_fields None int isinstance getattr cls n_sequence_fields None int isinstance getattr cls n_unnamed_fields None int Check type does allow subclassing bool cls __flags__ Py_TPFLAGS_BASETYPE only works CPython Reference https github com metaopt optree blob main optree typing py is_structseq_instance obj object - bool Return whether object instance PyStructSequence is_structseq_class type obj _tuple_flatten d tuple T - tuple list T Context list d None _tuple_flatten_with_keys d tuple T - tuple list tuple KeyEntry T Context values context = _tuple_flatten d pyrefly ignore bad-return SequenceKey i v i v enumerate values context _tuple_unflatten values Iterable T context Context - tuple T tuple values _list_flatten d list T - tuple list T Context d None _list_flatten_with_keys d list T - tuple list tuple KeyEntry T Context values context = _list_flatten d pyrefly ignore bad-return SequenceKey i v i v enumerate values context _list_unflatten values Iterable T context Context - list T list values _dict_flatten d dict Any T - tuple list T Context list d values list d keys _dict_flatten_with_keys d dict Any T - tuple list tuple KeyEntry T Context values context = _dict_flatten d pyrefly ignore bad-return MappingKey k v k v zip context values strict=True context _dict_unflatten values Iterable T context Context - dict Any T dict zip context values strict=True _namedtuple_flatten d NamedTuple - tuple list Any Context list d type d _namedtuple_flatten_with_keys d NamedTuple - tuple list tuple KeyEntry Any Context values context = _namedtuple_flatten d pyrefly ignore bad-return GetAttrKey field v field v zip context _fields values strict=True context _namedtuple_unflatten values Iterable T context Context - NamedTuple cast NamedTuple context values _namedtuple_serialize context Context - DumpableContext context SUPPORTED_SERIALIZED_TYPES raise NotImplementedError f Can t serialize TreeSpec namedtuple context because we didn t register serializated_type_name Please register using ` _register_namedtuple ` serialize_node_def = SUPPORTED_SERIALIZED_TYPES context serialized_type_name = serialize_node_def serialized_type_name serialized_type_name == NO_SERIALIZED_TYPE_NAME_FOUND raise NotImplementedError f Can t serialize TreeSpec namedtuple context because we couldn t find serializated_type_name Please register using ` _register_namedtuple ` serialized_type_name _namedtuple_deserialize dumpable_context DumpableContext - Context dumpable_context SERIALIZED_TYPE_TO_PYTHON_TYPE raise NotImplementedError f Can t deserialize TreeSpec namedtuple dumpable_context because we couldn t find serializated name typ = SERIALIZED_TYPE_TO_PYTHON_TYPE dumpable_context typ _ordereddict_flatten d OrderedDict Any T - tuple list T Context list d values list d keys _ordereddict_flatten_with_keys d OrderedDict Any T - tuple list tuple KeyEntry T Context values context = _ordereddict_flatten d pyrefly ignore bad-return MappingKey k v k v zip context values strict=True context _ordereddict_unflatten values Iterable T context Context - OrderedDict Any T OrderedDict key value key value zip context values strict=True _odict_flatten = _ordereddict_flatten _odict_unflatten = _ordereddict_unflatten _defaultdict_flatten d defaultdict Any T - tuple list T Context values dict_context = _dict_flatten d values d default_factory dict_context _defaultdict_flatten_with_keys d defaultdict Any T - tuple list tuple KeyEntry T Context values context = _defaultdict_flatten d _ dict_context = context pyrefly ignore bad-return MappingKey k v k v zip dict_context values strict=True context _defaultdict_unflatten values Iterable T context Context - defaultdict Any T default_factory dict_context = context defaultdict default_factory _dict_unflatten values dict_context _defaultdict_serialize context Context - DumpableContext default_factory dict_context = context json_defaultdict = default_factory_module default_factory __module__ default_factory_name default_factory __qualname__ dict_context dict_context json_defaultdict _defaultdict_deserialize dumpable_context DumpableContext - Context isinstance dumpable_context dict raise AssertionError dumpable_context must dict expected_keys = default_factory_module default_factory_name dict_context set dumpable_context = expected_keys raise AssertionError f dumpable_context keys must expected_keys got set dumpable_context default_factory_module = dumpable_context default_factory_module default_factory_name = dumpable_context default_factory_name isinstance default_factory_module str raise AssertionError default_factory_module must string isinstance default_factory_name str raise AssertionError default_factory_name must string module = importlib import_module default_factory_module default_factory = getattr module default_factory_name dict_context = dumpable_context dict_context default_factory dict_context _deque_flatten d deque T - tuple list T Context list d d maxlen _deque_flatten_with_keys d deque T - tuple list tuple KeyEntry T Context values context = _deque_flatten d pyrefly ignore bad-return SequenceKey i v i v enumerate values context _deque_unflatten values Iterable T context Context - deque T deque values maxlen=context _private_register_pytree_node tuple _tuple_flatten _tuple_unflatten serialized_type_name= builtins tuple flatten_with_keys_fn=_tuple_flatten_with_keys _private_register_pytree_node list _list_flatten _list_unflatten serialized_type_name= builtins list flatten_with_keys_fn=_list_flatten_with_keys _private_register_pytree_node dict _dict_flatten _dict_unflatten serialized_type_name= builtins dict flatten_with_keys_fn=_dict_flatten_with_keys _private_register_pytree_node namedtuple type ignore arg-type _namedtuple_flatten _namedtuple_unflatten serialized_type_name= collections namedtuple to_dumpable_context=_namedtuple_serialize from_dumpable_context=_namedtuple_deserialize flatten_with_keys_fn=_namedtuple_flatten_with_keys _private_register_pytree_node OrderedDict _ordereddict_flatten _ordereddict_unflatten serialized_type_name= collections OrderedDict flatten_with_keys_fn=_ordereddict_flatten_with_keys _private_register_pytree_node defaultdict _defaultdict_flatten _defaultdict_unflatten serialized_type_name= collections defaultdict to_dumpable_context=_defaultdict_serialize from_dumpable_context=_defaultdict_deserialize flatten_with_keys_fn=_defaultdict_flatten_with_keys _private_register_pytree_node deque _deque_flatten _deque_unflatten serialized_type_name= collections deque flatten_with_keys_fn=_deque_flatten_with_keys STANDARD_DICT_TYPES frozenset type = frozenset dict OrderedDict defaultdict BUILTIN_TYPES frozenset type = frozenset tuple list dict namedtuple type ignore arg-type OrderedDict defaultdict deque deprecated torch utils _pytree _is_namedtuple_instance private will removed future release Please use torch utils _pytree is_namedtuple_instance instead category=FutureWarning _is_namedtuple_instance tree Any - bool is_namedtuple_instance tree _get_node_type tree Any - Any node_type = type tree All namedtuple types implicitly registered pytree nodes XXX Other parts codebase expect namedtuple types always ` namedtuple ` instead actual namedtuple type Even type explicitly registered is_namedtuple_class node_type namedtuple node_type A leaf defined anything Node tree_is_leaf tree PyTree is_leaf Optional Callable PyTree bool = None - bool Check pytree leaf tree_is_leaf True tree_is_leaf None True tree_is_leaf False tree_is_leaf is_leaf=lambda x isinstance x tuple True tree_is_leaf b c False tree_is_leaf b c None False is_leaf None is_leaf tree True _get_node_type tree SUPPORTED_NODES deprecated torch utils _pytree _is_leaf private will removed future release Please use torch utils _pytree tree_is_leaf instead category=FutureWarning _is_leaf tree PyTree is_leaf Optional Callable PyTree bool = None - bool tree_is_leaf tree is_leaf=is_leaf A TreeSpec represents structure pytree It holds type type root Node pytree context some context useful unflattening pytree children specs each child root Node num_nodes total number nodes num_leaves number leaves num_children number children root Node i e len children is_leaf whether root Node leaf dataclasses dataclass init=False frozen=True eq=True repr=False TreeSpec type Any _context Context _children list Self num_nodes int = dataclasses field init=False num_leaves int = dataclasses field init=False num_children int = dataclasses field init=False __init__ type Any context Context keep backward compatibility children_specs list Self keep backward compatibility - None object __setattr__ type type object __setattr__ _context context object __setattr__ _children children_specs __post_init__ __post_init__ - None type None assert _context None assert len _children == num_nodes = num_leaves = num_children = num_nodes = sum spec num_nodes spec _children start= num_leaves = sum spec num_leaves spec _children num_children = len _children object __setattr__ num_nodes num_nodes object __setattr__ num_leaves num_leaves object __setattr__ num_children num_children __repr__ indent int = - str repr_prefix str = f TreeSpec type __name__ _context children_specs_str str = num_children indent += children_specs_str += _children __repr__ indent children_specs_str += num_children children_specs_str += join \n + indent + child __repr__ indent child _children repr_suffix str = f children_specs_str repr_prefix + repr_suffix __eq__ other PyTree - bool other True other __class__ __class__ str type = str other type False _context = other _context False _children = other _children False True NotImplemented property context - Context _context property deprecated ` treespec children_specs ` deprecated Use ` treespec child index ` access single child ` treespec children ` get all children category=FutureWarning children_specs - list Self _children is_leaf - bool num_nodes == num_leaves == children - list Self _children copy child index int - Self _children index flatten_up_to tree PyTree - list PyTree helper treespec TreeSpec tree PyTree subtrees list PyTree - None treespec is_leaf subtrees append tree node_type = _get_node_type tree treespec type BUILTIN_TYPES Always require custom node types match exactly node_type = treespec type raise ValueError f Type mismatch f expected treespec type r got node_type r flatten_fn = SUPPORTED_NODES node_type flatten_fn children context = flatten_fn tree len children = treespec num_children raise ValueError f Node arity mismatch f expected treespec num_children got len children context = treespec _context raise ValueError f Node context mismatch custom node type treespec type r For builtin dictionary types we allow some flexibility Otherwise we require exact matches both_standard_dict = treespec type STANDARD_DICT_TYPES node_type STANDARD_DICT_TYPES both_standard_dict node_type = treespec type raise ValueError f Node type mismatch f expected treespec type r got node_type r len tree = treespec num_children raise ValueError f Node arity mismatch f expected treespec num_children got len tree both_standard_dict dictionary types compatible each other dict_context = treespec _context treespec type defaultdict ignore mismatch ` default_factory ` defaultdict treespec _context expected_keys = dict_context got_key_set = set tree expected_key_set = set expected_keys got_key_set = expected_key_set missing_keys = expected_key_set difference got_key_set extra_keys = got_key_set difference expected_key_set message = missing_keys message += f missing key s missing_keys extra_keys message += f extra key s extra_keys raise ValueError f Node keys mismatch message children = tree key key expected_keys node_type treespec type flatten_fn = SUPPORTED_NODES node_type flatten_fn children context = flatten_fn tree node_type deque ignore mismatch ` maxlen ` deque context = treespec _context raise ValueError f Node context mismatch node type treespec type r f expected treespec _context r got context r namedtuple type mismatch subtree subspec zip children treespec _children strict=True helper subspec subtree subtrees subtrees list PyTree = helper tree subtrees subtrees unflatten leaves Iterable Any - PyTree isinstance leaves list tuple leaves = list leaves len leaves = num_leaves raise ValueError f treespec unflatten leaves ` leaves ` has length len leaves f spec refers pytree holds num_leaves f items is_leaf leaves unflatten_fn = SUPPORTED_NODES type unflatten_fn Recursively unflatten children start = end = child_pytrees = child_spec _children end += child_spec num_leaves child_pytrees append child_spec unflatten leaves start end start = end unflatten_fn child_pytrees _context __hash__ - int node_type = type node_type defaultdict default_factory dict_context = _context hashable_context = default_factory tuple dict_context node_type dict OrderedDict hashable_context = tuple _context node_type None node_type BUILTIN_TYPES hashable_context = _context isinstance _context ConstantNode hashable_context = _context value The context user-defined node types might hashable Ignore hashing This does break correctness equal objects imply same hash This might increase hash collision rate we don t care about hashable_context = None hash node_type hashable_context tuple _children PyTreeSpec TypeAlias = TreeSpec NOTE subclassing dataclass subtle In order enable reasoning about ` dataclasses fields ` etc while having simplified constructor takes no argument we wrap ` dataclass init=True ` again fields have ` init=False ` deprecated ` isinstance treespec LeafSpec ` deprecated use ` isinstance treespec TreeSpec treespec is_leaf ` instead category=FutureWarning dataclasses dataclass init=True frozen=True eq=False repr=False LeafSpec TreeSpec type Any = dataclasses field default=None init=False _context Context = dataclasses field default=None init=False _children list Self = dataclasses field default_factory=list init=False __post_init__ - None Override ` __post_init__ ` ` num_leaves ` derivation object __setattr__ num_nodes object __setattr__ num_leaves object __setattr__ num_children __repr__ indent int = - str All leaves equivalent so represent single object save object construction time warnings catch_warnings warnings filterwarnings ignore category=FutureWarning module=__name__ append=False _LEAF_SPEC = LeafSpec treespec_leaf - LeafSpec Make treespec representing leaf node _LEAF_SPEC treespec_tuple iterable Iterable TreeSpec = - TreeSpec Make tuple treespec iterable child treespecs children = list iterable any isinstance child TreeSpec child children raise ValueError f Expected tuple TreeSpec values got children r TreeSpec tuple None children treespec_dict mapping Union Mapping Any TreeSpec Iterable tuple Any TreeSpec = kwargs TreeSpec - TreeSpec Make dict treespec dict child treespecs dct = dict mapping kwargs any isinstance child TreeSpec child dct values raise ValueError f Expected dictionary TreeSpec values got dct r TreeSpec dict list dct keys list dct values tree_flatten tree PyTree is_leaf Optional Callable PyTree bool = None - tuple list Any TreeSpec Flattens pytree into list values TreeSpec can used reconstruct pytree helper node PyTree leaves list Any - TreeSpec tree_is_leaf node is_leaf=is_leaf leaves append node _LEAF_SPEC node_type = _get_node_type node flatten_fn = SUPPORTED_NODES node_type flatten_fn children context = flatten_fn node Recursively flatten children subspecs = helper child leaves child children TreeSpec node_type context subspecs leaves list Any = treespec = helper tree leaves leaves treespec tree_unflatten leaves Iterable Any treespec TreeSpec - PyTree Given list values TreeSpec builds pytree This inverse operation ` tree_flatten ` isinstance treespec TreeSpec raise TypeError f tree_unflatten leaves treespec Expected ` treespec ` f instance TreeSpec got item type type treespec treespec unflatten leaves tree_iter tree PyTree is_leaf Optional Callable PyTree bool = None - Iterable Any Get iterator over leaves pytree tree_is_leaf tree is_leaf=is_leaf yield tree node_type = _get_node_type tree flatten_fn = SUPPORTED_NODES node_type flatten_fn child_pytrees _ = flatten_fn tree Recursively flatten children child child_pytrees yield tree_iter child is_leaf=is_leaf tree_leaves tree PyTree is_leaf Optional Callable PyTree bool = None - list Any Get list leaves pytree list tree_iter tree is_leaf=is_leaf tree_structure tree PyTree is_leaf Optional Callable PyTree bool = None - TreeSpec Get TreeSpec pytree tree_flatten tree is_leaf=is_leaf tree_map func Callable Any tree PyTree rests PyTree is_leaf Optional Callable PyTree bool = None - PyTree Map multi-input function over pytree args produce new pytree See also func ` tree_map_ ` tree_map lambda x x + x y x y tree_map lambda x x None x y z None x False y False False z True If multiple inputs given structure tree taken first input subsequent inputs need only have ` ` tree ` ` prefix tree_map lambda x y x + y Args func callable A function takes ` ` + len rests ` ` arguments applied corresponding leaves pytrees tree pytree A pytree mapped over each leaf providing first positional argument function ` ` func ` ` rests tuple pytree A tuple pytrees each which has same structure ` ` tree ` ` has ` ` tree ` ` prefix is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A new pytree same structure ` ` tree ` ` value each leaf given ` ` func x xs ` ` where ` ` x ` ` value corresponding leaf ` ` tree ` ` ` ` xs ` ` tuple values corresponding nodes ` ` rests ` ` leaves treespec = tree_flatten tree is_leaf=is_leaf flat_args = leaves + treespec flatten_up_to r r rests treespec unflatten map func flat_args tree_map_ func Callable Any tree PyTree rests PyTree is_leaf Optional Callable PyTree bool = None - PyTree Like func ` tree_map ` do inplace call each leaf original tree See also func ` tree_map ` Args func callable A function takes ` ` + len rests ` ` arguments applied corresponding leaves pytrees tree pytree A pytree mapped over each leaf providing first positional argument function ` ` func ` ` rests tuple pytree A tuple pytrees each which has same structure ` ` tree ` ` has ` ` tree ` ` prefix is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns The original ` ` tree ` ` value each leaf given side-effect function ` ` func x xs ` ` value where ` ` x ` ` value corresponding leaf ` ` tree ` ` ` ` xs ` ` tuple values values corresponding nodes ` ` rests ` ` leaves treespec = tree_flatten tree is_leaf=is_leaf flat_args = leaves + treespec flatten_up_to r r rests deque map func flat_args maxlen= consume exhaust iterable tree Type = tuple type T type S Type = tuple type T type S type U TypeAny = Union type Any tuple type Any types UnionType Fn = Callable Union T S R Fn = Callable Union T S U R Fn = Callable T R FnAny = Callable Any R MapOnlyFn = Callable T Callable Any Any These specializations help type inference lambda passed function overload map_only type_or_types_or_pred type T - MapOnlyFn Fn T Any overload map_only type_or_types_or_pred Type T S - MapOnlyFn Fn T S Any overload map_only type_or_types_or_pred Type T S U - MapOnlyFn Fn T S U Any This specialization needed implementations below call overload map_only type_or_types_or_pred TypeAny - MapOnlyFn FnAny Any overload map_only type_or_types_or_pred Callable Any bool - MapOnlyFn FnAny Any map_only type_or_types_or_pred Union TypeAny Callable Any bool - MapOnlyFn FnAny Any Suppose you writing tree_map over tensors leaving everything unchanged Ordinarily you would have write go t isinstance t Tensor t With function you only need write map_only Tensor go t You can also directly use tree_map_only isinstance type_or_types_or_pred type tuple types UnionType pred x Any - bool isinstance x type_or_types_or_pred type ignore arg-type callable type_or_types_or_pred pred = type_or_types_or_pred type ignore assignment raise TypeError Argument must type tuple types callable wrapper func Callable T Any - Callable Any Any functools wraps func wrapped x T - Any pred x func x x wrapped wrapper overload tree_map_only type_or_types_or_pred type T func Fn T Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only type_or_types_or_pred Type T S func Fn T S Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only type_or_types_or_pred Type T S U func Fn T S U Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only type_or_types_or_pred TypeAny func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only type_or_types_or_pred Callable Any bool func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree tree_map_only type_or_types_or_pred Union TypeAny Callable Any bool func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree tree_map map_only type_or_types_or_pred func tree is_leaf=is_leaf overload tree_map_only_ type_or_types_or_pred type T func Fn T Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only_ type_or_types_or_pred Type T S func Fn T S Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only_ type_or_types_or_pred Type T S U func Fn T S U Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only_ type_or_types_or_pred TypeAny func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only_ type_or_types_or_pred Callable Any bool func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree tree_map_only_ type_or_types_or_pred Union TypeAny Callable Any bool func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree tree_map_ map_only type_or_types_or_pred func tree is_leaf=is_leaf tree_all pred Callable Any bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool flat_args = tree_iter tree is_leaf=is_leaf all map pred flat_args tree_any pred Callable Any bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool flat_args = tree_iter tree is_leaf=is_leaf any map pred flat_args overload tree_all_only type_or_types type T pred Fn T bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool overload tree_all_only type_or_types Type T S pred Fn T S bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool overload tree_all_only type_or_types Type T S U pred Fn T S U bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool tree_all_only type_or_types TypeAny pred FnAny bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool flat_args = tree_iter tree is_leaf=is_leaf all pred x x flat_args isinstance x type_or_types overload tree_any_only type_or_types type T pred Fn T bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool overload tree_any_only type_or_types Type T S pred Fn T S bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool overload tree_any_only type_or_types Type T S U pred Fn T S U bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool tree_any_only type_or_types TypeAny pred FnAny bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool flat_args = tree_iter tree is_leaf=is_leaf any pred x x flat_args isinstance x type_or_types Broadcasts pytree provided TreeSpec returns flattened values If possible then function returns None For example given pytree= spec=TreeSpec list None LeafSpec LeafSpec would This useful part vmap implementation user can pass vmap fn in_dims inputs ` in_dims ` should broadcastable tree structure ` inputs ` we use _broadcast_to_and_flatten check _broadcast_to_and_flatten tree PyTree treespec TreeSpec is_leaf Optional Callable PyTree bool = None - Optional list Any isinstance treespec TreeSpec raise AssertionError treespec must TreeSpec tree_is_leaf tree is_leaf=is_leaf tree treespec num_leaves treespec is_leaf None node_type = _get_node_type tree node_type = treespec type None flatten_fn = SUPPORTED_NODES node_type flatten_fn child_pytrees context = flatten_fn tree Check Node different spec len child_pytrees = treespec num_children context = treespec _context None Recursively flatten children result list Any = child child_spec zip child_pytrees treespec _children strict=True flat = _broadcast_to_and_flatten child child_spec is_leaf=is_leaf flat None result += flat None result dataclasses dataclass _TreeSpecSchema _TreeSpecSchema schema used serialize TreeSpec It contains following fields - type A string name type null case LeafSpec - context Any format which json dumpable - children_spec A list children serialized specs type Optional str context DumpableContext children_spec list _TreeSpecSchema _ProtocolFn NamedTuple treespec_to_json Callable TreeSpec DumpableContext json_to_treespec Callable DumpableContext TreeSpec _SUPPORTED_PROTOCOLS dict int _ProtocolFn = _treespec_to_json treespec TreeSpec - _TreeSpecSchema treespec is_leaf _TreeSpecSchema None None treespec type SUPPORTED_SERIALIZED_TYPES raise NotImplementedError f Serializing treespec type pytree registered serialize_node_def = SUPPORTED_SERIALIZED_TYPES treespec type serialized_type_name = serialize_node_def serialized_type_name serialized_type_name == NO_SERIALIZED_TYPE_NAME_FOUND raise NotImplementedError f No registered serialization name treespec type found Please update your _register_pytree_node call ` serialized_type_name ` kwarg serialize_node_def to_dumpable_context None try serialized_context = json dumps treespec _context cls=EnumEncoder except TypeError e raise TypeError Unable serialize context Please make context json dump-able register custom serializer using _register_pytree_node e serialized_context = serialize_node_def to_dumpable_context treespec _context child_schemas = _treespec_to_json child child treespec _children _TreeSpecSchema serialized_type_name serialized_context child_schemas enum_object_hook obj dict str Any - Union Enum dict str Any __enum__ obj modname _ classname = obj fqn partition mod = importlib import_module modname enum_cls = mod attr classname split enum_cls = getattr enum_cls attr enum_cls = cast type Enum enum_cls pyrefly ignore unsupported-operation enum_cls obj name obj _json_to_treespec json_schema DumpableContext - TreeSpec json_schema type None json_schema context None len json_schema children_spec == _LEAF_SPEC json_schema type SERIALIZED_TYPE_TO_PYTHON_TYPE raise NotImplementedError f Deserializing json_schema type pytree registered typ = SERIALIZED_TYPE_TO_PYTHON_TYPE json_schema type serialize_node_def = SUPPORTED_SERIALIZED_TYPES typ serialize_node_def from_dumpable_context None try context = json loads json_schema context object_hook=enum_object_hook except TypeError ex raise TypeError Unable deserialize context Please make context json load-able register custom serializer using _register_pytree_node ex context = serialize_node_def from_dumpable_context json_schema context children_specs = _json_to_treespec child_string child_string json_schema children_spec TreeSpec typ context children_specs _SUPPORTED_PROTOCOLS = _ProtocolFn _treespec_to_json _json_to_treespec treespec_dumps treespec TreeSpec protocol Optional int = None - str isinstance treespec TreeSpec raise TypeError f treespec_dumps treespec protocol Expected ` treespec ` instance f TreeSpec got item type type treespec protocol None protocol = DEFAULT_TREESPEC_SERIALIZATION_PROTOCOL protocol _SUPPORTED_PROTOCOLS json_spec = _SUPPORTED_PROTOCOLS protocol treespec_to_json treespec raise ValueError f Unknown protocol protocol f Available protocols list _SUPPORTED_PROTOCOLS keys str_spec = json dumps protocol dataclasses asdict json_spec cls=EnumEncoder str_spec functools lru_cache treespec_loads serialized str - TreeSpec protocol json_schema = json loads serialized protocol _SUPPORTED_PROTOCOLS _SUPPORTED_PROTOCOLS protocol json_to_treespec json_schema raise ValueError f Unknown protocol protocol f Available protocols list _SUPPORTED_PROTOCOLS keys _DummyLeaf __repr__ - str treespec_pprint treespec TreeSpec - str dummy_tree = tree_unflatten _DummyLeaf _ range treespec num_leaves treespec repr dummy_tree TODO angelayi remove function after OSS internal stabilize deprecated ` pytree_to_str ` deprecated Please use ` treespec_dumps ` instead category=FutureWarning pytree_to_str treespec TreeSpec - str treespec_dumps treespec TODO angelayi remove function after OSS internal stabilize deprecated ` str_to_pytree ` deprecated Please use ` treespec_loads ` instead category=FutureWarning str_to_pytree json str - TreeSpec treespec_loads json arg_tree_leaves args PyTree kwargs PyTree - list Any Get flat list arguments function A slightly faster version tree_leaves args kwargs leaves list Any = args leaves extend tree_iter kwargs values leaves extend tree_iter leaves tree_flatten_with_path tree PyTree is_leaf Optional Callable PyTree bool = None - tuple list tuple KeyPath Any TreeSpec Flattens pytree like func ` tree_flatten ` also returns each leaf s key path Args tree pytree flatten If contains custom type type must registered appropriate ` tree_flatten_with_path_fn ` when registered func ` register_pytree_node ` is_leaf An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A tuple where first element list key path leaf pairs second element ` TreeSpec ` representing structure flattened tree _ treespec = tree_flatten tree is_leaf list _generate_key_paths tree is_leaf treespec tree_leaves_with_path tree PyTree is_leaf Optional Callable PyTree bool = None - list tuple KeyPath Any Gets leaves pytree like ` ` tree_leaves ` ` returns each leaf s key path Args tree pytree If contains custom type type must registered appropriate ` tree_flatten_with_path_fn ` when registered func ` register_pytree_node ` is_leaf An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A list key path leaf pairs list _generate_key_paths tree is_leaf _generate_key_paths key_path KeyPath tree PyTree is_leaf Optional Callable PyTree bool = None - Iterable tuple KeyPath Any is_leaf is_leaf tree yield key_path tree node_type = _get_node_type tree handler = SUPPORTED_NODES get node_type handler This leaf yield key_path tree flatten_with_keys = handler flatten_with_keys_fn flatten_with_keys key_children _ = flatten_with_keys tree k c key_children yield _generate_key_paths key_path k c is_leaf We registered pytree didn t add flatten_with_keys_fn complain raise ValueError f Did find flatten_with_keys_fn type node_type Please pass flatten_with_keys_fn argument register_pytree_node tree_map_with_path func Callable Any tree PyTree rests PyTree is_leaf Optional Callable PyTree bool = None - PyTree Like func ` tree_map ` provided callable takes additional key path argument Args func A function takes ` ` + len rests ` ` arguments applied corresponding leaves pytrees The first positional argument ` ` func ` ` key path leaf question The second positional argument value leaf tree A pytree mapped over each leaf providing first positional argument function ` ` func ` ` rests A tuple pytrees each which has same structure ` ` tree ` ` has ` ` tree ` ` prefix is_leaf An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A new pytree same structure ` ` tree ` ` value each leaf given ` ` func keypath x xs ` ` where ` ` keypath ` ` key path corresponding leaf ` ` tree ` ` ` ` x ` ` value leaf ` ` xs ` ` tuple values corresponding nodes ` ` rests ` ` keypath_leaves treespec = tree_flatten_with_path tree is_leaf keypath_leaves = list zip keypath_leaves strict=True all_keypath_leaves = keypath_leaves + treespec flatten_up_to r r rests treespec unflatten func xs xs zip all_keypath_leaves strict=True keystr kp KeyPath - str Given key path pretty-printed representation join str k k kp key_get obj Any kp KeyPath - Any Given object key path value key path k kp obj = k get obj obj