Owner s module fx passes ruff noqa F dataclasses dataclass operator logging sys torch torch fx _symbolic_trace symbolic_trace torch fx passes infra partitioner CapabilityBasedPartitioner torch fx passes operator_support OperatorSupport torch fx passes utils fuser_utils fuse_by_partitions torch fx passes utils matcher_utils SubgraphMatcher torch testing _internal common_utils run_tests parametrize instantiate_parametrized_tests torch testing _internal jit_utils JitTestCase logging basicConfig level=logging WARNING logger = logging getLogger __name__ TestModule torch nn Module __init__ - None super __init__ linear = torch nn Linear linear = torch nn Linear param = torch nn Parameter torch rand forward b c add = + b linear_ = linear add add_ = add + c add_ = add_ + param add_ = add_ + linear_ add_ = add_ + add_ linear_ = linear add_ add_ = linear_ + add_ add_ = add_ + relu = add_ relu add_ add_ relu TestDeepModule torch nn Module __init__ - None super __init__ linear = torch nn Linear forward b c o = + b o = o + testing avoid DFS uses passes Since Python has max recursion depth _ range sys getrecursionlimit + o = o - c o TestPartitionFunctions staticmethod forward b c add = + b add_ = add + b add_ = add_ + c relu_ = add_ relu add_ = add_ + add_ add_ = add_ + relu_ + add_ relu_ = add_ relu add_ = relu_ + add_ add_ = add_ + add_ add_ add_ staticmethod forward b _ add = + b add_ = add + b relu_ = add_ relu blocked add_ = add_ + relu_ add_ = add_ + add_ add_ add_ staticmethod forward b c add = + b add_ = + c add_ = b + c add add_ add_ staticmethod forward b c add = + b add_ = + c add_ = b + c torch where add add_ add_ staticmethod forward b c add should fused right branch left branch supported add = + left branch relu = add relu right branch add_ = add + relu add_ staticmethod forward b c add should have its own partition neither branches supported add = + left branch relu = add relu right branch relu_ = add relu relu relu_ staticmethod forward b c both branches supported all adds should fused together add = + left branch add_ = add + right branch larger add_ = add + add_ = add_ + add_ add_ staticmethod forward b c both branches same partition add should join same partition add = + left branch add_ = add + right branch add_ = add + left right branch merges add_ = add_ + add_ add_ staticmethod forward b c add = + branch add_ = add + branch add_ = add + branch_ add_ = add + out = torch stack add_ add_ add_ out staticmethod forward b c add = + branch add_ = add + branch add_ = add + branch depends branch add_ = add + add_ out = torch stack add_ add_ add_ out staticmethod forward b c add = + branch add_ = add relu branch depends branch add_ = add + add_ branch add_ = add relu out = torch stack add_ add_ add_ out staticmethod forward b c b = + c = + x = b relu x = c relu b = b + x c = c + c has dependency x b when we merge c c c dependency should updated fusion group reflected decision fuse b b which forms cyclic dependency new graph c = x + c b c staticmethod forward b c = split b = + b c = + c b + c staticmethod forward b c = torch ops aten std_mean out = + out staticmethod forward b c = torch ops aten view = torch ops aten permute = + = torch ops aten permute = + = torch ops aten permute torch ops aten permute staticmethod forward b c = - = torch ops aten view = torch ops aten permute = + = torch ops aten permute = + = torch ops aten permute = torch ops aten permute - staticmethod forward b c d e f = + b = c + d = e + f staticmethod forward b c = torch ops aten var_mean A mock OperatorSupport where only operator add supported MockOperatorSupport OperatorSupport is_node_supported submodules node torch fx Node - bool node op == call_function node target operator add operator getitem torch ops aten view torch ops aten permute torch ops aten std_mean instantiate_parametrized_tests TestFXGraphPasses JitTestCase parametrize fn expected_partition bookend_non_compute_pass TestPartitionFunctions forward add_ add_ add_ add_ add_ add_ add_ add False TestPartitionFunctions forward add_ add_ add_ add False horizontal fusion common producer TestPartitionFunctions forward add_ add_ add False TestPartitionFunctions forward add_ add_ add False branches cases TestPartitionFunctions forward add_ add False TestPartitionFunctions forward add False TestPartitionFunctions forward add_ add_ add add_ False TestPartitionFunctions forward add_ add_ add add_ False branch cases TestPartitionFunctions forward add_ add_ add_ add False TestPartitionFunctions forward add_ add_ add add_ False TestPartitionFunctions forward add_ add False necessarily only partition just verify there s no cyclic dependency after partition TestPartitionFunctions forward add_ add_ add_ add add_ False getitem special case TestPartitionFunctions forward add_ add_ add False TestPartitionFunctions forward add std_mean getitem getitem_ False bookend non_compute pass TestPartitionFunctions forward permute_ add_ add True TestPartitionFunctions forward add_ add permute_ view permute_ permute_ permute False TestPartitionFunctions forward permute_ add_ add True TestPartitionFunctions forward add_ add permute_ view permute_ permute_ permute False should empty partition partition empty nodes TestPartitionFunctions forward False test_partitioner fn expected_partition bookend_non_compute_pass traced = symbolic_trace fn non_compute_ops = bookend_non_compute_pass non_compute_ops = torch ops aten view torch ops aten permute supported_ops = MockOperatorSupport partitioner = CapabilityBasedPartitioner traced supported_ops allows_single_node_partition=True non_compute_ops=non_compute_ops partitions = partitioner propose_partitions bookend_non_compute_pass partitioner remove_bookend_non_compute_ops partitions partitions_name = node name node partition nodes partition partitions assert len partitions_name == len expected_partition i range len partitions_name assert set partitions_name i == set expected_partition i fused_graph = partitioner fuse_partitions partitions b c = torch rand torch rand torch rand expected = fn b c result = fused_graph b c torch testing assert_close expected result parametrize fn expected_partition TestPartitionFunctions forward add add_ add_ test_partitioner_independent_output fn expected_partition traced = symbolic_trace fn supported_ops = MockOperatorSupport partitioner = CapabilityBasedPartitioner traced supported_ops allows_single_node_partition=True partitions = partitioner propose_partitions partitions_name = node name node partition nodes partition partitions assert len partitions_name == len expected_partition i range len partitions_name assert set partitions_name i == set expected_partition i fused_graph = partitioner fuse_partitions partitions b c d e f = torch rand torch rand torch rand torch rand torch rand torch rand expected = fn b c d e f result = fused_graph b c d e f torch testing assert_close expected result parametrize partition add add_ add_ add_ add add_ add_ vertical fusion add_ add_ horizontal fusion add_ add_ add_ add_ arbitrary node order add_ add_ add_ add_ arbitrary node order add_ add_ add_ add_ add_ add_ arbitrary partition order add_ linear includes call_function + call_module node add_ relu includes call_function + call_module node param add_ includes get_attr + call_module nodes param add_ linear includes get_attr + call_function + call_module nodes add linear add_ param add_ add_ add_ linear add_ add_ relu full graph test_fuser_util partition m = TestModule gm = symbolic_trace m nodes_by_name = node name node node gm graph nodes partitions = node_names partition partitions append dict fromkeys nodes_by_name name name node_names fused_graph = fuse_by_partitions gm partitions b c = torch rand torch rand torch rand expected = m b c result = fused_graph b c torch testing assert_close expected result parametrize partition add add_ add_ add_ add_ add_ exists multiple partitions add add_ add_ invalid partition circular dependency add_ add_ invalid partition circular dependency relu add_ invalid partition circular dependency test_fuser_util_xfail partition m = TestModule gm = symbolic_trace m nodes_by_name = node name node node gm graph nodes partitions = node_names partition partitions append dict fromkeys nodes_by_name name name node_names assertRaises Exception fuse_by_partitions gm partitions test_fuser_pass_deep_model m = TestDeepModule traced = symbolic_trace m supported_ops = MockOperatorSupport partitioner = CapabilityBasedPartitioner traced supported_ops allows_single_node_partition=True partitions = partitioner propose_partitions dataclass TestCase match_output bool match_placeholder bool num_matches int remove_overlapping_matches bool = True SingleNodePattern staticmethod forward x val = torch neg x torch add val val staticmethod pattern torch neg test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True SimplePattern staticmethod forward x w w m = torch cat w w sum m = torch cat w w sum m = torch cat m m sum x + torch max m + torch max m + m staticmethod pattern b torch cat b sum test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True SimpleFullGraphMatching staticmethod forward x = torch neg x torch add staticmethod pattern x = torch neg x torch add test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True DiamondShapePatternTestCase staticmethod forward x = torch neg x = relu left = sigmoid right = relu out = left + right out staticmethod pattern = relu left = sigmoid right = relu out = left + right out test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True NonFullyContainedMatches staticmethod forward x w w b b fully contained matched subgraph m = torch cat w w m = torch cat x b t = torch addmm b m m t t _sum = torch sum t use t leaking leaking matched subgraph m leaked m = torch cat w w m = torch cat x b t = torch addmm b m m t m _sum = torch sum m t _sum m _sum staticmethod pattern x w w b b m = torch cat w w m = torch cat x b torch addmm b m m t test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True leaked used placeholder leaking ChainRepeatedPattern staticmethod forward x x = torch sigmoid x x = torch sigmoid x x = torch sigmoid x torch sigmoid x staticmethod pattern x torch sigmoid torch sigmoid x test_cases = match_output match_placeholder num_matches TestCase False False remove_overlapping_matches=False TestCase False False remove_overlapping_matches=True TestCase True False TestCase False True TestCase True True QuantizationModel staticmethod forward x x += x = x dequantize x = torch sigmoid x x = x torch float x staticmethod pattern x x = x dequantize x = torch sigmoid x x = x torch float x test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True MultipleOutputsWithDependency staticmethod forward x y = x relu z = y sigmoid z y staticmethod pattern b = relu c = b sigmoid b c outputs have data dependency test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True MultipleOutputsWithoutDependency staticmethod forward x x = x + target subgraph match x = x relu z = x sum y = x sigmoid out = y sigmoid + z sum out staticmethod pattern = relu b = sigmoid c = sum b c test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True MultipleOutputsMultipleOverlappingMatches staticmethod forward x x = x + target subgraph match x = x relu z = x sum z = x sum y = x sigmoid y = x sigmoid z + z + y + y staticmethod pattern = relu b = sigmoid c = sum b c test_cases = match_output match_placeholder num_matches TestCase False False remove_overlapping_matches=False TestCase False False remove_overlapping_matches=True MultipleOutputsMultipleNonOverlappingMatches staticmethod forward x x = x + target subgraph match x = x relu z = x sum y = x sigmoid x = x relu z = x sum y = x sigmoid z + z + y + y staticmethod pattern = relu b = sigmoid c = sum b c test_cases = match_output match_placeholder num_matches TestCase False False MultipleOutputsIdenticalAnchor staticmethod forward x x = x + target subgraph match x = x relu y = x sigmoid y = x sigmoid y y staticmethod pattern = relu b = sigmoid b = sigmoid b b test_cases = match_output match_placeholder num_matches False False FIXME currently still matches should fix TestCase True False TestCase False True MultipleOutputsHorizontalPattern staticmethod forward x x = x + target subgraph match y = x relu y = x sigmoid y y staticmethod pattern b = relu b = sigmoid b b test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True MultiOutputWithWithInvalidMatches staticmethod forward x res = torch nn functional linear x torch rand res = torch sigmoid res res = res res res = torch sum res dim= res staticmethod pattern b c lin_res = torch nn functional linear b mul_res = lin_res c lin_res mul_res test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True QuantizationFp Pattern classmethod setup cls cls quantization = torch library Library fp _quantization DEF noqa TOR cls quantization define quantize_per_tensor_affine_fp Tensor int dtype float scale - Tensor cls quantization define dequantize_per_tensor_affine_fp Tensor int dtype float scale - Tensor classmethod tearDown cls del cls quantization staticmethod forward arg _ arg _ qt = torch ops fp _quantization _scale_ = _scale_ quantize_per_tensor_affine_fp = qt quantize_per_tensor_affine_fp arg _ _scale_ dequantize_per_tensor_affine_fp = qt dequantize_per_tensor_affine_fp quantize_per_tensor_affine_fp _scale_ _scale_ = _scale_ quantize_per_tensor_affine_fp _ = qt quantize_per_tensor_affine_fp arg _ _scale_ dequantize_per_tensor_affine_fp _ = qt dequantize_per_tensor_affine_fp quantize_per_tensor_affine_fp _ _scale_ add = torch ops aten add Tensor dequantize_per_tensor_affine_fp dequantize_per_tensor_affine_fp _ _scale_ = _scale_ quantize_per_tensor_affine_fp _ = qt quantize_per_tensor_affine_fp add _scale_ dequantize_per_tensor_affine_fp _ = qt dequantize_per_tensor_affine_fp quantize_per_tensor_affine_fp _ _scale_ dequantize_per_tensor_affine_fp _ staticmethod pattern a_dtype a_scale b b_dtype b_scale out_scale qt = torch ops fp _quantization = qt dequantize_per_tensor_affine_fp a_dtype a_scale b = qt dequantize_per_tensor_affine_fp b b_dtype b_scale output = torch ops aten add Tensor b qt dequantize_per_tensor_affine_fp output = qt quantize_per_tensor_affine_fp output a_dtype out_scale output test_cases = match_output match_placeholder num_matches TestCase False False NoAnchorFound This test case pattern where no matching anchor found target graph ` anchor ` starting point pattern matching s usually boundary returning nodes staticmethod forward x x = x + x staticmethod pattern b = relu b test_cases = match_output match_placeholder num_matches TestCase False False TestCase True False TestCase False True TestCase True True instantiate_parametrized_tests TestFXMatcherUtils JitTestCase parametrize test_model SingleNodePattern SimplePattern SimpleFullGraphMatching DiamondShapePatternTestCase NonFullyContainedMatches ChainRepeatedPattern QuantizationModel MultipleOutputsWithDependency MultipleOutputsWithoutDependency MultipleOutputsMultipleOverlappingMatches MultipleOutputsMultipleNonOverlappingMatches MultipleOutputsIdenticalAnchor MultipleOutputsHorizontalPattern MultiOutputWithWithInvalidMatches QuantizationFp Pattern NoAnchorFound test_subgraph_matcher test_model setup = getattr test_model setup None callable setup setup traced = symbolic_trace test_model forward pattern_traced = symbolic_trace test_model pattern test_case test_model test_cases matcher = SubgraphMatcher pattern_traced graph match_output=test_case match_output match_placeholder=test_case match_placeholder remove_overlapping_matches=test_case remove_overlapping_matches matches = matcher match traced graph assert len matches == test_case num_matches match matches node pattern_traced graph nodes test_case match_placeholder node op == placeholder continue test_case match_output node op == output continue assert node match nodes_map tearDown = getattr test_model tearDown None callable setup tearDown __name__ == __main__ run_tests