mypy ignore-errors Dtypes scalar type implementations torch dtypes Here ` dtype ` always torch dtype module knows nothing about scalar types wrapper dtypes anything like PyTorch only collections namedtuple torch defaults mimic NumPy allow user control DefaultDTypes = namedtuple DefaultDTypes float_dtype complex_dtype int_dtype global state We set first time we call default_dtypes avoid importing torch _dynamo config create circular reference _default_dtypes = None default_dtypes global _default_dtypes _default_dtypes None torch _dynamo config config _default_dtypes = DefaultDTypes float_dtype=getattr torch config numpy_default_float complex_dtype=getattr torch config numpy_default_complex int_dtype=getattr torch config numpy_default_int assert isinstance _default_dtypes float_dtype torch dtype assert isinstance _default_dtypes complex_dtype torch dtype assert isinstance _default_dtypes int_dtype torch dtype _default_dtypes get_default_dtype_for dtype Default scalar type given sctype category dtype == torch bool dtype dtype is_complex default_dtypes complex_dtype dtype is_floating_point default_dtypes float_dtype must some integer default_dtypes int_dtype _casting_dicts _cd can_cast_impl from_torch_dtype to_torch_dtype casting _cd _can_cast_dict casting from_torch_dtype to_torch_dtype result_type_impl tensors NB torch dtypes here dtyp = tensors dtype len tensors == dtyp curr tensors dtyp = _cd _result_type_dict dtyp curr dtype dtyp python_type_for_torch dtyp Get python scalar type torch dtype dtyp is_floating_point typ = float dtyp is_complex typ = complex dtyp == torch bool typ = bool typ = int typ ### NEP helpers ### _SCALAR_TYPES = int bool float complex _SCALAR_AND_SYMBOLIC_TYPES = _SCALAR_TYPES torch SymInt torch SymFloat torch SymBool _NEP _FUNCS_TENSOR_ONLY = minimum maximum logaddexp logaddexp lcm gcd hypot heaviside fmod fmin fmax copysign arctan is_scalar x isinstance x _SCALAR_TYPES is_scalar_or_symbolic x isinstance x _SCALAR_AND_SYMBOLIC_TYPES _dtype_for_scalar py_type bool torch bool torch SymBool torch bool int torch int torch SymInt torch int float torch float torch SymFloat torch float complex torch complex py_type _dtype_for_scalar_or_tensor x x dtype isinstance x torch Tensor _dtype_for_scalar type x is_float_or_fp_tensor x _dtype_for_scalar_or_tensor x is_floating_point is_complex_or_complex_tensor x _dtype_for_scalar_or_tensor x is_complex _category dtype torch bool torch SymBool int torch uint torch int torch int torch int torch int torch SymInt float torch float torch float torch float torch SymFloat complex torch complex torch complex dtype nep _to_tensors x x handle_weaks function_name If either inputs python scalar type-promote NEP to_tensor scalar dtype=None dtype None dtype = _dtype_for_scalar type scalar dtype = get_default_dtype_for dtype torch as_tensor scalar dtype=dtype x _is_weak = isinstance x torch Tensor x _is_weak = isinstance x torch Tensor handle_weaks x _is_weak x _is_weak x = to_tensor x x _is_weak x x = to_tensor x x _is_weak x x x scalar op tensor NEP assert x _is_weak = x _is_weak weak not_weak = x x x _is_weak x x find dtype weak s type weak_dtype = _dtype_for_scalar type weak cat_weak = _category weak_dtype cat_not_weak = _category not_weak dtype dt = not_weak dtype cat_weak = cat_not_weak None special-case complex + float weak_dtype is_complex not_weak dtype == torch float dt = torch complex detect overflows PyTorch uint - wraps around while NEP mandates exception Note we only check each element binop overflows result Consider e g ` uint + ` Operands OK uint result overflows wrap around Numpy emits RuntimeWarning PyTorch does we do either cat_weak == cat_not_weak == integers iinfo = torch iinfo not_weak dtype iinfo min = weak = iinfo max raise OverflowError f Python integer weak out bounds not_weak dtype weak_dtype = dt function_name _NEP _FUNCS_TENSOR_ONLY finally can make ` weak ` into D tensor both parameters required tensor weak = to_tensor weak dt weak not_weak x _is_weak not_weak weak