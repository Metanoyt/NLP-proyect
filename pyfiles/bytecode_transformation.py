This module provides utilities analyzing transforming manipulating Python bytecode It includes functionality - Converting between different bytecode formats versions - Virtualizing jumps managing jump targets - Handling exception tables their entries - Managing instruction offsets extended arguments - Providing clean API bytecode modification transformation - Supporting Python version-specific bytecode features - Generating bytecode template functions The module designed work across different Python versions + handles version-specific bytecode differences transparently copy dataclasses dis functools itertools sys types uuid collections abc Callable Iterable Iterator Mapping Sequence typing Any cast Optional TYPE_CHECKING Union config bytecode_analysis get_indexof propagate_line_nums remove_extra_line_nums stacksize_analysis utils is_safe_constant TYPE_CHECKING output_graph DynamoTracerOutput dataclasses dataclass slots=True InstructionExnTabEntry start Instruction end Instruction target Instruction depth int lasti bool __repr__ - str f InstructionExnTabEntry start= start short_inst_repr f end= end short_inst_repr f target= target short_inst_repr f depth= depth lasti= lasti __eq__ o object - bool isinstance o InstructionExnTabEntry False start o start end o end target o target depth == o depth lasti == o lasti dataclasses dataclass slots=True Instruction A mutable version dis Instruction opcode int opname str arg Optional int argval Any offset Optional int = None starts_line Optional int = None is_jump_target bool = False positions Optional dis Positions = None extra fields make modification easier target Optional Instruction = None exn_tab_entry Optional InstructionExnTabEntry = None argrepr Optional str = None __hash__ - int id __eq__ other object - bool id == id other short_inst_repr - str f Instruction opname= opname offset= offset copy_positions other Instruction - None starts_line = other starts_line positions = other positions sys version_info = convert_instruction i dis Instruction - Instruction Instruction i opcode i opname i arg i argval i offset i line_number i is_jump_target i positions sys version_info = convert_instruction i dis Instruction - Instruction Instruction i opcode i opname i arg i argval i offset i starts_line i is_jump_target i positions convert_instruction i dis Instruction - Instruction Instruction i opcode i opname i arg i argval i offset i starts_line i is_jump_target None _NotProvided __repr__ - str _NotProvided sys version_info = inst_has_op_bits name str - bool name LOAD_ATTR LOAD_GLOBAL LOAD_SUPER_ATTR sys version_info = inst_has_op_bits name str - bool name == LOAD_GLOBAL inst_has_op_bits name str False create_instruction name str arg Optional int = None argval Optional Any = _NotProvided target Optional Instruction = None - Instruction At most one ` arg ` ` argval ` ` target ` can None _NotProvided This prevent ambiguity e g does create_instruction LOAD_CONST mean load constant co_consts load constant If ` arg ` provided will computed during assembly ` argval ` ` target ` Bits args instructions LOAD_GLOBAL LOAD_ATTR + LOAD_SUPER_ATTR modify behavior instruction In case we allow both ` arg ` ` argval ` set The value ` arg ` here expected value op bits true value ` arg ` will computed during assembly If ` arg ` set bits assumed allow instructions op bits have both arg argval specified inst_has_op_bits name target None raise RuntimeError target cannot specified instruction arg None arg = cnt = arg None + argval _NotProvided + target None cnt raise RuntimeError only one arg argval target can None _NotProvided arg None isinstance arg int raise RuntimeError instruction arg must int None Instruction opcode=dis opmap name opname=name arg=arg argval=argval target=target Python remaps create_jump_absolute target Instruction - Instruction inst = JUMP_FORWARD sys version_info = JUMP_ABSOLUTE create_instruction inst target=target is_jump_absolute target Instruction - bool target opname JUMP_FORWARD JUMP_ABSOLUTE create_load_const val Any checked bool = True - Instruction In general we should only create ` LOAD_CONST ` immutable objects sometimes s convenient _and safe_ Dynamo create ` LOAD_CONST ` mutable objects In such cases use ` checked=False ` checked assert is_safe_constant val f unsafe constant val create_instruction LOAD_CONST argval=val create_dup_top - Instruction sys version_info = create_instruction COPY arg= create_instruction DUP_TOP create_rot_n n int - list Instruction Returns simple sequence instructions rotates TOS n-th position stack For Python returns single ROT_ instruction If no such instruction exists error raised caller expected generate equivalent sequence instructions For Python = any rotation can expressed simple sequence swaps n = don t rotate sys version_info = rotate can expressed sequence swap operations e g rotate equivalent swap swap create_instruction SWAP arg=i i range n - n = create_instruction ROT_ + TWO THREE FOUR n - create_instruction ROT_N arg=n add_push_null inst_or_insts Union Instruction list Instruction - list Instruction Appends prepends PUSH_NULL instruction ` inst_or_insts ` depending Python version Used when you know ` inst_or_insts ` generates callable will called NOTE Assumes ` inst_or_insts ` single instruction sequence instructions pushes exactly object stack called It important you include ALL instructions construct callable - just first instruction prefix Will attempt use NULL push bit instructions such bits LOAD_GLOBAL + LOAD_ATTR + LOAD_SUPER_ATTR In case instructions WILL modified isinstance inst_or_insts Instruction insts list Instruction = inst_or_insts assert isinstance inst_or_insts list insts = inst_or_insts inst_has_bit_set idx int - bool assert insts idx arg None insts idx arg == type ignore operator set_inst_bit idx int - None assert insts idx arg None insts idx arg &#124; = type ignore operator sys version_info = In NULL follows callable inst_has_op_bits insts - opname inst_has_bit_set - All insts op bits have push_null bit last one Only set bit hasn t been set - otherwise we need add another PUSH_NULL set_inst_bit - insts = insts + create_instruction PUSH_NULL sys version_info = LOAD_ATTR LOAD_SUPER_ATTR end We assume ` insts ` will only load object so LOAD_GLOBAL end doesn t need checked inst_has_op_bits insts - opname inst_has_bit_set - set_inst_bit - insts opname == LOAD_GLOBAL inst_has_bit_set set_inst_bit insts = create_instruction PUSH_NULL + insts sys version_info = introduced NULL preceding callable inst_has_op_bits insts opname inst_has_bit_set set_inst_bit insts = create_instruction PUSH_NULL + insts insts add_push_null_call_function_ex inst_or_insts Union Instruction list Instruction - list Instruction Like add_push_null low bit LOAD_ATTR LOAD_SUPER_ATTR set due expected CALL_FUNCTION_EX instruction isinstance inst_or_insts Instruction insts list Instruction = inst_or_insts assert isinstance inst_or_insts list insts = inst_or_insts sys version_info insts idx = - sys version_info = insts idx opname == LOAD_GLOBAL assert insts idx arg None insts idx arg == type ignore operator insts idx arg &#124; = type ignore operator insts sys version_info = insts = insts + create_instruction PUSH_NULL insts = create_instruction PUSH_NULL + insts insts create_call_function nargs int push_null bool - list Instruction Creates sequence instructions makes function call ` push_null ` used Python + only It used codegen when function call intended made NULL + fn convention we know NULL has been pushed yet We will push NULL rotate correct position immediately before making function call ` push_null ` should True no NULL pushed callable Conversely ` push_null ` should False NULL pushed callable Prefer using ` push_null=False ` when possible since we will need rotate NULL right place which less efficient Generally you should codegen function using ` add_push_null ` then ` create_call_function ` ` push_null=False ` Example when set push_null False insts = create_instruction LOAD_GLOBAL argval= torch create_instruction LOAD_ATTR argval= nn create_instruction LOAD_ATTR argval= functional create_instruction LOAD_ATTR argval= relu insts = add_push_null insts insts append create_instruction LOAD_FAST argval= x insts extend create_call_function False Example when set push_null True insts = create_instruction LOAD_FAST x should_wrap wrapper_name wrappers should_wrap insts extend create_instruction LOAD_GLOBAL argval= wrapper create_instruction SWAP arg= create_call_function True sys version_info = output = push_null output append create_instruction PUSH_NULL swapped NULL callable rots = nargs + sys version_info = nargs + output extend create_rot_n rots sys version_info output append create_instruction PRECALL arg=nargs output append create_instruction CALL arg=nargs output create_instruction CALL_FUNCTION arg=nargs create_call_function_ex has_kwargs bool push_null bool ignore_ _kwargs_push bool = False - list Instruction Assumes + has_kwargs=False there NOT NULL TOS kwargs This utility function will add PUSH_NULL If caller has already pushed NULL kwargs then set ignore_ _kwargs_push=True so we don t push another NULL kwargs sys version_info = output = sys version_info = has_kwargs ignore_ _kwargs_push output append create_instruction PUSH_NULL has_kwargs = True push_null output append create_instruction PUSH_NULL swapped NULL callable flags == values popped - otherwise flags == value rots = int has_kwargs + sys version_info = int has_kwargs + output extend create_rot_n rots output append create_instruction CALL_FUNCTION_EX arg=int has_kwargs output create_instruction CALL_FUNCTION_EX arg=int has_kwargs create_call_method nargs int - list Instruction sys version_info = create_instruction CALL arg=nargs sys version_info = create_instruction PRECALL arg=nargs create_instruction CALL arg=nargs create_instruction CALL_METHOD arg=nargs create_load_method name str - Instruction sys version_info = create LOAD_ATTR instruction low bit set create_instruction LOAD_ATTR arg= argval=name create_instruction LOAD_METHOD argval=name create_setup_with target Instruction - Instruction opname = BEFORE_WITH sys version_info = SETUP_WITH create_instruction opname target=target create_swap n int - list Instruction sys version_info = create_instruction SWAP arg=n Python SWAP macro expands multiple instructions n == n == create_instruction ROT_TWO n == create_instruction ROT_THREE create_instruction ROT_TWO e g swap b stack b b b b b b - b b b b b b b b b b b b b - b b b reverse b None b b create_instruction BUILD_LIST arg=n - create_instruction DUP_TOP create_instruction LOAD_CONST argval=- create_binary_subscr create_instruction ROT_THREE create_instruction DUP_TOP create_instruction ROT_THREE create_instruction LOAD_CONST argval=- create_instruction STORE_SUBSCR create_instruction DUP_TOP create_load_method reverse create_call_method create_instruction POP_TOP create_instruction UNPACK_SEQUENCE arg=n - create_binary_slice start Optional int end Optional int store bool = False - list Instruction BINARY_SLICE STORE_SLICE ` set ` True all Python versions sys version_info = subscr_inst = create_instruction STORE_SUBSCR store create_binary_subscr create_load_const slice start end subscr_inst sys version_info = inst_name = STORE_SLICE store BINARY_SLICE create_load_const start create_load_const end create_instruction inst_name inst_name = STORE_SUBSCR store BINARY_SUBSCR create_load_const start create_load_const end create_instruction BUILD_SLICE arg= create_instruction inst_name create_copy i int - list Instruction sys version_info = create_instruction COPY arg=i i == create_instruction DUP_TOP COPY create_swap i create_dup_top create_swap i + create_swap mainly debugging generated bytecode create_print_on_stack depth int - list Instruction add_push_null create_instruction LOAD_CONST argval=print create_copy depth + sys version_info = create_call_function False create_instruction POP_TOP mainly debugging generated bytecode create_print_value value Any - list Instruction add_push_null create_instruction LOAD_CONST argval=print create_instruction LOAD_CONST argval=value create_call_function False create_instruction POP_TOP create_binary_subscr - Instruction sys version_info create_instruction BINARY_SUBSCR https github com python cpython blob e c bc f f fe e e cf f d Include opcode h#L create_instruction BINARY_OP arg= create_build_tuple n int - Instruction sys version_info = n == create_load_const create_instruction BUILD_TUPLE arg=n linetable_writer first_lineno int - tuple list int Callable int int None Callable int None Used create typing CodeType co_linetable See https github com python cpython blob main Objects lnotab_notes txt This internal format line number table Python assert sys version_info == linetable list int = lineno = first_lineno lineno_delta = byteno = _update byteno_delta int lineno_delta int - None while byteno_delta = lineno_delta = byte_offset = max min byteno_delta line_offset = max - min lineno_delta assert byte_offset = line_offset = byteno_delta -= byte_offset lineno_delta -= line_offset linetable extend byte_offset line_offset xFF update lineno_new int byteno_new int - None nonlocal lineno lineno_delta byteno byteno_delta = byteno_new - byteno byteno = byteno_new _update byteno_delta lineno_delta lineno_delta = lineno_new - lineno lineno = lineno_new end total_bytes int - None _update total_bytes - byteno lineno_delta linetable update end encode_varint n int - list int -bit chunk encoding unsigned integer See https github com python cpython blob Objects locations md assert n = b = n n = while n b - &#124; = b append n n = b linetable_ _writer first_lineno int - tuple list int Callable Optional dis Positions int None Used create typing CodeType co_linetable See https github com python cpython blob Objects locations md This internal format line number table Python assert sys version_info = linetable = lineno = first_lineno update positions Optional dis Positions inst_size int - None nonlocal lineno lineno_new = positions lineno positions None _update delta int size int - None assert size = first byte - use no column info positions malformed otherwise use long form other_varints tuple int = positions positions lineno None positions end_lineno None positions col_offset None positions end_col_offset None linetable append b _ _ + size - whatever reason column offset needs ` + ` https github com python cpython blob c c e c dff fc b b Python compile c#L other_varints = positions end_lineno - positions lineno positions col_offset + positions end_col_offset + linetable append b _ _ + size - encode signed int delta delta = -delta &#124; delta = encode unsigned int linetable extend encode_varint delta n other_varints linetable extend encode_varint n lineno_new None lineno_delta = lineno_delta = lineno_new - lineno lineno = lineno_new while inst_size _update lineno_delta inst_size -= _update lineno_delta inst_size linetable update dataclasses dataclass slots=True ExceptionTableEntry start int end int target int depth int lasti bool encode_exception_table_varint n int - list int Similar ` encode_varint ` -bit chunks ordered reverse assert n = b = n n = while n b append n n = b reverse i range len b - b i &#124; = b decode_exception_table_varint bytes_iter Iterator int - int Inverse ` encode_exception_table_varint ` b = next bytes_iter val = b while b val = b = next bytes_iter val &#124; = b val check_exception_table tab list ExceptionTableEntry - None Verifies list ExceptionTableEntries will make well-formed jump table entries non-empty sorted do overlap i range len tab - assert tab i start = tab i end tab i end tab i + start tab i + start = tab i + end parse_exception_table exntab bytes - list ExceptionTableEntry Parse exception table according https github com python cpython blob Objects exception_handling_notes txt exntab_iter = iter exntab tab = try while True start = decode_exception_table_varint exntab_iter length = decode_exception_table_varint exntab_iter end = start + length - target = decode_exception_table_varint exntab_iter dl = decode_exception_table_varint exntab_iter depth = dl lasti = bool dl tab append ExceptionTableEntry start end target depth lasti except StopIteration check_exception_table tab tab assemble_exception_table tab list ExceptionTableEntry - bytes Inverse parse_exception_table - encodes list exception table entries into bytes b = entry tab first_entry = encode_exception_table_varint entry start first_entry &#124; = b extend first_entry length = entry end - entry start + b extend encode_exception_table_varint length b extend encode_exception_table_varint entry target dl = entry depth + entry lasti b extend encode_exception_table_varint dl bytes b assemble instructions list Instruction firstlineno int - tuple bytes bytes Do opposite dis get_instructions code list int = sys version_info = lnotab update_lineno = linetable_ _writer firstlineno num_ext = i inst enumerate instructions inst opname == EXTENDED_ARG inst_size = num_ext += copy positions actual instruction j instructions i + j opname = EXTENDED_ARG inst positions = instructions i + j positions break inst_size = instruction_size inst + num_ext num_ext = update_lineno inst positions inst_size num_ext = arg = inst arg code extend inst opcode arg xFF _ range instruction_size inst - code extend lnotab update_lineno end = linetable_writer firstlineno inst instructions inst starts_line None update_lineno inst starts_line len code arg = inst arg code extend inst opcode arg xFF end len code bytes code bytes lnotab _get_instruction_by_offset offset_to_inst dict int Instruction offset int - Optional Instruction Get instruction located given offset accounting EXTENDED_ARGs n offset_to_inst offset + n opcode = dis EXTENDED_ARG offset_to_inst offset + n None virtualize_jumps instructions Iterable Instruction - None Replace jump targets pointers make editing easier jump_targets = inst offset inst inst instructions inst offset None inst instructions inst opcode dis hasjabs inst opcode dis hasjrel inst target = _get_instruction_by_offset jump_targets inst argval _REL_JUMPS = set dis hasjrel flip_jump_direction instruction Instruction - None sys version_info raise RuntimeError Cannot flip jump direction Python FORWARD instruction opname instruction opname = instruction opname replace FORWARD BACKWARD BACKWARD instruction opname instruction opname = instruction opname replace BACKWARD FORWARD raise AttributeError Instruction forward backward jump instruction opcode = dis opmap instruction opname assert instruction opcode _REL_JUMPS _get_instruction_front instructions list Instruction idx int - Instruction i e get first EXTENDED_ARG instruction any when targeting instructions idx jump target = instructions idx offset idx = offset instructions idx - offset opcode == dis EXTENDED_ARG target = instructions idx - offset break target devirtualize_jumps instructions list Instruction - None Fill args virtualized jump target after instructions may have moved jumps = set dis hasjabs union set dis hasjrel check negative jump args fix them inst instructions inst opcode jumps inst opcode dis hasjabs assert inst target None inst target offset None inst offset None inst target offset inst offset sys version_info raise RuntimeError Got negative jump offset Python forward jumps become backward FORWARD inst opname flip_jump_direction inst backward jumps become forward sys version_info = BACKWARD inst opname flip_jump_direction inst jump instruction size may have changed due flips update_offsets instructions indexof = get_indexof instructions compute jump instruction arg inst instructions inst opcode jumps assert inst target None target = _get_instruction_front instructions indexof inst target inst opcode dis hasjabs sys version_info ` arg ` expected bytecode offset whereas ` offset ` byte offset Divide since bytecode bytes large inst arg = int target offset raise RuntimeError Python + should have absolute jumps relative jump byte offset between target next instruction assert target offset None inst offset None inst arg = abs int target offset - inst offset - instruction_size inst pyrefly ignore unsupported-operation inst arg = inst argval = target offset inst argrepr = f target offset virtualize_exception_table exn_tab_bytes bytes instructions list Instruction - None Replace exception table entries pointers make editing easier exn_tab = parse_exception_table exn_tab_bytes offset_to_inst = cast int inst offset inst inst instructions offsets = sorted offset_to_inst keys end_offset_idx = exn_tab_iter = iter exn_tab try step - tuple ExceptionTableEntry InstructionExnTabEntry nonlocal end_offset_idx entry = next exn_tab_iter find rightmost offset = entry end since entry end may actual instruction e g end instruction LOAD_GLOBAL which takes more than bytes then entry end points end LOAD_GLOBAL instruction beginning while end_offset_idx len offsets offsets end_offset_idx = entry end end_offset_idx += assert end_offset_idx end_offset = offsets end_offset_idx - inst_entry = InstructionExnTabEntry _get_instruction_by_offset offset_to_inst entry start type ignore arg-type _get_instruction_by_offset offset_to_inst end_offset type ignore arg-type _get_instruction_by_offset offset_to_inst entry target type ignore arg-type entry depth entry lasti entry inst_entry entry inst_entry = step inst instructions assert inst offset None while inst offset entry end entry inst_entry = step inst offset = entry start inst exn_tab_entry = copy copy inst_entry except StopIteration pass compute_exception_table instructions list Instruction - list ExceptionTableEntry Compute exception table list format instructions exn_tab_entries exn_dict dict tuple int int tuple int int bool = indexof = get_indexof instructions inst instructions inst exn_tab_entry account prefixed EXTENDED_ARGS start = _get_instruction_front instructions indexof inst exn_tab_entry start offset assert start None point last bytes end instruction end = cast int inst exn_tab_entry end offset + instruction_size inst exn_tab_entry end - assert end None target = _get_instruction_front instructions indexof inst exn_tab_entry target offset assert target None key = start end val = target inst exn_tab_entry depth inst exn_tab_entry lasti key exn_dict assert exn_dict key == val exn_dict key = val Dynamo may construct nested exception table entries convenience Python expects exception table entries overlap NOTE below keys refer old instruction entries starts ends entries refer generated exception table entries Sort keys increasing start then decreasing end keys_sorted = sorted exn_dict keys key=lambda t t -t smallest byte next exception table entry can start nexti = stack current nested keys key_stack list tuple int int = exn_tab list ExceptionTableEntry = pop - None Pop key_stack append exception table entry possible nonlocal nexti key_stack key = key_stack pop nexti = key exn_tab append ExceptionTableEntry max key nexti key exn_dict key nexti = key + key keys_sorted pop keys no longer nested over current key while key_stack key_stack - key pop key_stack create entry covering current key possible assert key_stack - = key = key = key_stack - left = max nexti key_stack - left key exn_tab append ExceptionTableEntry left key - exn_dict key_stack - nexti = key key_stack append key while key_stack pop check_exception_table exn_tab exn_tab check_inst_exn_tab_entries_nested tab list InstructionExnTabEntry indexof dict Instruction int - None Checks ` tab ` properly sorted list nested InstructionExnTabEntry s i e no entries partially overlap Properly sorted means entries sorted increasing starts then decreasing ends entry_stack list tuple int int = entry tab key = indexof entry start indexof entry end while entry_stack entry_stack - key entry_stack pop entry_stack assert entry_stack - = key = key = entry_stack - entry_stack append key propagate_inst_exn_table_entries instructions list Instruction - None Copies exception table entries all instructions entry s range Supports nested exception table entries indexof = get_indexof instructions entries dict tuple int int InstructionExnTabEntry = inst instructions inst exn_tab_entry key = indexof inst exn_tab_entry start indexof inst exn_tab_entry end key entries assert inst exn_tab_entry == entries key entries key = inst exn_tab_entry sorted_entries = entries key key sorted entries keys key=lambda t t -t check_inst_exn_tab_entries_nested sorted_entries indexof Propagation nested entries works since nested entries come later sorted order entry sorted_entries i range indexof entry start indexof entry end + instructions i exn_tab_entry = copy copy entry check_inst_exn_tab_entries_valid instructions list Instruction - None Checks exn_tab_entries instructions valid An entry s start end target must instructions Instructions exn_tab_entry located within entry s start end instructions Instructions do share exn_tab_entries Implicitly checks no duplicate instructions indexof = get_indexof instructions exn_tab_entry_set = set i inst enumerate instructions inst exn_tab_entry assert sys version_info = assert id inst exn_tab_entry exn_tab_entry_set exn_tab_entry_set add id inst exn_tab_entry entry = inst exn_tab_entry assert entry start indexof assert entry end indexof assert entry target indexof assert indexof entry start = i = indexof entry end strip_extended_args instructions list Instruction - None instructions = i i instructions i opcode = dis EXTENDED_ARG Overwrites old_inst sequence new instructions This necessary order preserve jump targets old instruction exception table entries positions Returns modified sequence instructions including modified old instruction can manipulated elsewhere overwrite_instruction old_inst Instruction new_insts list Instruction - list Instruction update old_inst exnt_tab_entry end necessary old_inst exn_tab_entry old_inst exn_tab_entry end old_inst len new_insts old_inst exn_tab_entry end = new_insts - preserve exception table entries positions inst new_insts inst exn_tab_entry = copy copy old_inst exn_tab_entry inst positions = old_inst positions modify old_inst in-place preserve jump target old_inst opcode = new_insts opcode old_inst opname = new_insts opname old_inst arg = new_insts arg old_inst argval = new_insts argval old_inst target = new_insts target old_inst + new_insts remove_load_call_method instructions list Instruction - list Instruction LOAD_METHOD puts NULL stack which causes issues so remove assert sys version_info rewrites = LOAD_METHOD LOAD_ATTR CALL_METHOD CALL_FUNCTION inst instructions inst opname rewrites inst opname = rewrites inst opname inst opcode = dis opmap inst opname instructions remove_jump_if_none instructions list Instruction - None new_insts = inst instructions _NONE inst opname is_op = create_instruction IS_OP arg=int NOT inst opname need both argval arg set correctly now later is_op argval = is_op arg sys version_info jump_op = create_instruction POP_JUMP_FORWARD_IF_TRUE FORWARD inst opname POP_JUMP_BACKWARD_IF_TRUE target=inst target jump_op = create_instruction POP_JUMP_IF_TRUE target=inst target replace_insts = create_instruction LOAD_CONST argval=None is_op jump_op new_insts extend overwrite_instruction inst replace_insts new_insts append inst instructions = new_insts remove_binary_store_slice instructions list Instruction - None new_insts = inst instructions new_insts append inst inst opname BINARY_SLICE STORE_SLICE new instruction sys version_info = inst opname == BINARY_SLICE subscr_inst = create_binary_subscr subscr_inst = create_instruction inst opname replace SLICE SUBSCR inst exn_tab_entry inst exn_tab_entry end inst inst exn_tab_entry end = subscr_inst subscr_inst exn_tab_entry = copy copy inst exn_tab_entry subscr_inst positions = inst positions modify inst in-place preserve jump target inst opcode = dis opmap BUILD_SLICE inst opname = BUILD_SLICE inst arg = inst argval = new_insts append subscr_inst instructions = new_insts FUSED_INSTS = LOAD_FAST_LOAD_FAST LOAD_FAST LOAD_FAST LOAD_FAST_BORROW_LOAD_FAST_BORROW LOAD_FAST_BORROW LOAD_FAST_BORROW STORE_FAST_STORE_FAST STORE_FAST STORE_FAST STORE_FAST_LOAD_FAST STORE_FAST LOAD_FAST remove_fused_load_store instructions list Instruction - None new_insts = inst instructions inst opname FUSED_INSTS inst inst = FUSED_INSTS inst opname argval argval = inst argval replace_insts = create_instruction inst argval=argval create_instruction inst argval=argval new_insts extend overwrite_instruction inst replace_insts new_insts append inst instructions = new_insts adds GRAPH_BREAK_IF_LEAF real instruction before RETURN_ instructions testing purposes add_graph_break_if_leaf_instructions instructions list Instruction - None new_insts = inst instructions RETURN inst opname replace_insts = create_instruction NOP argval= GRAPH_BREAK_IF_LEAF create_instruction inst opname argval=inst argval new_insts extend overwrite_instruction inst replace_insts new_insts append inst instructions = new_insts remove_graph_break_if_leaf_instructions instructions list Instruction - None new_insts = inst next_inst itertools pairwise instructions inst opname == NOP inst argval == GRAPH_BREAK_IF_LEAF next_inst opname startswith RETURN remove instruction update all other instructions jump targets i range len instructions instructions i target inst instructions i target = next_inst instructions i exn_tab_entry linter mistakenly complaining None has no attribute codepath only runs instructions i None instructions i exn_tab_entry start inst type ignore union-attr instructions i exn_tab_entry start = next_inst type ignore union-attr instructions i exn_tab_entry end inst type ignore union-attr instructions i exn_tab_entry end = next_inst type ignore union-attr instructions i exn_tab_entry target inst type ignore union-attr instructions i exn_tab_entry target = next_inst type ignore union-attr new_insts append inst new_insts append instructions - instructions = new_insts explicit_super code types CodeType instructions list Instruction - None convert super no args into explicit arg form cell_and_free = code co_cellvars + code co_freevars len code co_varnames A function no argument cannot contain valid super call output = idx inst enumerate instructions output append inst inst opname == LOAD_GLOBAL inst argval == super nexti = instructions idx + nexti arg == sys version_info = nexti opname == CALL sys version_info = sys version_info nexti opname == PRECALL sys version_info nexti opname == CALL_FUNCTION assert __class__ cell_and_free output append create_instruction LOAD_DEREF argval= __class__ first_var = code co_varnames first_var cell_and_free output append create_instruction LOAD_DEREF argval=first_var output append create_instruction LOAD_FAST argval=first_var nexti arg = nexti argval = nexti opname == PRECALL also update following CALL instruction call_inst = instructions idx + call_inst arg = call_inst argval = instructions = output fix_extended_args instructions list Instruction - int Fill correct argvals EXTENDED_ARG ops output list Instruction = maybe_pop_n n int - None _ range n output output - opcode == dis EXTENDED_ARG output pop inst instructions inst opcode == dis EXTENDED_ARG Leave instruction alone now so we never shrink code inst arg = inst arg inst arg xFFFFFF maybe_pop_n output append create_instruction EXTENDED_ARG arg=inst arg output append create_instruction EXTENDED_ARG arg=inst arg output append create_instruction EXTENDED_ARG arg=inst arg inst arg inst arg xFFFF maybe_pop_n output append create_instruction EXTENDED_ARG arg=inst arg output append create_instruction EXTENDED_ARG arg=inst arg inst arg inst arg xFF maybe_pop_n output append create_instruction EXTENDED_ARG arg=inst arg output append inst added = len output - len instructions assert added = instructions = output added instruction_size inst Instruction - int torch sys version_info = torch _C _dynamo eval_frame py_opcode_caches inst opcode + check_offsets instructions Sequence Instruction - None offset = inst instructions assert inst offset == offset offset += instruction_size inst update_offsets instructions Sequence Instruction - None offset = inst instructions inst offset = offset pyrefly ignore unsupported-operation offset += instruction_size inst debug_bytes args bytes - str index = range max map len args result = join f x x arg arg index + list args + int = b b zip args - args - bytes mismatch\n + \n join result debug_checks code types CodeType - None Make sure our assembler produces same bytes we start dode _ = transform_code_object code lambda x y None safe=True assert code co_code == dode co_code debug_bytes code co_code dode co_code assert code co_lnotab == dode co_lnotab debug_bytes code co_lnotab dode co_lnotab HAS_LOCAL = set dis haslocal HAS_NAME = set dis hasname HAS_FREE = set dis hasfree HAS_CONST = set dis hasconst get_const_index code_options dict str Any val Any - int i v enumerate code_options co_consts NOTE stronger comparison required since we have examples where two values compare equal have different semantic meaning some cases e g == - have different effects torch copysign val v i code_options co_consts += val len code_options co_consts - fix_vars instructions list Instruction code_options dict str Any varname_from_oparg Optional Callable Any = None - None compute instruction arg argval arg provided names = name idx idx name enumerate code_options co_names get_name_index name str - int try idx = names name except KeyError Add missing item co_names idx = names name = len names code_options co_names = code_options co_names name assert len code_options co_names == len names idx sys version_info assert varname_from_oparg None varnames = name idx idx name enumerate code_options co_varnames freenames = name idx idx name enumerate code_options co_cellvars + code_options co_freevars assert callable varname_from_oparg allnames = idx itertools count try name = varname_from_oparg idx allnames name = idx except IndexError break varnames = name allnames name name code_options co_varnames freenames = name allnames name name code_options co_cellvars + code_options co_freevars i range len instructions should_compute_arg - bool argval prioritized over arg instructions i argval _NotProvided instructions i opname == LOAD_GLOBAL LOAD_GLOBAL requires both arg argval - see create_instruction assert instructions i argval _NotProvided sys version_info = assert instructions i arg None instructions i arg = get_name_index instructions i argval + cast int instructions i arg instructions i arg = get_name_index instructions i argval instructions i opname == LOAD_ATTR LOAD_ATTR requires both arg argval like LOAD_GLOBAL assert instructions i argval _NotProvided sys version_info = assert instructions i arg None instructions i arg = get_name_index instructions i argval + cast int instructions i arg instructions i arg = get_name_index instructions i argval instructions i opname == LOAD_SUPER_ATTR assert instructions i arg None assert instructions i argval _NotProvided Copy low bit force second bit explicit super + instructions i arg = get_name_index instructions i argval + cast int instructions i arg + instructions i opname FUSED_INSTS assert sys version_info = assert isinstance instructions i argval tuple assert len instructions i argval == arg_tuple = tuple varnames name name varnames freenames name name instructions i argval instructions i arg = arg_tuple + arg_tuple instructions i opcode HAS_LOCAL should_compute_arg sys version_info = instructions i argval varnames instructions like LOAD_FAST used both local free vars instructions i arg = freenames instructions i argval instructions i arg = varnames instructions i argval instructions i opcode HAS_NAME should_compute_arg instructions i arg = get_name_index instructions i argval instructions i opcode HAS_FREE should_compute_arg instructions i arg = freenames instructions i argval instructions i opcode HAS_CONST NOTE only update argval arg provided This assumes any additions co_consts appended instructions i arg None cannot use dictionary since consts may hashable idx = get_const_index code_options instructions i argval assert idx = instructions i arg = idx clear_instruction_args instructions list Instruction - None Clear instruction arg instructions have argvals Useful using dis d bytecode within generated bytecode inst instructions inst argval _NotProvided inst opcode HAS_LOCAL inst opcode HAS_NAME inst opcode HAS_FREE inst opcode HAS_CONST inst opname LOAD_GLOBAL LOAD_ATTR LOAD_SUPER_ATTR inst arg = None functools lru_cache get_code_keys - list str Python changes code keys fully documented See https github com python cpython blob Objects clinic codeobject c h#L new format keys = co_argcount keys append co_posonlyargcount keys extend co_kwonlyargcount co_nlocals co_stacksize co_flags co_code co_consts co_names co_varnames co_filename co_name sys version_info = keys append co_qualname keys append co_firstlineno keys append co_linetable sys version_info = documented introduced https github com python cpython issues keys append co_exceptiontable keys extend co_freevars co_cellvars keys transform_code_object code types CodeType transformations Callable list Instruction dict str Any Optional DynamoTracerOutput safe bool = False - tuple types CodeType Optional DynamoTracerOutput keys = get_code_keys code_options = k getattr code k k keys assert len code_options co_varnames == code_options co_nlocals instructions = cleaned_instructions code safe propagate line nums again added instructions propagate_line_nums instructions tracer_output = transformations instructions code_options _ bytecode = clean_and_assemble_instructions instructions keys code_options bytecode tracer_output clean_and_assemble_instructions instructions list Instruction keys list str code_options dict str Any - tuple list Instruction types CodeType remove_graph_break_if_leaf_instructions instructions also implicitly checks no duplicate instructions check_inst_exn_tab_entries_valid instructions code_options co_nlocals = len code_options co_varnames varname_from_oparg = None sys version_info = temporary code object updated names tmp_code = types CodeType code_options k k keys varname_from_oparg = tmp_code _varname_from_oparg type ignore attr-defined fix_vars instructions code_options varname_from_oparg=varname_from_oparg dirty = True while dirty update_offsets instructions devirtualize_jumps instructions pass might change offsets so we need try again dirty = bool fix_extended_args instructions remove_extra_line_nums instructions bytecode lnotab = assemble instructions code_options co_firstlineno code_options co_linetable = lnotab code_options co_code = bytecode code_options co_stacksize = stacksize_analysis instructions assert set keys - co_posonlyargcount == set code_options keys - co_posonlyargcount sys version_info = code_options co_exceptiontable = assemble_exception_table compute_exception_table instructions instructions types CodeType code_options k k keys populate_kw_names_argval instructions Sequence Instruction consts Any - None inst instructions inst opname == KW_NAMES inst argval = consts inst arg If safe=True we do make any bytecode modifications Mainly used debugging bytecode_transformation see debug_checks cleaned_instructions code types CodeType safe bool = False - list Instruction instructions = _cached_cleaned_instructions code safe We have lot code implicitly mutates instruction array We could do better here making copies explicit when necessary _clone_instructions instructions Copy instructions array making sure remap individual instruction targets _clone_instructions instructions Sequence Instruction - list Instruction This super hot fastest way do tried copy copy dataclasses replace copied = Instruction i opcode i opname i arg i argval i offset i starts_line i is_jump_target i positions i target i exn_tab_entry i argrepr i instructions remap = dict zip instructions copied Handle ` None ` remapper so we don t need extra ` ` remap None = None type ignore index assignment i copied i target = remap i target type ignore index entry = i exn_tab_entry i exn_tab_entry = InstructionExnTabEntry remap entry start remap entry end remap entry target entry depth entry lasti copied functools lru_cache _cached_cleaned_instructions code types CodeType safe bool = False - Sequence Instruction instructions = list map convert_instruction dis get_instructions code propagate now case we remove some instructions propagate_line_nums instructions check_offsets instructions sys version_info = populate_kw_names_argval instructions code co_consts virtualize_exception_table code co_exceptiontable instructions virtualize_jumps instructions strip_extended_args instructions safe sys version_info remove_load_call_method instructions sys version_info explicit_super code instructions sys version_info = remove_jump_if_none instructions sys version_info = remove_binary_store_slice instructions sys version_info = remove_fused_load_store instructions config debug_force_graph_break_on_leaf_return add_graph_break_if_leaf_instructions instructions sys version_info = update_offsets instructions devirtualize_jumps instructions instructions _unique_id_counter = itertools count unique_id name str with_uuid bool = False - str ret = f name _ next _unique_id_counter with_uuid ret += f _ uuid uuid replace - _ ret is_generator code types CodeType - bool co_generator = x code co_flags co_generator bytecode_from_template fn Callable Any varname_map Optional Mapping Any Any = None noreturn bool = True noprefix bool = True - list Instruction Generates bytecode template function ` fn ` use dynamo bytecode generation For example we can generate Python-version-independent bytecode looping through dictionary copying values new dictionary template d d k v d items d k = v try block template try dummy except dummy raise dummy Args fn function template generate bytecode varname_map mapping ` fn ` s varnames new names This map will applied generated bytecode s varnames For example local variables ` fn ` can replaced new names generated ` OutputGraph new_var ` noreturn remove all RETURN_ bytecodes replace them jump end bytecode NOTE any items pushed stack WILL remain stack Append POP_TOP you don t want item present noprefix remove prefix bytecodes all bytecode before first RESUME inclusive insts = cleaned_instructions fn __code__ clear_instruction_args insts noprefix i inst enumerate insts inst opname == RESUME insts = insts i + break inst insts If we don t reset starts_line then generated bytecode s line number will based fn s inst starts_line = None inst positions = None varname_map inst argval varname_map inst argval = varname_map inst argval noreturn sys version_info = replace RETURN_CONST LOAD_CONST RETURN_VALUE new_insts = inst insts inst opname == RETURN_CONST inst opcode = dis opmap LOAD_CONST inst opname = LOAD_CONST new_insts append inst no need propagate target exn table new_insts append create_instruction RETURN_VALUE new_insts append inst insts = new_insts returns = inst insts inst opname == RETURN_VALUE returns append inst len returns == returns insts - only end - just pop insts pop - len returns create jump target - last inst we can replace NOP make jump target insts - returns - insts - opname = NOP insts - opcode = dis opmap NOP insts - arg = None insts - argval = _NotProvided returns pop - insts append create_instruction NOP replace returns jumps inst returns don t replace inst new instruction due targeting exn table etc jump_inst = create_jump_absolute insts - inst opname = jump_inst opname inst opcode = jump_inst opcode inst arg = jump_inst arg inst argval = jump_inst argval inst target = jump_inst target insts