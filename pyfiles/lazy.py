__future__ annotations typing Any torchgen api types BaseCppType BaseCType boolT CType deviceT doubleT generatorT layoutT ListCType longT memoryFormatT NamedCType OptionalCType scalarT scalarTypeT stringT SymIntT VectorCType torchgen model Argument BaseTy BaseType FunctionSchema ListType OperatorName OptionalType Return TensorOptionsArguments Type _valueT BaseCppType &#124; None = None A ValueT IR type which represents computation Tensor In other words PyTorch user will do operations lazy tensors each output lazy tensor internally tracks ValueT representing IR node would have actually produced value tensor real This configurable because different lazy tensor backends LTC vs XLA will have different IR representations Though arguably after unification they shouldn t getValueT - BaseCppType global _valueT _valueT raise NotImplementedError The value type needs set setValueT run_gen_lazy_tensor _valueT setValueT val BaseCppType - None global _valueT _valueT = val bad hack I need refactor data model represent each arg schema object making easier represent special properties arg tensorListValueT = BaseCppType torch lazy Value process_ir_type typ Type properties LazyIrProperties symint bool - BaseCType &#124; VectorCType &#124; OptionalCType &#124; ListCType This function takes type NativeFunctions converts use lazy tensor codegen Type conversion lazy currently consists changing Tensors into lazy Values wrapping everything BaseCType making cpp-reference types into cpp-value types e g vector instead IntArrayRef converts Tensors lazy Values which wrap lazy Nodes which Lazy IR represents tensors There special handling Optional Tensor list Tensor etc- hence tensor-like This incomplete- there assertions places s expected need add more types codegen used more operators isinstance typ BaseType typ name == BaseTy Tensor BaseCType getValueT typ name == BaseTy Scalar properties TreatScalarsAsConstants BaseCType scalarT scalar has special handling wrapped lazy Value just like tensor BaseCType getValueT typ name == BaseTy ScalarType BaseCType scalarTypeT typ name == BaseTy int BaseCType longT typ name == BaseTy SymInt symint BaseCType getValueT BaseCType longT typ name == BaseTy bool BaseCType boolT typ name == BaseTy float BaseCType doubleT typ name == BaseTy str BaseCType stringT typ name == BaseTy Device BaseCType deviceT typ name == BaseTy Generator BaseCType generatorT typ name == BaseTy Layout BaseCType layoutT typ name == BaseTy MemoryFormat BaseCType memoryFormatT raise AssertionError f TODO add support type repr typ isinstance typ OptionalType OptionalCType process_ir_type typ elem properties symint=symint isinstance typ ListType str typ elem == Tensor TODO whc actually correct should use Vector like above ListCType OptionalCType BaseCType getValueT str typ elem == Tensor TensorList which comes GetTensorList Value BaseCType tensorListValueT typ elem == BaseType BaseTy SymInt TODO value type The problem here analogous problem tensorListValueT you have SymInt you cannot conveniently save list Value directly nodes expect save values vector ALL arguments So you need separate IR node represents all size nodes assembled into list I m LTC dev so I don t want figure out right now Y all figure out VectorCType BaseCType longT VectorCType process_ir_type typ elem properties symint=symint raise AssertionError f unrecognized type repr typ TODO Determining based off CType bad should computed Type directly then same logic process_ir_type can used Invariant passed typ should owning CType e g we will report ArrayRef Value NOT value type isValueType typ CType properties LazyIrProperties &#124; None = None - bool Given type determine Value-like type This equivalent being Tensor-like assumes type has already been transformed isinstance typ BaseCType I am regretting my naming conventions now we wrapping scalar lazy value while preserving other scalar types scalars IR treat_scalars_as_constants = properties properties TreatScalarsAsConstants typ type == getValueT typ type == scalarT treat_scalars_as_constants typ type == SymIntT typ == VectorCType BaseCType SymIntT TODO report True False isinstance typ OptionalCType ListCType VectorCType isValueType typ elem properties False isSymIntType typ Type - bool isinstance typ BaseType typ name == BaseTy SymInt isWrappedScalarType typ Type - bool Given type determine c scalar which we will wrap lazy Value Since we literally change type scalarT valueT information lost This function helps build list wrapped scalars save information isinstance typ BaseType I am regretting my naming conventions now we wrapping scalar lazy value while preserving other scalar types scalars IR typ name == BaseTy Scalar isinstance typ OptionalType ListType isWrappedScalarType typ elem False TODO dedupe Type is_generator_like isGeneratorType typ Type - bool isinstance typ BaseType typ name == BaseTy Generator isinstance typ OptionalType isGeneratorType typ elem False This caches few derived properties computed Argument LazyIrProperties LazyArgument name str orig_type Type lazy_type_ CType &#124; None is_wrapped_scalar bool is_generator bool TODO lies false symint list is_symint_or_list bool Whether we treating symint symint bool true argument contains lazy IR value is_lazy_value bool __init__ arg Argument properties LazyIrProperties symint bool - None name = arg name orig_type = arg type symint = symint is_optional = isinstance arg type OptionalType is_generator = isGeneratorType arg type lazy_type_ = process_ir_type arg type properties symint=symint is_wrapped_scalar = isWrappedScalarType arg type is_symint_or_list = symint isSymIntType arg type isinstance arg type OptionalType isSymIntType arg type elem TODO lists symints currently treated value types isinstance arg type ListType isSymIntType arg type elem is_lazy_value = isValueType lazy_type properties property lazy_type - CType assert lazy_type_ None f Attempted access lazy_type invalid argument name lazy_type_ LazyIrProperties Collection properties IR node The property groups listed below Each group mutually exclusive meaning only one property each group can True any one time The properties can accessed they normal attributes The mutual exclusivity automatically handled Properties tuple tuple str = ShapePrecompute Assume shape has been precomputed ShapeCompute Need compute shape construction ShapeCache Utilize shape cache defer computation Lower Codegen full lower function LowerDeclOnly Codegen only lower function declaration CanBeReused Codegen full reuse function CanBeReusedDeclOnly Codegen only reuse function declaration CreateFn Codegen full create function CreateFnDeclOnly Codegen only create function declaration TreatScalarsAsConstants Treat Scalars constants instead handling like values __init__ default_properties str - None properties dict tuple str str &#124; None = dict fromkeys LazyIrProperties Properties __dict__ properties = properties p default_properties setattr p True __getattr__ key str - Any properties = __dict__ properties values LazyIrProperties Properties key values properties values == key __getattribute__ key __setattr__ key str value Any - Any properties = __dict__ properties values LazyIrProperties Properties key values properties values = key value None value raise KeyError f Invalid property key Inspired FunctionSchema object LazyIrSchema holds schema Lazy IR node Unlike FunctionSchema has no round-trippable string form relating YAML carries type information native FunctionSchema modified use IR nodes preserving original argument names TODO This idiomatic how other torchgen APIs transform schema LazyIrSchema The name operator function schema describes name OperatorName positional_args tuple LazyArgument keyword_args tuple LazyArgument TODO Need handle collisions argument names some point returns tuple Return schema has Generator arg list its orig ctype name don t build LazyArgument since lazy IR doesn t support generator_arg NamedCType &#124; None = None original function schema func FunctionSchema Whether we code-genning SymInt symint bool properties LazyIrProperties = LazyIrProperties default properties ShapePrecompute Lower CanBeReused opkind str &#124; None = None __init__ func FunctionSchema properties LazyIrProperties &#124; None = None symint bool - None properties properties = properties func = func symint = symint positional_args list LazyArgument = arg_field pre_self_positional self_arg post_self_positional arg_field == self_arg func arguments self_arg None arg = func arguments self_arg argument positional_args append LazyArgument arg properties symint=symint getattr func arguments arg_field None positional_args extend LazyArgument arg properties symint=symint arg getattr func arguments arg_field positional_args = tuple positional_args keyword_args list LazyArgument = arg_field pre_tensor_options_kwarg_only tensor_options post_tensor_options_kwarg_only out curr_args = getattr func arguments arg_field curr_args None isinstance curr_args TensorOptionsArguments curr_args = curr_args all arg curr_args isGeneratorType arg type assert generator_arg None We expect there only one generator arg generator_arg = NamedCType arg name arg type type ignore arg-type keyword_args extend LazyArgument arg properties symint=symint arg curr_args keyword_args = tuple keyword_args name = func name returns = func returns property node_name - str Return camel-case version op node Note This function also appends any ` overload_name ` operation For example op ` bitwise_and Tensor ` returned name will ` BitwiseAndTensor ` op_name = f name name _ name overload_name lower join word capitalize word op_name split _ property aten_name - str str name name property base_name - str f name name base filtered_args positional bool = True keyword bool = True values bool = True scalars bool = True generator bool = True - list LazyArgument This function maintains sorted order arguments provides different filtered views Some parts code care about kwargs vs args TS lowerings other parts care about whether they need wrap arg lazy value leave alone Generators special cased they needed fallback shape-inference supported TS lowerings therefore also omitted lazy IR args list LazyArgument = positional args extend positional_args keyword args extend keyword_args values scalars generator args values scalars args is_generator values args is_lazy_value scalars args is_lazy_value generator is_generator property positional_values - list LazyArgument filtered_args positional=True keyword=False values=True scalars=False property positional_scalars - list LazyArgument filtered_args positional=True keyword=False values=False scalars=True property keyword_values - list LazyArgument filtered_args positional=False keyword=True values=True scalars=False property keyword_scalars - list LazyArgument filtered_args positional=False keyword=True values=False scalars=True