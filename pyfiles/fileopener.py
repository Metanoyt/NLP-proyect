collections abc Iterable Iterator io IOBase typing Optional torch utils data datapipes _decorator functional_datapipe torch utils data datapipes datapipe IterDataPipe torch utils data datapipes utils common get_file_binaries_from_pathnames __all__ = FileOpenerIterDataPipe functional_datapipe open_files FileOpenerIterDataPipe IterDataPipe tuple str IOBase r Given pathnames opens files yield pathname file stream tuple functional name ` ` open_files ` ` Args datapipe Iterable datapipe provides pathnames mode An optional string specifies mode which file opened ` ` open ` ` It defaults ` ` r ` ` other options ` ` b ` ` reading binary mode ` ` t ` ` text mode encoding An optional string specifies encoding underlying file It defaults ` ` None ` ` match default encoding ` ` open ` ` length Nominal length datapipe Note The opened file handles will closed Python s GC periodically Users can choose close them explicitly Example xdoctest +SKIP torchdata datapipes iter FileLister FileOpener StreamReader dp = FileLister root= filter lambda fname fname endswith txt dp = FileOpener dp dp = StreamReader dp list dp abc txt abc __init__ datapipe Iterable str mode str = r encoding Optional str = None length int = - super __init__ datapipe Iterable str = datapipe mode str = mode encoding Optional str = encoding mode b t rb rt r raise ValueError f Invalid mode mode TODO enforce typing each instance based mode otherwise ` argument_validation ` DataPipe may potentially broken b mode encoding None raise ValueError binary mode doesn t take encoding argument length int = length Remove annotation due IOBase general type true type determined runtime based mode Some ` DataPipe ` requiring subtype would cause mypy error __iter__ - Iterator tuple str IOBase yield get_file_binaries_from_pathnames datapipe mode encoding __len__ - int length == - raise TypeError f type __name__ instance doesn t have valid length length