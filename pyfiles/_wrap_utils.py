mypy allow-untyped-defs collections functools inspect warnings collections abc Callable functools partial typing Any Union torch nn nn torch distributed fsdp _common_utils _get_module_fsdp_state _override_module_mixed_precision torch distributed fsdp wrap _construct_wrap_fn _or_policy _Policy _post_order_apply _recursive_wrap _run_mixed_precision_override_policy _wrap_module_cls_individually _auto_wrap root_module nn Module policy Union Callable _Policy ignored_modules set nn Module ignored_params set nn Parameter root_kwargs dict str Any fsdp_fn Callable e g ` FullyShardedDataParallel ` ` fully_shard ` Auto wraps modules ` ` root_module ` ` s tree according ` ` policy ` ` following post-order traversal Precondition ` ` root_kwargs ` ` should contain all arguments except ` ` module ` ` This function accepts kwargs dict directly since gets forwarded into post-order traversal function mixed_precision = root_kwargs mixed_precision is_wrapper = inspect isclass fsdp_fn TODO We may relax no-nested-wrapping constraint support manual wrapping followed auto wrapping _check_nested_wrapping root_module isinstance policy _Policy root_kwargs auto_wrap_policy is_wrapper policy = None target_module_to_kwargs = policy _run_policy root_module ignored_modules root_kwargs mixed_precision None target_module_to_kwargs = _run_mixed_precision_override_policy root_module mixed_precision _module_classes_to_ignore ignored_modules root_kwargs target_module_to_kwargs overridden_module_classes = _override_module_mixed_precision root_module mixed_precision _module_classes_to_ignore _warn_on_overridden_mixed_precision overridden_module_classes use_orig_params = root_kwargs get use_orig_params False _validate_frozen_params root_module set target_module_to_kwargs keys ignored_params use_orig_params wrap_fn = _construct_wrap_fn root_module target_module_to_kwargs fsdp_fn _post_order_apply root_module wrap_fn recursive_wrap_kwargs = module root_module auto_wrap_policy policy wrapper_cls fsdp_fn ignored_modules ignored_modules ignored_params ignored_params only_wrap_children True mixed_precision None Wrap modules ignored types separately register forward hooks cast fp back original dtype respectively overridden_module_classes = _override_module_mixed_precision root_module mixed_precision _module_classes_to_ignore policy = functools partial _or_policy policies= policy partial _wrap_module_cls_individually module_classes=mixed_precision _module_classes_to_ignore recursive_wrap_kwargs auto_wrap_policy = policy _warn_on_overridden_mixed_precision overridden_module_classes _recursive_wrap recursive_wrap_kwargs root_kwargs type ignore arg-type _check_nested_wrapping root_module nn Module module_name module root_module named_modules _get_module_fsdp_state module None raise ValueError FSDP auto wrapping requires modules already have f FSDP applied found module_name in\n root_module _warn_on_overridden_mixed_precision overridden_module_classes set type nn Module len overridden_module_classes == warnings warn Both mixed precision auto_wrap_policy specified FSDP f where wrapped module has submodules type \n overridden_module_classes \n These modules will wrapped separate FSDP instacnes mixed precision disabled stacklevel= _validate_frozen_params root_module nn Module modules_to_wrap set nn Module ignored_params set nn Parameter use_orig_params bool This checks given ` ` modules_to_wrap ` ` each module would manage parameters uniformly frozen non-frozen This uniformity requirement strict ` ` use_orig_params=False ` ` hard error highly recommended ` ` use_orig_params=True ` ` user warning post_order_named_modules = _get_post_order_named_modules root_module visited_modules set nn Module = set module_name module post_order_named_modules module modules_to_wrap param_to_fqn = _get_managed_param_to_fqn module ignored_params visited_modules module_name frozen_param_fqns list str = frozen_param_numel = nonfrozen_param_fqns list str = nonfrozen_param_numel = param fqn param_to_fqn items param requires_grad nonfrozen_param_fqns append fqn nonfrozen_param_numel += param numel frozen_param_fqns append fqn frozen_param_numel += param numel len frozen_param_fqns len nonfrozen_param_fqns msg = f module_name has both parameters requires_grad=True False use_orig_params total_param_numel = frozen_param_numel + nonfrozen_param_numel msg += We do recommend wrapping such modules since gradient memory usage will higher than expected f total_param_numel numel instead nonfrozen_param_numel numel before sharding via reduce-scatter msg += FSDP does support wrapping such modules when use_orig_params=False msg += If possible wrap frozen parameters FSDP separately \n msg += f The following parameters have requires_grad=True \n nonfrozen_param_fqns \n f The following parameters have requires_grad=False \n frozen_param_fqns use_orig_params warnings warn msg stacklevel= raise ValueError msg _get_post_order_named_modules root_module nn Module - list tuple str nn Module This returns named modules following post-order traversal which valid reverse topological sort We achieve using reverse stack-based DFS order instead reversing ` ` root_module named_modules ` ` since former gives modules registration order each level module tree opposed reverse which allows us error warn first registered module violates condition For example consider following module structure M S S SS SS S The reverse DFS order S SS SS S S M while reverse ` ` named_modules ` ` order S SS SS S S M visited_modules = root_module stack = root_module Append reverse end linear-time algorithm reverse_post_order_named_modules list tuple str nn Module = while stack module_name module = stack pop reverse_post_order_named_modules append module_name module child_module_name child_module module named_children child_module None only overrides ` named_children ` continue child_module visited_modules visited_modules add child_module module_name = child_module_name = module_name + + child_module_name stack append child_module_name child_module post_order_named_modules = list reversed reverse_post_order_named_modules post_order_named_modules _get_managed_param_to_fqn module_to_wrap nn Module ignored_params set nn Parameter visited_modules set nn Module root_prefix str - dict nn Parameter str This returns dict maps managed parameter its FQN given ` ` module_to_wrap ` ` The dict s keys exactly parameters would managed module where achieved calling function modules wrap reverse topological order destructively updating ` ` visited_modules ` ` traversing into those modules The FQNs prefixed root via ` ` root_prefix ` ` more informative NOTE This function meant called pre-wrapping iteratively reverse topological order cover full module tree This differs ` ` _get_param_to_fqn ` ` function meant called post-wrapping full module tree one shot Given those differences we do try unify two param_to_fqn dict nn Parameter str = Run BFS any tree traversal works queue = collections deque module_to_wrap root_prefix visited_modules add module_to_wrap while queue module prefix = queue popleft param_name param module named_parameters recurse=False param ignored_params fqn = param_name prefix == prefix + + param_name param_to_fqn param = fqn child_module_name child_module module named_children child_module None only overrides ` named_children ` continue child_module visited_modules visited_modules add child_module child_prefix = child_module_name prefix == prefix + + child_module_name queue append child_module child_prefix param_to_fqn