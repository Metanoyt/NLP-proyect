Owner s oncall r p Copyright c Facebook Inc its affiliates All rights reserved This source code licensed under BSD-style license found LICENSE file root directory source tree multiprocessing mp signal time unittest unittest mock mock torch distributed elastic timer timer torch distributed elastic timer api TimerRequest torch distributed elastic timer local_timer MultiprocessingRequestQueue torch testing _internal common_utils IS_ARM IS_MACOS IS_WINDOWS run_tests TEST_WITH_DEV_DBG_ASAN TEST_WITH_TSAN TestCase timer supported these platforms INVALID_PLATFORMS = IS_WINDOWS IS_MACOS TEST_WITH_DEV_DBG_ASAN IS_ARM INVALID_PLATFORMS func should time out func n mp_queue mp_queue None timer configure timer LocalTimerClient mp_queue n timer expires after= func n - None time sleep LocalTimerTest TestCase setUp super setUp ctx = mp get_context spawn mp_queue = ctx Queue max_interval = server = timer LocalTimerServer mp_queue max_interval server start tearDown super tearDown server stop test_exception_propagation assertRaises Exception msg= foobar timer expires after= raise Exception foobar noqa TRY test_no_client no timer client configured exception expected timer configure None assertRaises RuntimeError timer expires after= pass test_client_interaction no timer client configured one passed explicitly no exception expected timer_client = timer LocalTimerClient mp_queue timer_client acquire = mock MagicMock wraps=timer_client acquire timer_client release = mock MagicMock wraps=timer_client release timer expires after= scope= test client=timer_client pass timer_client acquire assert_called_once_with test mock ANY timer_client release assert_called_once_with test test_happy_path timer configure timer LocalTimerClient mp_queue timer expires after= time sleep test_get_timer_recursive If function acquires countdown timer default scope then recursive calls function should re-acquire timer rather than creating new one That only last recursive call s timer will take effect server start timer configure timer LocalTimerClient mp_queue func should time out func n n timer expires after= func n - time sleep func p = ctx Process target=func args= mp_queue p start p join assertEqual -signal SIGKILL p exitcode staticmethod _run mp_queue timeout duration client = timer LocalTimerClient mp_queue timer configure client timer expires after=timeout time sleep duration unittest skipIf TEST_WITH_TSAN test tsan incompatible test_timer timeout = duration = p = mp Process target=self _run args= mp_queue timeout duration p start p join assertEqual -signal SIGKILL p exitcode _enqueue_on_interval mp_queue n interval sem enqueues ` ` n ` ` timer requests into ` ` mp_queue ` ` one element per interval seconds Releases given semaphore once before going work sem release i range n mp_queue put TimerRequest i test_scope time sleep interval INVALID_PLATFORMS MultiprocessingRequestQueueTest TestCase test_get mp_queue = mp Queue request_queue = MultiprocessingRequestQueue mp_queue requests = request_queue get timeout= assertEqual len requests request = TimerRequest test_scope mp_queue put request requests = request_queue get timeout= assertEqual len requests assertIn request requests unittest skipIf TEST_WITH_TSAN test incompatible tsan test_get_size Creates producer process enqueues ` ` n ` ` elements every ` ` interval ` ` seconds Asserts ` ` get n timeout=n interval+delta ` ` yields all ` ` n ` ` elements mp_queue = mp Queue request_queue = MultiprocessingRequestQueue mp_queue n = interval = sem = mp Semaphore p = mp Process target=_enqueue_on_interval args= mp_queue n interval sem p start sem acquire blocks until process has started run function timeout = interval n + start = time time requests = request_queue get n timeout=timeout assertLessEqual time time - start timeout + interval assertEqual n len requests test_get_less_than_size Tests slow producer Creates producer process enqueues ` ` n ` ` elements every ` ` interval ` ` seconds Asserts ` ` get n timeout= interval n ` ` yields most ` ` n ` ` elements mp_queue = mp Queue request_queue = MultiprocessingRequestQueue mp_queue n = interval = sem = mp Semaphore p = mp Process target=_enqueue_on_interval args= mp_queue n interval sem p start sem acquire blocks until process has started run function requests = request_queue get n timeout= interval n assertLessEqual n len requests INVALID_PLATFORMS LocalTimerServerTest TestCase setUp super setUp mp_queue = mp Queue max_interval = server = timer LocalTimerServer mp_queue max_interval tearDown super tearDown server stop test_watchdog_call_count checks watchdog function ran wait interval +- times server _run_watchdog = mock MagicMock wraps=self server _run_watchdog wait = server start time sleep wait server stop watchdog_call_count = server _run_watchdog call_count assertGreaterEqual watchdog_call_count int wait max_interval - assertLessEqual watchdog_call_count int wait max_interval + test_watchdog_empty_queue checks watchdog can run empty queue server _run_watchdog _expired_timer pid scope expired = time time - TimerRequest worker_id=pid scope_id=scope expiration_time=expired _valid_timer pid scope valid = time time + TimerRequest worker_id=pid scope_id=scope expiration_time=valid _release_timer pid scope TimerRequest worker_id=pid scope_id=scope expiration_time=- mock patch os kill test_expired_timers mock_os_kill tests single expired timer process should terminate process clean up all pending timers owned process test_pid = - mp_queue put _expired_timer pid=test_pid scope= test mp_queue put _valid_timer pid=test_pid scope= test server _run_watchdog assertEqual len server _timers mock_os_kill assert_called_once_with test_pid signal SIGKILL mock patch os kill test_acquire_release mock_os_kill tests timer can acquired then released should terminate process timer can vacuously released e g no-op test_pid = - mp_queue put _valid_timer pid=test_pid scope= test mp_queue put _release_timer pid=test_pid scope= test mp_queue put _release_timer pid=test_pid scope= test server _run_watchdog assertEqual len server _timers mock_os_kill assert_not_called mock patch os kill test_valid_timers mock_os_kill tests valid timers processed correctly process left alone mp_queue put _valid_timer pid=- scope= test mp_queue put _valid_timer pid=- scope= test mp_queue put _valid_timer pid=- scope= test mp_queue put _valid_timer pid=- scope= test server _run_watchdog assertEqual len server _timers assertTrue - test server _timers assertTrue - test server _timers assertTrue - test server _timers assertTrue - test server _timers mock_os_kill assert_not_called __name__ == __main__ run_tests