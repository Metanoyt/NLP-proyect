mypy allow-untyped-defs math operator traceback functools partial typing NamedTuple TYPE_CHECKING sympy torch torch fx torch fx experimental symbolic_shapes free_unbacked_symbols torch fx passes infra pass_base PassBase PassResult torch utils _sympy numbers int_oo torch utils _sympy value_ranges ValueRanges TYPE_CHECKING collections abc Callable __all__ = InputDim InputDim NamedTuple input_name str dim int _convert_to_int val Convert simple sympy Integers into concrete int val sympy oo int_oo math inf val -sympy oo -int_oo -math inf isinstance val sympy Integer int val raise RuntimeError Export constraints cannot non-integer expressions _convert_range_to_int range ValueRanges assert isinstance range ValueRanges min_val = _convert_to_int range lower max_val = _convert_to_int range upper min_val max_val _AddRuntimeAssertionsForInlineConstraintsPass PassBase __init__ range_constraints dict sympy Symbol ValueRanges super __init__ range_constraints dict sympy Symbol ValueRanges = range_constraints _asserts_generated_unbacked_symbols set sympy Symbol = set counter = _assert_range_constraint node lower upper assert_msg last_node = node lower -math inf last_node = _insert_assert_async last_node operator ge node lower assert_msg upper math inf last_node = _insert_assert_async last_node operator le node upper assert_msg _insert_assert_async last_node op lower upper assert_msg Inserts assert_async call_function nodes graph This function called during interpreter-based pass counter += graph = last_node graph graph inserting_after last_node cmp = graph call_function op lower upper graph inserting_after cmp cmp_tensor = graph call_function torch ops aten scalar_tensor default cmp graph inserting_after cmp_tensor assert_async = graph call_function torch ops aten _assert_async msg cmp_tensor assert_msg assert_async call graph_module - PassResult existing_inline_assertions = _get_existing_inline_assertions graph_module range_constraints module graph_module modules isinstance module torch fx GraphModule continue node module graph nodes node op = call_function continue val node meta continue val = node meta val In general we may have deal case such ret shape We need first find out what symbols require assertion then we need follow path ret symbol construct proxies along way construct messages piece-wise same time We use post-order traversal collect all proxies callbacks needed construct error message callbacks top-level traversal tree we execute all callbacks We need callbacks because order call function create proxy shape we need proxy shape which further requires proxy ret etc add_assertions val call_backs list Callable = messages list str = isinstance val torch SymInt torch SymFloat torch SymBool symbol = val node expr symbol existing_inline_assertions call_backs messages isinstance symbol sympy Symbol free_unbacked_symbols symbol symbol _asserts_generated_unbacked_symbols call_backs messages We only care about unbacked symints these inline constraints which prefixed u constraint = range_constraints symbol min_val max_val = _convert_range_to_int constraint assert_msg = f outside inline constraint min_val max_val call_backs append partial _assert_range_constraint lower=min_val upper=max_val messages append assert_msg _asserts_generated_unbacked_symbols add symbol isinstance val torch Tensor i sym enumerate val shape cbs msgs = add_assertions sym cb msg zip cbs msgs sym_size_cb node assert_msg dim node graph inserting_after node dim_node = module graph call_function torch ops aten sym_size int node dim cb node=dim_node assert_msg=assert_msg call_backs append partial sym_size_cb dim=i messages append f shape i + msg call_backs messages callbacks messages = add_assertions val cb msg zip callbacks messages cb node=node assert_msg=f node + msg module recompile Sometimes pass would wrong graph where we have mismatched node names signature Before we fix let s just skip counter == type _AddRuntimeAssertionsForInlineConstraintsPass PassResult graph_module False Populate stack trace dummy vals respect IR node graph_module graph nodes node meta get stack_trace None node op placeholder output node meta stack_trace = join traceback format_stack limit= PassResult graph_module True _get_existing_inline_assertions graph_module torch fx GraphModule range_constraints dict sympy Symbol ValueRanges - dict sympy Symbol ValueRanges existing_inline_assertions dict sympy Symbol ValueRanges = module graph_module modules isinstance module torch fx GraphModule continue Find all existing inline assertions They will look something like _local_scalar_dense = call_function target=torch ops aten _local_scalar_dense default args = arg _ kwargs = ge = call_function target=operator ge args = _local_scalar_dense kwargs = _assert_scalar = call_function target=torch ops aten _assert_scalar default args = scalar_tensor kwargs = node module graph nodes node target = torch ops aten _assert_scalar default continue compare_arg = node args isinstance compare_arg torch fx Node compare_arg op == call_function compare_arg target operator le operator ge len compare_arg args == continue compare_op = compare_arg target lhs rhs = compare_arg args maybe_get_symint x isinstance x torch fx Node val x meta isinstance x meta val torch SymInt x meta val node expr x lhs = maybe_get_symint lhs rhs = maybe_get_symint rhs compare_op operator ge lhs rhs = rhs lhs isinstance lhs sympy Symbol isinstance rhs int symint = lhs scalar = rhs isinstance rhs sympy Symbol isinstance lhs int symint = rhs scalar = lhs continue symint range_constraints raise RuntimeError f Unable find symint symint range_constraints previous_range = existing_inline_assertions get symint ValueRanges -math inf math inf symint lhs bounds = ValueRanges -math inf scalar bounds = ValueRanges scalar math inf existing_inline_assertions symint = previous_range bounds existing_inline_assertions