logging math enum IntEnum typing Optional torch distributed _tools ilp_utils Graph is_submodule torch distributed _tools sac_estimator SACStats try pulp type ignore import-untyped import-not-found lpDot LpInteger LpMaximize LpMinimize LpProblem LpStatus lpSum LpVariable PULP_CBC_CMD value except ImportError err raise ImportError Please install pulp package See https github com coin-or pulp err Create logger object logger = logging getLogger __name__ Set logging level INFO logger setLevel logging INFO sac_milp graph Graph memory_budget float world_size int = ac_units Optional list str = None fsdp_units Optional list str = None - tuple dict str float float int MILP decide which modules AC how much memory discard The objective minimize recomputation time The constraint ensure peak memory under budget Args graph graph representation model module submodule tree where each node submodule memory runtime stats memory_budget memory budget GiB world_size number GPUs In case FSDP world_size will used compute amount parameter gradient memory each rank ac_units list user-specified AC units fsdp_units list FSDP units AC units cannot supermodules FSDP units Returns Dict str float optimal SAC solution mapping module fqn percentage activation memory discard float recomputation time optimal SAC solution int upper bound peak memory optimal SAC solution note value - means ILP solver failed find solution num_nodes = len graph nodes M = note numerical issue may occur M too big MEM_MULTIPLIER = Create MILP problem prob = LpProblem SAC LpMinimize Create decision variables y_i indicator module i AC ed y = LpVariable matrix y list range num_nodes LpInteger r_i percentage discarded activation memory r = LpVariable matrix r list range num_nodes d_i discarded activation memory module i d = LpVariable matrix d list range num_nodes a_i total activation memory module i = LpVariable matrix list range num_nodes m_i memory module i combining parameters gradients activations m = LpVariable matrix m list range num_nodes rcp_i percentage recomputation time rcp = LpVariable matrix rcp list range num_nodes rct_i recomputation time module i ms rct = LpVariable matrix rct list range num_nodes max_m peak memory max_m = LpVariable max_m Add constraints Constraint User specified AC units ac_units ac_units_set = set ac_units i range num_nodes graph nodes i fqn ac_units_set prob += y i == Constraint AC units cannot supmodules user specified FSDP units fsdp_units i range num_nodes any is_submodule fsdp_unit graph nodes i fqn fsdp_unit fsdp_units prob += y i == Constraint No nested AC units i range num_nodes j range i + num_nodes graph ad_matrix i j == prob += y i + y j = Constraint Do AC leaf modules i range num_nodes graph nodes i is_leaf prob += y i == Constraint Express amount discarded activation memory i range num_nodes There two measures activation memory ACM IA IA activation memory saved when using AC ACM total activation memory including those typically saved when using AC Note ACM = IA graph nodes i is_leaf graph nodes i sac_memory graph nodes i act_fw_per_module logger warning For module s graph nodes i fqn logger warning activation memory memory tracker d graph nodes i act_fw_per_module logger warning activation memory SAC estimator d graph nodes i sac_memory logger warning Something wrong Please check logger warning Overriding latter former graph nodes i sac_memory = graph nodes i act_fw_per_module ACM_i = graph nodes i sac_memory MEM_MULTIPLIER IA_i = graph nodes i act_fw_per_module MEM_MULTIPLIER prob += d i == ACM_i r i - ACM_i - IA_i y i Constraint Ensure correctness r_i There two parts its correctness r_i only y_i == discard only AC unit r_i needs large enough cover difference between ACM IA Otherwise we saving any memory i range num_nodes prob += y i = r i graph nodes i is_leaf continue ACM_i = graph nodes i sac_memory MEM_MULTIPLIER IA_i = graph nodes i act_fw_per_module MEM_MULTIPLIER prob += r i = ACM_i - IA_i ACM_i y i Constraint Express total activation memory backward pass i range num_nodes AG_i = graph nodes i act_grad_per_module MEM_MULTIPLIER TA_i = graph nodes i act_total MEM_MULTIPLIER related discarded amount memory pos = graph nodes i pos_fw_post_order coeff = num_nodes p range pos j = graph name node graph fw_post_order p index coeff j = prob += i == TA_i + AG_i - lpDot coeff d Constraint Express total amount memory each module Note unsharded parameters gradients included here P_ = graph nodes param_per_module MEM_MULTIPLIER i range num_nodes TG_i = graph nodes i grad_total MEM_MULTIPLIER prob += m i == i + P_ + TG_i world_size Constraint Express peak memory i range num_nodes prob += max_m = m i Constraint Express percentage recomputation time i range num_nodes s range graph nodes i n_segments slope = graph nodes i slopes s intercept = graph nodes i intercepts s prob += rcp i = slope r i + intercept Constraint Express recomputation time rct_i = rcp_i ACT_i y_i == i range num_nodes ACT_i = graph nodes i sac_runtime prob += rct i = M y i prob += rct i = ACT_i rcp i prob += rct i = ACT_i rcp i - M - y i Constraint Peak memory should below budget prob += max_m = memory_budget Set Objeictive prob += lpSum rct Solve solver = PULP_CBC_CMD gapRel= timeLimit= msg= status = prob solve solver If solver fails print status empty solution status = logger error Solver failed find solution s LpStatus status - Gather solution optimal solution found ac_decisions = i range num_nodes round y i varValue == ac_decisions graph nodes i fqn = round r i varValue recomputation_time = round value prob objective peak_mem = round max_m varValue MEM_MULTIPLIER ac_decisions recomputation_time peak_mem SACDecision IntEnum RECOMPUTE = SAVE = get_optimal_checkpointing_policy_per_module sac_stats SACStats memory_budget float - list int This adapted -- https github com facebookresearch xformers blob c c ac f b bc c ed f f xformers checkpoint py#L Given SACStats module including list operators their memory runtimes metadata decide via MILP optimal set operators checkpoint under given ` ` memory_budget ` ` Args sac_stats SACStats object module memory_budget float between zero one Returns List int decision whether each operator should saved recomptued = memory_budget = raise ValueError f ` memory_budget ` must float between Got memory_budget num_ops = len sac_stats func_names Create MILP problem prob = LpProblem SAC-per-module LpMaximize Create decision variables x i = means i-th operator should saved otherwise should recomputed x = LpVariable matrix x list range num_ops LpInteger Add constraints Constraint random ops should saved ` ` force_store_random ` ` True otherwise random ops should either all recomputed all saved sac_stats force_store_random i sac_stats rand_ops prob += x i == SACDecision SAVE value i i zip sac_stats rand_ops - sac_stats rand_ops prob += x i == x i Constraint view-like ops should always recomputed i sac_stats view_like_ops prob += x i == SACDecision RECOMPUTE value Constraint inplace ops should always done conjunction its parent op op op_parent sac_stats inplace_ops op = op_parent prob += x op == x op_parent prob += x op == SACDecision SAVE value Constraint saved memory should under ` ` memory_budget ` ` max_memory = math ceil memory_budget sum sac_stats memory prob += lpDot x sac_stats memory = max_memory Objective minimize recomputation time note ILP maximization problem because x i == means op saved recomputed thus recomputation time sum sac_stats runtimes - lpDot x sac_stats runtimes prob += lpDot x sac_stats runtimes Solve solver = PULP_CBC_CMD gapRel= timeLimit= msg= status = prob solve solver If solver fails print status empty solution status = logger error Solver failed find solution s LpStatus status Gather solution optimal solution found round x i varValue i range num_ops