Owner s oncall profiler gc re textwrap unittest weakref typing Any torch torch nn nn torch optim torch utils data torch _C _profiler _ExtraFields_PyCall _TensorMetadata torch profiler _utils profile torch testing _internal common_utils run_tests TestCase tqdm shutdown properly will leave monitor thread alive This causes issue multithreading test because we check all events test their tids The events correspond these lingering threads all have TID uint _t - which invalid The work around turning off monitoring thread when tqdm loaded Since these unit tests safe turn off monitor thread try tqdm tqdm tqdm monitor_interval = except ImportError pass Json = dict str Any find_node_with_name nodes name node _utils traverse_dfs nodes node name == name node find_node_with_regex nodes pattern node _utils traverse_dfs nodes re search pattern node name node SimpleNet nn Module __init__ - None super __init__ fc = nn Linear fc = nn Linear forward x fc fc x TestTorchTidyProfiler TestCase _get_tensor_fields node index assertIsNotNone node assertIsInstance node extra_fields torch _C _profiler _ExtraFields_TorchOp tensor_info = node extra_fields inputs index assertIsInstance tensor_info _TensorMetadata assertIsNotNone tensor_info impl_ptr assertIsNotNone tensor_info storage_data_ptr assertIsNotNone tensor_info id tensor_info impl_ptr tensor_info storage_data_ptr tensor_info id test_pointers_and_ids = torch randn a_initial_storage_data = storage data_ptr Views tensors can share same storage have different TensorImpls b = view c = torch randn c_initial_storage_data = c storage data_ptr d = torch randn profile with_stack=True profile_memory=True record_shapes=True p _ = + c _ = b c Resize should create new data_ptr keep TensorImpl same f = resize_ _ = torch relu f ` set_ ` points Tensor existing storage _ = d sin c set_ d storage _ = c cos nodes = p profiler kineto_results experimental_event_tree get_fields op_name index _get_tensor_fields find_node_with_name nodes op_name index a_impl a_storage_data a_id = get_fields aten add b_impl b_storage_data _ = get_fields aten mul Profiler matches ground truth Python API assertEqual a_storage_data a_initial_storage_data Views handled correctly assertEqual a_storage_data b_storage_data assertNotEqual a_impl b_impl The same Tensor used multiple calls gives identical results c_impl c_storage_data c_id = get_fields aten add assertEqual c_impl c_storage_data c_id get_fields aten mul assertEqual c_storage_data c_initial_storage_data Mutations underlying storage reflected But ID shared f_impl f_storage_data f_id = get_fields aten relu assertEqual a_impl f_impl assertNotEqual a_storage_data f_storage_data assertEqual a_id f_id Calling ` set_ ` existing Tensor makes them share ID d_impl d_storage_data d_id = get_fields aten sin c_impl_new c_storage_data_new c_id_new = get_fields aten cos assertNotEqual d_impl c_impl_new assertEqual d_storage_data c_storage_data_new assertEqual c_id c_id_new assertEqual d_id c_id_new staticmethod _format_allocations profiled_code gc collect profile profile_memory=True record_shapes=True prof profiled_code gc collect root_events = prof profiler kineto_results experimental_event_tree events = sorted _utils traverse_dfs root_events key=lambda x x start_time_ns allocations = tuple event extra_fields event events isinstance event extra_fields torch _C _profiler _ExtraFields_Allocation textwrap indent \n join f repr i id f repr i allocation_id f Allocation i alloc_size Free i allocations test_tensorimpl_invalidation_set - None profiled_code add_empty_set bool x = torch ones Determines new storage created before after old one destroyed add_empty_set x set_ x set_ torch ones storage x view_as x assertExpectedInline _format_allocations lambda profiled_code add_empty_set=False \ Allocation Allocation Free Free assertExpectedInline _format_allocations lambda profiled_code add_empty_set=True \ Allocation Free Allocation Free test_tensorimpl_invalidation_keep_alive - None profiled_code add_empty_set bool x = torch ones x_storages = x storage _ range x set_ x set_ torch ones storage This keeps StorageImpls alive preserves chain Despite ` set_ ` call x_storages append x storage x view_as x Free storage deterministic fashion while x_storages x_storages pop gc collect Determines new storage created before after old one destroyed add_empty_set x set_ _ range x set_ torch ones storage x view_as x del x gc collect assertExpectedInline _format_allocations lambda profiled_code add_empty_set=False \ Allocation Allocation Allocation Allocation Free Free Free Allocation Free Allocation Free Allocation Free Free assertExpectedInline _format_allocations lambda profiled_code add_empty_set=True \ Allocation Allocation Allocation Allocation Free Free Free Free Allocation Allocation Free Allocation Free Free test_tensorimpl_invalidation_full - None profiled_code x = torch ones x_storages = x storage _ range x set_ x set_ torch ones storage x_storages append x storage x view_as x Free storage deterministic fashion while x_storages x_storages pop gc collect _ range x set_ torch ones storage _ range x set_ x set_ torch ones storage i range x resize_ + i x view_as x assertExpectedInline _format_allocations profiled_code \ Allocation Allocation Allocation Allocation Free Free Free Allocation Free Allocation Free Allocation Free Free Allocation Free Allocation Free Allocation Allocation Free Allocation Free Allocation Free Free test_tensorimpl_invalidation_scalar_args - None profiled_code torch no_grad x = torch ones _ range x add_ assertExpectedInline _format_allocations profiled_code \ Allocation Allocation Allocation Free Free Allocation Allocation Free Free Allocation Allocation Free Free Allocation Allocation Free Free Allocation Allocation Free Free Allocation Allocation Free Free Allocation Allocation Free Free Allocation Allocation Free Free Allocation Allocation Free Free Allocation Allocation Free Free Free test_module_and_optimizer_ids - None model = torch nn Linear bias=True optimizer = torch optim SGD model parameters lr= momentum= check cold_start bool - None profile with_stack=True profile_memory=True record_shapes=True p x = torch ones _ = x sin Mark ` x ` model x backward optimizer step _ = optimizer state model weight momentum_buffer cos Mark weight momentum _ = model weight grad tan Mark weight gradient nodes = p profiler kineto_results experimental_event_tree get_fields op_name index _get_tensor_fields find_node_with_name nodes op_name index Marked Tensors act ground truth python tracer IDs _ _ x_id = get_fields aten sin _ _ weight_momenumtum_id = get_fields aten cos _ _ weight_grad_id = get_fields aten tan assertNotEqual x_id weight_momenumtum_id assertNotEqual x_id weight_grad_id assertNotEqual weight_momenumtum_id weight_grad_id Use linear op identify weight ground truth linear_op_node = find_node_with_name nodes aten linear assertIsNotNone linear_op_node x_metadata weight_metadata _ = linear_op_node extra_fields inputs assertEqual x_id x_metadata id Module linear_module_node = find_node_with_name nodes nn Module Linear_ assertIsNotNone linear_module_node assertIsNotNone linear_module_node extra_fields module assertIsNone linear_module_node extra_fields optimizer linear_parameters = linear_module_node extra_fields module parameters name weight weight_grad = linear_parameters assertEqual name weight assertEqual weight id weight_metadata id assertEqual weight_grad None cold_start cold_start assertEqual weight_grad id weight_grad_id Optimizer step_node = find_node_with_regex nodes _optimizer_step_code assertIsNotNone step_node assertIsNone step_node extra_fields module assertIsNotNone step_node extra_fields optimizer optimizer_parameters = step_node extra_fields optimizer parameters assertEqual len optimizer_parameters Weight bias weight weight_grad state = optimizer_parameters assertEqual weight id weight_metadata id assertEqual weight_grad id weight_grad_id assertEqual len state assertEqual state momentum_buffer assertEqual state id weight_momenumtum_id Check we handle first step lazy initialization steady state check cold_start=True check cold_start=False _test_allocation_ids before_fn after_fn - None profile profile_memory=True record_shapes=True p Introduce other operations allocations check robustness _ = before_fn x = torch rand x resize_ We need use ` x ` post resize profiler determine its ID x sin Introduce other operations allocations check robustness _ = after_fn Ensure ` x ` last variable collected make easier find deallocation event gc collect del x gc collect nodes = p profiler kineto_results experimental_event_tree find_chain names list str out = name names root = out - out nodes out append find_node_with_name root name assertIsNotNone out - name out allocation = find_chain aten rand aten empty memory - extra_fields _ uniform_node = find_chain aten rand aten uniform_ _ x_storage_data x_id = _get_tensor_fields uniform_node Make sure IDs consistent between allocations op inputs assertEqual allocation ptr x_storage_data assertEqual allocation id x_id resize_node = find_node_with_name nodes aten resize_ assertIsNotNone resize_node assertEqual len resize_node children allocate_new = resize_node children extra_fields free_old = resize_node children extra_fields Destruction old storage x assertEqual free_old id allocation id assertEqual free_old ptr allocation ptr Make sure ID retained through change storage assertEqual allocate_new id allocation id assertNotEqual allocate_new ptr allocation ptr Deletion when ` x ` goes out scope free_new = i i nodes i tag == torch _C _profiler _EventType Allocation - extra_fields assertIsInstance free_new torch _C _profiler _ExtraFields_Allocation assertEqual free_new id allocate_new id assertEqual free_new ptr allocate_new ptr test_allocation_ids - None _test_allocation_ids lambda None lambda None test_allocation_ids_with_other_ops - None x = torch ones _test_allocation_ids lambda x + relu_ lambda torch zeros cos test_impl_reuse - None repeats = _ profile profile_memory=True record_shapes=True p _ range repeats torch ones gc collect roots = p profiler kineto_results experimental_event_tree tensor_impls = tuple e extra_fields inputs impl_ptr e _utils traverse_dfs roots e name == aten fill_ assertEqual len tensor_impls repeats assertEqual len set tensor_impls repeats test_allocation_id_uniqueness - None repeats = _ profile profile_memory=True record_shapes=True p _ range repeats torch ones gc collect roots = p profiler kineto_results experimental_event_tree id_set = set e _utils traverse_dfs roots fields = e extra_fields isinstance fields torch _C _profiler _ExtraFields_TorchOp id_set &#124; = t allocation_id t fields inputs isinstance t _TensorMetadata isinstance fields torch _C _profiler _ExtraFields_Allocation id_set add fields allocation_id id_set difference_update None assertEqual repeats len id_set test_extra_fields profile with_stack=True profile_memory=True p _ = torch ones nodes = p profiler kineto_results experimental_event_tree node = find_node_with_name nodes aten ones assertIsNotNone node assertIsInstance node extra_fields torch _C _profiler _ExtraFields_TorchOp assertIsInstance node parent extra_fields torch _C _profiler _ExtraFields_PyCCall assertEqual node children name aten empty assertEqual node children children name memory assertIsInstance node children children extra_fields torch _C _profiler _ExtraFields_Allocation test_tensor_properties x = torch ones as_strided y = torch ones requires_grad=True profile with_stack=True profile_memory=True record_shapes=True p _ = x + y _ = x y nodes = p profiler kineto_results experimental_event_tree node = find_node_with_name nodes aten add assertIsNotNone node assertIsInstance node extra_fields torch _C _profiler _ExtraFields_TorchOp getattr_inputs name default getattr i name default i node extra_fields inputs assertEqual getattr_inputs sizes assertEqual getattr_inputs strides assertEqual getattr_inputs layout None torch strided torch strided None assertEqual getattr_inputs device None torch device cpu torch device cpu None assertEqual getattr_inputs dtype None torch float torch float None assertEqual node extra_fields scope torch profiler RecordScope FUNCTION mul_node = find_node_with_name nodes aten mul assertIsNotNone mul_node assertEqual node extra_fields sequence_number + mul_node extra_fields sequence_number test_sparse_tensors i = v = s = torch sparse_coo_tensor i v profile with_stack=True profile_memory=True record_shapes=True p _ = s + s nodes = p profiler kineto_results experimental_event_tree node = find_node_with_name nodes aten add assertIsNotNone node assertIsInstance node extra_fields torch _C _profiler _ExtraFields_TorchOp getattr_inputs name default getattr i name default i node extra_fields inputs assertEqual getattr_inputs sizes assertEqual getattr_inputs strides assertEqual getattr_inputs layout None torch sparse_coo torch sparse_coo None assertEqual getattr_inputs device None torch device cpu torch device cpu None unittest skipIf torch backends mkldnn is_available MKL-DNN build disabled test_mkldnn_tensors x = torch ones to_mkldnn profile with_stack=True profile_memory=True record_shapes=True p _ = x + x nodes = p profiler kineto_results experimental_event_tree node = find_node_with_name nodes aten add assertIsNotNone node assertIsInstance node extra_fields torch _C _profiler _ExtraFields_TorchOp getattr_inputs name default getattr i name default i node extra_fields inputs assertEqual getattr_inputs sizes assertEqual getattr_inputs strides assertEqual getattr_inputs layout None torch _mkldnn torch _mkldnn None assertEqual getattr_inputs device None torch device cpu torch device cpu None test_scalar_ins x = torch ones alpha = profile with_stack=True profile_memory=True record_shapes=True p _ = torch add x alpha=alpha nodes = p profiler kineto_results experimental_event_tree node = find_node_with_name nodes aten add assertIsNotNone node getattr_inputs name default getattr i name default i node extra_fields inputs The second argument add gets promotoed zerodim Tensor assertEqual getattr_inputs dtype None torch float torch float None assertEqual getattr_inputs sizes assertEqual node extra_fields inputs alpha test_tensor_lists x = torch ones y = torch ones profile with_stack=True profile_memory=True record_shapes=True p _ = torch stack x y nodes = p profiler kineto_results experimental_event_tree node = find_node_with_name nodes aten stack inputs = node extra_fields inputs assertEqual len inputs assertIsInstance inputs list assertEqual len inputs assertEqual x storage data_ptr inputs storage_data_ptr assertEqual y storage data_ptr inputs storage_data_ptr test_nnmodule_params flat_out_extrafields nodes out=None out None out = node nodes isinstance node extra_fields _ExtraFields_PyCall node extra_fields module node extra_fields module parameters out append node extra_fields module flat_out_extrafields node children out out inputs = torch rand net = SimpleNet out = net inputs torch nn functional cross_entropy out torch rand backward torch profiler profile with_stack=True profile_memory=True p _ = net inputs modules = flat_out_extrafields p profiler kineto_results experimental_event_tree assertEqual len modules f Expected two parameter list got len modules params = n p storage_data_ptr g storage_data_ptr module modules n p g module parameters expected = name val storage data_ptr val grad storage data_ptr name val net fc _parameters items expected += name val storage data_ptr val grad storage data_ptr name val net fc _parameters items assertEqual expected params f expected vs params _flat_out_extrafields nodes out=None out None out = node nodes isinstance node extra_fields _ExtraFields_PyCall node extra_fields optimizer node extra_fields optimizer parameters avoiding OptInfo duplicates iterations addr = node extra_fields optimizer parameters storage_data_ptr o o out addr == o parameters storage_data_ptr out append node extra_fields optimizer _flat_out_extrafields node children out out _check_results opt opts check_items=False assertEqual len opts f Expected optimizer len opts len opts assertEqual id opt opts self_ptr f Optimizer addr id opt vs profiled addr opts self_ptr check_items assertEqual len opt param_groups len opts group opt_ zip opt param_groups opts assertEqual v storage data_ptr v group get params o storage_data_ptr o _ _ opt_ parameters opt_ opts observed_state = p storage_data_ptr name s storage_data_ptr name s state p _ state opt_ parameters Make sure profiler collected all optimizer state check address recorded profiler correct parameter parameter_state opt state items assertEqual name value storage data_ptr name value parameter_state items observed_state get parameter storage data_ptr test_optimizer inputs = torch rand torch profiler profile with_stack=True profile_memory=True p net = SimpleNet opt = torch optim SGD net parameters lr= momentum= opt zero_grad out = net inputs loss = torch nn functional cross_entropy out torch rand loss backward opt step _check_results opt _flat_out_extrafields p profiler kineto_results experimental_event_tree False _test_optimizer_parameters optimizer_factory inputs = torch rand torch profiler profile with_stack=True profile_memory=True p net = SimpleNet opt = optimizer_factory net parameters _ range opt zero_grad out = net inputs loss = torch nn functional cross_entropy out torch rand loss backward opt step _check_results opt _flat_out_extrafields p profiler kineto_results experimental_event_tree True test_optimizer_parameters_sgd _test_optimizer_parameters lambda params torch optim SGD params lr= momentum= test_optimizer_parameters_adam _test_optimizer_parameters lambda params torch optim Adam params foreach=True test_allocations gc collect profile profile_memory=True p x = torch empty nodes = p profiler kineto_results experimental_event_tree node = find_node_with_name nodes memory assertIsNotNone node alloc_size = fp - bytes ptr = node extra_fields ptr assertGreater ptr assertEqual node extra_fields alloc_size alloc_size assertEqual node extra_fields device torch device cpu total_allocated = node extra_fields total_allocated total_reserved only CUDACachingAllocator assertEqual node extra_fields total_reserved profile profile_memory=True p del x gc collect nodes = p profiler kineto_results experimental_event_tree node = find_node_with_name nodes memory assertIsNotNone node assertEqual node extra_fields ptr ptr assertEqual node extra_fields alloc_size -alloc_size assertEqual node extra_fields device torch device cpu assertEqual node extra_fields total_allocated total_allocated - alloc_size test_refcounts Sentinel pass make outer_sentinel = Sentinel outer Python will only close over variables used function _ = outer_sentinel inner_sentinel = Sentinel inner _ = inner_sentinel profile with_stack=True inner weakref ref inner_sentinel outer weakref ref outer_sentinel Use factory function ensure test scope never sees strong references ` del ` has strange semantics interact closures AST level so simpler outer outer_sentinel_ref = make inner_sentinel_ref = outer assertIsNone inner_sentinel_ref ` outer ` holds last reference via closure assertIsNotNone outer_sentinel_ref del outer assertIsNone outer_sentinel_ref __name__ == __main__ run_tests