mypy allow-untyped-defs This file provides number global variables handlers actually thread local dynamically scoped Inductor patching them various implementations depending situation These handlers interacted fairly stylized way Typically we will V module virtualized V Various handlers accessible attributes module example you might access ` ` V graph sizevars size_hint ` ` resolve size hint associated number There few distinct usage patterns virtualized global variables Implicit argument passing Examples ` ` V current_node ` ` ` ` V aot_compilation ` ` Use ` ` V set_current_node ` ` change what current node while we re executing some region code so code inside region can query ` ` V current_node ` ` find out what This often more convenient than manually threading current node argument through all call stacks Per-compilation global state Examples ` ` V fake_mode ` ` ` ` V graph ` ` For given ` ` compile_fx ` ` invocation these typically don t change they associated some internal state so they cannot just global functions We install these objects beginning compilation then you can conveniently access them without having pass them around Alternate define-by-run interpretations Examples ` ` V ops ` ` ` ` V kernel ` ` A commonly used IR Inductor define-by-run instead maintaining explicit syntax data structures we instead represent loop bodies callable functions which internally invoke operations defined ` ` V ops ` ` To perform semantic analysis print code generate these operations we dynamically patch ` ` V ops ` ` alternate handler intended semantics then run callable function For example extract out traditional FX graph representation define-by-run IR simply install handler records each ` ` ops ` ` call graph TODO Define parent protocol defines all operations V ops expected support It typically error access virtualized global without having installed appropriate handler you will get NullHandler although some cases we provide default implementation One last thing although most virtualized globals accessed via ` ` V ` ` ` ` ops ` ` ubiquitous enough have its own top level variable so you will typically see ` ` ops constant ` ` rather than ` ` V ops constant ` ` In fact these equivalent former interface supports arithmetic overloads like ` ` x + y ` ` instead forcing ` ` ops add x y ` ` so should preferred Some operators seemingly unused they implicitly used ops_wrapper In particular we typically have operator every basic pointwise PyTorch operation supported __future__ annotations contextlib AbstractContextManager contextmanager threading local typing Any Callable cast Generic TYPE_CHECKING TypeVar Union torch utils _ordered_set OrderedSet ops_handler noqa F DefaultHandler KernelFormatterHandler MockHandler OpsHandler ReductionType StoreMode WrapperHandler TYPE_CHECKING torch torch _inductor choices InductorChoices torch _inductor codegen cpp_utils LocalBufferContext torch _inductor debug DebugContext torch _inductor graph GraphLowering torch _inductor ir ExternKernelNode torch _inductor loop_body InterpreterShim torch _subclasses FakeTensorMode threadlocal = local T = TypeVar T NullHandler Sentinel indicating global variable unset ala None Typically attempting access global variable before s set error NullHandler won t fail until you try access attribute If virtualized value set _PoisonedVirtual then any attempt get value will result exception being raised This useful we want trap uninitialized reads virtualized globals - example when compiling subprocess we don t want child reading globals weren t copied parent _PoisonedVirtual = object Virtualized Generic T Implements global variable redirects via thread local variable NB construct create global variable singleton This allows us swap different op implementations codegen NB Despite fact we typically call these handlers e g NullHandler default value variable we sometimes use these variables store other things like booleans __init__ vname str default Union Callable T type NullHandler _vname = vname _key str = f __torchinductor_ vname _default = default _set_handler value T - AbstractContextManager None prior = _get_handler False setattr threadlocal _key value contextmanager ctx try yield finally _set_handler prior ctx _get_handler check_poisoned bool = True - T try value = getattr threadlocal _key check_poisoned value _PoisonedVirtual raise RuntimeError f Attempt use poisoned virtualized value _vname value except AttributeError TODO To honest I feel we probably should just error case instead making null handler will probably error when you getattr _default type ignore return-value __getattr__ name str - Any getattr _get_handler name NullKernelHandler NullHandler We need access ` V kernel removed_buffers ` DeferredLine when there no kernel context This happens when codegening wrapper Initialize ` removed_buffers ` ` inplaced_to_remove ` explicitly so we don t need call getattr default value which error prone typo attribute name __init__ super __init__ removed_buffers = OrderedSet Any inplaced_to_remove = OrderedSet Any index_dtype = tl int get_index_dtype_as_torch_dtype torch index_dtype == tl int torch int index_dtype == tl int torch int raise ValueError f Unknown dtype index_dtype _ops Virtualized OpsHandler Any = Virtualized ops cast type OpsHandler Any MockHandler _graph Virtualized GraphLowering = Virtualized graph NullHandler _extern_kernel_nodes Virtualized list ExternKernelNode = Virtualized extern_kernel_nodes NullHandler _real_inputs Virtualized list torch Tensor = Virtualized real_inputs NullHandler _fake_mode Virtualized FakeTensorMode = Virtualized fake_mode NullHandler _kernel Virtualized NullKernelHandler = Virtualized kernel NullKernelHandler TODO improve type _debug Virtualized DebugContext = Virtualized debug NullHandler _interpreter Virtualized InterpreterShim = Virtualized interpreter NullHandler _aot_compilation Virtualized bool = Virtualized aot_compilation NullHandler _current_node Virtualized torch fx Node = Virtualized current_node NullHandler _local_buffer_context Virtualized LocalBufferContext = Virtualized local_buffer_context NullHandler _choices_default Lazy init global choices handler We virtualize InductorChoices allow changing inductor heuristics out tree torch _inductor config torch _inductor choices InductorChoices config inductor_choices_class None rv = config inductor_choices_class rv = InductorChoices setattr threadlocal _choices _key rv rv _choices Virtualized InductorChoices = Virtualized choices _choices_default OpsValue The type most ops calls This exists so we can overload magic methods write mathematical expressions much more fluently So instead ops add ops mul ops mul ops sub ops mul _Ap x _Ap x x _ we can write _Ap x - _Ap x x + _ value Any __init__ value value = value __str__ str value __repr__ f OpsValue value r __add__ other ops add other __mul__ other ops mul other __sub__ other ops sub other __neg__ ops neg __truediv__ other ops truediv other __floordiv__ other ops floordiv other __mod__ other ops mod other __pow__ other ops pow other __lt__ other ops lt other __le__ other ops le other __eq__ other ops eq other __ne__ other ops ne other __gt__ other ops gt other __ge__ other ops ge other __and__ other ops bitwise_and other __or__ other ops bitwise_or other __xor__ other ops bitwise_xor other __invert__ ops bitwise_not __rshfit__ n ops bitwise_right_shift n __lshift__ n ops bitwise_left_shift n OpsWrapper DefaultHandler This wraps any returned IR values into ` OpsValue ` instance so we can overload magic methods writing mathematical expressions fluently _default name str args tuple Any kwargs dict str Any - Any new_args = OpsWrapper _unwrap args new_kwargs = k OpsWrapper _unwrap v k v kwargs items OpsWrapper _wrap getattr _ops name new_args new_kwargs staticmethod _unwrap x isinstance x list tuple tuple OpsWrapper _unwrap v v x isinstance x OpsValue x value x staticmethod _wrap x isinstance x list tuple tuple OpsValue v v x OpsValue x staticmethod indirect_indexing index size check=True wrap_neg=True Returns sympy value IR value index = OpsWrapper _unwrap index _ops indirect_indexing index size check wrap_neg ops OpsHandler Any = OpsWrapper _V MockHandler = MockHandler KernelFormatterHandler = KernelFormatterHandler WrapperHandler = WrapperHandler set_ops_handler Callable OpsHandler Any AbstractContextManager None = _ops _set_handler get_ops_handler Callable OpsHandler Any = _ops _get_handler set_graph_handler Callable GraphLowering Any = _graph _set_handler set_extern_kernel_nodes Callable list ExternKernelNode Any = _extern_kernel_nodes _set_handler set_real_inputs Callable Any Any = _real_inputs _set_handler get_real_inputs Callable Any = _real_inputs _get_handler set_fake_mode Callable Any Any = _fake_mode _set_handler get_fake_mode Callable Any = _fake_mode _get_handler set_kernel_handler Callable Any Any = _kernel _set_handler set_debug_handler Callable Any Any = _debug _set_handler set_interpreter_handler Callable Any Any = _interpreter _set_handler set_aot_compilation Callable bool Any = _aot_compilation _set_handler get_aot_compilation Callable Any = _aot_compilation _get_handler set_current_node Callable Any Any = _current_node _set_handler get_current_node Callable Any = _current_node _get_handler set_local_buffer_context Callable Any Any = _local_buffer_context _set_handler get_local_buffer_context Callable Any = _local_buffer_context _get_handler set_choices_handler Callable Any Any = _choices _set_handler property ops - OpsHandler Any The operator handler specific current codegen task _ops _get_handler property graph - GraphLowering The graph currently being generated _graph _get_handler property extern_kernel_nodes - list ExternKernelNode The extern_kernel_nodes needed entire graph including subgraphs See ` ProxyExecutor Design Note ` ir py more details _extern_kernel_nodes _get_handler property real_inputs non-fake example inputs _real_inputs _get_handler property fake_mode The graph currently being generated _fake_mode _get_handler property kernel The kernel currently being generated _kernel _get_handler property debug _debug _get_handler property interpreter _interpreter _get_handler property aot_compilation _aot_compilation _get_handler True property current_node _current_node _get_handler property local_buffer_context _local_buffer_context _get_handler property choices - InductorChoices _choices _get_handler V = _V