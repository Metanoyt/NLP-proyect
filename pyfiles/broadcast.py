itertools operator numpy np torch benchmark BroadcastMulBench benchmark Benchmark __init__ mode device dtype case M N K super __init__ mode device dtype case = case M = M N = N K = K case == row d = rand M N device=device dtype=dtype requires_grad=self requires_grad d = rand M K device=device dtype=dtype requires_grad=self requires_grad case == mid d = rand M N device=device dtype=dtype requires_grad=self requires_grad d = rand N K device=device dtype=dtype requires_grad=self requires_grad case == col d = rand M K device=device dtype=dtype requires_grad=self requires_grad d = rand N K device=device dtype=dtype requires_grad=self requires_grad raise ValueError f invalid case case inputs = d d forward d d y = d + d y reference numpy d + numpy d config M N K staticmethod default_configs memory_workload mode == fwd sol_count = algorithmic_count = sol_count = + algorithmic_count = + + buffer_size = M N K sol buffer_size sol_count algorithmic buffer_size algorithmic_count BroadcastRowBench BroadcastMulBench __init__ mode device dtype M N K super __init__ mode device dtype row M N K staticmethod module broadcast_row BroadcastMidBench BroadcastMulBench __init__ mode device dtype M N K super __init__ mode device dtype mid M N K staticmethod module broadcast_mid BroadcastColBench BroadcastMulBench __init__ mode device dtype M N K super __init__ mode device dtype col M N K staticmethod module broadcast_col BroadcastThreeArgs benchmark Benchmark __init__ mode device dtype M N K L super __init__ mode device dtype M = M N = N K = K L = L d = rand M N device=device dtype=dtype requires_grad=self requires_grad d = rand K M device=device dtype=dtype requires_grad=self requires_grad d = rand L K device=device dtype=dtype requires_grad=self requires_grad inputs = d d d forward d d d y = d + d + d y reference numpy d + numpy d + numpy d config M N K L staticmethod default_configs memory_workload mode == fwd sol_count = algorithmic_count = sol_count = + algorithmic_count = + + + buffer_size = M N K L sol buffer_size sol_count algorithmic buffer_size algorithmic_count staticmethod module broadcast_ args benchmark register_benchmark_class BroadcastRowBench benchmark register_benchmark_class BroadcastMidBench benchmark register_benchmark_class BroadcastColBench benchmark register_benchmark_class BroadcastThreeArgs TODO merge elementwise bench A template elementwise operations A derived will override instance customize its behavior BroadcastBench benchmark Benchmark List customization variables op_str = None binary_op_pt_func = None binary_op_np_func = None unary_op_pt_func = None unary_op_np_func = None split_input = True __init__ mode device dtype M N K super __init__ mode device dtype M = M N = N K = K d = rand M N device=device dtype=dtype requires_grad=self requires_grad d = rand K N device=device dtype=dtype requires_grad=self requires_grad d = rand M N device=device dtype=dtype requires_grad=self requires_grad d = rand K M device=device dtype=dtype requires_grad=self requires_grad inputs = d d d d _eval d d d d binary_op unary_op binary_op binary_op x y x + y unary_op unary_op x x split_input d = unary_op d d = unary_op d d = unary_op d d = unary_op d d d d d = unary_op d unary_op d unary_op d + unary_op d = binary_op d d b = binary_op d d c = + b c forward d d d d binary_op = __class__ binary_op_pt_func unary_op = __class__ unary_op_pt_func _eval d d d d binary_op unary_op reference binary_op = __class__ binary_op_np_func unary_op = __class__ unary_op_np_func d d d d = numpy d d d d d d _eval d d d d binary_op unary_op config M N K classmethod module cls broadcast_ + cls op_str memory_workload input_count = len inputs mode == fwd split_input sol_count = algorithmic_count = sol_count = algorithmic_count = split_input sol_count = algorithmic_count = input_count sol_count = algorithmic_count = input_count buffer_size = M N K sol buffer_size sol_count algorithmic buffer_size algorithmic_count staticmethod default_configs register_broadcast_ops binary_op_list = mul operator mul add operator add sub operator sub div lambda b b + e- pow torch pow np power no fuson triggered max torch max np maximum min torch min np minimum unary_op_list = erf torch erf np erf exp torch exp np exp sin torch sin np sin cos torch cos np cos split_input binary_op itertools product True False binary_op_list Make copy BroadcastBench len binary_op == op_str op_pt_func = binary_op op_np_func = op_pt_func len binary_op == op_str op_pt_func op_np_func = binary_op split_str = split split_input shared op_str = split_str + _ + op_str bm_cls = type BroadcastBench_ + op_str BroadcastBench bm_cls op_str = op_str bm_cls binary_op_pt_func = op_pt_func bm_cls binary_op_np_func = op_np_func bm_cls split_input = split_input benchmark register_benchmark_class bm_cls split_input unary_op itertools product True False unary_op_list Make copy BroadcastBench len unary_op == op_str op_pt_func = unary_op op_np_func = op_pt_func len unary_op == op_str op_pt_func op_np_func = unary_op split_str = split split_input shared op_str = split_str + _ + op_str bm_cls = type BroadcastBench_ + op_str BroadcastBench bm_cls op_str = op_str bm_cls unary_op_pt_func = op_pt_func bm_cls unary_op_np_func = op_np_func bm_cls split_input = split_input benchmark register_benchmark_class bm_cls register_broadcast_ops