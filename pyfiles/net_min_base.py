mypy allow-untyped-defs logging collections abc Callable dataclasses dataclass typing Any cast Optional torch torch fx torch fx _compatibility compatibility torch fx node map_arg shape_prop ShapeProp split_utils split_by_tags tools_common CALLABLE_NODE_OPS FxNetAccFusionsFinder Names NodeList NodeSet TensorOrTensors Tensors __all__ = FxNetMinimizerBadModuleError FxNetMinimizerRunFuncError FxNetMinimizerResultMismatchError _LOGGER = logging getLogger __name__ compatibility is_backward_compatible=False FxNetMinimizerBadModuleError Exception Raised failed split out minimize module compatibility is_backward_compatible=False FxNetMinimizerRunFuncError Exception Raised error occurs during run_a run_b functions compatibility is_backward_compatible=False FxNetMinimizerResultMismatchError Exception Raised comparing function thinks results mismatching dataclass _MinimizerSettingBase Args ` accumulate_error ` Instead using s input both converted module verify use previous outputs each converted module input accumulate errors ` traverse_method ` sequential binary accumulate Determine way traverse nodes FX module ` find_all ` Minimizer will go through entire model all problematic nodes ` return_intermediate ` If true when using ` run_nodes ` function run model intermediate results all ops will returned output ` all_outputs ` If true when using ` _run_and_compare ` function all output nodes subgraph will used comparison accumulate_error bool = False traverse_method str = sequential find_all bool = False return_intermediate bool = False all_outputs bool = False __str__ settings_str = FX Minimizer Settings \n k v vars items settings_str += f \t k v \n settings_str _MinimizerBase This used automatically find problematic nodes model It takes FX graphmodule generate some submodules while traverse graph Then two functions ` run_a ` ` run_b ` will used run same submodule function ` compare_fn ` will used compare results Currently we provides two ways traverse graph generate submodules Sequential traversal will traverse graph node node generate one submodule one single node Binary searching will do binary search style traversal graph For internal Users guide can found here https fb quip com HDtuAgiKGfkP __init__ module torch fx GraphModule sample_input Tensors compare_fn Callable TensorOrTensors TensorOrTensors Names tuple float bool settings _MinimizerSettingBase module_exporter Optional Callable Tensors torch fx GraphModule str None = None exclusion_fn Optional Callable NodeList int int None = None assert isinstance module torch fx GraphModule module = module sample_input = sample_input compare_fn = compare_fn module_exporter = module_exporter settings = settings exclusion_fn = exclusion_fn Stores outputs run_a function a_outputs dict str Any = Stores outputs run_b function b_outputs dict str Any = Stores results compare_fn results dict Any Any = Stores report runs reports list list str = Current iteration iteration int = callable_nodes = node node module graph nodes node op CALLABLE_NODE_OPS run_shape_prop fusions = FxNetAccFusionsFinder module callable_nodes Check number input sample_input matches number placeholders placeholders = node name node module graph nodes node op == placeholder assert len placeholders == len sample_input Store sample_input i name enumerate placeholders a_outputs name = sample_input i b_outputs name = sample_input i run_shape_prop - None Helper function run shape propagation module Can overridden subclasses custom shape propagation logic ShapeProp module propagate sample_input run_a mod torch fx GraphModule inputs Tensors report_idx int = - - TensorOrTensors Run ` mod ` ` inputs ` generate output The output will compared output run_b raise RuntimeError run_a implemented run_b mod torch fx GraphModule inputs Tensors report_idx int = - - TensorOrTensors Run ` mod ` ` inputs ` generate output The output will compared output run_a raise RuntimeError run_b implemented _store_outputs a_result TensorOrTensors b_result TensorOrTensors submodule torch fx GraphModule Store outputs run_a run_b into a_outputs b_outputs so we can use them when execute preceding nodes use those outputs inputs Args a_result Output run_a Could tensor tensors b_result Output run_b Could tensor tensors submodule The module generates a_result b_result output_node = next node node submodule graph nodes node op == output Only one output isinstance output_node args torch fx Node a_outputs output_node args name = a_result b_outputs output_node args name = b_result Multiple outputs i arg enumerate output_node args a_outputs arg name = a_result i b_outputs arg name = b_result i _get_submod_inputs main_module torch fx GraphModule submod_path str - tuple Tensors Tensors Try get submodule inputs stored outputs If found then use torch_glow get_submod_inputs get inputs If accumulate_error False use a_input run_a run_b otherwise use a_input run_a b_input run_b Args main_module Top-levlel fx module submod_path Path submodule we want run compare results Returns a_input List tensor s will used run_a submodule inputs b_input List tensor s will used run_b submodule inputs a_input = b_input = submodule = getattr main_module submod_path placeholders = node name node submodule graph nodes node op == placeholder If all placeholder can found stored outputs use stored outputs inputs Otherwise use ` torch_glow get_submod_inputs ` get inputs set placeholders = a_outputs keys name placeholders a_input append a_outputs name b_input append b_outputs name settings accumulate_error print f Can t find previous stored outputs named placeholders get_inputs torch nn Module inputs Any nonlocal a_input a_input = inputs Use forward hook get inputs submodule handle = submodule register_forward_pre_hook get_inputs main_module sample_input handle remove b_input = a_input settings accumulate_error a_input a_input a_input b_input _tag_nodes selected_nodes NodeSet Tag selected nodes tag minimize Nodes same tags will split same submodule afterwards Args selected_nodes Nodes we want minimize We will tag those nodes minimize all preceding nodes main_ all following nodes main_ node module graph nodes node op CALLABLE_NODE_OPS continue node selected_nodes node tag = minimize any n tag minimize main_ n node all_input_nodes n op CALLABLE_NODE_OPS node tag = main_ node tag = main_ _build_submodule nodes NodeSet - tuple torch fx GraphModule str Split module so one submodule consists ` nodes ` only ` nodes ` Args nodes Nodes we want include minimize submodule Returns split_module torch fx GraphModule module after split submodule_name str name submodule consists ` nodes ` Color provided nodes _tag_nodes nodes Split module based coloring split_module = split_by_tags module main_ minimize main_ Find submodule containing colored nodes submodule_name str = child_name _ split_module named_children type ignore union-attr Skip submodules we re interested moment minimize child_name continue submodule_name == submodule_name = child_name raise FxNetMinimizerBadModuleError f Expected only one minimize submodule nodes nodes submodule_name == raise FxNetMinimizerBadModuleError f Minimize submodule found nodes nodes split_module submodule_name type ignore return-value _run_and_compare split_module torch fx GraphModule submod_name str output_names Names report_idx int = - Run submodule ` split_module ` has name ` submod_name ` using ` run_a ` ` run_b ` compare their results Args split_module Main module contains minimize submodule submod_name Name minimize submodule output_names Names node we want output If None we will use original output submodule = getattr split_module submod_name a_input b_input = _get_submod_inputs split_module submod_name len reports == reports append iteration = report = reports report_idx report_idx = iteration - report append Run compare output_names settings all_outputs output_nodes NodeList = node submodule graph nodes node op == output submodule graph erase_node node node name output_names output_nodes append node submodule graph output output_nodes len output_nodes == tuple output_nodes submodule graph lint submodule recompile Use name args output node key store comparison result node submodule graph nodes node op == output result_key = map_arg node args lambda x x name try a_result = run_a submodule a_input report_idx b_result = run_b submodule b_input report_idx _store_outputs a_result b_result submodule except Exception e report append f Exception raised when running submod_name e raise FxNetMinimizerRunFuncError noqa B f Exception raised when running submod_name e Compare results names Names = output_names output_names None names = str v v result_key type ignore possibly-undefined numeric_result bool_result = compare_fn a_result b_result names results result_key = numeric_result type ignore possibly-undefined report append f Numerical accuracy = numeric_result bool_result report append f Result mismatch result_key type ignore possibly-undefined module_exporter isinstance result_key tuple type ignore possibly-undefined pyrefly ignore unbound-name result_key = result_key - If result still tuple happens non-sequential mode we only use first element name isinstance result_key tuple type ignore possibly-undefined pyrefly ignore unbound-name result_key = str result_key pyre-ignore function module_exporter a_input submodule pyrefly ignore unbound-name result_key + _cpu pyre-ignore function module_exporter b_input submodule pyrefly ignore unbound-name result_key + _acc raise FxNetMinimizerResultMismatchError f Result mismatch result_key type ignore possibly-undefined _binary_search_impl all_nodes NodeList start_idx int end_idx int - NodeSet Recursive binary search implementation culprits NodeSet = set nodes NodeList = all_nodes start_idx end_idx report list str = exclusion_fn None exclusion_fn nodes start_idx end_idx len nodes == report = All nodes excluded user reports append report culprits first_node_name = nodes name output_node_name = nodes - name iteration += reports append report report append f Binary search iteration iteration report append f From node index start_idx first_node_name end_idx - output_node_name f Size interested node list len nodes cur_nodes NodeSet = set nodes try split_module submod_name = _build_submodule cur_nodes _run_and_compare split_module submod_name output_node_name except FxNetMinimizerRunFuncError FxNetMinimizerResultMismatchError len nodes == report append f This last node sub-module f Search current branch successful culprit = cur_nodes print_report report cur_nodes report append Proceed split lower halves current sub-module individually print_report report mid = len nodes culprits = _binary_search_impl all_nodes start_idx start_idx + mid len culprits = settings find_all culprits culprits = _binary_search_impl all_nodes start_idx + mid end_idx len culprits == report append f Further split lowering found no errors f Unable minimize submodule list nodes nodes print_report report culprits report append No discrepancy found print_report report set _binary_traverse nodes NodeList - NodeSet Binary search ` nodes ` culprit _binary_search_impl nodes len nodes _sequential_traverse nodes NodeList - NodeSet Traverse ` nodes ` one one determine any them culprit culprits NodeSet = set node nodes report list str = reports append report iteration += report append f Sequential traverse iteration iteration report append f Visit node node name _LOGGER info Visit node s node name node_list NodeList = node exclusion_fn None exclusion_fn node_list - - len node_list == report append f User exclusion node name print_report report settings find_all culprits continue cur_nodes NodeSet = node node fusions cur_nodes = fusions node try split_module submod_name = _build_submodule cur_nodes _run_and_compare split_module submod_name node name print_report report except FxNetMinimizerResultMismatchError culprits add node report append f Found culprit numeric error node print_report report settings find_all culprits except FxNetMinimizerRunFuncError culprits update cur_nodes report append f Found culprit run error node print_report report settings find_all culprits culprits _block_traverse_impl nodes NodeList start_idx int end_idx int find_last_node bool - Optional int Recursive block search implementation find_last_node If True search last node which result numerics difference False find first node sorted node list report list str = mid = start_idx + end_idx cur_nodes_list NodeList = nodes mid + find_last_node nodes mid exclusion_fn exclusion_fn cur_nodes_list - - cur_nodes = set cur_nodes_list first_node_name = cur_nodes_list name last_node_name = cur_nodes_list - name target_node_name = last_node_name find_last_node first_node_name iteration += reports append report report extend = f Block search iteration iteration report extend f Search last find_last_node first node culprits f From node index start_idx nodes start_idx name end_idx nodes end_idx name f Subgraph constructed first_node_name last_node_name f Targeting node target_node_name f Size interested node list end_idx - start_idx + report_idx = len reports - try split_module submod_name = _build_submodule cur_nodes _run_and_compare split_module submod_name last_node_name report_idx except FxNetMinimizerResultMismatchError FxNetMinimizerRunFuncError report append f Culprits found node first_node_name last_node_name start_idx == mid == end_idx report extend This last node sub-module Search current branch successful node f start_idx node name nodes start_idx name print_report report start_idx report append Proceed split lower halves current sub-module individually print_report report find_last_node _block_traverse_impl nodes start_idx mid find_last_node _block_traverse_impl nodes mid + end_idx find_last_node report append f Culprits found node start mid nodes mid name start_idx == mid == end_idx We did find anything pointers have moved start_idx == find_last_node start_idx == len nodes - find_last_node report append f At last find_last_node first node no culprits found print_report report None Otherwise we have converged border between discrepancy valid start_idx + find_last_node - report append Proceed split lower halves current sub-module individually print_report report find_last_node _block_traverse_impl nodes mid + end_idx find_last_node _block_traverse_impl nodes start_idx mid find_last_node _block_traverse nodes NodeList find_last_node Optional bool - NodeSet Traverse topologically sorted node list Find minimum block start_idx end_idx which contains culprit st pass search end_idx finding last node culprit block where Numerical accuracy end_idx threshold nd pass search start_idx finding first node culprit block where Numerical accuracy start_idx end_idx threshold Form minimum block start_idx - end_idx culprits NodeSet = set first_node_name = nodes name last_node_name = nodes - name last_node_report = f Block search first_node_name last_node_name last_node_report append reports append last_node_report start_idx = end_idx = len nodes - final_start_idx Optional int = start_idx final_end_idx Optional int = end_idx run_both = find_last_node None step find end_idx culprit block run_both find_last_node last_node_report append Start searching last node culprit print_report last_node_report final_end_idx = _block_traverse_impl nodes start_idx end_idx True final_end_idx None last_node_report append No culprits found print_report last_node_report culprits last_node_report extend Finish Pass f Find end_idx = final_end_idx nodes final_end_idx name print_report last_node_report step reduce culprit block start_idx end_idx run_both find_last_node first_node_report = Start searching first node culprit print_report first_node_report final_start_idx = _block_traverse_impl nodes end_idx + start_idx final_end_idx end_idx False final_start_idx None last_node_report append No culprits found print_report last_node_report culprits first_node_report append reports append first_node_report first_node_report extend Finish Pass f Find start_idx = final_start_idx nodes final_start_idx name print_report first_node_report step form module minimum culprits These indexes guaranteed exist range_start range_end = cast int final_start_idx cast int final_end_idx culprits update nodes range_start range_end + result_report = f Finish searching found minimum block nodes range_start nodes range_end reports append result_report print_report result_report culprits _defined_traverse nodes NodeList - NodeSet run user defined ` nodes ` determine culprit culprits NodeSet = set exclusion_fn None exclusion_fn nodes - - len nodes == report = All nodes excluded user reports append report culprits first_node_name = nodes name output_node_name = nodes - name report = f Defined graph first_node_name output_node_name cur_nodes NodeSet = set nodes try split_module submod_name = _build_submodule cur_nodes _run_and_compare split_module submod_name output_node_name print_report report except FxNetMinimizerResultMismatchError FxNetMinimizerRunFuncError report append f Found culprit cur_nodes print_report report culprits culprits _accumulate_traverse nodes NodeList - NodeSet culprits NodeSet = set nodes_to_run NodeSet = set find_all supported accumulate traversal because all ops run NNPI So we after first op raises error settings find_all print Find All mode supported accumulate traversal culprits node nodes report list str = reports append report iteration += report append f Accumulate traverse iteration iteration nodes_to_run add node node_name = node name node_name None isinstance node_name tuple node_name = node_name assert node_name None isinstance node_name str f minimize node_name node_name report append f Add node node_name try split_module submod_name = _build_submodule nodes_to_run _run_and_compare split_module submod_name node_name print_report report except FxNetMinimizerResultMismatchError FxNetMinimizerRunFuncError culprits add node report append f Found culprit node print_report report culprits culprits _skip_traverse_impl all_nodes NodeList start_idx int end_idx int - NodeSet Skip certain nodes graph based settings culprits NodeSet = set nodes NodeList = all_nodes start_idx end_idx cur_nodes NodeSet = set nodes exclusion_fn None exclusion_fn nodes start_idx end_idx cur_nodes = set nodes node nodes node fusions cur_nodes update fusions node report list str = reports append report iteration += report append f Nodes block iteration report append f From node index start_idx end_idx - f Size interested node list len nodes try split_module submod_name = _build_submodule cur_nodes _run_and_compare split_module submod_name except FxNetMinimizerResultMismatchError culprits update cur_nodes report append f Found culprit numeric error cur_nodes print_report report culprits except FxNetMinimizerRunFuncError culprits update cur_nodes report append f Found culprit run error cur_nodes print_report report culprits report append No discrepancy found print_report report set _skip_traverse all_nodes NodeList skip_nodes list - NodeSet Skip certain nodes graph based settings start_idx = num_nodes = len all_nodes idx = culprits = set while idx num_nodes node = all_nodes idx node name skip_nodes skip node idx start_idx culprits = _skip_traverse_impl all_nodes start_idx idx start_idx = idx + idx == num_nodes - start_idx = idx last node culprits = _skip_traverse_impl all_nodes start_idx idx + idx += culprits _collect_nodes start Optional str end Optional str - NodeList Collect nodes model between nodes name ` start ` ` end ` These two nodes also included nodes NodeList = add_node = start None node module graph nodes node op CALLABLE_NODE_OPS continue node name == start add_node = True add_node nodes append node node name == end break nodes run_nodes start Optional str = None end Optional str = None Run part model ` start ` node ` end ` node If ` start ` None then we start beginning model If ` end ` None then we stop end model Args start The name node which first node submodule we want run If set None then we ll start first node model end The name node which last node submodule we want run If set None we ll end last node model nodes = _collect_nodes start end cur_nodes = set nodes node nodes node fusions cur_nodes update fusions node output_names = settings return_intermediate output_names = node name node nodes try split_module submod_name = _build_submodule cur_nodes _run_and_compare split_module submod_name output_names except FxNetMinimizerRunFuncError FxNetMinimizerResultMismatchError e print e print_report report list str i range len report i print + report i print report i print_reports report reports print_report report minimize start Optional str = None end Optional str = None skip_nodes Optional list = None find_last_node Optional bool = None - NodeSet Minimizing model node name ` start ` node name ` end ` base settings Find culprits causes FxNetMinimizerRunFuncError FxNetMinimizerResultMismatchError errors Args start The name node where we want start minimizing If set None then we ll start first node model end The name node where we want terminate minimizing If set None we ll end last node model skip_nodes The names nodes where we want skip during minimizing It ll create subgraphs without these skip nodes under hood Only applicable mode skip find_last_node True only last_node culprits needed mode block False only first_node culprits needed Only applicable mode block Returns nodes A list nodes causes FxNetMinimizerRunFuncError FxNetMinimizerResultMismatchError errors during minimizing print settings print module graph nodes = _collect_nodes start end settings traverse_method == sequential _sequential_traverse nodes settings traverse_method == binary _binary_traverse nodes settings traverse_method == accumulate _accumulate_traverse nodes settings traverse_method == skip skip_nodes None raise RuntimeError skip_nodes can t None when traverse_method skip _skip_traverse nodes skip_nodes settings traverse_method == defined _defined_traverse nodes settings traverse_method == block _block_traverse nodes find_last_node raise RuntimeError f Unknown traverse method settings traverse_method