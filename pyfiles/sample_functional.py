torch torch nn functional F torch testing _internal common_nn wrap_functional ` sample_functional ` used ` test_cpp_api_parity py ` test Python C++ API parity test harness works ` torch nn functional ` functions When ` has_parity=true ` passed ` sample_functional ` behavior ` sample_functional ` same C++ equivalent When ` has_parity=false ` passed ` sample_functional ` behavior ` sample_functional ` different C++ equivalent sample_functional x has_parity has_parity x x torch nn functional sample_functional = sample_functional SAMPLE_FUNCTIONAL_CPP_SOURCE = \n namespace torch namespace nn namespace functional struct C _EXPORT SampleFunctionalFuncOptions SampleFunctionalFuncOptions bool has_parity has_parity_ has_parity TORCH_ARG bool has_parity Tensor sample_functional Tensor x SampleFunctionalFuncOptions options x namespace functional namespace nn namespace torch functional_tests = dict constructor=wrap_functional F sample_functional has_parity=True cpp_options_args= F SampleFunctionalFuncOptions true input_size= fullname= sample_functional_has_parity has_parity=True dict constructor=wrap_functional F sample_functional has_parity=False cpp_options_args= F SampleFunctionalFuncOptions false input_size= fullname= sample_functional_no_parity has_parity=False This test setting ` test_cpp_api_parity=False ` flag skips C++ API parity test accordingly otherwise test would run throw parity error dict constructor=wrap_functional F sample_functional has_parity=False cpp_options_args= F SampleFunctionalFuncOptions false input_size= fullname= sample_functional_THIS_TEST_SHOULD_BE_SKIPPED test_cpp_api_parity=False