Owner s oncall r p Copyright c Meta Platforms Inc its affiliates All rights reserved This source code licensed under BSD-style license found LICENSE file root directory source tree multiprocessing mp os signal time unittest unittest mock mock uuid torch distributed elastic timer timer torch testing _internal common_utils IS_ARM IS_MACOS IS_WINDOWS run_tests TEST_WITH_TSAN TestCase timer supported these platforms IS_WINDOWS IS_MACOS IS_ARM func should time out func n file_path file_path None timer configure timer FileTimerClient file_path n timer expires after= func n - None time sleep FileTimerTest TestCase setUp super setUp max_interval = file_path = f tmp test_file_path_ os getpid _ uuid uuid server = timer FileTimerServer file_path test max_interval server start tearDown super tearDown server stop test_exception_propagation assertRaises RuntimeError msg= foobar timer expires after= raise RuntimeError foobar test_no_client no timer client configured exception expected timer configure None assertRaises RuntimeError timer expires after= pass test_client_interaction no timer client configured one passed explicitly no exception expected timer_client = timer FileTimerClient file_path timer_client acquire = mock MagicMock wraps=timer_client acquire timer_client release = mock MagicMock wraps=timer_client release timer expires after= scope= test client=timer_client pass timer_client acquire assert_called_once_with test mock ANY timer_client release assert_called_once_with test test_happy_path timer configure timer FileTimerClient file_path timer expires after= time sleep test_get_timer_recursive If function acquires countdown timer default scope then recursive calls function should re-acquire timer rather than creating new one That only last recursive call s timer will take effect timer configure timer FileTimerClient file_path func should time out func n n timer expires after= func n - time sleep func p = mp Process target=func args= file_path p start p join assertEqual -signal SIGKILL p exitcode test_multiple_clients_interaction func should time out func n file_path file_path None timer configure timer FileTimerClient file_path n timer expires after= func n - None time sleep num_clients = num_requests_per_client = processes = _ range num_clients p = mp Process target=func args= num_requests_per_client file_path processes append p p start p processes p join server run_once Allows server process all requests assertEqual num_clients num_requests_per_client server _request_count mock patch torch distributed elastic timer FileTimerServer _reap_worker test_exit_before_release mock_reap func file_path client = timer FileTimerClient file_path timer configure client expire = time time + client acquire test_scope expire time sleep p = mp Process target=func args= file_path p start p join time sleep server run_once Allows server process all requests mock_reap assert_not_called assertEqual len server _timers mock patch torch distributed elastic timer FileTimerServer _reap_worker mock patch torch distributed elastic timer FileTimerServer is_process_running test_exit_before_release_reap mock_pid_exists mock_reap func file_path client = timer FileTimerClient file_path timer configure client expire = time time + client acquire test_scope expire time sleep mock_pid_exists return_value = True p = mp Process target=func args= file_path p start p join time sleep server run_once Allows server process all requests mock_reap assert_called assertEqual len server _timers staticmethod _run file_path timeout duration client = timer FileTimerClient file_path timer configure client timer expires after=timeout time sleep duration unittest skipIf TEST_WITH_TSAN test tsan incompatible test_timer timeout = duration = p = mp Process target=self _run args= file_path timeout duration p start p join assertEqual -signal SIGKILL p exitcode _request_on_interval file_path n interval sem enqueues ` ` n ` ` timer requests into ` ` mp_queue ` ` one element per interval seconds Releases given semaphore once before going work client = timer FileTimerClient file_path sem release _ range n client acquire test_scope time sleep interval FileTimerClientTest TestCase test_send_request_without_server client = timer FileTimerClient test_file timer configure client assertRaises BrokenPipeError timer expires after= time sleep FileTimerServerTest TestCase setUp super setUp file_path = f tmp test_file_path_ os getpid _ uuid uuid max_interval = server = timer FileTimerServer file_path test max_interval tearDown super tearDown server stop test_watchdog_call_count checks watchdog function ran wait interval +- times server _run_watchdog = mock MagicMock wraps=self server _run_watchdog server start test_pid = - client = timer FileTimerClient file_path client _send_request _valid_timer pid=test_pid scope= test wait = time sleep wait server stop watchdog_call_count = server _run_watchdog call_count assertGreaterEqual watchdog_call_count int wait max_interval - assertLessEqual watchdog_call_count int wait max_interval + test_watchdog_empty_queue checks watchdog can run empty pipe server start _expired_timer pid scope expired = time time - timer FileTimerRequest worker_pid=pid scope_id=scope expiration_time=expired signal=signal SIGKILL _valid_timer pid scope valid = time time + timer FileTimerRequest worker_pid=pid scope_id=scope expiration_time=valid signal=signal SIGKILL _release_timer pid scope timer FileTimerRequest worker_pid=pid scope_id=scope expiration_time=- mock patch os kill mock patch torch distributed elastic timer file_based_local_timer log_debug_info_for_expired_timers test_expired_timers mock_debug_info mock_os_kill tests single expired timer process should terminate process clean up all pending timers owned process server start test_pid = - client = timer FileTimerClient file_path client _send_request _expired_timer pid=test_pid scope= test client _send_request _valid_timer pid=test_pid scope= test server run_once Allows server process all requests assertEqual len server _timers mock_os_kill assert_called_once_with test_pid signal SIGKILL mock_debug_info assert_called mock patch os kill test_send_request_release mock_os_kill tests timer can acquired then released should terminate process timer can vacuously released e g no-op server start client = timer FileTimerClient file_path test_pid = - client _send_request _valid_timer pid=test_pid scope= test client _send_request _release_timer pid=test_pid scope= test client _send_request _release_timer pid=test_pid scope= test assertEqual len server _timers mock_os_kill assert_not_called mock patch torch distributed elastic timer FileTimerServer is_process_running mock patch os kill test_valid_timers mock_os_kill mock_pid_exists tests valid timers processed correctly process left alone server start mock_pid_exists return_value = True client = timer FileTimerClient file_path client _send_request _valid_timer pid=- scope= test client _send_request _valid_timer pid=- scope= test client _send_request _valid_timer pid=- scope= test client _send_request _valid_timer pid=- scope= test server run_once Allows server process all requests assertEqual len server _timers assertTrue - test server _timers assertTrue - test server _timers assertTrue - test server _timers assertTrue - test server _timers mock_os_kill assert_not_called __name__ == __main__ run_tests