======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_itertools py torch torch _dynamo test_case torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests skipIfTorchDynamo slowTest __TestCase = CPythonTestCase ======= END DYNAMO PATCH ======= doctest unittest itertools test support test support threading_helper script_helper itertools weakref decimal Decimal fractions Fraction operator random copy pickle functools reduce sys struct threading gc warnings pickle_deprecated testfunc Run test three times First verify Deprecation Warning raised Second run normally DeprecationWarnings temporarily disabled Third run warnings promoted errors inner assertWarns DeprecationWarning testfunc warnings catch_warnings warnings simplefilter ignore category=DeprecationWarning testfunc warnings catch_warnings warnings simplefilter error category=DeprecationWarning assertRaises DeprecationWarning AssertionError SystemError testfunc inner maxsize = support MAX_Py_ssize_t minsize = -maxsize- torch _dynamo disable choice args random choice args torch _dynamo disable randrange args random randrange args lzip args list zip args onearg x Test function one argument x errfunc args Test function raises error raise ValueError gen Non-restartable source sequence i yield i isEven x Test predicate x == isOdd x Test predicate x == tupleize args args irange n i range n yield i StopNow Class emulating empty iterable __iter__ __next__ raise StopIteration take n seq Convenience function partially consuming long infinite iterable list islice seq n prod iterable reduce operator mul iterable fact n Factorial prod range n+ root level methods pickling ability _testR r r _testR r r underten x x picklecopiers = lambda s proto=proto pickle loads pickle dumps s proto proto range pickle HIGHEST_PROTOCOL + TestBasicOps __TestCase pickletest protocol stop= take= compare=None Test iterator same after pickling also when part-consumed expand i= Recursively expand iterables within sensible bounds i raise RuntimeError infinite recursion encountered isinstance str try l = list islice stop except TypeError can t expand expand e i+ e l Test initial copy against original dump = pickle dumps protocol i = pickle loads dump assertEqual type type i b = expand expand i assertEqual b compare c = expand compare assertEqual c Take copy create another copy compare them i = pickle loads dump took = try i range take next i took += except StopIteration pass #in case there less data than take dump = pickle dumps i protocol i = pickle loads dump b = expand i expand i assertEqual b compare c = expand compare took assertEqual c pickle_deprecated test_accumulate assertEqual list accumulate range one positional arg assertEqual list accumulate iterable=range kw arg typ int complex Decimal Fraction multiple types assertEqual list accumulate map typ range list map typ assertEqual list accumulate abc ab abc works non-numeric assertEqual list accumulate empty iterable assertEqual list accumulate iterable length one assertRaises TypeError accumulate range too many args assertRaises TypeError accumulate too few args assertRaises TypeError accumulate x=range unexpected kwd arg assertRaises TypeError list accumulate args don t add s = assertEqual list accumulate s min assertEqual list accumulate s max assertEqual list accumulate s operator mul assertRaises TypeError list accumulate s chr unary-operation proto range pickle HIGHEST_PROTOCOL + pickletest proto accumulate range test pickling pickletest proto accumulate range initial= assertEqual list accumulate initial=None assertEqual list accumulate initial= assertEqual list accumulate initial= assertRaises TypeError list accumulate test_batched assertEqual list batched ABCDEFG A B C D E F G assertEqual list batched ABCDEFG A B C D E F G assertEqual list batched ABCDEFG A B C D E F G assertEqual list batched ABCDEF strict=True A B C D E F assertRaises ValueError Incomplete batch when strict list batched ABCDEFG strict=True assertRaises TypeError Too few arguments list batched ABCDEFG assertRaises TypeError list batched ABCDEFG None Too many arguments assertRaises TypeError list batched None Non-iterable input assertRaises TypeError list batched ABCDEFG hello n string assertRaises ValueError list batched ABCDEFG n zero assertRaises ValueError list batched ABCDEFG - n negative data = ABCDEFGHIJKLMNOPQRSTUVWXYZ n range i range len data s = data i batches = list batched s n subTest s=s n=n batches=batches Order preserved no data lost assertEqual join chain batches s Each batch exact tuple assertTrue all type batch tuple batch batches All last batch size n batches last_batch = batches pop assertTrue all len batch == n batch batches assertTrue len last_batch = n batches append last_batch test_chain chain iterables Pure python version docs iterables element yield element c chain chain assertEqual list c abc list abcdef assertEqual list c abc list abc assertEqual list c assertEqual take c abc list abcd assertRaises TypeError list c test_chain_from_iterable assertEqual list chain from_iterable abc list abcdef assertEqual list chain from_iterable abc list abc assertEqual list chain from_iterable assertEqual take chain from_iterable abc list abcd assertRaises TypeError list chain from_iterable assertEqual list islice chain from_iterable repeat range pickle_deprecated test_chain_reducible oper copy deepcopy + picklecopiers = chain abc assertEqual list oper list abcdef assertEqual next assertEqual list oper list bcdef assertEqual list oper chain assertEqual take oper chain abc list abcd assertRaises TypeError list oper chain proto range pickle HIGHEST_PROTOCOL + pickletest proto chain abc compare=list abcdef pickle_deprecated test_chain_setstate assertRaises TypeError chain __setstate__ assertRaises TypeError chain __setstate__ assertRaises TypeError chain __setstate__ assertRaises TypeError chain __setstate__ assertRaises TypeError chain __setstate__ iter = chain __setstate__ iter abc assertEqual list b c d e f = chain __setstate__ iter abc iter ghi assertEqual list ghi b c d e f pickle_deprecated test_combinations assertRaises TypeError combinations abc missing r argument assertRaises TypeError combinations abc too many arguments assertRaises TypeError combinations None pool iterable assertRaises ValueError combinations abc - r negative op lambda + picklecopiers assertEqual list op combinations abc r n assertEqual list op combinations ABCD A B A C A D B C B D C D testIntermediate = combinations ABCD next testIntermediate assertEqual list op testIntermediate A C A D B C B D C D assertEqual list op combinations range testIntermediate = combinations range next testIntermediate assertEqual list op testIntermediate combinations iterable r Pure python version shown docs pool = tuple iterable n = len pool r n indices = list range r yield tuple pool i i indices while i reversed range r indices i = i + n - r break indices i += j range i+ r indices j = indices j- + yield tuple pool i i indices combinations iterable r Pure python version shown docs pool = tuple iterable n = len pool indices permutations range n r sorted indices == list indices yield tuple pool i i indices combinations iterable r Pure python version cwr pool = tuple iterable n = len pool indices combinations_with_replacement range n r len set indices == r yield tuple pool i i indices n range values = x- x range n r range n+ result = list combinations values r assertEqual len result r n fact n fact r fact n-r right number combs assertEqual len result len set result no repeats assertEqual result sorted result lexicographic order c result assertEqual len c r r-length combinations assertEqual len set c r no duplicate elements assertEqual list c sorted c keep original ordering assertTrue all e values e c elements taken input iterable assertEqual list c e e values e c comb subsequence input iterable assertEqual result list combinations values r matches first pure python version assertEqual result list combinations values r matches second pure python version assertEqual result list combinations values r matches second pure python version proto range pickle HIGHEST_PROTOCOL + pickletest proto combinations values r test pickling support bigaddrspacetest test_combinations_overflow assertRaises OverflowError MemoryError combinations AA Test implementation detail tuple re-use support impl_detail tuple reuse specific CPython test_combinations_tuple_reuse assertEqual len set map id combinations abcde assertNotEqual len set map id list combinations abcde pickle_deprecated test_combinations_with_replacement cwr = combinations_with_replacement assertRaises TypeError cwr abc missing r argument assertRaises TypeError cwr abc too many arguments assertRaises TypeError cwr None pool iterable assertRaises ValueError cwr abc - r negative op lambda + picklecopiers assertEqual list op cwr ABC A A A B A C B B B C C C testIntermediate = cwr ABC next testIntermediate assertEqual list op testIntermediate A B A C B B B C C C cwr iterable r Pure python version shown docs number items returned n+r- r n- when n pool = tuple iterable n = len pool n r indices = r yield tuple pool i i indices while i reversed range r indices i = n - break indices i = indices i + r - i yield tuple pool i i indices cwr iterable r Pure python version shown docs pool = tuple iterable n = len pool indices product range n repeat=r sorted indices == list indices yield tuple pool i i indices numcombs n r n r fact n+r- fact r fact n- n range values = x- x range n r range n+ result = list cwr values r assertEqual len result numcombs n r right number combs assertEqual len result len set result no repeats assertEqual result sorted result lexicographic order regular_combs = list combinations values r compare combs without replacement n == r = assertEqual result regular_combs cases should identical assertTrue set result = set regular_combs rest should supersets regular combs c result assertEqual len c r r-length combinations noruns = k k v groupby c combo without consecutive repeats assertEqual len noruns len set noruns no repeats other than consecutive assertEqual list c sorted c keep original ordering assertTrue all e values e c elements taken input iterable assertEqual noruns e e values e c comb subsequence input iterable assertEqual result list cwr values r matches first pure python version assertEqual result list cwr values r matches second pure python version proto range pickle HIGHEST_PROTOCOL + pickletest proto cwr values r test pickling support bigaddrspacetest test_combinations_with_replacement_overflow assertRaises OverflowError MemoryError combinations_with_replacement AA Test implementation detail tuple re-use support impl_detail tuple reuse specific CPython test_combinations_with_replacement_tuple_reuse cwr = combinations_with_replacement assertEqual len set map id cwr abcde assertNotEqual len set map id list cwr abcde test_permutations assertEqual list permutations abc r n assertEqual list permutations range permutations iterable r=None Pure python version shown docs pool = tuple iterable n = len pool r = n r None r r n indices = list range n cycles = list range n-r+ n+ - yield tuple pool i i indices r while n i reversed range r cycles i -= cycles i == indices i = indices i+ + indices i i+ cycles i = n - i j = cycles i indices i indices -j = indices -j indices i yield tuple pool i i indices r break permutations iterable r=None Pure python version shown docs pool = tuple iterable n = len pool r = n r None r indices product range n repeat=r len set indices == r yield tuple pool i i indices n range values = x- x range n r range n+ result = list permutations values r assertEqual len result r n fact n fact n-r right number perms assertEqual len result len set result no repeats assertEqual result sorted result lexicographic order p result assertEqual len p r r-length permutations assertEqual len set p r no duplicate elements assertTrue all e values e p elements taken input iterable assertEqual result list permutations values r matches first pure python version assertEqual result list permutations values r matches second pure python version r == n assertEqual result list permutations values None test r None assertEqual result list permutations values test default r support bigaddrspacetest test_permutations_overflow assertRaises OverflowError MemoryError permutations A support impl_detail tuple reuse specific CPython test_permutations_tuple_reuse assertEqual len set map id permutations abcde assertNotEqual len set map id list permutations abcde test_combinatorics Test relationships between product permutations combinations combinations_with_replacement n range s = ABCDEFG n r range prod = list product s repeat=r cwr = list combinations_with_replacement s r perm = list permutations s r comb = list combinations s r Check size assertEqual len prod n r assertEqual len cwr fact n+r- fact r fact n- n r assertEqual len perm r n fact n fact n-r assertEqual len comb r n fact n fact r fact n-r Check lexicographic order without repeated tuples assertEqual prod sorted set prod assertEqual cwr sorted set cwr assertEqual perm sorted set perm assertEqual comb sorted set comb Check interrelationships assertEqual cwr t t prod sorted t ==list t cwr prods which sorted assertEqual perm t t prod len set t ==r perm prods no dups assertEqual comb t t perm sorted t ==list t comb perms sorted assertEqual comb t t cwr len set t ==r comb cwrs without dups assertEqual comb list filter set cwr __contains__ perm comb perm cwr assertEqual comb list filter set perm __contains__ cwr comb cwr perm assertEqual comb sorted set cwr set perm comb both cwr perm pickle_deprecated test_compress assertEqual list compress data= ABCDEF selectors= list ACEF assertEqual list compress ABCDEF list ACEF assertEqual list compress ABCDEF list assertEqual list compress ABCDEF list ABCDEF assertEqual list compress ABCDEF list AC assertEqual list compress ABC list BC n = data = chain from_iterable repeat range n selectors = chain from_iterable repeat assertEqual list compress data selectors n assertRaises TypeError compress None range st arg iterable assertRaises TypeError compress range None nd arg iterable assertRaises TypeError compress range too few args assertRaises TypeError compress range None too many args check copy deepcopy pickle op lambda copy copy lambda copy deepcopy + picklecopiers data selectors result result ABCDEF ACEF CEF ABCDEF ABCDEF ABCDEF BCDEF ABCDEF AC C ABC BC C assertEqual list op compress data=data selectors=selectors list result assertEqual list op compress data selectors list result testIntermediate = compress data selectors result next testIntermediate assertEqual list op testIntermediate list result pickle_deprecated test_count assertEqual lzip abc count b c assertEqual lzip abc count b c assertEqual take lzip abc count b assertEqual take zip abc count - - b assertEqual take zip abc count - - b - assertRaises TypeError count assertRaises TypeError count assertEqual take count maxsize maxsize maxsize + maxsize + assertEqual take count maxsize- list range maxsize- maxsize+ assertEqual take count -maxsize- list range -maxsize- -maxsize+ assertEqual take count assertEqual take count - j - j - j - j assertEqual take count Decimal Decimal Decimal Decimal assertEqual take count Fraction Fraction Fraction Fraction BIGINT = assertEqual take count BIGINT BIGINT BIGINT+ BIGINT+ c = count assertEqual repr c count next c assertEqual repr c count c = count - assertEqual repr c count - next c assertEqual next c - assertEqual repr count count assertEqual repr count count assertEqual repr count maxsize f count maxsize c = count maxsize - assertEqual repr c f count maxsize - next c c now masize assertEqual repr c f count maxsize next c assertEqual repr c f count maxsize + assertEqual type next count float i -sys maxsize- -sys maxsize+ - - sys maxsize- sys maxsize+ Test repr r = repr count i r = count r __mod__ i assertEqual r r check copy deepcopy pickle value - maxsize- maxsize+ c = count value assertEqual next copy copy c value assertEqual next copy deepcopy c value proto range pickle HIGHEST_PROTOCOL + pickletest proto count value #check proper internal error handling large step sizes count maxsize+ sys exc_info pickle_deprecated test_count_with_step assertEqual lzip abc count b c assertEqual lzip abc count start= step= b c assertEqual lzip abc count step=- b - c - assertRaises TypeError count b assertEqual lzip abc count b c assertEqual lzip abc count b c assertEqual lzip abc count b c assertEqual take count maxsize- take range maxsize- maxsize+ assertEqual take count -maxsize- take range -maxsize- -maxsize+ assertEqual take count maxsize+ list range + maxsize+ maxsize+ assertEqual take count maxsize maxsize maxsize + maxsize + assertEqual take count maxsize maxsize maxsize maxsize maxsize assertEqual take count -maxsize maxsize -maxsize maxsize assertEqual take count assertEqual take count - j - j - j assertEqual take count Decimal Decimal Decimal Decimal Decimal assertEqual take count Fraction Fraction Fraction Fraction Fraction BIGINT = assertEqual take count step=BIGINT BIGINT BIGINT assertEqual repr take count repr c = count assertEqual repr c count next c assertEqual repr c count c = count - assertEqual repr c count - next c assertEqual repr c count - c = count - - assertEqual repr c count - - next c assertEqual repr c count - - assertEqual repr c count - - assertEqual repr count count assertEqual repr count count suppress step= when s int assertEqual repr count count do show float values lilke assertEqual repr count count c = count assertEqual type next c int assertEqual type next c float i -sys maxsize- -sys maxsize+ - - sys maxsize- sys maxsize+ j -sys maxsize- -sys maxsize+ - - sys maxsize- sys maxsize+ Test repr r = repr count i j j == r = count r i r = count r r i j assertEqual r r proto range pickle HIGHEST_PROTOCOL + pickletest proto count i j c = count maxsize - assertEqual repr c f count maxsize - next c c now masize assertEqual repr c f count maxsize next c assertEqual repr c f count maxsize + c = count maxsize + - assertEqual repr c f count maxsize + - next c c now masize assertEqual repr c f count maxsize - next c assertEqual repr c f count maxsize - - threading_helper requires_working_threading test_count_threading step= test verifies multithreading consistency which mostly testing builds without GIL nice test anyway count_to = _ num_threads = c = count step=step counting_thread i range count_to next c threads = i range num_threads thread = threading Thread target=counting_thread thread start threads append thread thread threads thread join assertEqual next c count_to num_threads step test_count_with_step_threading test_count_threading step= test_cycle assertEqual take cycle abc list abcabcabca assertEqual list cycle assertRaises TypeError cycle assertRaises TypeError cycle assertEqual list islice cycle gen pickle_deprecated test_cycle_copy_pickle check copy deepcopy pickle c = cycle abc assertEqual next c #simple copy currently supported because __reduce__ returns #an internal iterator #self assertEqual take copy copy c list bcabcabcab assertEqual take copy deepcopy c list bcabcabcab proto range pickle HIGHEST_PROTOCOL + assertEqual take pickle loads pickle dumps c proto list bcabcabcab next c assertEqual take pickle loads pickle dumps c proto list cabcabcabc next c next c proto range pickle HIGHEST_PROTOCOL + pickletest proto cycle abc proto range pickle HIGHEST_PROTOCOL + test partial consumed input iterable = iter abcde c = cycle _ = next c i range consume inputs p = pickle dumps c proto d = pickle loads p rebuild cycle object assertEqual take d list cdeabcdeabcdeabcdeab test completely consumed input iterable = iter abcde c = cycle _ = next c i range consume inputs p = pickle dumps c proto d = pickle loads p rebuild cycle object assertEqual take d list cdeabcdeabcdeabcdeab pickle_deprecated test_cycle_unpickle_compat testcases = b citertools\ncycle\n c__builtin__\niter\n lI \naI \naI \natRI \nbtR lI \naI \ntb b citertools\ncycle\n c__builtin__\niter\n K\x K\x K\x etRK\x btR K\x aK\x tb b \x \x citertools\ncycle\nc__builtin__\niter\n K\x K\x K\x e\x RK\x b\x R K\x aK\x \x b b \x \x citertools\ncycle\ncbuiltins\niter\n K\x K\x K\x e\x RK\x b\x R K\x aK\x \x b b \x \x \x =\x \x \x \x \x \x \x \x c\titertools\x c\x cycle\x \x c\x builtins\x c\x iter\x K\x K\x K\x e\x RK\x b\x R K\x aK\x \x b b citertools\ncycle\n c__builtin__\niter\n lp \nI \naI \naI \natRI \nbtR g \nI \ntb b citertools\ncycle\n c__builtin__\niter\n q\x K\x K\x K\x etRK\x btR h\x K\x tb b \x \x citertools\ncycle\nc__builtin__\niter\n q\x K\x K\x K\x e\x RK\x b\x Rh\x K\x \x b b \x \x citertools\ncycle\ncbuiltins\niter\n q\x K\x K\x K\x e\x RK\x b\x Rh\x K\x \x b b \x \x \x \x \x \x \x \x \x \x \x c\titertools\x c\x cycle\x \x c\x builtins\x c\x iter\x \x K\x K\x K\x e\x RK\x b\x Rh\x K\x \x b b citertools\ncycle\n c__builtin__\niter\n lI \naI \naI \natRI \nbtR lI \naI \ntb b citertools\ncycle\n c__builtin__\niter\n K\x K\x K\x etRK\x btR K\x aI \ntb b \x \x citertools\ncycle\nc__builtin__\niter\n K\x K\x K\x e\x RK\x b\x R K\x a\x \x b b \x \x citertools\ncycle\ncbuiltins\niter\n K\x K\x K\x e\x RK\x b\x R K\x a\x \x b b \x \x \x \x \x \x \x \x \x \x \x c\titertools\x c\x cycle\x \x c\x builtins\x c\x iter\x K\x K\x K\x e\x RK\x b\x R K\x a\x \x b b citertools\ncycle\n c__builtin__\niter\n lp \nI \naI \naI \natRI \nbtR g \nI \ntb b citertools\ncycle\n c__builtin__\niter\n q\x K\x K\x K\x etRK\x btR h\x I \ntb b \x \x citertools\ncycle\nc__builtin__\niter\n q\x K\x K\x K\x e\x RK\x b\x Rh\x \x \x b b \x \x citertools\ncycle\ncbuiltins\niter\n q\x K\x K\x K\x e\x RK\x b\x Rh\x \x \x b b \x \x \x \x \x \x \x \x \x \x \x c\titertools\x c\x cycle\x \x c\x builtins\x c\x iter\x \x K\x K\x K\x e\x RK\x b\x Rh\x \x \x b assert len testcases == t testcases = pickle loads t assertEqual take pickle_deprecated test_cycle_setstate Verify both modes restoring state Mode efficient It uses incompletely consumed input iterator build cycle object then passes state list previously consumed values There no data overlap between two c = cycle defg c __setstate__ list abc assertEqual take c list defgabcdefgabcdefgab Mode inefficient It starts cycle object built iterator over remaining elements partial cycle then passes state all previously seen values overlaps values included iterator c = cycle defg c __setstate__ list abcdefg assertEqual take c list defgabcdefgabcdefgab The first argument setstate needs tuple assertRaises TypeError cycle defg __setstate__ list abcdefg The first argument setstate tuple must list assertRaises TypeError c = cycle defg c __setstate__ tuple defg take c The second argument setstate tuple must int assertRaises TypeError cycle defg __setstate__ list abcdefg x assertRaises TypeError cycle __setstate__ assertRaises TypeError cycle __setstate__ pickle_deprecated test_groupby Check whether accepts arguments correctly assertEqual list groupby assertEqual list groupby key=id assertRaises TypeError list groupby abc assertRaises TypeError groupby None assertRaises TypeError groupby abc lambda x x Check normal input s = dup = k g groupby s lambda r r elem g assertEqual k elem dup append elem assertEqual s dup Check normal pickled proto range pickle HIGHEST_PROTOCOL + dup = k g pickle loads pickle dumps groupby s _testR proto elem g assertEqual k elem dup append elem assertEqual s dup Check nested case dup = k g groupby s _testR ik ig groupby g _testR elem ig assertEqual k elem assertEqual ik elem dup append elem assertEqual s dup Check nested pickled proto range pickle HIGHEST_PROTOCOL + dup = k g pickle loads pickle dumps groupby s _testR proto ik ig pickle loads pickle dumps groupby g _testR proto elem ig assertEqual k elem assertEqual ik elem dup append elem assertEqual s dup Check case where inner iterator used keys = k k g groupby s _testR expectedkeys = set r r s assertEqual set keys expectedkeys assertEqual len keys len expectedkeys Check case where inner iterator used after advancing groupby iterator s = list zip AABBBAAAA range = groupby s _testR _ g = next _ g = next _ g = next assertEqual list g assertEqual list g assertEqual next g A list exhaust groupby iterator assertEqual list g proto range pickle HIGHEST_PROTOCOL + = groupby s _testR _ g = next next next assertEqual list pickle loads pickle dumps g proto Exercise pipes filters style s = abracadabra sort s &#124; uniq r = k k g groupby sorted s assertEqual r b c d r sort s &#124; uniq -d r = k k g groupby sorted s list islice g assertEqual r b r sort s &#124; uniq -c r = len list g k k g groupby sorted s assertEqual r b c d r sort s &#124; uniq -c &#124; sort -rn &#124; head - r = sorted len list g k k g groupby sorted s reverse=True assertEqual r r b iter __next__ failure ExpectedError Exception pass delayed_raise n= i range n yield yo raise ExpectedError gulp iterable keyp=None func=list func g k g groupby iterable keyp iter __next__ failure outer object assertRaises ExpectedError gulp delayed_raise iter __next__ failure inner object assertRaises ExpectedError gulp delayed_raise __eq__ failure DummyCmp __eq__ dst raise ExpectedError s = DummyCmp DummyCmp None __eq__ failure outer object assertRaises ExpectedError gulp s func=id __eq__ failure inner object assertRaises ExpectedError gulp s keyfunc failure keyfunc obj keyfunc skip keyfunc skip -= obj raise ExpectedError keyfunc failure outer object keyfunc skip = assertRaises ExpectedError gulp None keyfunc keyfunc skip = assertRaises ExpectedError gulp None None keyfunc test_filter assertEqual list filter isEven range assertEqual list filter None assertEqual list filter bool assertEqual take filter isEven count these tests raise dynamo exceptions TypeError assertRaises TypeError filter assertRaises TypeError filter lambda x x assertRaises TypeError filter lambda x x range assertRaises TypeError filter isEven dynamo raises Unsupported case assertRaises TypeError next filter range range check copy deepcopy pickle ans = c = filter isEven range assertEqual list copy copy c ans c = filter isEven range assertEqual list copy deepcopy c ans proto range pickle HIGHEST_PROTOCOL + c = filter isEven range assertEqual list pickle loads pickle dumps c proto ans next c assertEqual list pickle loads pickle dumps c proto ans proto range pickle HIGHEST_PROTOCOL + c = filter isEven range pickletest proto c test_filterfalse assertEqual list filterfalse isEven range assertEqual list filterfalse None assertEqual list filterfalse bool assertEqual take filterfalse isEven count assertRaises TypeError filterfalse assertRaises TypeError filterfalse lambda x x assertRaises TypeError filterfalse lambda x x range assertRaises TypeError filterfalse isEven torch _dynamo error_on_graph_break False assertRaises TypeError next filterfalse range range proto range pickle HIGHEST_PROTOCOL + pickletest proto filterfalse isEven range test_zip XXX This rather silly now builtin zip calls zip ans = x y x y zip abc count assertEqual ans b c assertEqual list zip abc range lzip abc range assertEqual list zip abcdef range lzip abcdef range assertEqual take zip abcdef count lzip abcdef range assertEqual list zip abcdef lzip abcdef assertEqual list zip lzip assertRaises TypeError zip assertRaises TypeError zip range assertEqual tuple list pair pair zip abc lzip abc assertEqual pair pair zip abc lzip abc support impl_detail tuple reuse specific CPython pickle_deprecated test_zip_tuple_reuse ids = list map id zip abc assertEqual min ids max ids ids = list map id list zip abc assertEqual len dict fromkeys ids len ids check copy deepcopy pickle ans = x y x y copy copy zip abc count assertEqual ans b c ans = x y x y copy deepcopy zip abc count assertEqual ans b c proto range pickle HIGHEST_PROTOCOL + ans = x y x y pickle loads pickle dumps zip abc count proto assertEqual ans b c proto range pickle HIGHEST_PROTOCOL + testIntermediate = zip abc count next testIntermediate ans = x y x y pickle loads pickle dumps testIntermediate proto assertEqual ans b c proto range pickle HIGHEST_PROTOCOL + pickletest proto zip abc count test_ziplongest args abc range range abc range range range range range range range range range range range range range range target = tuple arg i i len arg None arg args i range max map len args assertEqual list zip_longest args target assertEqual list zip_longest args target target = tuple e None X e e t t target Replace None fills X assertEqual list zip_longest args dict fillvalue= X target assertEqual take zip_longest abcdef count list zip abcdef range take infinite input assertEqual list zip_longest list zip assertEqual list zip_longest list zip assertEqual list zip_longest abcdef list zip abcdef assertEqual list zip_longest abc defg list zip list abc + None defg empty keyword dict assertRaises TypeError zip_longest assertRaises TypeError zip_longest range stmt zip_longest abc fv= zip_longest abc fillvalue= bogus_keyword=None try eval stmt globals locals except TypeError pass fail Did raise Type + stmt assertEqual tuple list pair pair zip_longest abc list zip abc assertEqual pair pair zip_longest abc list zip abc support impl_detail tuple reuse specific CPython test_zip_longest_tuple_reuse ids = list map id zip_longest abc assertEqual min ids max ids ids = list map id list zip_longest abc assertEqual len dict fromkeys ids len ids pickle_deprecated test_zip_longest_pickling proto range pickle HIGHEST_PROTOCOL + pickletest proto zip_longest abc pickletest proto zip_longest abc defgh pickletest proto zip_longest abc defgh fillvalue= pickletest proto zip_longest defgh test_zip_longest_bad_iterable exception = TypeError BadIterable __iter__ raise exception assertRaises TypeError cm zip_longest BadIterable assertIs cm exception exception test_bug_ Repeater similar itertools repeat __init__ o t e o = o t = int t e = e __iter__ its iterator itself __next__ t t -= o raise e Formerly code would fail debug mode Undetected Error Stop Iteration r = Repeater StopIteration r = Repeater StopIteration run r r result = i j zip_longest r r fillvalue= support captured_output stdout print i j result append i j result assertEqual run r r Formerly RuntimeError would lost StopIteration would stop expected r = Repeater RuntimeError r = Repeater StopIteration = zip_longest r r fillvalue= assertEqual next assertEqual next assertEqual next assertRaises RuntimeError next test_pairwise assertEqual list pairwise assertEqual list pairwise assertEqual list pairwise ab b assertEqual list pairwise abcde b b c c d d e assertEqual list pairwise range _ list zip range _ range _ assertRaises TypeError pairwise too few arguments assertRaises TypeError pairwise abc too many arguments assertRaises TypeError pairwise iterable= abc keyword arguments assertRaises TypeError pairwise None non-iterable argument test_pairwise_reenter check reenter_at expected I count = __iter__ __next__ count += count reenter_at next count new object = pairwise I item expected assertEqual next item check check check check check check check test_pairwise_reenter check maxcount expected I count = __iter__ __next__ count = maxcount raise StopIteration count += count == next None count new object = pairwise I assertEqual list expected check check check check test_product args result zero iterables ab b one iterable range range two iterables range range range first iterable zero length range range range middle iterable zero length range range range last iterable zero length assertEqual list product args result r range assertEqual list product args r list product args dict repeat=r assertEqual len list product range product args kwds pools = list map tuple args kwds get repeat n = len pools n == yield any len pool == pool pools indices = n yield tuple pool i pool i zip pools indices while i reversed range n right left indices i == len pools i - continue indices i += j range i+ n indices j = yield tuple pool i pool i zip pools indices break product iterables repeat= Pure python version used docs repeat raise ValueError repeat argument cannot negative pools = tuple pool pool iterables repeat result = pool pools result = x+ y x result y pool prod result yield tuple prod argtypes = abc range range dict a= b= c= set abcdefg range tuple range i range torch _dynamo error_on_graph_break False args = choice argtypes j range randrange expected_len = prod map len args assertEqual len list product args expected_len assertEqual list product args list product args assertEqual list product args list product args args = map iter args assertEqual len list product args expected_len support bigaddrspacetest test_product_overflow assertRaises OverflowError MemoryError product ab repeat= support impl_detail tuple reuse specific CPython test_product_tuple_reuse assertEqual len set map id product abc assertNotEqual len set map id list product abc pickle_deprecated test_product_pickling check copy deepcopy pickle args result zero iterables ab b one iterable range range two iterables range range range first iterable zero length range range range middle iterable zero length range range range last iterable zero length assertEqual list copy copy product args result assertEqual list copy deepcopy product args result proto range pickle HIGHEST_PROTOCOL + pickletest proto product args pickle_deprecated test_product_issue_ test indices properly clamped length tuples p = product p __setstate__ x will access tuple element clamped assertEqual next p test empty tuple list will result immediate StopIteration p = product p __setstate__ x will access tuple element clamped assertRaises StopIteration next p pickle_deprecated test_repeat assertEqual list repeat object= times= assertEqual lzip range repeat assertEqual list repeat assertEqual take repeat assertEqual list repeat assertEqual list repeat - assertRaises TypeError repeat assertRaises TypeError repeat None assertRaises TypeError repeat None r = repeat + j assertEqual repr r repeat + j r = repeat + j assertEqual repr r repeat + j list r assertEqual repr r repeat + j check copy deepcopy pickle c = repeat object= times= assertEqual next c assertEqual take copy copy c list assertEqual take copy deepcopy c list proto range pickle HIGHEST_PROTOCOL + pickletest proto repeat object= times= test_repeat_with_negative_times assertEqual repr repeat - repeat assertEqual repr repeat - repeat assertEqual repr repeat times=- repeat assertEqual repr repeat times=- repeat pickle_deprecated test_map assertEqual list map operator pow range range assertEqual list map tupleize abc range b c assertEqual list map tupleize abc count b c assertEqual take map tupleize abc count b assertEqual list map operator pow assertRaises TypeError map assertRaises TypeError list map None range range assertRaises TypeError map operator neg assertRaises TypeError next map range assertRaises ValueError next map errfunc assertRaises TypeError next map onearg check copy deepcopy pickle ans = b c c = map tupleize abc count assertEqual list copy copy c ans c = map tupleize abc count assertEqual list copy deepcopy c ans proto range pickle HIGHEST_PROTOCOL + c = map tupleize abc count pickletest proto c pickle_deprecated test_starmap assertEqual list starmap operator pow zip range range assertEqual take starmap operator pow zip count count assertEqual list starmap operator pow assertEqual list starmap operator pow iter assertRaises TypeError list starmap operator pow None assertRaises TypeError starmap assertRaises TypeError starmap operator pow extra assertRaises TypeError next starmap assertRaises ValueError next starmap errfunc assertRaises TypeError next starmap onearg check copy deepcopy pickle ans = c = starmap operator pow zip range range assertEqual list copy copy c ans c = starmap operator pow zip range range assertEqual list copy deepcopy c ans proto range pickle HIGHEST_PROTOCOL + c = starmap operator pow zip range range pickletest proto c pickle_deprecated test_islice args islice args should agree range args assertEqual list islice range args list range args args tgtargs Stop when seqn exhausted assertEqual list islice range args list range tgtargs Test stop=None assertEqual list islice range None list range assertEqual list islice range None None list range assertEqual list islice range None None None list range assertEqual list islice range None list range assertEqual list islice range None list range Test number items consumed SF = iter range assertEqual list islice list range assertEqual list list range = iter range assertEqual list islice assertEqual list list range Test invalid arguments ra = range assertRaises TypeError islice ra assertRaises TypeError islice ra assertRaises ValueError islice ra - assertRaises ValueError islice ra - - assertRaises ValueError islice ra - assertRaises ValueError islice ra assertRaises ValueError islice ra assertRaises ValueError islice ra assertRaises ValueError islice ra assertRaises ValueError islice ra assertRaises ValueError islice ra assertEqual len list islice count maxsize Issue Less islice predictable state c = count assertEqual list islice c assertEqual next c check copy deepcopy pickle args islice args should agree range args assertEqual list copy copy islice range args list range args assertEqual list copy deepcopy islice range args list range args proto range pickle HIGHEST_PROTOCOL + pickletest proto islice range args Issue check source iterator referenced islice after latter has been exhausted = x x wr = weakref ref = islice assertIsNotNone wr list exhaust iterator support gc_collect assertIsNone wr Issue islice can accept integer-like objects arguments IntLike object __init__ val val = val __index__ val assertEqual list islice range IntLike list range assertEqual list islice range IntLike IntLike list range assertEqual list islice range IntLike IntLike IntLike list range pickle_deprecated test_takewhile data = assertEqual list takewhile underten data assertEqual list takewhile underten assertRaises TypeError takewhile assertRaises TypeError takewhile operator pow assertRaises TypeError takewhile operator pow extra assertRaises TypeError next takewhile assertRaises ValueError next takewhile errfunc t = takewhile bool assertEqual list t assertRaises StopIteration next t check copy deepcopy pickle assertEqual list copy copy takewhile underten data assertEqual list copy deepcopy takewhile underten data proto range pickle HIGHEST_PROTOCOL + pickletest proto takewhile underten data pickle_deprecated test_dropwhile data = assertEqual list dropwhile underten data assertEqual list dropwhile underten assertRaises TypeError dropwhile assertRaises TypeError dropwhile operator pow assertRaises TypeError dropwhile operator pow extra assertRaises TypeError next dropwhile assertRaises ValueError next dropwhile errfunc check copy deepcopy pickle assertEqual list copy copy dropwhile underten data assertEqual list copy deepcopy dropwhile underten data proto range pickle HIGHEST_PROTOCOL + pickletest proto dropwhile underten data pickle_deprecated test_tee n = b = tee test empty iterator assertEqual list assertEqual list b b = tee irange n test interleaved assertEqual lzip b lzip range n range n b = tee irange n test interleaved assertEqual list list range n assertEqual list b list range n b = tee irange n test dealloc leading iterator i range assertEqual next i del assertEqual list b list range n b = tee irange n test dealloc trailing iterator i range assertEqual next i del b assertEqual list list range n j range test randomly interleaved order = n + n random shuffle order lists = its = tee irange n i order value = next its i lists i append value assertEqual lists list range n assertEqual lists list range n test argument format checking assertRaises TypeError tee assertRaises TypeError tee assertRaises TypeError tee x assertRaises TypeError tee x tee object should instantiable b = tee abc c = type assertEqual list c list test long-lagged multi-way split b c = tee range i range assertEqual next i assertEqual list b list range assertEqual next c next c list range assertEqual list list range assertEqual list c list range test values n assertRaises TypeError tee abc invalid assertRaises ValueError tee - n range result = tee abc n assertEqual type result tuple assertEqual len result n assertEqual list x x result list abc n tee objects independent see bug gh- b = tee abc c d = tee e f = tee c assertTrue len b c d e f == test tee_new t t = tee abc tnew = type t assertRaises TypeError tnew assertRaises TypeError tnew t = tnew t assertTrue list t == list t == list t == list abc test tee objects weak referenceable b = tee range p = weakref proxy assertEqual getattr p __class__ type b del support gc_collect For PyPy other GCs assertRaises ReferenceError getattr p __class__ ans = list abc long_ans = list range check copy b = tee abc assertEqual list copy copy ans assertEqual list copy copy b ans b = tee list range assertEqual list copy copy long_ans assertEqual list copy copy b long_ans check partially consumed copy b = tee abc take take b assertEqual list copy copy ans assertEqual list copy copy b ans assertEqual list ans assertEqual list b ans b = tee range take take b assertEqual list copy copy long_ans assertEqual list copy copy b long_ans assertEqual list long_ans assertEqual list b long_ans check deepcopy b = tee abc assertEqual list copy deepcopy ans assertEqual list copy deepcopy b ans assertEqual list ans assertEqual list b ans b = tee range assertEqual list copy deepcopy long_ans assertEqual list copy deepcopy b long_ans assertEqual list long_ans assertEqual list b long_ans check partially consumed deepcopy b = tee abc take take b assertEqual list copy deepcopy ans assertEqual list copy deepcopy b ans assertEqual list ans assertEqual list b ans b = tee range take take b assertEqual list copy deepcopy long_ans assertEqual list copy deepcopy b long_ans assertEqual list long_ans assertEqual list b long_ans check pickle proto range pickle HIGHEST_PROTOCOL + pickletest proto iter tee abc b = tee abc pickletest proto compare=ans pickletest proto b compare=ans test_tee_dealloc_segfault gh- segfaults when accessing module state tp_dealloc script = typing copyreg itertools copyreg buggy_tee = itertools tee script_helper assert_python_ok -c script Issue Crash when deleting backward iterator tee skipIfTorchDynamo infinite loop torch dynamo test_tee_del_backward forward backward = tee repeat None try any forward exhaust iterator del backward except del forward backward raise test_tee_reenter I first = True __iter__ __next__ first = first first = False first next b b = tee I assertRaisesRegex RuntimeError tee next threading_helper requires_working_threading test_tee_concurrent start = threading Event finish = threading Event I __iter__ __next__ start set finish wait b = tee I thread = threading Thread target=next args= thread start try start wait assertRaisesRegex RuntimeError tee next b finally finish set thread join test_StopIteration assertRaises StopIteration next zip f chain cycle zip groupby assertRaises StopIteration next f assertRaises StopIteration next f StopNow assertRaises StopIteration next islice None assertRaises StopIteration next islice StopNow None p q = tee assertRaises StopIteration next p assertRaises StopIteration next q p q = tee StopNow assertRaises StopIteration next p assertRaises StopIteration next q assertRaises StopIteration next repeat None f filter filterfalse map takewhile dropwhile starmap assertRaises StopIteration next f lambda x x assertRaises StopIteration next f lambda x x StopNow support cpython_only test_combinations_result_gc bpo- combinations s tuple-reuse speed trick breaks GC s assumptions about what can untracked Make sure we re-track result tuples whenever we reuse them = combinations None next gc collect That GC collection probably untracked recycled internal result tuple which has value None Make sure s re-tracked when s mutated returned __next__ assertTrue gc is_tracked next support cpython_only test_combinations_with_replacement_result_gc Ditto combinations_with_replacement = combinations_with_replacement None next gc collect assertTrue gc is_tracked next support cpython_only test_permutations_result_gc Ditto permutations = permutations None next gc collect assertTrue gc is_tracked next support cpython_only test_product_result_gc Ditto product = product None next gc collect assertTrue gc is_tracked next support cpython_only test_zip_longest_result_gc Ditto zip_longest = zip_longest gc collect assertTrue gc is_tracked next support cpython_only test_pairwise_result_gc Ditto pairwise = pairwise None None gc collect assertTrue gc is_tracked next support cpython_only test_immutable_types itertools _grouper _tee _tee_dataobject dataset = accumulate batched chain combinations combinations_with_replacement compress count cycle dropwhile filterfalse groupby _grouper islice pairwise permutations product repeat starmap takewhile _tee _tee_dataobject zip_longest tp dataset subTest tp=tp assertRaisesRegex TypeError immutable tp foobar = TestExamples __TestCase test_accumulate assertEqual list accumulate pickle_deprecated test_accumulate_reducible check copy deepcopy pickle data = accumulated = proto range pickle HIGHEST_PROTOCOL + = accumulate data assertEqual list pickle loads pickle dumps proto accumulated assertEqual next assertEqual list pickle loads pickle dumps proto accumulated = accumulate data assertEqual next assertEqual list copy deepcopy accumulated assertEqual list copy copy accumulated pickle_deprecated test_accumulate_reducible_none Issue total None = accumulate None None None operator is_ assertEqual next None proto range pickle HIGHEST_PROTOCOL + it_copy = pickle loads pickle dumps proto assertEqual list it_copy True False assertEqual list copy deepcopy True False assertEqual list copy copy True False test_chain assertEqual join chain ABC DEF ABCDEF test_chain_from_iterable assertEqual join chain from_iterable ABC DEF ABCDEF test_combinations assertEqual list combinations ABCD A B A C A D B C B D C D assertEqual list combinations range test_combinations_with_replacement assertEqual list combinations_with_replacement ABC A A A B A C B B B C C C test_compress assertEqual list compress ABCDEF list ACEF test_count assertEqual list islice count test_cycle assertEqual list islice cycle ABCD list ABCDABCDABCD test_dropwhile assertEqual list dropwhile lambda x x test_groupby assertEqual k k g groupby AAAABBBCCDAABBB list ABCDAB assertEqual list g k g groupby AAAABBBCCD list AAAA list BBB list CC list D test_filter assertEqual list filter lambda x x range test_filterfalse assertEqual list filterfalse lambda x x range test_map assertEqual list map pow test_islice assertEqual list islice ABCDEFG list AB assertEqual list islice ABCDEFG list CD assertEqual list islice ABCDEFG None list CDEFG assertEqual list islice ABCDEFG None list ACEG test_zip assertEqual list zip ABCD xy A x B y test_zip_longest assertEqual list zip_longest ABCD xy fillvalue= - A x B y C - D - test_permutations assertEqual list permutations ABCD list map tuple AB AC AD BA BC BD CA CB CD DA DB DC split assertEqual list permutations range test_product assertEqual list product ABCD xy list map tuple Ax Ay Bx By Cx Cy Dx Dy split assertEqual list product range repeat= test_repeat assertEqual list repeat test_stapmap assertEqual list starmap pow test_takewhile assertEqual list takewhile lambda x x TestPurePythonRoughEquivalents __TestCase test_batched_recipe batched_recipe iterable n Batch data into tuples length n The last batch may shorter batched ABCDEFG -- ABC DEF G n raise ValueError n must least one = iter iterable while batch = tuple islice n yield batch iterable n product ab abc abcd abcde abcdef abcdefg None - None subTest iterable=iterable n=n try e r = None list batched iterable n except Exception e e r = type e None try e r = None list batched_recipe iterable n except Exception e e r = type e None assertEqual r r assertEqual e e staticmethod islice iterable args s = slice args start stop step = s start s stop sys maxsize s step = iter range start stop step try nexti = next except StopIteration Consume iterable up start position i element zip range start iterable pass try i element enumerate iterable i == nexti yield element nexti = next except StopIteration Consume stop i element zip range i + stop iterable pass skipIfTorchDynamo infinite loop torch dynamo test_islice_recipe assertEqual list islice ABCDEFG list AB assertEqual list islice ABCDEFG list CD assertEqual list islice ABCDEFG None list CDEFG assertEqual list islice ABCDEFG None list ACEG Test items consumed = iter range assertEqual list islice list range assertEqual list list range = iter range assertEqual list islice assertEqual list list range Test slice finishes predictable state c = count assertEqual list islice c assertEqual next c test_tee_recipe Begin tee recipe ########################################### tee iterable n= n raise ValueError n == iterator = _tee iterable result = iterator _ range n - result append _tee iterator tuple result _tee __init__ iterable = iter iterable isinstance _tee iterator = iterator link = link iterator = link = None None __iter__ __next__ link = link link None link = next iterator link = None None value link = link value End tee recipe ############################################# n = b = tee test empty iterator assertEqual list assertEqual list b b = tee irange n test interleaved assertEqual lzip b lzip range n range n b = tee irange n test interleaved assertEqual list list range n assertEqual list b list range n b = tee irange n test dealloc leading iterator i range assertEqual next i del assertEqual list b list range n b = tee irange n test dealloc trailing iterator i range assertEqual next i del b assertEqual list list range n j range test randomly interleaved order = n + n random shuffle order lists = its = tee irange n i order value = next its i lists i append value assertEqual lists list range n assertEqual lists list range n test argument format checking assertRaises TypeError tee assertRaises TypeError tee assertRaises TypeError tee x assertRaises TypeError tee x tee object should instantiable b = tee abc c = type assertEqual list c list test long-lagged multi-way split b c = tee range i range assertEqual next i assertEqual list b list range assertEqual next c next c list range assertEqual list list range assertEqual list c list range test invalid values n assertRaises TypeError tee abc invalid assertRaises ValueError tee - n range result = tee abc n assertEqual type result tuple assertEqual len result n assertEqual list x x result list abc n tee objects independent see bug gh- b = tee abc c d = tee e f = tee c assertTrue len b c d e f == test tee_new t t = tee abc tnew = type t assertRaises TypeError tnew assertRaises TypeError tnew t = tnew t assertTrue list t == list t == list t == list abc test tee objects weak referenceable b = tee range p = weakref proxy assertEqual getattr p __class__ type b del gc collect For PyPy other GCs assertRaises ReferenceError getattr p __class__ ans = list abc long_ans = list range Tests applicable tee recipe False check copy b = tee abc assertEqual list copy copy ans assertEqual list copy copy b ans b = tee list range assertEqual list copy copy long_ans assertEqual list copy copy b long_ans check partially consumed copy b = tee abc take take b assertEqual list copy copy ans assertEqual list copy copy b ans assertEqual list ans assertEqual list b ans b = tee range take take b assertEqual list copy copy long_ans assertEqual list copy copy b long_ans assertEqual list long_ans assertEqual list b long_ans Issue Crash when deleting backward iterator tee forward backward = tee repeat None try any forward exhaust iterator del backward except del forward backward raise TestGC __TestCase makecycle iterator container container append iterator next iterator del container iterator test_accumulate = makecycle accumulate test_batched = makecycle batched test_chain = makecycle chain test_chain_from_iterable = makecycle chain from_iterable test_combinations = makecycle combinations test_combinations_with_replacement = makecycle combinations_with_replacement test_compress = makecycle compress ABCDEF test_count = Int = type Int int dict x=a makecycle count Int Int test_cycle = makecycle cycle test_dropwhile = makecycle dropwhile bool test_groupby = makecycle groupby lambda x x test_issue Issue -- _grouper iterator included GC n = keyfunc = lambda x x i j groupby range n key=keyfunc keyfunc __dict__ setdefault x append j test_filter = makecycle filter lambda x True test_filterfalse = makecycle filterfalse lambda x False test_zip = makecycle zip test_zip_longest = makecycle zip_longest b = None makecycle zip_longest fillvalue=b test_map = makecycle map lambda x x test_islice = makecycle islice None test_pairwise = makecycle pairwise test_permutations = makecycle permutations test_product = makecycle product repeat= test_repeat = makecycle repeat test_starmap = makecycle starmap lambda t t test_takewhile = makecycle takewhile bool R seqn Regular generator i seqn yield i G Sequence using __getitem__ __init__ seqn seqn = seqn __getitem__ i seqn i I Sequence using iterator protocol __init__ seqn seqn = seqn i = __iter__ __next__ i = len seqn raise StopIteration v = seqn i i += v Ig Sequence using iterator protocol defined generator __init__ seqn seqn = seqn i = __iter__ val seqn yield val X Missing __getitem__ __iter__ __init__ seqn seqn = seqn i = __next__ i = len seqn raise StopIteration v = seqn i i += v N Iterator missing __next__ __init__ seqn seqn = seqn i = __iter__ E Test propagation exceptions __init__ seqn seqn = seqn i = __iter__ __next__ E Test propagation exceptions after two iterations __init__ seqn seqn = seqn i = __iter__ __next__ i == raise ZeroDivisionError v = seqn i i += v S Test immediate stop __init__ seqn pass __iter__ __next__ raise StopIteration L seqn Test multiple tiers iterators chain map lambda x x R Ig G seqn TestVariousIteratorArgs __TestCase test_accumulate s = r = n = len s g G I Ig L R assertEqual list accumulate g s r assertEqual list accumulate S s assertRaises TypeError accumulate X s assertRaises TypeError accumulate N s assertRaises ZeroDivisionError list accumulate E s test_batched s = abcde r = b c d e n = g G I Ig L R subTest g=g assertEqual list batched g s n r assertEqual list batched S s assertRaises TypeError batched X s assertRaises TypeError batched N s assertRaises ZeroDivisionError list batched E s assertRaises ZeroDivisionError list batched E s test_chain s range do range g G I Ig S L R assertEqual list chain g s list g s assertEqual list chain g s g s list g s +list g s assertRaises TypeError list chain X s assertRaises TypeError list chain N s assertRaises ZeroDivisionError list chain E s test_compress s range do range n = len s g G I Ig S L R assertEqual list compress g s repeat list g s assertRaises TypeError compress X s repeat assertRaises TypeError compress N s repeat assertRaises ZeroDivisionError list compress E s repeat test_product s range do range assertRaises TypeError product X s assertRaises TypeError product N s assertRaises ZeroDivisionError product E s test_cycle s range do range g G I Ig S L R tgtlen = len s expected = list g s actual = list islice cycle g s tgtlen assertEqual actual expected assertRaises TypeError cycle X s assertRaises TypeError cycle N s assertRaises ZeroDivisionError list cycle E s test_groupby s range range range range g G I Ig S L R assertEqual k k sb groupby g s list g s assertRaises TypeError groupby X s assertRaises TypeError groupby N s assertRaises ZeroDivisionError list groupby E s test_filter s range range range range g G I Ig S L R assertEqual list filter isEven g s x x g s isEven x assertRaises TypeError filter isEven X s assertRaises TypeError filter isEven N s assertRaises ZeroDivisionError list filter isEven E s test_filterfalse s range range range range g G I Ig S L R assertEqual list filterfalse isEven g s x x g s isOdd x assertRaises TypeError filterfalse isEven X s assertRaises TypeError filterfalse isEven N s assertRaises ZeroDivisionError list filterfalse isEven E s test_zip s range do range g G I Ig S L R assertEqual list zip g s lzip g s assertEqual list zip g s g s lzip g s g s assertRaises TypeError zip X s assertRaises TypeError zip N s assertRaises ZeroDivisionError list zip E s test_ziplongest s range do range g G I Ig S L R assertEqual list zip_longest g s list zip g s assertEqual list zip_longest g s g s list zip g s g s assertRaises TypeError zip_longest X s assertRaises TypeError zip_longest N s assertRaises ZeroDivisionError list zip_longest E s test_map s range range range range g G I Ig S L R assertEqual list map onearg g s onearg x x g s assertEqual list map operator pow g s g s x x x g s assertRaises TypeError map onearg X s assertRaises TypeError map onearg N s assertRaises ZeroDivisionError list map onearg E s test_islice s range do range g G I Ig S L R assertEqual list islice g s None list g s assertRaises TypeError islice X s assertRaises TypeError islice N s assertRaises ZeroDivisionError list islice E s test_pairwise s range do range g G I Ig S L R seq = list g s expected = list zip seq seq actual = list pairwise g s assertEqual actual expected assertRaises TypeError pairwise X s assertRaises TypeError pairwise N s assertRaises ZeroDivisionError list pairwise E s test_starmap s range range range range g G I Ig S L R ss = lzip s s assertEqual list starmap operator pow g ss x x x g s assertRaises TypeError starmap operator pow X ss assertRaises TypeError starmap operator pow N ss assertRaises ZeroDivisionError list starmap operator pow E ss test_takewhile s range range range range g G I Ig S L R tgt = elem g s isEven elem break tgt append elem assertEqual list takewhile isEven g s tgt assertRaises TypeError takewhile isEven X s assertRaises TypeError takewhile isEven N s assertRaises ZeroDivisionError list takewhile isEven E s test_dropwhile s range range range range g G I Ig S L R tgt = elem g s tgt isOdd elem continue tgt append elem assertEqual list dropwhile isOdd g s tgt assertRaises TypeError dropwhile isOdd X s assertRaises TypeError dropwhile isOdd N s assertRaises ZeroDivisionError list dropwhile isOdd E s test_tee s range do range g G I Ig S L R = tee g s assertEqual list list g s assertEqual list list g s assertRaises TypeError tee X s assertRaises TypeError tee N s assertRaises ZeroDivisionError list tee E s LengthTransparency __TestCase test_repeat assertEqual operator length_hint repeat None assertEqual operator length_hint repeat None assertEqual operator length_hint repeat None test_repeat_with_negative_times assertEqual operator length_hint repeat None - assertEqual operator length_hint repeat None - assertEqual operator length_hint repeat None times=- assertEqual operator length_hint repeat None times=- RegressionTests __TestCase test_sf_ Fix Armin Rigo s successful efforts wreak havoc mutatingtuple tuple f tuple builds tuple t which copy tuple then calls f t then mutates t equal tuple needs len tuple == len tuple g value first= first del first f next z value items = list tuple items = list tuple gen = map g items z = zip gen len tuple next z f t global T T = t first = list T first = mutatingtuple f second = list T assertEqual first second test_sf_ Make sure chain cycle catch exceptions immediately rather than when shifting between input sources gen hist append yield hist append raise AssertionError hist append gen x hist append yield hist append hist = assertRaises AssertionError list chain gen gen False assertEqual hist hist = assertRaises AssertionError list chain gen gen True assertEqual hist hist = assertRaises AssertionError list cycle gen assertEqual hist support skip_if_pgo_task support requires_resource cpu slowTest test_long_chain_of_empty_iterables Make sure itertools chain doesn t run into recursion limits when dealing long chains empty iterables Even high number would probably only fail Py_DEBUG mode = chain from_iterable unused range assertRaises StopIteration next test_issue _ f n n == list b n = k b groupby range f list b shouldn t crash test_issue _ K __init__ v pass __eq__ other nonlocal i i += i == next g None True i = g = next groupby range K j range next g None shouldn t crash SubclassWithKwargsTest __TestCase test_keywords_in_subclass count subclassable testcases = repeat zip ab b filter None filterfalse None chain map str starmap operator pow islice takewhile isEven dropwhile isEven cycle compress ABC A C cls args result testcases subTest cls subclass cls pass u = subclass args assertIs type u subclass assertEqual list islice u result assertRaises TypeError subclass args newarg= cls args result testcases Constructors repeat zip compress accept keyword arguments Their subclasses need overriding __new__ support new keyword arguments cls repeat zip compress continue subTest cls subclass_with_init cls __init__ args newarg=None newarg = newarg u = subclass_with_init args newarg= assertIs type u subclass_with_init assertEqual list islice u result assertEqual u newarg cls args result testcases subTest cls subclass_with_new cls __new__ cls args newarg=None = super __new__ cls args newarg = newarg u = subclass_with_new args newarg= assertIs type u subclass_with_new assertEqual list islice u result assertEqual u newarg __name__ == __main__ run_tests