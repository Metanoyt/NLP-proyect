################################################################################################# Copyright c - NVIDIA CORPORATION AFFILIATES All rights reserved SPDX-License-Identifier BSD- -Clause Redistribution use source binary forms without modification permitted provided following conditions met Redistributions source code must retain above copyright notice list conditions following disclaimer Redistributions binary form must reproduce above copyright notice list conditions following disclaimer documentation other materials provided distribution Neither name copyright holder nor names its contributors may used endorse promote products derived software without specific prior written permission THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE ################################################################################################# Definition CuTe Layouts functions manipulate them which works order lexicographic instead co-lexicographic implemented original layout py itertools chain typing Optional TypeAlias Union typing_extensions TypeIs int_tuple crd idx flatten has_none IntTuple is_int is_tuple product slice_ suffix_product Type aliases LayoutOrIntTuple TypeAlias = Union Layout IntTuple LayoutProfile TypeAlias = Optional Union tuple object Layout LayoutInput TypeAlias = Optional Union Layout IntTuple tuple object CoordinateType TypeAlias = Optional Union int IntTuple tuple object Input slice_ crd idx functions LayoutBase pass is_layout x object - TypeIs Layout isinstance x LayoutBase Layout LayoutBase __init__ _shape IntTuple _stride Optional IntTuple = None - None shape = _shape _stride None stride = suffix_product shape stride = _stride operator == __eq__ other object - bool isinstance other Layout False shape == other shape stride == other stride operator len L len rank like tuples __len__ - int is_tuple shape len shape operator map coord idx __call__ args CoordinateType - Union Layout int Map logical coordinate linear index Coord has no Underscore slice operators OR Slice layout sublayout Coord has Underscore slice op Follow same behavior ` Layout operator Coord const ` cute C++ has_none args len args == Layout slice_ args shape slice_ args stride Layout slice_ args shape slice_ args stride len args == crd idx args shape stride type ignore arg-type crd idx args shape stride type ignore arg-type operator get-i like tuples __getitem__ i int - Layout is_tuple shape Layout shape i stride i type ignore index assert i == Layout shape stride size layout Size domain size - int product shape cosize layout Size codomain cosize - int size - + type ignore operator print str __str__ - str f shape stride error msgs representation __repr__ - str f Layout shape stride Make Layout list layouts each layout s own mode result make_layout layouts Union Layout tuple Layout - Layout len layouts == is_layout layouts layouts = layouts shape stride = zip shape stride layouts type ignore union-attr Layout shape stride Size domain size layout LayoutOrIntTuple - int is_layout layout layout size product layout Size codomain cosize layout Layout - int layout cosize Layout coalesce -- flatten combine many modes possible while preserving int-to-int function coalesce layout Layout profile LayoutProfile = None - Layout is_tuple profile assert len layout = len profile make_layout chain coalesce layout i profile i i range len profile type ignore arg-type layout i i range len profile len layout result_shape = result_stride = Since we now follow lexicographic order we need process right left And make implementation more efficient we append end list reverse end shape stride zip reversed flatten layout shape reversed flatten layout stride skip their shape- s shape == continue replace our shape- anything result_shape - == result_shape - = shape result_stride - = stride merge modes shape stride match result_shape - result_stride - == stride result_shape - = result_shape - shape append new mode result_shape append shape result_stride append stride len result_shape == Layout result_shape result_stride result_shape reverse result_stride reverse Layout tuple result_shape tuple result_stride Layout filter -- replace all stride- modes size- then coalesce remove them filter layout Layout profile LayoutProfile = None - Layout is_tuple profile assert len layout = len profile make_layout chain filter layout i profile i i range len profile type ignore arg-type layout i i range len profile len layout result_shape = result_stride = shape stride zip flatten layout shape flatten layout stride skip their shape- s stride- s shape == stride == result_shape append shape result_stride append stride len result_shape == Layout coalesce Layout tuple result_shape tuple result_stride Layout composition Use tuples-of-layouts perform operation by-mode None no-op composition layoutA Layout layoutB LayoutInput - Layout layoutB None layoutA is_int layoutB composition layoutA Layout layoutB is_tuple layoutB assert len layoutA = len layoutB make_layout chain composition layoutA i layoutB i i range len layoutB type ignore arg-type layoutA i i range len layoutB len layoutA is_tuple layoutB shape make_layout composition layoutA layoutB_i layoutB_i layoutB type ignore arg-type attr-defined layoutB stride == Layout layoutB shape result_shape = result_stride = rest_shape = layoutB shape rest_stride = layoutB stride flat_A = coalesce layoutA when left layout multi-dimensional sublayout aka = b c x y z layout = s d integral s d means we want “ remove ” first d elements left starting rightmost This will increase stride “ keep ” first s those strided elements This does affect stride For example = layout = Step remove first elements stride increase i e - Step keep first those strided elements i e - Because we going lexicographically we go through left layout right left curr_shape curr_stride zip reversed flatten flat_A shape reversed flatten flat_A stride assert curr_shape rest_stride == rest_stride curr_shape == type ignore operator new_shape = min max curr_shape rest_stride rest_shape type ignore operator new_shape = result_shape append new_shape Append end will reverse later result_stride append rest_stride curr_stride rest_shape = rest_shape new_shape type ignore operator rest_stride = - -rest_stride curr_shape type ignore operator Python exclusive impl always floor div so == ceil_div abs rest_stride curr_shape signum rest_stride When left has single-size sublayout reach last sublayout aka left = b layout = s d result rather trivial left o layout = b o s d = s b d For example = layout = result = rest_shape = len result_shape == result_shape append rest_shape Append end will reverse later result_stride append rest_stride flatten flat_A stride Reverse lists because we build lists reverse order append end way more efficient result_shape reverse result_stride reverse len result_shape == Layout result_shape result_stride type ignore arg-type Layout tuple result_shape tuple result_stride type ignore arg-type Layout complement complement layout LayoutOrIntTuple max_idx int = - Layout is_int layout complement Layout layout result_shape = result_stride = current_idx = sorted_DS = sorted zip flatten layout stride flatten layout shape type ignore union-attr stride shape sorted_DS stride == shape == continue in_bound = current_idx = shape stride To support symbolic value which can t evaluated now assert type in_bound bool in_bound result_shape append stride current_idx result_stride append current_idx current_idx = shape stride result_shape append max_idx + current_idx - current_idx ceil_div result_stride append current_idx This different original pycute implementation because we want follow lexicographic order here where right-most dimension innermost dimension smallest stride result_shape reverse result_stride reverse coalesce Layout tuple result_shape tuple result_stride Layout right inverse right_inverse layout Optional LayoutOrIntTuple - Optional Layout layout None None is_int layout Layout layout result_shape = result_stride = current_idx = flat_shape = flatten layout shape type ignore union-attr flat_stride = flatten layout stride type ignore union-attr sorted_DSA = sorted zip flat_stride flat_shape suffix_product flat_shape type ignore arg-type stride shape rstride sorted_DSA shape == continue current_idx = stride break result_shape append shape result_stride append rstride current_idx = shape stride result_shape reverse result_stride reverse coalesce Layout tuple result_shape tuple result_stride Layout left inverse left_inverse layout Optional LayoutOrIntTuple - Optional Layout layout None None is_int layout Layout layout right_inverse make_layout complement layout layout type ignore arg-type Split layout composition B rest Use tuples-of-layouts perform operation by-mode None no-op logical_divide layoutA Layout layoutB LayoutInput - Layout layoutB None layoutA is_int layoutB logical_divide layoutA Layout layoutB is_tuple layoutB assert len layoutA = len layoutB make_layout chain logical_divide layoutA i layoutB i type ignore arg-type i range len layoutB layoutA i i range len layoutB len layoutA composition layoutA make_layout layoutB complement layoutB size layoutA Reproduce layoutA over layoutB Use tuples-of-layouts perform operation by-mode None no-op logical_product layoutA Layout layoutB LayoutInput - Layout layoutB None layoutA is_int layoutB logical_divide layoutA Layout layoutB is_tuple layoutB assert len layoutA = len layoutB make_layout chain logical_product layoutA i layoutB i type ignore arg-type i range len layoutB layoutA i i range len layoutB len layoutA make_layout layoutA composition complement layoutA size layoutA cosize layoutB layoutB Gather modes hierarchical logical_divide logical_product hier_unzip splitter object layoutA Layout layoutB LayoutInput - Layout layoutB None make_layout Layout layoutA is_tuple layoutB assert len layoutA = len layoutB A layout shape A B b C c split = make_layout hier_unzip splitter layoutA i layoutB i type ignore arg-type i range len layoutB Gather shape A B C b c y z make_layout make_layout split i i range len layoutB type ignore arg-type make_layout chain type ignore arg-type split i i range len layoutB layoutA i i range len layoutB len layoutA splitter must rank- layout splitter layoutA layoutB type ignore operator Apply logical divide hierarchically gather split modes into two modes zipped_divide layoutA Layout layoutB LayoutInput - Layout hier_unzip logical_divide layoutA layoutB Perform logical divide hierarchically gather tiles B-layouts into new mode tiled_divide layoutA Layout layoutB LayoutInput - Layout result = zipped_divide layoutA layoutB make_layout result + result i i range len result type ignore arg-type Apply logical product hierarchically gather split modes into two modes zipped_product layoutA Layout layoutB LayoutInput - Layout hier_unzip logical_product layoutA layoutB Perform logical product hierarchically gather tiles B-layouts into new mode tiled_product layoutA Layout layoutB LayoutInput - Layout result = zipped_product layoutA layoutB make_layout result + result i i range len result type ignore arg-type slice_and_offset crd tuple object layout Layout - tuple Layout int Layout slice_ crd layout shape slice_ crd layout stride crd idx crd layout shape layout stride type ignore arg-type