usr bin env python mypy allow-untyped-defs The Python Hipify script ## Copyright c - Advanced Micro Devices Inc All rights reserved - Advanced Micro Devices Inc Facebook Inc All rights reserved Permission hereby granted free charge any person obtaining copy software associated documentation files Software deal Software without restriction including without limitation rights use copy modify merge publish distribute sublicense sell copies Software permit persons whom Software furnished do so subject following conditions The above copyright notice permission notice shall included all copies substantial portions Software THE SOFTWARE IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND EXPRESS OR IMPLIED INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM DAMAGES OR OTHER LIABILITY WHETHER IN AN ACTION OF CONTRACT TORT OR OTHERWISE ARISING FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE argparse fnmatch re shutil sys os constants cuda_to_hip_mappings CUDA_TO_HIP_MAPPINGS cuda_to_hip_mappings MATH_TRANSPILATIONS typing Optional collections abc Iterator collections abc Mapping Iterable enum Enum functools hashlib CurrentState Enum INITIALIZED = DONE = HipifyResult __init__ current_state hipified_path current_state = current_state hipified_path = hipified_path status = __str__ f HipifyResult current_state current_state hipified_path hipified_path status status HipifyFinalResult = dict str HipifyResult HIPIFY_C_BREADCRUMB = This file automatically generated hipify \n HIPIFY_FINAL_RESULT HipifyFinalResult = Hardcode PyTorch template map This dictionary provides mapping PyTorch kernel template types their actual types PYTORCH_TEMPLATE_MAP = Dtype scalar_t T scalar_t __all__ = InputError openf bcolors GeneratedFileCleaner match_extensions matched_files_iter preprocess_file_and_save_result compute_stats add_dim processKernelLaunches find_closure_group find_bracket_group find_parentheses_group replace_math_functions hip_header_magic replace_extern_shared get_hip_file_path is_out_of_place is_pytorch_file is_cusparse_file is_special_file is_caffe _gpu_file is_caffe _gpu_file Trie preprocessor file_specific_replacement file_add_header fix_static_global_kernels extract_arguments str bool CurrentState HipifyResult hipify InputError Exception Exception raised errors input __init__ message super __init__ message message = message __str__ f Input error message openf filename mode open filename mode errors= ignore Color coding printing bcolors HEADER = \ m OKBLUE = \ m OKGREEN = \ m WARNING = \ m FAIL = \ m ENDC = \ m BOLD = \ m UNDERLINE = \ m To programmer output hipify most likely intermediates This allows users hipify ask cleanup running hipify compilation instantiating context manager keep_intermediates=False The main usecase cpp_extensions specifically load method It good idea keep intermediates case errors recompile unchanged files cases where you don t want keep them e g CI can used remove files GeneratedFileCleaner Context Manager clean up generated files __init__ keep_intermediates=False keep_intermediates = keep_intermediates files_to_clean = set dirs_to_clean = __enter__ open fn args kwargs os path exists fn files_to_clean add os path abspath fn pyrefly ignore not-iterable open fn args kwargs makedirs dn exist_ok=False parent n = os path split dn n parent n = os path split parent parent n os path exists parent makedirs parent exist_ok=True os path isdir dn exist_ok os mkdir dn dirs_to_clean append os path abspath dn __exit__ type value traceback keep_intermediates f files_to_clean os unlink f d dirs_to_clean - os rmdir d Follow UNIX convention paths use instead \\ Windows _to_unix_path path str - str path replace os sep match_extensions filename str extensions Iterable - bool Helper method see filename ends certain extension any filename endswith e e extensions _fnmatch filepath patterns any fnmatch fnmatch filepath pattern pattern patterns matched_files_iter root_path str includes Iterable = ignores Iterable = extensions Iterable = out_of_place_only bool = False is_pytorch_extension bool = False - Iterator str exact_matches = set includes This very rough heuristic really we want avoid scanning any file which checked into source control script needs work even you re Git Hg checkout so easier just block biggest time sinks won t matter end abs_dirpath dirs filenames os walk root_path topdown=True rel_dirpath = os path relpath abs_dirpath root_path rel_dirpath == Blah blah blah O n blah blah git dirs dirs remove git build dirs dirs remove build third_party dirs dirs remove third_party dirs append third_party nvfuser filename filenames filepath = _to_unix_path os path join abs_dirpath filename rel_filepath = _to_unix_path os path join rel_dirpath filename We respect extensions UNLESS you wrote entire filename verbatim which case we always accept _fnmatch filepath includes _fnmatch filepath ignores match_extensions filepath extensions filepath exact_matches is_pytorch_extension pytorch extensions consider all files is_pytorch_file rel_filepath is_caffe _gpu_file rel_filepath continue out_of_place_only is_out_of_place rel_filepath continue yield filepath preprocess_file_and_save_result output_directory str filepath str all_files Iterable header_include_dirs Iterable stats dict str list hip_clang_launch bool is_pytorch_extension bool clean_ctx GeneratedFileCleaner show_progress bool - None fin_path = os path abspath os path join output_directory filepath hipify_result = HipifyResult current_state=CurrentState INITIALIZED hipified_path=fin_path HIPIFY_FINAL_RESULT fin_path = hipify_result result = preprocessor output_directory filepath all_files header_include_dirs stats hip_clang_launch is_pytorch_extension clean_ctx show_progress Show what happened show_progress ignored result status print fin_path - result hipified_path result status flush=True HIPIFY_FINAL_RESULT fin_path = result compute_stats stats unsupported_calls = cuda_call cuda_call _filepath stats unsupported_calls Print number unsupported calls print f Total number unsupported CUDA function calls len unsupported_calls d Print list unsupported calls print join unsupported_calls Print number kernel launches print f \nTotal number replaced kernel launches len stats kernel_launches d add_dim kernel_string cuda_kernel adds dim second third arguments kernel launch count = closure = kernel_string = kernel_string replace replace arg_locs list dict str int = _ range arg_locs count start = ind c enumerate kernel_string count break c == closure += c == closure -= c == ind == len kernel_string - closure == arg_locs count end = ind + c = count += count arg_locs count start = ind + first_arg_raw = kernel_string arg_locs start arg_locs end + second_arg_raw = kernel_string arg_locs start arg_locs end first_arg_clean = kernel_string arg_locs start arg_locs end replace \n strip second_arg_clean = kernel_string arg_locs start arg_locs end replace \n strip first_arg_dim = f dim first_arg_clean second_arg_dim = f dim second_arg_clean first_arg_raw_dim = first_arg_raw replace first_arg_clean first_arg_dim second_arg_raw_dim = second_arg_raw replace second_arg_clean second_arg_dim cuda_kernel = cuda_kernel replace first_arg_raw + second_arg_raw first_arg_raw_dim + second_arg_raw_dim cuda_kernel RE_KERNEL_LAUNCH = re compile r + detail +\\\n + processKernelLaunches string stats Replace CUDA style Kernel launches HIP style kernel launches Concat namespace kernel names Find cleaner way doing later string = RE_KERNEL_LAUNCH sub lambda inp f inp group inp group string grab_method_and_template in_kernel The positions relevant kernel components pos = kernel_launch start in_kernel start end in_kernel end kernel_name start - end - template start - end - Count balancing template count = Status whether we parsing certain item START = AT_TEMPLATE = AFTER_TEMPLATE = AT_KERNEL_NAME = status = START Parse string character character i range pos kernel_launch start - - - char = string i Handle Templating Arguments status START AT_TEMPLATE char == status == START status = AT_TEMPLATE pos template end = i count += char == count -= count == status == AT_TEMPLATE pos template start = i status = AFTER_TEMPLATE Handle Kernel Name status = AT_TEMPLATE string i isalnum string i _ status = AT_KERNEL_NAME status = AT_KERNEL_NAME pos kernel_name end = i Case Kernel name starts string i == pos kernel_name start = Finished pos kernel_name pos template pos kernel_launch Potential ending point we re already traversing kernel s name status == AT_KERNEL_NAME pos kernel_name start = i Finished pos kernel_name pos template pos kernel_launch find_kernel_bounds string Finds starting ending points all kernel launches string kernel_end = kernel_positions = Continue until we cannot find any more kernels anymore while string find kernel_end = - Get kernel starting position starting previous ending point kernel_start = string find kernel_end Get kernel ending position adjust end point past kernel_end = string find kernel_start + kernel_end = raise InputError no kernel end found Add list traversed kernels kernel_positions append start kernel_start end kernel_end group string kernel_start kernel_end kernel_positions Replace comments string literals code so find_kernel_bounds does wrongly capture kernels comments string literals This function replaces them x keep positions mask_comments string in_comment = prev_c = new_string = c string in_comment == Outside comments c == prev_c == in_comment = c == prev_c == in_comment = c == prev_c = \\ prev_c = in_comment = in_comment == In xxx c == \r c == \n in_comment = in_comment == In xxx c == prev_c == in_comment = in_comment == In c == prev_c = \\ in_comment = prev_c = c in_comment == new_string += c new_string += x new_string Grab positional ranges all kernel launches get_kernel_positions = list find_kernel_bounds mask_comments string output_string = string Replace each CUDA kernel HIP kernel kernel get_kernel_positions Get kernel components params = grab_method_and_template kernel Find parenthesis after kernel launch parenthesis = string find kernel end Extract cuda kernel cuda_kernel = string params start parenthesis + kernel_string = string kernel start kernel end end_param_index = params end == - kernel_name_with_template = string params start params end_param_index end + cuda_kernel_dim = add_dim kernel_string cuda_kernel Keep number kernel launch params consistent grid dims group dims stream dynamic shared size num_klp = len extract_arguments kernel group replace replace hip_kernel = hipLaunchKernelGGL + cuda_kernel_dim - replace - num_klp + replace replace replace kernel_name_with_template + kernel_name_with_template + Replace cuda kernel hip kernel output_string = output_string replace cuda_kernel hip_kernel Update statistics stats kernel_launches append hip_kernel output_string find_closure_group input_string start group Generalization finding balancing closure group group = then finds first balanced parentheses group = then finds first balanced bracket Given input string starting position input string group type find_closure_group returns positions group group tuple Example find_closure_group hi inside_parenthesis = False parens = pos = start p_start p_end = - - while pos len input_string input_string pos == group inside_parenthesis False inside_parenthesis = True parens = p_start = pos parens += input_string pos == group inside_parenthesis parens -= parens == p_end = pos p_start p_end pos += None None find_bracket_group input_string start Finds first balanced parentheses find_closure_group input_string start group= find_parentheses_group input_string start Finds first balanced bracket find_closure_group input_string start group= RE_ASSERT = re compile r \bassert \ replace_math_functions input_string FIXME Temporarily replace std invocations math functions non-std versions prevent linker errors NOTE This can lead correctness issues when running tests since correct version math function exp expf might get called Plan remove function once HIP supports std math function calls inside device code output_string = input_string func MATH_TRANSPILATIONS output_string = output_string replace fr func f MATH_TRANSPILATIONS func output_string RE_SYNCTHREADS = re compile r \b __syncthreads \b \w \ hip_header_magic input_string If file makes kernel builtin calls does include cuda_runtime h header then automatically add #include match magic includes provided NVCC TODO Update logic ignore cases where cuda_runtime h included another file Copy input output_string = input_string Check one following headers already included headers = hip hip_runtime h hip hip_runtime_api h any re search fr #include ext &#124; ext output_string ext headers output_string Rough logic detect we re inside device code hasDeviceLogic int hasDeviceLogic = hipLaunchKernelGGL output_string hasDeviceLogic += __global__ output_string hasDeviceLogic += __shared__ output_string hasDeviceLogic += RE_SYNCTHREADS search output_string None If device logic found provide necessary header hasDeviceLogic output_string = #include hip hip_runtime h \n + input_string output_string RE_EXTERN_SHARED = re compile r extern\s+ \w\ \ + \s __shared__\s+ \w \s + \s+ \w+ \s \ \s \ \s replace_extern_shared input_string Match extern __shared__ type foo syntax use HIP_DYNAMIC_SHARED MACRO instead https github com ROCm hip blob master docs markdown hip_kernel_language md#__shared__ Example extern __shared__ char smemChar = HIP_DYNAMIC_SHARED char smemChar extern __shared__ unsigned char smem = HIP_DYNAMIC_SHARED unsigned char my_smem output_string = input_string output_string = RE_EXTERN_SHARED sub lambda inp f HIP_DYNAMIC_SHARED inp group inp group inp group output_string output_string get_hip_file_path rel_filepath is_pytorch_extension=False Returns new name hipified file At moment some PyTorch source files HIPified place The predicate is_out_of_place tells us case os path isabs rel_filepath raise AssertionError rel_filepath must relative path is_pytorch_extension is_out_of_place rel_filepath rel_filepath dirpath filename = os path split rel_filepath root ext = os path splitext filename Here s plan In general we need disambiguate HIPified filename so gets different name original filename so we don t overwrite original file There s lot different naming conventions across PyTorch Caffe general recipe convert occurrences cuda gpu hip add hip there no occurrences cuda gpu anywhere Concretely we do following - If there directory component named cuda replace hip AND - If file name contains CUDA replace HIP AND - ALWAYS replace cu hip because those files contain CUDA kernels needs hipified processed hip compiler - If we hipifying PyTorch extension parent directory name did change result above transformations insert hip file path direct parent folder file - If we hipifying PyTorch extension parent directory name well filename incl extension did change result above transformations insert _hip filename This isn t set stone we might adjust support other naming conventions ext == cu ext = hip orig_filename = filename orig_dirpath = dirpath dirpath = dirpath replace cuda hip dirpath = dirpath replace CUDA HIP dirpath = dirpath replace THC THH root = root replace cuda hip root = root replace CUDA HIP Special case handle caffe core THCCachingAllocator dirpath = caffe core root = root replace THC THH is_pytorch_extension dirpath == orig_dirpath dirpath = os path join dirpath hip is_pytorch_extension dirpath == orig_dirpath root + ext == orig_filename root = root + _hip os path join dirpath root + ext is_out_of_place rel_filepath os path isabs rel_filepath raise AssertionError rel_filepath must relative path rel_filepath startswith torch False rel_filepath startswith third_party nvfuser False rel_filepath startswith tools autograd templates False True Keep synchronized includes ignores build_amd py is_pytorch_file rel_filepath os path isabs rel_filepath raise AssertionError rel_filepath must relative path rel_filepath startswith aten rel_filepath startswith aten src ATen core False True rel_filepath startswith torch True rel_filepath startswith third_party nvfuser True rel_filepath startswith third_party fbgemm True rel_filepath startswith tools autograd templates True False is_cusparse_file rel_filepath is_pytorch_file rel_filepath sparse rel_filepath lower False is_special_file rel_filepath is_pytorch_file rel_filepath sparse rel_filepath lower True linalg rel_filepath lower batchlinearalgebralibblas rel_filepath lower False don t use special mappings specific linalg cublas file True False is_caffe _gpu_file rel_filepath os path isabs rel_filepath raise AssertionError rel_filepath must relative path rel_filepath startswith c cuda True filename = os path basename rel_filepath _ ext = os path splitext filename pyrefly ignore unsupported-operation gpu filename ext cu cuh cudnn filename TrieNode A Trie node whose children represented directory char TrieNode A special char represents end word __init__ children = Trie Creates Trie out list words The trie can exported Regex pattern The corresponding Regex should match much faster than simple Regex union __init__ Initialize trie empty root node root = TrieNode _hash = hashlib md usedforsecurity=False _digest = _hash digest add word Add word Trie _hash update word encode _digest = _hash digest node = root char word node children setdefault char TrieNode node = node children char node children = True Mark end word dump Return root node Trie root quote char Escape char regex re escape char search word Search whether word present Trie Returns True yes False node = root char word char node children node = node children char False make sure check end-of-word marker present node children functools lru_cache noqa B _pattern root digest Convert Trie into regular expression pattern Memoized hash digest trie which built incrementally during add node = root node children len node children keys == None alt = store alternative patterns cc = store char char classes q = node representing end word char sorted node children keys isinstance node children char TrieNode try recurse = _pattern node children char _digest alt append quote char + recurse except Exception cc append quote char q = cconly = len alt len cc len cc == alt append cc alt append + join cc + len alt == result = alt result = + &#124; join alt + q cconly result += result = f result result pattern Export Trie regex pattern _pattern root _digest export_to_regex Export Trie regex pattern _pattern root _digest CAFFE _TRIE = Trie CAFFE _MAP = PYTORCH_TRIE = Trie PYTORCH_MAP dict str object = In PyTorch we map cuBLAS- rocBLAS cuSPARSE- hipSPARSE Note prefix roc versus hip The hip APIs offer more direct CUDA-friendly mapping calling rocBLAS directly has better performance Unfortunately roc types hip types differ i e rocblas_float_complex versus hipComplex In case SPARSE we must use hip types complex instead roc types pytorch mappings assume roc Therefore we create new SPARSE mapping has higher priority Its mappings will trigger first only when miss occurs will lower-priority pytorch mapping take place When file contains sparse filename mapping marked API_SPARSE preferred over other choices Similarly linalg files require rocBLAS - hipSOLVER so they also need special handling PYTORCH_SPECIAL_MAP = mapping CUDA_TO_HIP_MAPPINGS isinstance mapping Mapping raise TypeError Expected each mapping CUDA_TO_HIP_MAPPINGS Mapping src value mapping items dst = value meta_data = value constants API_CAFFE meta_data PYTORCH_TRIE add src src already PYTORCH_MAP dst belongs API_SPECIAL do overwrite PYTORCH_MAP store dst separately constants API_SPECIAL meta_data PYTORCH_MAP get src PYTORCH_SPECIAL_MAP src = dst PYTORCH_MAP src = dst constants API_PYTORCH meta_data constants API_SPECIAL meta_data CAFFE _TRIE add src CAFFE _MAP src = dst RE_CAFFE _PREPROCESSOR = re compile CAFFE _TRIE export_to_regex RE_PYTORCH_PREPROCESSOR = re compile fr =\W PYTORCH_TRIE export_to_regex =\W RE_QUOTE_HEADER = re compile r #include ^ + RE_ANGLE_HEADER = re compile r #include ^ + RE_THC_GENERIC_FILE = re compile r #define THC_GENERIC_FILE ^ + RE_CU_SUFFIX = re compile r \ cu\b careful pick up cuh Returns HipifyResult object following details hipified_path absolute path hipified source file status ok hipified file written out skipped identical hipified file already existed hipified file couldn t written out ignored source file hipified file itself meant hipified current_state CurrentState INITIALIZED source file first ready hipified CurrentState DONE source file done hipification process preprocessor output_directory str filepath str all_files Iterable header_include_dirs Iterable stats dict str list hip_clang_launch bool is_pytorch_extension bool clean_ctx GeneratedFileCleaner show_progress bool - HipifyResult Executes CUDA - HIP conversion specified file fin_path = os path abspath os path join output_directory filepath filepath = _to_unix_path filepath hipify_result = HIPIFY_FINAL_RESULT fin_path filepath all_files hipify_result hipified_path = None hipify_result status = ignored hipified hipify_result current_state = CurrentState DONE hipify_result rel_filepath = _to_unix_path os path relpath filepath output_directory open fin_path encoding= utf- fin fin readline == HIPIFY_C_BREADCRUMB hipify_result hipified_path = None hipify_result status = ignored input hipified output hipify_result current_state = CurrentState DONE hipify_result fin seek output_source = fin read orig_output_source = output_source get_hip_file_path needs relative path work correctly fout_path = os path abspath os path join output_directory get_hip_file_path rel_filepath is_pytorch_extension os path exists os path dirname fout_path clean_ctx makedirs os path dirname fout_path unsupported_calls statistics reporting broken atm pt_repl m PYTORCH_MAP m group pt_special_repl m checks SPECIAL map first miss occurs falls back pytorch mappings PYTORCH_SPECIAL_MAP get m group pt_repl m is_pytorch_extension output_source = RE_PYTORCH_PREPROCESSOR sub pt_repl output_source is_special_file rel_filepath output_source = RE_PYTORCH_PREPROCESSOR sub pt_special_repl output_source is_pytorch_file rel_filepath output_source = RE_PYTORCH_PREPROCESSOR sub pt_repl output_source c _repl m CAFFE _MAP m group output_source = RE_CAFFE _PREPROCESSOR sub c _repl output_source Header rewrites mk_repl templ include_current_dir=True repl m f = m group filename = os path basename f f startswith ATen cuda ATen native cuda ATen native nested cuda ATen native quantized cuda ATen native sparse cuda ATen native transformers cuda THC f startswith THC f startswith THCP templ format get_hip_file_path m group is_pytorch_extension filename one files being hipified extension is_pytorch_extension any s endswith filename s all_files header_dir = None header_filepath = None If include_current_dir True look first same dir including source file include_current_dir header_dir_to_check = os path dirname fin_path header_path_to_check = os path abspath os path join header_dir_to_check f os path exists header_path_to_check header_dir = header_dir_to_check header_filepath = header_path_to_check If found look include dirs one one first match wins header_filepath None header_include_dir header_include_dirs header_dir_to_check = os path join output_directory header_include_dir header_path_to_check = os path abspath os path join header_dir_to_check f os path exists header_path_to_check header_dir = header_dir_to_check header_filepath = header_path_to_check If header file found keep header_filepath None m group Hipify header file first needed header_filepath HIPIFY_FINAL_RESULT preprocess_file_and_save_result output_directory header_filepath all_files header_include_dirs stats hip_clang_launch is_pytorch_extension clean_ctx show_progress header_filepath HIPIFY_FINAL_RESULT header_result = HIPIFY_FINAL_RESULT header_filepath header_result current_state == CurrentState INITIALIZED get_hip_file_path needs relative path work correctly header_rel_path = os path relpath header_filepath output_directory header_fout_path = os path abspath os path join output_directory get_hip_file_path header_rel_path is_pytorch_extension header_result hipified_path = header_fout_path HIPIFY_FINAL_RESULT header_filepath = header_result templ format os path relpath header_fout_path header_fout_path None header_filepath header_dir hipified_header_filepath = HIPIFY_FINAL_RESULT header_filepath hipified_path templ format _to_unix_path os path relpath hipified_header_filepath hipified_header_filepath None header_filepath header_dir m group repl output_source = RE_QUOTE_HEADER sub mk_repl #include True output_source output_source = RE_ANGLE_HEADER sub mk_repl #include False output_source output_source = RE_THC_GENERIC_FILE sub mk_repl #define THC_GENERIC_FILE output_source CMakeLists txt rewrites filepath endswith CMakeLists txt output_source = output_source replace CUDA HIP output_source = output_source replace THC THH output_source = RE_CU_SUFFIX sub hip output_source Perform Kernel Launch Replacements hip_clang_launch output_source = processKernelLaunches output_source stats Replace std non-std versions filepath endswith cu cuh PowKernel filepath output_source = replace_math_functions output_source Include header device code contained output_source = hip_header_magic output_source Replace extern __shared__ NOTE No longer needed after transition hcc hipclang output_source = replace_extern_shared output_source Don t write out identical hipified files extensions dirpath has changed is_pytorch_extension orig_output_source == output_source os path dirname fin_path == os path dirname fout_path hipify_result hipified_path = fin_path hipify_result status = skipped no changes hipify_result current_state = CurrentState DONE hipify_result Add hipify breadcrumb C-style files avoid re-hipification fin_path = fout_path match_extensions fin_path cu cuh c cc cpp h hpp output_source = HIPIFY_C_BREADCRUMB + output_source do_write = True os path exists fout_path open fout_path encoding= utf- fout_old do_write = fout_old read = output_source do_write try clean_ctx open fout_path w encoding= utf- fout fout write output_source hipify_result hipified_path = fout_path hipify_result status = ok hipify_result current_state = CurrentState DONE hipify_result except OSError e print f bcolors WARNING Failed save fout_path e strerror leaving fin_path unchanged bcolors ENDC file=sys stderr hipify_result hipified_path = fin_path hipify_result status = skipped no permissions hipify_result current_state = CurrentState DONE hipify_result hipify_result hipified_path = fout_path hipify_result status = skipped already hipified hipify_result current_state = CurrentState DONE hipify_result file_specific_replacement filepath search_string replace_string strict=False openf filepath r+ f contents = f read strict contents = re sub fr \b re escape search_string \b lambda x replace_string contents contents = contents replace search_string replace_string f seek f write contents f truncate file_add_header filepath header openf filepath r+ f contents = f read header = header - = header = f header contents = f #include header \n + contents f seek f write contents f truncate fix_static_global_kernels in_txt Static global kernels HIP results compilation error in_txt = in_txt replace __global__ static __global__ in_txt RE_INCLUDE = re compile r #include \n extract_arguments start string Return list arguments upcoming function parameter closure Example string input blocks threads THCState_getCurrentStream state arguments output start end start end start end start end arguments = closures = current_position = start argument_start_pos = current_position + Search final parenthesis while current_position len string string current_position == closures += string current_position == closures -= string current_position == closures += string current_position == string current_position - = - closures closures -= Finished all arguments closures == closures == Add final argument arguments append start argument_start_pos end current_position break Finished current argument closures == closures == string current_position == arguments append start argument_start_pos end current_position argument_start_pos = current_position + current_position += arguments str bool v ArgumentParser doesn t support type=bool Thus helper method will convert possible string types True False v lower yes true t y True v lower no false f n False raise argparse ArgumentTypeError Boolean value expected hipify project_directory str show_detailed bool = False extensions Iterable = cu cuh c cc cpp h hpp header_extensions Iterable = cuh h hpp output_directory str = header_include_dirs Iterable = includes Iterable = extra_files Iterable = out_of_place_only bool = False ignores Iterable = show_progress bool = True hip_clang_launch bool = False is_pytorch_extension bool = False hipify_extra_files_only bool = False clean_ctx Optional GeneratedFileCleaner = None - HipifyFinalResult project_directory == project_directory = os getcwd Verify project directory exists os path exists project_directory print The project folder specified does exist sys exit If no output directory provide default one output_directory project_directory rstrip output_directory = project_directory + _amd project_directory = output_directory includes = include replace project_directory output_directory include includes ignores = ignore replace project_directory output_directory ignore ignores Copy project directory output directory done already os path exists output_directory shutil copytree project_directory output_directory includes = list map _to_unix_path includes ignores = list map _to_unix_path ignores all_files = list matched_files_iter output_directory includes=includes ignores=ignores extensions=extensions out_of_place_only=out_of_place_only is_pytorch_extension=is_pytorch_extension all_files_set = set all_files pyrefly ignore bad-assignment f extra_files os path isabs f f = os path join output_directory f f all_files_set all_files append f List all files header_include_paths ensure they hipified pathlib Path header_include_dir header_include_dirs os path isabs header_include_dir header_include_dir_path = Path header_include_dir header_include_dir_path = Path os path join output_directory header_include_dir all_files extend str path path header_include_dir_path rglob path is_file _fnmatch str path includes _fnmatch str path ignores match_extensions path name header_extensions clean_ctx None clean_ctx = GeneratedFileCleaner keep_intermediates=True Preprocessing statistics stats dict str list = unsupported_calls kernel_launches filepath all_files hipify_extra_files_only extra_files preprocess_file_and_save_result output_directory filepath all_files header_include_dirs stats hip_clang_launch is_pytorch_extension clean_ctx show_progress print bcolors OKGREEN + Successfully preprocessed all matching files + bcolors ENDC file=sys stderr Show detailed summary show_detailed compute_stats stats HIPIFY_FINAL_RESULT