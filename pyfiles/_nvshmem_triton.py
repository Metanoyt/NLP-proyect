logging os subprocess sysconfig typing Any Optional torch distributed dist torch utils _triton has_triton logger = logging getLogger __name__ NvshmemLibFinder A find path NVSHMEM device library Environment variable ` NVSHMEM_LIB_DIR ` Optional str The directory where NVSHMEM device library located If provided will use default path where NVSHMEM wheel installed search library common system paths Class variable store found library path reuse found_device_lib_path Optional str = None classmethod find_device_library cls - str Find path NVSHMEM device library Returns str The path libnvshmem_device bc included cls found_device_lib_path None Return cached path exists cls found_device_lib_path First check user has specified custom library path user_lib_dir = os environ get NVSHMEM_LIB_DIR None user_lib_dir None lib_path = os path join user_lib_dir libnvshmem_device bc os path exists lib_path raise RuntimeError f NVSHMEM device library found specified path user_lib_dir cls found_device_lib_path = lib_path lib_path Otherwise search library default installation paths paths = os path join sysconfig get_path purelib nvidia nvshmem lib Add common system installation paths common_paths = usr local lib usr lib opt nvidia nvshmem lib paths extend common_paths try torch torch_lib = os path join os path dirname torch __file__ lib so_path = os path join torch_lib libtorch_nvshmem so os path exists so_path try result = subprocess run readelf -d so_path capture_output=True text=True check=True line result stdout splitlines RPATH line RUNPATH line line rpath = line split split p rpath split p = p strip replace $ ORIGIN torch_lib p p paths paths append p except subprocess CalledProcessError pass except ImportError pass path paths device_lib = os path join path libnvshmem_device bc os path exists device_lib cls found_device_lib_path = device_lib device_lib raise RuntimeError f NVSHMEM device library found Searched paths enable_triton lib_dir Optional str = None - dict str str raise NotImplementedError ` enable_triton ` deprecated If you need NVSHMEM device function support Triton please use ` requires_nvshmem ` decorate your Triton kernel NvshmemKernelRegistry A register kernel functions require NVSHMEM initialization Class variable store functions initialized _to_init dict str Any = classmethod register cls name str - None Register kernel function given name Args name str The name kernel function cls _to_init setdefault name classmethod deregister cls name str - None Deregister kernel function given name Args name str The name kernel function cls _to_init pop name None classmethod has cls name str - bool Check kernel function given name registered Args name str The name kernel function Returns bool True kernel function registered False otherwise name cls _to_init _nvshmem_init_hook args kwargs - None type ignore no-untyped-def A hook function initialize CUModule created ` triton jit ` NVSHMEM device context torch _C _distributed_c d _nvshmemx_cumodule_init jit_function = kwargs fn jit_function fn_name = jit_function fn __name__ Only initialize NVSHMEM module kernels registered via requires_nvshmem NvshmemKernelRegistry has fn_name key = kwargs key device = kwargs compile device jit_function = kwargs fn jit_function kernel_cache = jit_function device_caches device kernel = kernel_cache get key None kernel None kernel run Initialize NVSHMEM CU module _nvshmemx_cumodule_init kernel module logger warning f It seems Triton hasn t created kernel function fn_name noqa G Please report issue Triton has_triton triton runtime jit JITFunction KernelInterface Create new Callable follows KernelInterface protocol so Callable works subscript operator e g ` foo ` GridCallableWithExtern KernelInterface ` KernelInterface ` invokes ` run ` ` __getitem__ ` i e We implement ` run ` method directing call ` JITFunction run ` added extern_libs kwarg so users don t have pass __init__ jit_func JITFunction extern_libs dict str str - None jit_func = jit_func extern_libs = extern_libs run args kwargs type ignore no-untyped-def Call JITFunction run added extern_libs kwarg jit_func run args kwargs extern_libs=self extern_libs requires_nvshmem type ignore no-untyped-def jit_func JITFunction created triton jit A decorator register Triton kernel function requires NVSHMEM initialization Example usage ` ` ` requires_nvshmem triton jit foo ` ` ` If you would like specify path NVSHMEM device library other than standard search locations you can use following environment variable ` ` ` export NVSHMEM_LIB_DIR= path nvshmem lib ` ` ` triton triton runtime jit JITFunction isinstance jit_func JITFunction raise TypeError f Expected JITFunction got type jit_func Find NVSHMEM device library lib_path = NvshmemLibFinder find_device_library extern_libs = libnvshmem_device lib_path Register JITFunction kernel registry initialized NvshmemKernelRegistry register jit_func fn __name__ Register NVSHMEM init function post-compile hook Note This global setting due lack Triton API exposure To avoid initializing Triton kernels do require NVSHMEM filtering performed hook function itself checking against NvshmemKernelRegistry triton knobs runtime jit_post_compile_hook = _nvshmem_init_hook GridCallableWithExtern jit_func extern_libs has_triton triton triton language tl triton language core triton jit type ignore misc put dest source nelems pe type ignore no-untyped-def Put tensor data local PE remote PE This high-level function provides tensor-aware interface NVSHMEM put operations It automatically handles type checking size calculations making API more ergonomic type-safe Args dest Destination tensor remote PE Type must match source source Source tensor local PE containing data copied nelems Number elements transfer pe PE number remote PE ≤ pe nvshmem_n_pes Notes - Performs compile-time type checking between dest source tensors - Automatically calculates byte size tensor type element count - This blocking operation returns after data has been copied out source array local PE - The operation does guarantee delivery destination PE Use nvshmem_fence ordering nvshmem_quiet completion Example ` ` ` Transfer elements PE nvshmem put dest_tensor src_tensor ` ` ` tl static_assert dest type == source type nbytes = nelems dest type element_ty itemsize putmem_block_extern_wrapper dest tl int source tl int nbytes tl int pe core extern putmem_block_extern_wrapper dest source size_bytes pe _semantic=None type ignore no-untyped-def Low-level extern wrapper NVSHMEM put core extern_elementwise dest source size_bytes pe core dtype int dest ptr core dtype int source ptr core dtype int size bytes core dtype int pe number nvshmemx_putmem_block core dtype int is_pure=False _semantic=_semantic triton jit type ignore misc get dest source nelems pe type ignore no-untyped-def Get tensor data remote PE local PE This high-level function provides tensor-aware interface NVSHMEM get operations It automatically handles type checking size calculations making API more ergonomic type-safe Args dest Destination tensor local PE Type must match source source Source tensor remote PE containing data copied nelems Number elements transfer pe PE number remote PE ≤ pe nvshmem_n_pes Notes - Performs compile-time type checking between dest source tensors - Automatically calculates byte size tensor type element count - This blocking operation returns after data has been delivered destination array local PE - The destination data guaranteed available use after call returns Example ` ` ` Get elements PE nvshmem get dest_tensor src_tensor ` ` ` tl static_assert dest type == source type nbytes = nelems dest type element_ty itemsize getmem_block_extern_wrapper dest tl int source tl int nbytes tl int pe core extern getmem_block_extern_wrapper dest source size_bytes pe _semantic=None type ignore no-untyped-def Low-level extern wrapper NVSHMEM get core extern_elementwise dest source size_bytes pe core dtype int dest ptr core dtype int source ptr core dtype int size bytes core dtype int pe number nvshmemx_getmem_block core dtype int is_pure=False _semantic=_semantic triton jit type ignore misc get_nbi dest source nelems pe type ignore no-untyped-def Get tensor data remote PE local PE non-blocking Different ` get ` function function returns after initiating operation The operation considered complete after subsequent call ` quiet ` Args dest Destination tensor local PE Type must match source source Source tensor remote PE containing data copied nelems Number elements transfer pe PE number remote PE ≤ pe nvshmem_n_pes Notes - Performs compile-time type checking between dest source tensors - Automatically calculates byte size tensor type element count Example ` ` ` Get elements PE nvshmem get_nbi dest src Some independent computation which overlaps get operation Wait completion get operation nvshmem quiet ` ` ` tl static_assert dest type == source type nbytes = nelems dest type element_ty itemsize getmem_block_extern_wrapper dest tl int source tl int nbytes tl int pe core extern getmem_nbi_block_extern_wrapper dest source size_bytes pe _semantic=None type ignore no-untyped-def Low-level extern wrapper NVSHMEM get core extern_elementwise dest source size_bytes pe core dtype int dest ptr core dtype int source ptr core dtype int size bytes core dtype int pe number nvshmemx_getmem_nbi_block core dtype int is_pure=False _semantic=_semantic triton jit type ignore misc putmem_signal_block type ignore no-untyped-def dst src size_bytes signal sig_val sig_op pe type ignore no-untyped-def Put data remote PE atomic signal operation using block-scoped operation This function copies data local PE remote PE then atomically updates signal variable remote PE indicate completion This enables efficient point-to-point synchronization between PEs Args dst tensor A tensor calling PE symmetric destination tensor remote PE src tensor Local tensor containing source data size_bytes int Number bytes transfer Must positive signal tensor Symmetric signal pad remote PE Must -byte aligned symmetric memory signal int Value used signal operation sig_op int Signal operation type Common values - NVSHMEM_SIGNAL_SET Atomic set operation - NVSHMEM_SIGNAL_ADD Atomic add operation pe int PE number remote PE ≤ pe nvshmem_n_pes Returns int Status code success Notes - This blocking operation returns after data has been copied out source array signal has been updated remote PE - The signal update performed atomically respect other signal operations synchronization routines - The signal variable must type uint _t symmetric memory - Use nvshmem_signal_wait_until synchronization Example ` ` ` Transfer data set completion flag NVSHMEM_SIGNAL_SET = nvshmem putmem_signal_block dst_ptr src_ptr sig_ptr NVSHMEM_SIGNAL_SET target_pe ` ` ` Ensure sig_val bits sig_val = &#124; sig_val putmem_signal_block_extern_wrapper dst tl int src tl int size_bytes tl int signal tl int sig_val tl uint sig_op pe core extern putmem_signal_block_extern_wrapper type ignore no-untyped-def dst src size_bytes signal sig_val sig_op pe _semantic=None type ignore no-untyped-def core extern_elementwise dst src size_bytes signal sig_val sig_op pe core dtype int core dtype int core dtype int core dtype int core dtype uint core dtype int core dtype int nvshmemx_putmem_signal_block core dtype int is_pure=False _semantic=_semantic Wait Signal Operations triton jit type ignore misc wait_until ivar cmp_op cmp_val type ignore no-untyped-def Wait until tensor variable meets specified condition This high-level function provides tensor-aware interface NVSHMEM wait_until operations It automatically handles tensor address extraction making API more ergonomic type-safe Args ivar_tensor Tensor monitor typically int uint symmetric memory cmp Comparison operator Common values - NVSHMEM_CMP_EQ Wait until ivar == cmp_val - NVSHMEM_CMP_NE Wait until ivar = cmp_val - NVSHMEM_CMP_GT Wait until ivar cmp_val - NVSHMEM_CMP_GE Wait until ivar = cmp_val - NVSHMEM_CMP_LT Wait until ivar cmp_val - NVSHMEM_CMP_LE Wait until ivar = cmp_val cmp_val Value compare against Notes - This blocking operation will wait indefinitely until condition satisfied - The tensor must symmetric memory accessible other PEs Example ` ` ` Wait until flag tensor becomes set another PE NVSHMEM_CMP_EQ = nvshmem wait_until_tensor flag_tensor NVSHMEM_CMP_EQ ` ` ` tl static_assert ivar type element_ty itemsize == wait_until expects -bit type synchronization variable wait_until_extern_wrapper ivar tl int cmp_op cmp_val core extern wait_until_extern_wrapper ivar cmp cmp_val _semantic=None type ignore no-untyped-def core extern_elementwise ivar cmp cmp_val core dtype int core dtype int core dtype int nvshmem_int_wait_until core dtype int is_pure=False _semantic=_semantic triton jit type ignore misc signal_wait_until signal cmp cmp_val type ignore no-untyped-def Wait until signal variable meets specified condition This function blocks calling thread until value specified signal variable satisfies given comparison condition Signal variables special uint _t symmetric objects used efficient synchronization signal operations Args signal tensor Symmetric signal tensor remote PE Must -byte aligned symmetric memory cmp int Comparison operator Common values - NVSHMEM_CMP_EQ Wait until signal == cmp_val - NVSHMEM_CMP_NE Wait until signal = cmp_val - NVSHMEM_CMP_GT Wait until signal cmp_val - NVSHMEM_CMP_GE Wait until signal = cmp_val - NVSHMEM_CMP_LT Wait until signal cmp_val - NVSHMEM_CMP_LE Wait until signal = cmp_val cmp_val int Value compare against Returns int Status code success Notes - This blocking operation designed specifically signal variables - Signal variables updated atomically putmem_signal operations - More efficient than wait_until signal-based synchronization patterns - Ensures signal update fully complete before returning - Commonly used putmem_signal_block producer-consumer patterns Example ` ` ` Wait signal set completion value NVSHMEM_CMP_EQ = nvshmem signal_wait_until signal_ptr NVSHMEM_CMP_EQ ` ` ` cmp_val = &#124; cmp_val signal_wait_until_extern_wrapper signal tl int cmp cmp_val tl uint core extern signal_wait_until_extern_wrapper signal cmp cmp_val _semantic=None type ignore no-untyped-def core extern_elementwise signal cmp cmp_val core dtype int core dtype int core dtype uint nvshmem_signal_wait_until core dtype int is_pure=False _semantic=_semantic core extern signal_op sig_addr signal sig_op pe _semantic=None type ignore no-untyped-def Perform atomic signal operation remote PE This function atomically updates signal variable specified remote PE using given operation value This enables efficient point-to-point synchronization notification between PEs Args sig_addr int Symmetric address signal variable uint _t remote PE Must -byte aligned symmetric memory signal int Value used signal operation sig_op int Signal operation type Common values - NVSHMEM_SIGNAL_SET Atomically set sig_addr = signal - NVSHMEM_SIGNAL_ADD Atomically set sig_addr += signal pe int PE number remote PE ≤ pe nvshmem_n_pes _semantic Optional semantic information Triton compilation Returns int Status code success Notes - This one-sided operation - remote PE does need participate - The signal operation performed atomically remote PE - Can used signal_wait_until remote PE synchronization - Provides low-overhead notification mechanism between PEs - The signal variable must type uint _t symmetric memory Example ` ` ` python Atomically set remote signal notify completion NVSHMEM_SIGNAL_SET = nvshmem signal_op remote_signal_ptr NVSHMEM_SIGNAL_SET target_pe ` ` ` core extern_elementwise sig_addr signal sig_op pe core dtype int core dtype int core dtype int core dtype int nvshmemx_signal_op core dtype int is_pure=False _semantic=_semantic Memory Ordering Operations core extern fence _semantic=None type ignore no-untyped-def Ensure ordering put operations each remote PE This function provides memory fence ensures point-to-point ordering remote memory operations Put operations issued before fence guaranteed ordered before put operations issued after fence when targeting same remote PE Args _semantic Optional semantic information Triton compilation Returns int Status code success Notes - This provides weaker ordering guarantees than quiet - Operations each PE ordered operations different PEs may still reordered relative each other - Does guarantee completion operations only ordering - Non-blocking operations ordered fence - use quiet instead - Essential ensuring correct ordering communication patterns Memory Ordering Guarantees - Put operations before fence → ordered before → Put operations after fence - Ordering maintained per-destination-PE basis - Remote PEs can observe enforced ordering Example ` ` ` Ensure first put completes before second put same PE nvshmem put dst src nelems target_pe nvshmem fence Enforce ordering nvshmem put dst src nelems target_pe ` ` ` core extern_elementwise nvshmem_fence core dtype int is_pure=False _semantic=_semantic core extern quiet _semantic=None type ignore no-untyped-def Wait completion all outstanding put operations This function blocks until all outstanding remote memory operations issued calling PE have completed It provides stronger guarantees than fence ensuring both ordering completion all operations Args _semantic Optional semantic information Triton compilation Returns int Status code success Notes - This blocking operation waits completion - Ensures all previous put operations have been delivered their destinations - Provides global ordering - operations ALL PEs ordered - Required complete non-blocking operations - More expensive than fence provides stronger guarantees Memory Ordering Guarantees - All put operations before quiet completed before any operations after quiet - Operations visible all PEs having occurred before subsequent operations - Both blocking non-blocking operations completed Example ` ` ` Ensure all data transfers complete before setting completion flag nvshmem putmem_block data_ptr src_ptr data_size target_pe nvshmem quiet Wait data transfer completion nvshmem putmem_block flag_ptr flag_src_ptr target_pe Signal completion ` ` ` core extern_elementwise nvshmem_quiet core dtype int is_pure=False _semantic=_semantic PE Information Operations core extern my_pe _semantic=None type ignore no-untyped-def Get PE number calling PE This function returns unique identifier PE number current processing element within NVSHMEM job PE numbers range nvshmem_n_pes - Args _semantic Optional semantic information Triton compilation Returns int PE number calling PE ≤ pe nvshmem_n_pes Notes - This pure function returns same value throughout execution - PE numbering starts contiguous - Each PE has unique identifier within NVSHMEM job - Can called both host device code - Essential implementing PE-specific logic communication patterns Example ` ` ` Get current PE number conditional logic pe = nvshmem my_pe pe == Root PE logic pass Non-root PE logic pass ` ` ` core extern_elementwise nvshmem_my_pe core dtype int is_pure=True _semantic=_semantic core extern n_pes _semantic=None type ignore no-untyped-def Get total number PEs NVSHMEM job This function returns total count processing elements PEs participating current NVSHMEM job This value remains constant throughout execution program Args _semantic Optional semantic information Triton compilation Returns int Total number PEs job always ≥ Notes - This pure function returns same value throughout execution - The value determined NVSHMEM initialization never changes - Valid PE numbers range n_pes - - Can called both host device code - Essential implementing collective operations communication patterns Example ` ` ` Broadcast root all other PEs total_pes = nvshmem n_pes my_rank = nvshmem my_pe my_rank == Send all other PEs peer range total_pes nvshmem putmem_block dst_ptr src_ptr size peer ` ` ` core extern_elementwise nvshmem_n_pes core dtype int is_pure=True _semantic=_semantic Synchronization Operations core extern barrier_all _semantic=None type ignore no-untyped-def Synchronize all PEs completion guarantee This function creates barrier across all PEs NVSHMEM job It ensures all local remote memory updates issued before barrier any PE completed before any PE exits barrier This provides both synchronization memory consistency Args _semantic Optional semantic information Triton compilation Returns int Status code success Notes - This collective operation - all PEs must participate - Stronger guarantee than sync_all - ensures completion remote operations - Blocks until all PEs reach barrier AND all memory operations complete - Must called kernels launched cooperative launch - Provides full memory consistency across all PEs - More expensive than sync_all due completion guarantees Memory Consistency Guarantees - All memory updates before barrier_all visible all PEs - All remote memory operations completed before any PE continues - Provides global synchronization point memory ordering Example ` ` ` Ensure all PEs complete their work before proceeding All PEs execute - s collective operation nvshmem barrier_all At point all previous operations complete all PEs ` ` ` core extern_elementwise nvshmem_barrier_all core dtype int is_pure=False _semantic=_semantic core extern sync_all _semantic=None type ignore no-untyped-def Synchronize all PEs local completion guarantee This function creates lightweight synchronization barrier across all PEs It ensures all local store operations issued before sync visible other PEs does guarantee completion remote memory operations initiated calling PE Args _semantic Optional semantic information Triton compilation Returns int Status code success Notes - This collective operation - all PEs must participate - Lighter weight than barrier_all - only ensures local store visibility - Does guarantee completion remote memory updates initiated locally - Must called kernels launched cooperative launch - Suitable when only synchronization completion needed - More efficient than barrier_all synchronization-only patterns Memory Consistency Guarantees - Local store operations visible other PEs - Does NOT ensure completion outgoing remote operations - Provides synchronization point without full completion overhead Example ` ` ` Lightweight synchronization between PEs All PEs execute - s collective operation nvshmem sync_all Local stores visible remote ops may still flight ` ` ` core extern_elementwise nvshmem_sync_all core dtype int is_pure=False _semantic=_semantic Collective Operations mem-based APIs - sizes bytes triton jit type ignore misc alltoall team dest source nelems_per_pe type ignore no-untyped-def All-to-all tensor exchange between PEs team This high-level function provides tensor-aware interface NVSHMEM alltoall operations Each PE sends nelems_per_pe elements every other PE receives same amount every other PE Args team Team handle collective operation Use NVSHMEM_TEAM_WORLD dest Destination tensor Must large enough nelems_per_pe n_pes elements source Source tensor containing data all PEs Must contain nelems_per_pe n_pes elements nelems_per_pe Number elements exchange each PE Notes - Performs compile-time type checking between dest source tensors - Automatically calculates byte size tensor type element count - This collective operation - all PEs team must participate - Data layout source= data_for_pe data_for_pe dest= data_from_pe data_from_pe Example ` ` ` Each PE exchanges elements every other PE nvshmem alltoall dest_tensor src_tensor ` ` ` tl static_assert dest type == source type size_bytes_per_pe = nelems_per_pe dest type element_ty itemsize alltoallmem_block_extern_wrapper team dest tl int source tl int size_bytes_per_pe tl int core extern type ignore misc alltoallmem_block_extern_wrapper team Any dest Any source Any size_bytes Any _semantic Any = None - None Low-level extern wrapper NVSHMEM alltoall core extern_elementwise team dest source size_bytes core dtype int team handle core dtype int dest ptr core dtype int source ptr core dtype int size bytes nvshmemx_alltoallmem_block core dtype int is_pure=False _semantic=_semantic triton jit type ignore misc broadcast team dest source nelems pe_root type ignore no-untyped-def Broadcast tensor data root PE all other PEs team This high-level function provides tensor-aware interface NVSHMEM broadcast operations It automatically handles type checking size calculations making API more ergonomic type-safe Args team Team handle collective operation Use NVSHMEM_TEAM_WORLD dest Destination tensor type information All PEs receive data here source Source tensor root PE Type must match dest nelems Number elements broadcast pe_root PE number root PE provides source data Notes - Performs compile-time type checking between dest source tensors - Automatically calculates byte size tensor type element count - This collective operation - all PEs team must participate - Must called kernels launched cooperative launch Example ` ` ` Broadcast elements PE all PEs nvshmem broadcast dest_tensor src_tensor ` ` ` tl static_assert dest type == source type nbytes = nelems dest type element_ty itemsize broadcastmem_block_extern_wrapper team dest tl int source tl int nbytes tl int pe_root core extern type ignore misc broadcastmem_block_extern_wrapper team Any dest Any source Any size_bytes Any pe_root Any _semantic Any = None - None Low-level extern wrapper NVSHMEM broadcast core extern_elementwise team dest source size_bytes pe_root core dtype int team handle core dtype int dest ptr core dtype int source ptr core dtype int size bytes core dtype int pe_root nvshmemx_broadcastmem_block core dtype int is_pure=False _semantic=_semantic Reduction Operation triton jit type ignore misc reduce team dest source nreduce operation tl constexpr type ignore no-untyped-def Performs collective reduction tensors across team PEs This high-level function provides tensor-aware interface NVSHMEM reduction operations It automatically infers data type input tensors calls appropriate underlying NVSHMEM function Args team The team handle collective NVSHMEM_TEAM_WORLD dest Destination tensor reduction results source Source tensor containing data reduced Must same type dest nreduce The number elements source tensor reduce operation The reduction operation perform sum max min prod Notes - Performs compile-time type checking between dest source tensors - This collective operation must called all PEs team - Requires cooperative grid launch Example ` ` ` Perform sum reduction two tensors nvshmem reduce dest_tensor src_tensor sum ` ` ` tl static_assert dest type == source type dtype = dest type element_ty reduce_extern_wrapper team dest tl int source tl int nreduce tl int operation dtype core extern type ignore misc reduce_extern_wrapper team Any dest Any source Any nreduce Any operation str dtype Any _semantic Any = None - None Low-level extern wrapper NVSHMEM reduction operations This function provides generic interface NVSHMEM reduction operations automatically selecting appropriate NVSHMEM function based data type operation specified Args team int The team handle NVSHMEM_TEAM_WORLD dest pointer Destination pointer where reduction results stored source pointer Source pointer containing data reduced nreduce int Number elements reduce operation str Reduction operation sum max min prod dtype Data type specification - accepts torch dtype tl dtype str constexpr _semantic Optional semantic information Triton compilation Raises ValueError If operation supported TypeError If data type supported Example nvshmem reduce dest_ptr src_ptr sum torch float Mapping Triton dtype names NVSHMEM typenames DTYPE_TO_NVSHMEM_MAP = int int int int int int int int uint uint uint uint uint uint uint uint fp half bf bfloat fp float fp double Triton dtype names standardized fp bf fp etc dtype_name = str dtype replace tl dtype_name DTYPE_TO_NVSHMEM_MAP raise TypeError f Unsupported reduction dtype dtype_name Supported dtypes list DTYPE_TO_NVSHMEM_MAP keys Extract operation name constexpr needed op_name = operation value hasattr operation value operation Validate operation supported supported_ops = sum max min prod op_name supported_ops raise ValueError f Unsupported reduction operation op_name Supported ops supported_ops Map NVSHMEM typename validate dtype supported nvshmem_typename = DTYPE_TO_NVSHMEM_MAP get dtype_name nvshmem_typename None raise TypeError f Unsupported reduction dtype dtype_name Supported dtypes list DTYPE_TO_NVSHMEM_MAP keys Generate NVSHMEM function name nvshmem_func = f nvshmem_ nvshmem_typename _ op_name _reduce Define function signature - all parameters int Triton they just ptrs signature = core dtype int team handle core dtype int destination pointer core dtype int source pointer core dtype int number elements core extern_elementwise team dest source nreduce signature nvshmem_func core dtype int is_pure=False _semantic=_semantic Utility inspecting Triton kernels triton_kernels dict = _log_triton_kernel kernel - None type ignore no-untyped-def atexit tempfile dist is_initialized dist get_rank = on_exit - None logger info PTX files kernel triton_kernels tempfile NamedTemporaryFile dir= tmp delete=False f f write kernel asm ptx encode utf- logger info f +- kernel name f name noqa G len triton_kernels == atexit register on_exit kernel triton_kernels triton_kernels kernel = None