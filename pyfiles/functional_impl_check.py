The purpose test check we have implementation parity between Python ` torch nn functional ` function its corresponding C++ ` torch nn functional ` function Concretely test does following Get test params dict common_nn py run forward pass Python functional created using test params Serialize Python functional s forward input arguments deserialize them C++ use them input C++ functional s forward pass Run forward pass C++ functional serialize C++ functional s forward output Compare Python C++ functional s forward output If they same then we have implementation parity between Python C++ module os pprint re tempfile string Template torch cpp_api_parity sample_functional SAMPLE_FUNCTIONAL_CPP_SOURCE cpp_api_parity utils add_test compile_cpp_code_inline compute_arg_dict compute_cpp_args_construction_stmts_and_forward_arg_symbols compute_temp_file_path decorate_test_fn generate_error_msg is_torch_nn_functional_test move_python_tensors_to_device serialize_arg_dict_as_script_module set_python_tensors_requires_grad TORCH_NN_COMMON_TEST_HARNESS TorchNNFunctionalTestParams try_remove_folder Expected substitutions $ functional_variant_name e g ` BCELoss_no_reduce ` $ cpp_args_construction_stmts $ cpp_function_call TORCH_NN_FUNCTIONAL_TEST_FORWARD = Template void $ functional_variant_name _test_forward const std string arg_dict_file_path const std string forward_output_file_path pybind gil_scoped_release no_gil namespace F = torch nn functional Declare arguments auto arg_dict = load_dict_from_file arg_dict_file_path $ cpp_args_construction_stmts Some functionals such ` F rrelu ` create random tensors their call path To make sure random tensors created same Python C++ we need set RNG seed manually torch manual_seed Run function arguments auto cpp_output = $ cpp_function_call Save output into file compared Python later write_ivalue_to_file torch IValue cpp_output forward_output_file_path run_forward unit_test_class test_params device = test_params device inputs = set_python_tensors_requires_grad move_python_tensors_to_device arg_value _ arg_value test_params arg_dict input device inputs += move_python_tensors_to_device arg_value _ arg_value test_params arg_dict target device inputs += move_python_tensors_to_device arg_value _ arg_value test_params arg_dict extra_args device Some functionals such ` F rrelu ` create random tensors their call path To make sure random tensors created same Python C++ we need set RNG seed manually torch manual_seed python_output = test_params test_instance constructor inputs python_output test_forward unit_test_class test_params functional_variant_name = test_params functional_variant_name cpp_tmp_folder = test_params cpp_tmp_folder Remove temporary folder exists already try_remove_folder cpp_tmp_folder os mkdir cpp_tmp_folder Run forward Python functional python_output = run_forward unit_test_class test_params Save Python arguments used C++ function arg_dict_file_path = compute_temp_file_path cpp_tmp_folder functional_variant_name arg_dict serialize_arg_dict_as_script_module test_params arg_dict save arg_dict_file_path cpp_test_name = f test_params functional_variant_name _test_forward cpp_test_fn = getattr unit_test_class functional_impl_check_cpp_module cpp_test_name run_cpp_test_fn_and_check_output forward_output_file_path = compute_temp_file_path cpp_tmp_folder functional_variant_name forward_output cpp_test_fn arg_dict_file_path forward_output_file_path cpp_output = torch load forward_output_file_path Check forward outputs equal unit_test_class assertEqual python_output cpp_output msg=generate_error_msg forward output cpp_output python_output run_cpp_test_fn_and_check_output Remove temporary folder stores C++ outputs try_remove_folder cpp_tmp_folder compute_functional_name test_params_dict camel_case_to_snake_case camel_case_str re sub r ^ = A-Z _ camel_case_str lower cpp_options_args test_params_dict Expected format ` cpp_options_args ` ` F FunctionalFuncOptions ` Example output ` binary_cross_entropy ` camel_case_to_snake_case test_params_dict cpp_options_args split replace F replace FuncOptions cpp_function_call test_params_dict Expected format ` cpp_function_call ` ` F functional_name ` Example output ` binary_cross_entropy ` test_params_dict cpp_function_call split replace F raise RuntimeError ` cpp_options_args ` ` cpp_function_call ` entry must present test params dict \n f pprint pformat test_params_dict compute_cpp_function_call test_params_dict arg_dict functional_name cpp_function_call test_params_dict test_params_dict cpp_function_call cpp_options_args test_params_dict cpp_forward_args_symbols = arg_name arg_name _ arg_dict input + arg_dict target + arg_dict extra_args F format functional_name join cpp_forward_args_symbols test_params_dict cpp_options_args raise RuntimeError ` cpp_options_args ` ` cpp_function_call ` entry must present test params dict \n f pprint pformat test_params_dict process_test_params_for_functional test_params_dict device test_instance_class test_instance = test_instance_class test_params_dict functional_name = compute_functional_name test_params_dict assert test_instance get_name startswith test_ Example output ` BCELoss_no_reduce_cuda ` functional_variant_name = test_instance get_name + _ + device device = cpu arg_dict = compute_arg_dict test_params_dict test_instance TorchNNFunctionalTestParams functional_name=functional_name functional_variant_name=functional_variant_name test_instance=test_instance cpp_function_call=compute_cpp_function_call test_params_dict arg_dict functional_name arg_dict=arg_dict has_parity=test_params_dict get has_parity True device=device cpp_tmp_folder=tempfile mkdtemp write_test_to_test_class unit_test_class test_params_dict test_instance_class parity_table devices assert is_torch_nn_functional_test test_params_dict assert cpp_options_args test_params_dict cpp_function_call test_params_dict To enable C++ API parity test ` cpp_options_args ` ` cpp_function_call ` entry must present test params dict \n f pprint pformat test_params_dict \n If you interested adding C++ API parity test please see \n NOTE How check NN module functional API parity between Python C++ frontends \n If please add ` test_cpp_api_parity=False ` test params dict file issue about assert cpp_options_args test_params_dict cpp_function_call test_params_dict Only one ` cpp_options_args ` ` cpp_function_call ` entries f should present test params dict \n pprint pformat test_params_dict functional_name = compute_functional_name test_params_dict assert hasattr torch nn functional functional_name f ` torch nn functional ` doesn t have function ` functional_name ` f Discovered while processing\n pprint pformat test_params_dict functional_full_name = F + functional_name assert functional_full_name parity_table torch nn functional f Please add ` functional_full_name ` entry ` torch nn functional ` section ` test cpp_api_parity parity-tracker md ` f Discovered while processing\n pprint pformat test_params_dict device devices test_params = process_test_params_for_functional test_params_dict=test_params_dict device=device test_instance_class=test_instance_class try_remove_folder test_params cpp_tmp_folder unit_test_name = f test_torch_nn_functional_ test_params functional_variant_name unit_test_class functional_test_params_map unit_test_name = test_params test_fn test_forward unit_test_class=self test_params=unit_test_class functional_test_params_map _testMethodName test_fn = decorate_test_fn test_fn=test_fn test_cuda=test_params_dict get test_cuda True has_impl_parity=parity_table torch nn functional functional_full_name test_params_dict get has_parity True device=device add_test unit_test_class unit_test_name test_fn generate_test_cpp_sources test_params template cpp_args_construction_stmts _ = compute_cpp_args_construction_stmts_and_forward_arg_symbols test_params test_cpp_sources = template substitute functional_variant_name=test_params functional_variant_name cpp_args_construction_stmts= \n join cpp_args_construction_stmts cpp_function_call=test_params cpp_function_call test_cpp_sources Build all C++ tests together instead once per test build_cpp_tests unit_test_class print_cpp_source=False assert len unit_test_class functional_test_params_map cpp_sources = TORCH_NN_COMMON_TEST_HARNESS + SAMPLE_FUNCTIONAL_CPP_SOURCE functions = test_params unit_test_class functional_test_params_map values cpp_sources += generate_test_cpp_sources test_params=test_params template=TORCH_NN_FUNCTIONAL_TEST_FORWARD functions append f test_params functional_variant_name _test_forward print_cpp_source print cpp_sources cpp_module = compile_cpp_code_inline name= functional_impl_check cpp_sources=cpp_sources functions=functions unit_test_class functional_impl_check_cpp_module = cpp_module