mypy allow-untyped-defs __future__ annotations operator collections abc container_abcs OrderedDict itertools chain islice typing Any Optional overload TYPE_CHECKING TypeVar Union typing_extensions deprecated Self torch torch _jit_internal _copy_to_script_wrapper torch nn parameter Parameter module Module TYPE_CHECKING collections abc Iterable Iterator Mapping __all__ = Container Sequential ModuleList ModuleDict ParameterList ParameterDict T = TypeVar T bound=Module _V = TypeVar _V Copied torch nn modules module required custom __repr__ ModuleList _addindent s_ numSpaces s = s_ split \n don t do anything single-line stuff len s == s_ first = s pop s = numSpaces + line line s s = \n join s s = first + \n + s s deprecated ` nn Container ` deprecated All s functionality now implemented ` nn Module ` Subclass instead category=FutureWarning Container Module __init__ kwargs Any - None super __init__ key value kwargs items add_module key value Sequential Module r A sequential container Modules will added order they passed constructor Alternatively ` ` OrderedDict ` ` modules can passed The ` ` forward ` ` method ` ` Sequential ` ` accepts any input forwards first module contains It then chains outputs inputs sequentially each subsequent module finally returning output last module The value ` ` Sequential ` ` provides over manually calling sequence modules allows treating whole container single module such performing transformation ` ` Sequential ` ` applies each modules stores which each registered submodule ` ` Sequential ` ` What s difference between ` ` Sequential ` ` ` torch nn ModuleList ` A ` ` ModuleList ` ` exactly what sounds like -- list storing ` ` Module ` ` s On other hand layers ` ` Sequential ` ` connected cascading way Example Using Sequential create small model When ` model ` run input will first passed ` Conv d ` The output ` Conv d ` will used input first ` ReLU ` output first ` ReLU ` will become input ` Conv d ` Finally output ` Conv d ` will used input second ` ReLU ` model = nn Sequential nn Conv d nn ReLU nn Conv d nn ReLU Using Sequential OrderedDict This functionally same above code model = nn Sequential OrderedDict conv nn Conv d relu nn ReLU conv nn Conv d relu nn ReLU _modules dict str Module type ignore assignment overload __init__ args Module - None overload pyrefly ignore inconsistent-overload __init__ arg OrderedDict str Module - None __init__ args super __init__ len args == isinstance args OrderedDict key module args items add_module key module idx module enumerate args add_module str idx module _get_item_by_idx iterator Iterable _V idx int - _V Get idx-th item iterator size = len idx = operator index idx -size = idx size raise IndexError f index idx out range idx = size next islice iterator idx None _copy_to_script_wrapper __getitem__ idx Union slice int - Union Sequential Module isinstance idx slice __class__ OrderedDict list _modules items idx _get_item_by_idx _modules values idx __setitem__ idx int module Module - None key str = _get_item_by_idx _modules keys idx setattr key module __delitem__ idx Union slice int - None isinstance idx slice key list _modules keys idx delattr key key = _get_item_by_idx _modules keys idx delattr key To preserve numbering str_indices = str i i range len _modules _modules = OrderedDict zip str_indices _modules values strict=True _copy_to_script_wrapper __len__ - int len _modules __add__ other - Sequential isinstance other Sequential ret = Sequential layer ret append layer layer other ret append layer ret raise ValueError add operator supports only objects f Sequential str type other given pop key Union int slice - Module Pop ` ` key ` ` v = key del key v __iadd__ other - Self isinstance other Sequential offset = len i module enumerate other add_module str i + offset module raise ValueError add operator supports only objects f Sequential str type other given __mul__ other int - Sequential isinstance other int raise TypeError f unsupported operand type s type type other other = raise ValueError f Non-positive multiplication factor other type combined = Sequential offset = _ range other module combined add_module str offset module offset += combined __rmul__ other int - Sequential __mul__ other __imul__ other int - Self isinstance other int raise TypeError f unsupported operand type s type type other other = raise ValueError f Non-positive multiplication factor other type len_original = len offset = len _ range other - i range len_original add_module str i + offset _modules str i offset += len_original _copy_to_script_wrapper __dir__ - list str keys = super __dir__ keys = key key keys key isdigit keys _copy_to_script_wrapper __iter__ - Iterator Module iter _modules values NB We can t really type check function type input may change dynamically tested TestScript test_sequential_intermediary_types Cannot annotate Any TorchScript expects more precise type forward input Runs forward pass module input = module input input append module Module - Self r Append given module end Args module nn Module module append Example torch nn nn n = nn Sequential nn Linear nn Linear n append nn Linear Sequential Linear in_features= out_features= bias=True Linear in_features= out_features= bias=True Linear in_features= out_features= bias=True add_module str len module insert index int module Module - Self Inserts module into Sequential container specified index Args index int The index insert module module Module The module inserted Example torch nn nn n = nn Sequential nn Linear nn Linear n insert nn Linear Sequential Linear in_features= out_features= bias=True Linear in_features= out_features= bias=True Linear in_features= out_features= bias=True isinstance module Module raise AssertionError f module should type Module n = len _modules -n = index = n raise IndexError f Index out range index index index += n i range n index - _modules str i = _modules str i - _modules str index = module extend sequential Iterable Module - Self Extends current Sequential container layers another Sequential container Args sequential Sequential A Sequential container whose layers will added current container Example torch nn nn n = nn Sequential nn Linear nn Linear other = nn Sequential nn Linear nn Linear n extend other ` n + other ` Sequential Linear in_features= out_features= bias=True Linear in_features= out_features= bias=True Linear in_features= out_features= bias=True Linear in_features= out_features= bias=True layer sequential append layer ModuleList Module r Holds submodules list ` ~torch nn ModuleList ` can indexed like regular Python list modules contains properly registered will visible all ` ~torch nn Module ` methods Args modules iterable optional iterable modules add Example MyModule nn Module __init__ - None super __init__ linears = nn ModuleList nn Linear i range forward x ModuleList can act iterable indexed using ints i l enumerate linears x = linears i x + l x x _modules dict str Module type ignore assignment __init__ modules Optional Iterable Module = None - None super __init__ modules None += modules _get_abs_string_index idx Get absolute index list modules idx = operator index idx -len = idx len raise IndexError f index idx out range idx idx += len str idx overload __getitem__ idx slice - ModuleList overload __getitem__ idx int - Module _copy_to_script_wrapper __getitem__ idx Union int slice - Union Module ModuleList isinstance idx slice __class__ list _modules values idx _modules _get_abs_string_index idx __setitem__ idx int module Module - None idx = _get_abs_string_index idx setattr str idx module __delitem__ idx Union int slice - None isinstance idx slice k range len _modules idx delattr str k delattr _get_abs_string_index idx To preserve numbering _modules being reconstructed modules after deletion str_indices = str i i range len _modules _modules = OrderedDict zip str_indices _modules values strict=True _copy_to_script_wrapper __len__ - int len _modules _copy_to_script_wrapper __iter__ - Iterator Module iter _modules values __iadd__ modules Iterable Module - Self extend modules __add__ other Iterable Module - ModuleList combined = ModuleList i module enumerate chain other combined add_module str i module combined __repr__ - str Return custom repr ModuleList compresses repeated module representations list_of_reprs = repr item item len list_of_reprs == _get_name + start_end_indices = repeated_blocks = list_of_reprs i r enumerate list_of_reprs r == repeated_blocks - start_end_indices - += continue start_end_indices append i i repeated_blocks append r lines = main_str = _get_name + start_id end_id b zip start_end_indices repeated_blocks strict=True local_repr = f start_id b default repr start_id = end_id n = end_id - start_id + local_repr = f start_id - end_id n x b local_repr = _addindent local_repr lines append local_repr main_str += \n + \n join lines + \n main_str += main_str _copy_to_script_wrapper __dir__ - list str keys = super __dir__ keys = key key keys key isdigit keys insert index int module Module - None r Insert given module before given index list Args index int index insert module nn Module module insert i range len _modules index - _modules str i = _modules str i - _modules str index = module append module Module - Self r Append given module end list Args module nn Module module append add_module str len module pop key Union int slice - Module v = key del key v extend modules Iterable Module - Self r Append modules Python iterable end list Args modules iterable iterable modules append isinstance modules container_abcs Iterable raise TypeError ModuleList extend should called iterable got + type modules __name__ offset = len i module enumerate modules add_module str offset + i module remove forward altogether fallback Module s _forward_unimplemented ModuleDict Module r Holds submodules dictionary ` ~torch nn ModuleDict ` can indexed like regular Python dictionary modules contains properly registered will visible all ` ~torch nn Module ` methods ` ~torch nn ModuleDict ` ordered dictionary respects order insertion meth ` ~torch nn ModuleDict update ` order merged ` ` OrderedDict ` ` ` ` dict ` ` started Python another ` ~torch nn ModuleDict ` argument meth ` ~torch nn ModuleDict update ` Note meth ` ~torch nn ModuleDict update ` other unordered mapping types e g Python s plain ` ` dict ` ` before Python version does preserve order merged mapping Args modules iterable optional mapping dictionary string module iterable key-value pairs type string module Example MyModule nn Module __init__ - None super __init__ choices = nn ModuleDict conv nn Conv d pool nn MaxPool d activations = nn ModuleDict lrelu nn LeakyReLU prelu nn PReLU forward x choice act x = choices choice x x = activations act x x _modules dict str Module type ignore assignment __init__ modules Optional Mapping str Module = None - None super __init__ modules None update modules _copy_to_script_wrapper __getitem__ key str - Module _modules key __setitem__ key str module Module - None add_module key module __delitem__ key str - None del _modules key _copy_to_script_wrapper __len__ - int len _modules _copy_to_script_wrapper __iter__ - Iterator str iter _modules _copy_to_script_wrapper __contains__ key str - bool key _modules clear - None Remove all items ModuleDict _modules clear pop key str - Module r Remove key ModuleDict its module Args key str key pop ModuleDict v = key del key v _copy_to_script_wrapper keys - container_abcs KeysView str r Return iterable ModuleDict keys _modules keys _copy_to_script_wrapper items - container_abcs ItemsView str Module r Return iterable ModuleDict key value pairs _modules items _copy_to_script_wrapper values - container_abcs ValuesView Module r Return iterable ModuleDict values _modules values update modules Mapping str Module - None r Update ` ~torch nn ModuleDict ` key-value pairs mapping overwriting existing keys note If attr ` modules ` ` ` OrderedDict ` ` ` ~torch nn ModuleDict ` iterable key-value pairs order new elements preserved Args modules iterable mapping dictionary string ` ~torch nn Module ` iterable key-value pairs type string ` ~torch nn Module ` isinstance modules container_abcs Iterable raise TypeError ModuleDict update should called iterable key value pairs got + type modules __name__ isinstance modules OrderedDict ModuleDict container_abcs Mapping key module modules items key = module modules here can list two items j m enumerate modules isinstance m container_abcs Iterable raise TypeError ModuleDict update sequence element + str j + should Iterable + type m __name__ pyrefly ignore bad-argument-type len m == raise ValueError ModuleDict update sequence element pyrefly ignore bad-argument-type + str j + has length + str len m + required modules can Mapping what s typed list name module name module s too cumbersome type correctly overloads so we add ignore here m = m type ignore assignment remove forward altogether fallback Module s _forward_unimplemented ParameterList Module r Holds parameters list ` ~torch nn ParameterList ` can used like regular Python list Tensors ` ~torch nn Parameter ` properly registered will visible all ` ~torch nn Module ` methods Note constructor assigning element list meth ` ~torch nn ParameterList append ` method meth ` ~torch nn ParameterList extend ` method will convert any ` ~torch Tensor ` into ` ~torch nn Parameter ` Args parameters iterable optional iterable elements add list Example MyModule nn Module __init__ - None super __init__ params = nn ParameterList nn Parameter torch randn i range forward x ParameterList can act iterable indexed using ints i p enumerate params x = params i mm x + p mm x x __init__ values Optional Iterable Any = None - None super __init__ _size = values None += values _get_abs_string_index idx Get absolute index list modules idx = operator index idx -len = idx len raise IndexError f index idx out range idx idx += len str idx overload __getitem__ idx int - Any overload pyrefly ignore inconsistent-overload __getitem__ T idx slice - T __getitem__ idx isinstance idx slice start stop step = idx indices len out = __class__ i range start stop step out append i out idx = _get_abs_string_index idx getattr str idx __setitem__ idx int param Any - None Note all other function add entry list part ParameterList end up here So only place where we need wrap things into Parameter needed Objects added via setattr list part thus won t call into function idx = _get_abs_string_index idx isinstance param torch Tensor isinstance param Parameter param = Parameter param setattr str idx param __len__ - int _size __iter__ - Iterator Any iter i i range len __iadd__ parameters Iterable Any - Self extend parameters __dir__ - list str keys = super __dir__ keys = key key keys key isdigit keys append value Any - Self Append given value end list Args value Any value append new_idx = len _size += new_idx = value extend values Iterable Any - Self Append values Python iterable end list Args values iterable iterable values append Tensor iterable we never want unpack here isinstance values container_abcs Iterable isinstance values torch Tensor raise TypeError ParameterList extend should called iterable got + type values __name__ value values append value extra_repr - str Return extra representation module child_lines = k p enumerate isinstance p torch Tensor size_str = x join str size size p size p device type cuda torch _C _get_privateuse _backend_name device_str = f p device device_str = parastr = containing size format Parameter isinstance p Parameter Tensor p dtype size_str device_str pyrefly ignore bad-argument-type child_lines append + str k + + parastr child_lines append pyrefly ignore bad-argument-type + str k + Object type + type p __name__ tmpstr = \n join child_lines tmpstr __call__ args kwargs raise RuntimeError ParameterList should called ParameterDict Module r Holds parameters dictionary ParameterDict can indexed like regular Python dictionary Parameters contains properly registered will visible all Module methods Other objects treated would done regular Python dictionary ` ~torch nn ParameterDict ` ordered dictionary meth ` ~torch nn ParameterDict update ` other unordered mapping types e g Python s plain ` ` dict ` ` does preserve order merged mapping On other hand ` ` OrderedDict ` ` another ` ~torch nn ParameterDict ` will preserve their ordering Note constructor assigning element dictionary meth ` ~torch nn ParameterDict update ` method will convert any ` ~torch Tensor ` into ` ~torch nn Parameter ` Args values iterable optional mapping dictionary string Any iterable key-value pairs type string Any Example MyModule nn Module __init__ - None super __init__ params = nn ParameterDict left nn Parameter torch randn right nn Parameter torch randn forward x choice x = params choice mm x x __init__ parameters Any = None - None super __init__ _keys dict str None = parameters None update parameters _key_to_attr key str - str isinstance key str raise TypeError Index given ParameterDict cannot used key f string type type key __name__ Open issue github you need non-string keys Use key as-is so ` named_parameters ` returns right thing key __getitem__ key str - Any attr = _key_to_attr key getattr attr __setitem__ key str value Any - None Note all other function add entry dictionary part ParameterDict end up here So only place where we need wrap things into Parameter needed Objects added via setattr dictionary part thus won t call into function _keys key = None attr = _key_to_attr key isinstance value torch Tensor isinstance value Parameter value = Parameter value setattr attr value __delitem__ key str - None del _keys key attr = _key_to_attr key delattr attr __len__ - int len _keys __iter__ - Iterator str iter _keys __reversed__ - Iterator str reversed _keys copy - ParameterDict Return copy ` ~torch nn ParameterDict ` instance We have use OrderedDict because ParameterDict constructor behaves differently plain dict vs OrderedDict ParameterDict OrderedDict k k k _keys __contains__ key str - bool key _keys setdefault key str default Optional Any = None - Any Set default key Parameterdict If key ParameterDict its value If insert ` key ` parameter ` default ` ` default ` ` default ` defaults ` None ` Args key str key set default default Any parameter set key key key = default key clear - None Remove all items ParameterDict k _keys copy del k pop key str - Any r Remove key ParameterDict its parameter Args key str key pop ParameterDict v = key del key v popitem - tuple str Any Remove last inserted ` key parameter ` pair ParameterDict k _ = _keys popitem We need key _keys able access del _keys k = None val = k del k k val get key str default Optional Any = None - Any r Return parameter associated key present Otherwise default provided None Args key str key get ParameterDict default Parameter optional value key present key key default noqa SIM fromkeys keys Iterable str default Optional Any = None - ParameterDict r Return new ParameterDict keys provided Args keys iterable string keys make new ParameterDict default Parameter optional value set all keys ParameterDict k default k keys keys - container_abcs KeysView str r Return iterable ParameterDict keys _keys keys items - Iterable tuple str Any r Return iterable ParameterDict key value pairs k k k _keys values - Iterable Any r Return iterable ParameterDict values k k _keys update parameters Union Mapping str Any ParameterDict - None r Update ` ~torch nn ParameterDict ` key-value pairs ` ` parameters ` ` overwriting existing keys note If attr ` parameters ` ` ` OrderedDict ` ` ` ~torch nn ParameterDict ` iterable key-value pairs order new elements preserved Args parameters iterable mapping dictionary string ` ~torch nn Parameter ` iterable key-value pairs type string ` ~torch nn Parameter ` isinstance parameters container_abcs Iterable raise TypeError ParametersDict update should called iterable key value pairs got + type parameters __name__ isinstance parameters OrderedDict ParameterDict key parameter parameters items key = parameter isinstance parameters container_abcs Mapping key parameter sorted parameters items key = parameter j p enumerate parameters isinstance p container_abcs Iterable raise TypeError ParameterDict update sequence element + str j + should Iterable + type p __name__ pyrefly ignore bad-argument-type len p == raise ValueError ParameterDict update sequence element pyrefly ignore bad-argument-type + str j + has length + str len p + required parameters length- list too cumbersome type see ModuleDict update comment p = p type ignore assignment extra_repr - str child_lines = k p items isinstance p torch Tensor size_str = x join str size size p size p device type cuda torch _C _get_privateuse _backend_name device_str = f p device device_str = parastr = containing size format Parameter isinstance p Parameter Tensor torch typename p size_str device_str pyrefly ignore bad-argument-type child_lines append + str k + + parastr child_lines append pyrefly ignore bad-argument-type + str k + Object type + type p __name__ tmpstr = \n join child_lines tmpstr __call__ input raise RuntimeError ParameterDict should called __or__ other ParameterDict - ParameterDict copy = copy copy update other copy __ror__ other ParameterDict - ParameterDict copy = other copy copy update copy __ior__ other ParameterDict - Self update other