copy dataclasses logging abc ABC abstractmethod collections defaultdict collections abc Generator contextlib contextmanager itertools chain typing Any Optional torch utils _appending_byte_serializer AppendingByteSerializer BytesReader BytesWriter torch utils _ordered_set OrderedSet log = logging getLogger __name__ dataclasses dataclass frozen=True CacheArtifact ABC Data each cache artifact will serialized deserialized key str content bytes = dataclasses field repr=False Do display potential binary staticmethod serialize writer BytesWriter cls CacheArtifact - None writer write_str cls key writer write_bytes cls content staticmethod deserialize artifact_type str reader BytesReader - CacheArtifact key = reader read_str content = reader read_bytes CacheArtifactFactory create artifact_type key content staticmethod encode content Any - bytes assert isinstance content bytes f Expected bytes got type content content abstractmethod populate_cache - None pass staticmethod type - str Returns type artifact Must unique across all CacheArtifact classes CacheArtifactFactory register will add property method CacheInfo based type _artifacts returns all artifacts specific cache raise RuntimeError CacheArtifact abstract please use subclass CacheArtifactFactory Factory creating CacheArtifact objects based their type _artifact_types dict str type CacheArtifact = classmethod register cls artifact_cls type CacheArtifact - type CacheArtifact artifact_type_key = artifact_cls type assert artifact_cls type cls _artifact_types f Artifact type= artifact_type_key already registered mega-cache artifact factory cls _artifact_types artifact_type_key = artifact_cls setattr CacheInfo f artifact_type_key _artifacts property lambda artifacts artifact_type_key artifact_cls classmethod _get_artifact_type cls artifact_type_key str - type CacheArtifact assert artifact_type_key cls _artifact_types f Artifact type= artifact_type_key registered mega-cache artifact factory cls _artifact_types artifact_type_key classmethod create cls artifact_type_key str key str content bytes - CacheArtifact artifact_cls = cls _get_artifact_type artifact_type_key pyrefly ignore bad-instantiation artifact_cls key content classmethod encode_create cls artifact_type_key str key str content Any - CacheArtifact artifact_cls = cls _get_artifact_type artifact_type_key pyrefly ignore bad-instantiation artifact_cls key artifact_cls encode content dataclasses dataclass CacheInfo Return value serialization deserialization purpose instrumentation artifacts defaultdict str list str = dataclasses field default_factory=lambda defaultdict list Methods set CacheArtifactFactory register based CacheArtifact type property inductor_artifacts - list str type ignore empty-body property autotune_artifacts - list str type ignore empty-body property aot_autograd_artifacts - list str type ignore empty-body property pgo_artifacts - list str type ignore empty-body property precompile_artifacts - list str type ignore empty-body add artifact CacheArtifact - None artifacts artifact type append artifact key clear - None artifacts clear empty - bool artifacts _serialize_single_cache writer BytesWriter cls tuple str list CacheArtifact - None writer write_str cls writer write_uint len cls artifact cls CacheArtifact serialize writer artifact _deserialize_single_cache reader BytesReader - tuple str list CacheArtifact artifacts = artifact_type_key = reader read_str num_artifacts = reader read_uint _ range num_artifacts artifacts append CacheArtifact deserialize artifact_type_key reader artifact_type_key artifacts CacheArtifactsResult = dict str list CacheArtifact CacheArtifactManager Lightweight manager collecting processing cache artifacts hot loading Intended Lifecycle - Execute code via torch compile will call CacheArtifactManager record_artifact each cache artifact - Call CacheArtifactManager serialize convert all cache artifacts portable format - Call CacheArtifactManager deserialize hot load cache artifacts potentially different process NOTE There s no FB FC guarantees results cache artifacts will used unless code version matches Protected compile_lock _new_cache_artifacts CacheArtifactsResult = defaultdict list Keep separate seen artifacts list make avoid unnecessary duplicates This list will cleared between serialize calls _seen_artifacts OrderedSet CacheArtifact = OrderedSet When serialize called artifacts transferred _cache_artifacts internal data structure _serializer This allows us only pay cost serialization serialize called _serializer AppendingByteSerializer tuple str list CacheArtifact = AppendingByteSerializer serialize_fn=_serialize_single_cache _cache_info CacheInfo = CacheInfo classmethod clear cls - None cls _new_cache_artifacts clear cls _seen_artifacts clear cls _serializer clear cls _cache_info clear classmethod contextmanager with_fresh_cache cls - Generator None None None original_new_cache_artifacts = cls _new_cache_artifacts original_seen_artifacts = cls _seen_artifacts original_serializer = cls _serializer original_cache_info = cls _cache_info cls _new_cache_artifacts = defaultdict list cls _seen_artifacts = OrderedSet cls _serializer = AppendingByteSerializer serialize_fn=_serialize_single_cache cls _cache_info = cls _cache_info __class__ try yield finally cls _new_cache_artifacts = original_new_cache_artifacts cls _seen_artifacts = original_seen_artifacts cls _serializer = original_serializer cls _cache_info = original_cache_info classmethod record_artifact cls artifact_type str key str content Any - None Called each caching operation record artifact mega list artifact = CacheArtifactFactory encode_create artifact_type key content artifact cls _seen_artifacts log debug Recording s str artifact cls _new_cache_artifacts artifact_type append artifact cls _seen_artifacts add artifact classmethod need_serialize cls - bool Have we seen new artifacts since last serialize call len cls _new_cache_artifacts = classmethod serialize cls - Optional tuple bytes CacheInfo Converts mega list into portable format artifact chain cls _new_cache_artifacts values log debug saving s artifact cls _cache_info add artifact cls _cache_info empty If there artifacts dont just bytes version None try We deep copy cls _cache_info since later compilations can keep adding cache_info info = copy deepcopy cls _cache_info cls _serializer extend cls _new_cache_artifacts items artifact_bytes = cls _serializer to_bytes cls _new_cache_artifacts clear artifact_bytes info except Exception log warning Failed pickle cache artifacts exc_info=True None staticmethod deserialize serialized_artifacts bytes - Optional CacheArtifactsResult Converts portable format back into CacheArtifacts try CacheArtifactManager _ensure_cache_artifacts_registered artifacts = dict AppendingByteSerializer to_list serialized_artifacts deserialize_fn=_deserialize_single_cache except Exception log warning Failed un-pickle cache artifacts exc_info=True None artifacts staticmethod populate_caches artifacts CacheArtifactsResult - CacheInfo info = CacheInfo artifact chain artifacts values log debug writing s artifact info add artifact artifact populate_cache info classmethod _ensure_cache_artifacts_registered cls - None When deserializing caches fresh process we need ensure all cache artifacts registered cache registry This done simply importing all cache artifacts already wrapped register call torch _dynamo package PrecompileCacheArtifact noqa F torch _dynamo pgo PGOCacheArtifact noqa F torch _functorch _aot_autograd autograd_cache noqa F AOTAutogradCacheArtifact torch _inductor codecache InductorCacheArtifact noqa F torch _inductor runtime autotune_cache noqa F AutotuneCacheArtifact