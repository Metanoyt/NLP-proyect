Owner s module multiprocessing os pickle random signal sys time unittest torch multiprocessing mp torch testing _internal common_utils IS_WINDOWS run_tests TestCase parametrize instantiate_parametrized_tests _test_success_func i pass _test_success_single_arg_func i arg arg arg put i _test_exception_single_func i arg i == arg raise ValueError f legitimate exception process i d time sleep _test_exception_all_func i time sleep random random raise ValueError f legitimate exception process i d _test_terminate_signal_func i i == os kill os getpid signal SIGABRT time sleep _test_terminate_exit_func i arg i == sys exit arg time sleep _test_success_first_then_exception_func i arg i == time sleep raise ValueError legitimate exception _test_nested_child_body i ready_queue nested_child_sleep ready_queue put None time sleep nested_child_sleep _test_infinite_task i while True time sleep _test_process_exit idx sys exit _test_nested i pids_queue nested_child_sleep start_method context = mp get_context start_method nested_child_ready_queue = context Queue nprocs = mp_context = mp start_processes fn=_test_nested_child_body args= nested_child_ready_queue nested_child_sleep nprocs=nprocs join=False daemon=False start_method=start_method pids_queue put mp_context pids Wait both children have started ensure they have called prctl register parent death signal _ range nprocs nested_child_ready_queue get Kill This should take down child processes well os kill os getpid signal SIGTERM instantiate_parametrized_tests _TestMultiProcessing start_method = None test_success mp start_processes _test_success_func nprocs= start_method=self start_method test_success_non_blocking mp_context = mp start_processes _test_success_func nprocs= join=False start_method=self start_method After all processes nproc= have joined must True mp_context join timeout=None mp_context join timeout=None assertTrue mp_context join timeout=None test_first_argument_index context = mp get_context start_method queue = context SimpleQueue mp start_processes _test_success_single_arg_func args= queue nprocs= start_method=self start_method assertEqual sorted queue get queue get test_exception_single nprocs = i range nprocs assertRaisesRegex Exception f \nValueError legitimate exception process i d $ mp start_processes _test_exception_single_func args= i nprocs=nprocs start_method=self start_method test_exception_all assertRaisesRegex Exception \nValueError legitimate exception process &#124; $ mp start_processes _test_exception_all_func nprocs= start_method=self start_method test_terminate_signal SIGABRT aliased SIGIOT message = process terminated signal SIGABRT &#124; SIGIOT Termination through signal expressed negative exit code multiprocessing so we know signal caused exit This doesn t appear exist Windows where exit code always positive therefore results different exception message Exit code means ERROR_BAD_COMMAND IS_WINDOWS message = process terminated exit code assertRaisesRegex Exception message mp start_processes _test_terminate_signal_func nprocs= start_method=self start_method parametrize grace_period None test_terminate_exit grace_period exitcode = ctx = mp start_processes _test_terminate_exit_func args= exitcode nprocs= start_method=self start_method join=False pid = ctx processes pid assertRaisesRegex Exception f process terminated exit code exitcode d assertLogs level= WARNING logs while ctx join grace_period=grace_period pass grace_period None pid killed signal expected_log = f Terminating process pid d via signal assertIn expected_log logs records getMessage pid exits its own assertFalse logs records Check no processes left p ctx processes assertFalse p is_alive test_success_first_then_exception exitcode = assertRaisesRegex Exception ValueError legitimate exception mp start_processes _test_success_first_then_exception_func args= exitcode nprocs= start_method=self start_method unittest skipIf sys platform = linux Only runs Linux requires prctl _test_nested context = mp get_context start_method pids_queue = context Queue nested_child_sleep = mp_context = mp start_processes noqa F fn=_test_nested args= pids_queue nested_child_sleep start_method nprocs= join=False daemon=False start_method=self start_method Wait nested children terminate time pids = pids_queue get start = time time while len pids pid pids try os kill pid except ProcessLookupError pids remove pid noqa B break This assert fails any nested child process still alive after nested_child_sleep seconds By extension test times out assertion error after nested_child_sleep seconds assertLess time time - start nested_child_sleep time sleep SpawnTest TestCase _TestMultiProcessing start_method = spawn test_exception_raises assertRaises mp ProcessRaisedException mp spawn _test_success_first_then_exception_func args= nprocs= test_signal_raises context = mp spawn _test_infinite_task args= nprocs= join=False pid context pids os kill pid signal SIGTERM assertRaises mp ProcessExitedException context join _test_process_exited assertRaises mp ProcessExitedException e mp spawn _test_process_exit args= nprocs= assertEqual e exit_code unittest skipIf IS_WINDOWS Fork only available Unix ForkTest TestCase _TestMultiProcessing start_method = fork unittest skipIf IS_WINDOWS Fork only available Unix ParallelForkServerShouldWorkTest TestCase _TestMultiProcessing orig_paralell_env_val = None setUp super setUp orig_paralell_env_val = os environ get mp ENV_VAR_PARALLEL_START os environ mp ENV_VAR_PARALLEL_START = tearDown super tearDown orig_paralell_env_val None del os environ mp ENV_VAR_PARALLEL_START os environ mp ENV_VAR_PARALLEL_START = orig_paralell_env_val unittest skipIf IS_WINDOWS Fork only available Unix ParallelForkServerPerfTest TestCase unittest skipIf sys version_info = Python + changed forkserver module caching behavior https docs python org whatsnew changelog html gh- test_forkserver_perf start_method = forkserver expensive = Expensive nprocs = orig_paralell_env_val = os environ get mp ENV_VAR_PARALLEL_START test non parallel case os environ mp ENV_VAR_PARALLEL_START = start = time perf_counter mp start_processes expensive my_call nprocs=nprocs start_method=start_method elapsed = time perf_counter - start elapsed time should least nprocs x sleep time assertGreaterEqual elapsed Expensive SLEEP_SECS nprocs test parallel case os environ mp ENV_VAR_PARALLEL_START = start = time perf_counter mp start_processes expensive my_call nprocs=nprocs start_method=start_method elapsed = time perf_counter - start elapsed time should less than nprocs x sleep time assertLess elapsed Expensive SLEEP_SECS nprocs orig_paralell_env_val None del os environ mp ENV_VAR_PARALLEL_START os environ mp ENV_VAR_PARALLEL_START = orig_paralell_env_val Expensive SLEEP_SECS = Simulate startup overhead such large imports time sleep SLEEP_SECS __init__ config str = my_call args pass ErrorTest TestCase test_errors_pickleable error mp ProcessRaisedException Oh no mp ProcessExitedException Oh no pickle loads pickle dumps error __name__ == __main__ run_tests