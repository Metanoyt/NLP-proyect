Contains utility functions working nested python data structures A pytree Python nested data structure It tree sense nodes Python collections e g list tuple dict leaves Python values Furthermore pytree should contain reference cycles pytrees useful working nested collections Tensors For example one can use ` tree_map ` map function over all Tensors inside some nested collection Tensors ` tree_leaves ` get flat list all Tensors inside some nested collection pytrees helpful implementing nested collection support PyTorch APIs functools types collections abc Callable Iterable Mapping typing Any Optional overload TypeVar Union typing_extensions deprecated Self TypeAlias TypeIs torch utils _pytree python_pytree torch torch_version TorchVersion _TorchVersion torch utils _pytree is_namedtuple is_namedtuple_class is_namedtuple_instance is_structseq is_structseq_class is_structseq_instance KeyEntry Do try ` optree ` package static version check already fails python_pytree _cxx_pytree_dynamo_traceable raise ImportError f __name__ depends ` optree = python_pytree _optree_minimum_version ` which optional dependency PyTorch To use please upgrade your optree package via ` python -m pip install -- upgrade optree ` optree optree PyTreeSpec direct type annotations __all__ = PyTree Context FlattenFunc UnflattenFunc DumpableContext ToDumpableContextFn FromDumpableContextFn PyTreeSpec TreeSpec LeafSpec keystr key_get register_pytree_node tree_is_leaf tree_flatten tree_flatten_with_path tree_unflatten tree_iter tree_leaves tree_leaves_with_path tree_structure tree_map tree_map_with_path tree_map_ tree_map_only tree_map_only_ tree_all tree_any tree_all_only tree_any_only treespec_dumps treespec_loads treespec_pprint is_namedtuple is_namedtuple_class is_namedtuple_instance is_structseq is_structseq_class is_structseq_instance In-tree installation may have VCS-based versioning Update previous static version python_pytree _optree_version = _TorchVersion optree __version__ type ignore attr-defined __TORCH_DICT_SESSION = optree dict_insertion_ordered True namespace= torch __TORCH_DICT_SESSION __enter__ enable globally permanently T = TypeVar T S = TypeVar S U = TypeVar U R = TypeVar R TreeSpec TypeAlias = PyTreeSpec Context = Any PyTree = Any FlattenFunc = Callable PyTree tuple list Any Context UnflattenFunc = Callable Iterable Any Context PyTree OpTreeUnflattenFunc = Callable Context Iterable Any PyTree DumpableContext = Any Any json dumpable text ToDumpableContextFn = Callable Context DumpableContext FromDumpableContextFn = Callable DumpableContext Context KeyPath = tuple KeyEntry FlattenWithKeysFunc = Callable PyTree tuple list tuple KeyEntry Any Any _reverse_args func UnflattenFunc - OpTreeUnflattenFunc functools wraps func wrapped args Any kwargs Any - Any func reversed args kwargs wrapped register_pytree_node cls type Any flatten_fn FlattenFunc unflatten_fn UnflattenFunc serialized_type_name Optional str = None to_dumpable_context Optional ToDumpableContextFn = None from_dumpable_context Optional FromDumpableContextFn = None flatten_with_keys_fn Optional FlattenWithKeysFunc = None - None Register container-like type pytree node Args cls type A Python type treat internal pytree node flatten_fn callable A function used during flattening taking instance ` ` cls ` ` returning pair iterable children flattened recursively some hashable auxiliary data stored treespec passed ` ` unflatten_fn ` ` unflatten_fn callable A function taking two arguments auxiliary data returned ` ` flatten_fn ` ` stored treespec unflattened children The function should instance ` ` cls ` ` serialized_type_name str optional A keyword argument used specify fully qualified name used when serializing tree spec to_dumpable_context callable optional An optional keyword argument custom specify how convert context pytree custom json dumpable representation This used json serialization which being used mod ` torch export ` right now from_dumpable_context callable optional An optional keyword argument custom specify how convert custom json dumpable representation context back original context This used json deserialization which being used mod ` torch export ` right now Example xdoctest +SKIP Registry Python type lambda functions register_pytree_node set lambda s sorted s None None lambda children _ set children flatten_with_keys_fn None raise NotImplementedError KeyPaths yet supported cxx_pytree _private_register_pytree_node cls flatten_fn unflatten_fn serialized_type_name=serialized_type_name to_dumpable_context=to_dumpable_context from_dumpable_context=from_dumpable_context python_pytree _private_register_pytree_node cls flatten_fn unflatten_fn serialized_type_name=serialized_type_name to_dumpable_context=to_dumpable_context from_dumpable_context=from_dumpable_context deprecated ` torch utils _cxx_pytree _register_pytree_node ` deprecated Please use ` torch utils _cxx_pytree register_pytree_node ` instead category=FutureWarning _register_pytree_node cls type Any flatten_fn FlattenFunc unflatten_fn UnflattenFunc serialized_type_name Optional str = None to_dumpable_context Optional ToDumpableContextFn = None from_dumpable_context Optional FromDumpableContextFn = None - None Register container-like type pytree node C++ pytree only The ` ` namespace ` ` argument used avoid collisions occur when different libraries register same Python type different behaviors It recommended add unique prefix namespace avoid conflicts other libraries Namespaces can also used specify same different namespaces different use cases warning For safety reasons ` ` namespace ` ` must specified while registering custom type It used isolate behavior flattening unflattening pytree node type This prevent accidental collisions between different libraries may register same type Args cls type A Python type treat internal pytree node flatten_fn callable A function used during flattening taking instance ` ` cls ` ` returning pair iterable children flattened recursively some hashable auxiliary data stored treespec passed ` ` unflatten_fn ` ` unflatten_fn callable A function taking two arguments auxiliary data returned ` ` flatten_fn ` ` stored treespec unflattened children The function should instance ` ` cls ` ` serialized_type_name str optional A keyword argument used specify fully qualified name used when serializing tree spec to_dumpable_context callable optional An optional keyword argument custom specify how convert context pytree custom json dumpable representation This used json serialization which being used mod ` torch export ` right now from_dumpable_context callable optional An optional keyword argument custom specify how convert custom json dumpable representation context back original context This used json deserialization which being used mod ` torch export ` right now _private_register_pytree_node cls flatten_fn unflatten_fn serialized_type_name=serialized_type_name to_dumpable_context=to_dumpable_context from_dumpable_context=from_dumpable_context _private_register_pytree_node cls type Any flatten_fn FlattenFunc unflatten_fn UnflattenFunc serialized_type_name Optional str = None to_dumpable_context Optional ToDumpableContextFn = None from_dumpable_context Optional FromDumpableContextFn = None - None This internal function used register pytree node type C++ pytree only End-users should use func ` register_pytree_node ` instead TODO XuehaiPan remove condition when we make Python pytree out-of-box support PyStructSequence types optree is_structseq_class cls optree register_pytree_node cls flatten_fn _reverse_args unflatten_fn namespace= torch _is_pytreespec_instance obj Any - TypeIs TreeSpec isinstance obj TreeSpec treespec_leaf - TreeSpec Make treespec representing leaf node optree treespec_leaf none_is_leaf=True namespace= torch treespec_tuple iterable Iterable TreeSpec = - TreeSpec Make tuple treespec iterable child treespecs optree treespec_tuple iterable none_is_leaf=True namespace= torch treespec_dict mapping Union Mapping Any TreeSpec Iterable tuple Any TreeSpec = kwargs TreeSpec - TreeSpec Make dict treespec dict child treespecs optree treespec_dict mapping kwargs none_is_leaf=True namespace= torch tree_is_leaf tree PyTree is_leaf Optional Callable PyTree bool = None - bool Check pytree leaf tree_is_leaf True tree_is_leaf None True tree_is_leaf False tree_is_leaf is_leaf=lambda x isinstance x tuple True tree_is_leaf b c False tree_is_leaf b c None False Args tree pytree A pytree check leaf node is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A boolean indicating pytree leaf node optree tree_is_leaf tree is_leaf=is_leaf none_is_leaf=True namespace= torch tree_flatten tree PyTree is_leaf Optional Callable PyTree bool = None - tuple list Any TreeSpec Flatten pytree See also func ` tree_unflatten ` The flattening order i e order elements output list deterministic corresponding left-to-right depth-first tree traversal tree = b c None d tree_flatten tree None PyTreeSpec b c d NoneIsLeaf namespace= torch tree_flatten PyTreeSpec NoneIsLeaf namespace= torch tree_flatten None None PyTreeSpec NoneIsLeaf namespace= torch collections OrderedDict tree = OrderedDict b c None d tree_flatten tree None PyTreeSpec OrderedDict b c d NoneIsLeaf namespace= torch Args tree pytree A pytree flatten is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A pair ` ` leaves treespec ` ` where first element list leaf values second element treespec representing structure pytree optree tree_flatten type ignore return-value tree is_leaf=is_leaf none_is_leaf=True namespace= torch tree_unflatten leaves Iterable Any treespec TreeSpec - PyTree Reconstruct pytree treespec leaves The inverse func ` tree_flatten ` tree = b c None d leaves treespec = tree_flatten tree tree == tree_unflatten leaves treespec True Args leaves iterable The list leaves use reconstruction The list must match number leaves treespec treespec TreeSpec The treespec reconstruct Returns The reconstructed pytree containing ` ` leaves ` ` placed structure described ` ` treespec ` ` optree tree_unflatten treespec leaves type ignore arg-type tree_iter tree PyTree is_leaf Optional Callable PyTree bool = None - Iterable Any Get iterator over leaves pytree See also func ` tree_flatten ` tree = b c None d list tree_iter tree None list tree_iter list tree_iter None None Args tree pytree A pytree flatten is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns An iterator over leaf values optree tree_iter tree is_leaf=is_leaf none_is_leaf=True namespace= torch tree_leaves tree PyTree is_leaf Optional Callable PyTree bool = None - list Any Get leaves pytree See also func ` tree_flatten ` tree = b c None d tree_leaves tree None tree_leaves tree_leaves None None Args tree pytree A pytree flatten is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A list leaf values optree tree_leaves tree is_leaf=is_leaf none_is_leaf=True namespace= torch tree_structure tree PyTree is_leaf Optional Callable PyTree bool = None - TreeSpec Get treespec pytree See also func ` tree_flatten ` tree = b c None d tree_structure tree PyTreeSpec b c d NoneIsLeaf namespace= torch tree_structure PyTreeSpec NoneIsLeaf namespace= torch tree_structure None PyTreeSpec NoneIsLeaf namespace= torch Args tree pytree A pytree flatten is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A treespec object representing structure pytree optree tree_structure type ignore return-value tree is_leaf=is_leaf none_is_leaf=True namespace= torch tree_map func Callable Any tree PyTree rests PyTree is_leaf Optional Callable PyTree bool = None - PyTree Map multi-input function over pytree args produce new pytree See also func ` tree_map_ ` tree_map lambda x x + x y x y tree_map lambda x x None x y z None x False y False False z True If multiple inputs given structure tree taken first input subsequent inputs need only have ` ` tree ` ` prefix tree_map lambda x y x + y Args func callable A function takes ` ` + len rests ` ` arguments applied corresponding leaves pytrees tree pytree A pytree mapped over each leaf providing first positional argument function ` ` func ` ` rests tuple pytree A tuple pytrees each which has same structure ` ` tree ` ` has ` ` tree ` ` prefix is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A new pytree same structure ` ` tree ` ` value each leaf given ` ` func x xs ` ` where ` ` x ` ` value corresponding leaf ` ` tree ` ` ` ` xs ` ` tuple values corresponding nodes ` ` rests ` ` optree tree_map func tree rests is_leaf=is_leaf none_is_leaf=True namespace= torch tree_map_ func Callable Any tree PyTree rests PyTree is_leaf Optional Callable PyTree bool = None - PyTree Like func ` tree_map ` do inplace call each leaf original tree See also func ` tree_map ` Args func callable A function takes ` ` + len rests ` ` arguments applied corresponding leaves pytrees tree pytree A pytree mapped over each leaf providing first positional argument function ` ` func ` ` rests tuple pytree A tuple pytrees each which has same structure ` ` tree ` ` has ` ` tree ` ` prefix is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns The original ` ` tree ` ` value each leaf given side-effect function ` ` func x xs ` ` value where ` ` x ` ` value corresponding leaf ` ` tree ` ` ` ` xs ` ` tuple values values corresponding nodes ` ` rests ` ` optree tree_map_ func tree rests is_leaf=is_leaf none_is_leaf=True namespace= torch Type = tuple type T type S Type = tuple type T type S type U TypeAny = Union type Any tuple type Any types UnionType Fn = Callable Union T S R Fn = Callable Union T S U R Fn = Callable T R FnAny = Callable Any R MapOnlyFn = Callable T Callable Any Any These specializations help type inference lambda passed function overload map_only type_or_types_or_pred type T - MapOnlyFn Fn T Any overload map_only type_or_types_or_pred Type T S - MapOnlyFn Fn T S Any overload map_only type_or_types_or_pred Type T S U - MapOnlyFn Fn T S U Any This specialization needed implementations below call overload map_only type_or_types_or_pred TypeAny - MapOnlyFn FnAny Any overload map_only type_or_types_or_pred Callable Any bool - MapOnlyFn FnAny Any map_only type_or_types_or_pred Union TypeAny Callable Any bool - MapOnlyFn FnAny Any Suppose you writing tree_map over tensors leaving everything unchanged Ordinarily you would have write go t isinstance t Tensor t With function you only need write map_only Tensor go t You can also directly use tree_map_only isinstance type_or_types_or_pred type tuple types UnionType pred x Any - bool isinstance x type_or_types_or_pred type ignore arg-type callable type_or_types_or_pred pred = type_or_types_or_pred type ignore assignment raise TypeError Argument must type tuple types callable wrapper func Callable T Any - Callable Any Any functools wraps func wrapped x T - Any pred x func x x wrapped wrapper overload tree_map_only type_or_types_or_pred type T func Fn T Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only type_or_types_or_pred Type T S func Fn T S Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only type_or_types_or_pred Type T S U func Fn T S U Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only type_or_types_or_pred TypeAny func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only type_or_types_or_pred Callable Any bool func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree tree_map_only type_or_types_or_pred Union TypeAny Callable Any bool func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree tree_map map_only type_or_types_or_pred func tree is_leaf=is_leaf overload tree_map_only_ type_or_types_or_pred type T func Fn T Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only_ type_or_types_or_pred Type T S func Fn T S Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only_ type_or_types_or_pred Type T S U func Fn T S U Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only_ type_or_types_or_pred TypeAny func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree overload tree_map_only_ type_or_types_or_pred Callable Any bool func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree tree_map_only_ type_or_types_or_pred Union TypeAny Callable Any bool func FnAny Any tree PyTree is_leaf Optional Callable PyTree bool = None - PyTree tree_map_ map_only type_or_types_or_pred func tree is_leaf=is_leaf tree_all pred Callable Any bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool flat_args = tree_iter tree is_leaf=is_leaf all map pred flat_args tree_any pred Callable Any bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool flat_args = tree_iter tree is_leaf=is_leaf any map pred flat_args overload tree_all_only type_or_types type T pred Fn T bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool overload tree_all_only type_or_types Type T S pred Fn T S bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool overload tree_all_only type_or_types Type T S U pred Fn T S U bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool tree_all_only type_or_types TypeAny pred FnAny bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool flat_args = tree_iter tree is_leaf=is_leaf all pred x x flat_args isinstance x type_or_types overload tree_any_only type_or_types type T pred Fn T bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool overload tree_any_only type_or_types Type T S pred Fn T S bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool overload tree_any_only type_or_types Type T S U pred Fn T S U bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool tree_any_only type_or_types TypeAny pred FnAny bool tree PyTree is_leaf Optional Callable PyTree bool = None - bool flat_args = tree_iter tree is_leaf=is_leaf any pred x x flat_args isinstance x type_or_types broadcast_prefix prefix_tree PyTree full_tree PyTree is_leaf Optional Callable PyTree bool = None - list Any Return list broadcasted leaves ` ` prefix_tree ` ` match number leaves ` ` full_tree ` ` If ` ` prefix_tree ` ` prefix ` ` full_tree ` ` means ` ` full_tree ` ` can constructed replacing leaves ` ` prefix_tree ` ` appropriate subtrees This function returns list leaves same size ` ` full_tree ` ` The leaves replicated ` ` prefix_tree ` ` The number replicas determined corresponding subtree ` ` full_tree ` ` broadcast_prefix broadcast_prefix broadcast_prefix Traceback most recent call last ValueError list arity mismatch expected got list broadcast_prefix broadcast_prefix b c None Args prefix_tree pytree A pytree same structure prefix ` ` full_tree ` ` full_tree pytree A pytree same structure suffix ` ` prefix_tree ` ` is_leaf callable optional An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A list leaves ` ` prefix_tree ` ` broadcasted match number leaves ` ` full_tree ` ` result list Any = add_leaves x Any subtree PyTree - None subtreespec = tree_structure subtree is_leaf=is_leaf result extend x subtreespec num_leaves tree_map_ add_leaves prefix_tree full_tree is_leaf=is_leaf result Broadcasts pytree provided TreeSpec returns flattened values If possible then function returns None For example given pytree= spec=TreeSpec list None LeafSpec LeafSpec would This useful part vmap implementation user can pass vmap fn in_dims inputs ` in_dims ` should broadcastable tree structure ` inputs ` we use _broadcast_to_and_flatten check _broadcast_to_and_flatten tree PyTree treespec TreeSpec is_leaf Optional Callable PyTree bool = None - Optional list Any _is_pytreespec_instance treespec raise AssertionError f _broadcast_to_and_flatten Expected ` treespec ` instance PyTreeSpec got type treespec full_tree = tree_unflatten treespec num_leaves treespec try broadcast_prefix tree full_tree is_leaf=is_leaf except ValueError None treespec_dumps treespec TreeSpec protocol Optional int = None - str Serialize treespec JSON string _is_pytreespec_instance treespec raise TypeError f treespec_dumps treespec Expected ` treespec ` instance f PyTreeSpec got item type type treespec dummy_tree = tree_unflatten treespec num_leaves treespec orig_treespec = python_pytree tree_structure dummy_tree python_pytree treespec_dumps orig_treespec protocol=protocol functools lru_cache treespec_loads serialized str - TreeSpec Deserialize treespec JSON string orig_treespec = python_pytree treespec_loads serialized dummy_tree = python_pytree tree_unflatten orig_treespec num_leaves orig_treespec treespec = tree_structure dummy_tree treespec _DummyLeaf __repr__ - str treespec_pprint treespec TreeSpec - str dummy_tree = tree_unflatten _DummyLeaf _ range treespec num_leaves treespec repr dummy_tree LeafSpecMeta type TreeSpec type ignore misc __instancecheck__ instance object - bool _is_pytreespec_instance instance instance is_leaf deprecated ` isinstance treespec LeafSpec ` deprecated use ` isinstance treespec TreeSpec ` ` treespec is_leaf ` instead category=FutureWarning LeafSpec TreeSpec metaclass=LeafSpecMeta type ignore misc final __new__ cls - Self treespec_leaf type ignore return-value tree_flatten_with_path tree PyTree is_leaf Optional Callable PyTree bool = None - tuple list tuple KeyPath Any TreeSpec Flattens pytree like func ` tree_flatten ` also returns each leaf s key path Args tree pytree flatten If contains custom type type must registered appropriate ` tree_flatten_with_path_fn ` when registered func ` register_pytree_node ` is_leaf An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A tuple where first element list key path leaf pairs second element ` TreeSpec ` representing structure flattened tree raise NotImplementedError KeyPaths yet supported cxx_pytree tree_leaves_with_path tree PyTree is_leaf Optional Callable PyTree bool = None - list tuple KeyPath Any Gets leaves pytree like ` ` tree_leaves ` ` returns each leaf s key path Args tree pytree If contains custom type type must registered appropriate ` tree_flatten_with_path_fn ` when registered func ` register_pytree_node ` is_leaf An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A list key path leaf pairs raise NotImplementedError KeyPaths yet supported cxx_pytree tree_map_with_path func Callable Any tree PyTree rests PyTree is_leaf Optional Callable PyTree bool = None - PyTree Like func ` tree_map ` provided callable takes additional key path argument Args func A function takes ` ` + len rests ` ` arguments applied corresponding leaves pytrees The first positional argument ` ` func ` ` key path leaf question The second positional argument value leaf tree A pytree mapped over each leaf providing first positional argument function ` ` func ` ` rests A tuple pytrees each which has same structure ` ` tree ` ` has ` ` tree ` ` prefix is_leaf An extra leaf predicate function will called each flattening step The function should have single argument signature ` ` is_leaf node - bool ` ` If returns data ` True ` whole subtree being treated leaf Otherwise default pytree registry will used determine node leaf If function specified default pytree registry will used Returns A new pytree same structure ` ` tree ` ` value each leaf given ` ` func keypath x xs ` ` where ` ` keypath ` ` key path corresponding leaf ` ` tree ` ` ` ` x ` ` value leaf ` ` xs ` ` tuple values corresponding nodes ` ` rests ` ` raise NotImplementedError KeyPaths yet supported cxx_pytree keystr kp KeyPath - str Given key path pretty-printed representation raise NotImplementedError KeyPaths yet supported cxx_pytree key_get obj Any kp KeyPath - Any Given object key path value key path raise NotImplementedError KeyPaths yet supported cxx_pytree python_pytree _NODE_REGISTRY_LOCK pyrefly ignore bad-assignment python_pytree _cxx_pytree_imported = True args kwargs = type ignore var-annotated args kwargs python_pytree _cxx_pytree_pending_imports _private_register_pytree_node args kwargs python_pytree _cxx_pytree_pending_imports clear del args kwargs