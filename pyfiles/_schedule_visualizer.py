Copyright c Meta Platforms Inc affiliates This visualizer requires matplotlib installed Example usage ops = get_schedule_ops InterleavedZeroBubble visualize_schedule ops test png collections typing NamedTuple Optional Union unittest mock torch distributed pipelining schedules _Action _ComputationType _PipelineSchedule _PipelineScheduleRuntime get_schedule_class PipelineScheduleMulti PipelineScheduleSingle torch distributed pipelining stage PipelineStage OpKey NamedTuple stage_index int computation_type _ComputationType microbatch_index int get_schedule_ops schedule Union str type _PipelineSchedule pp_degree int num_microbatches int num_stages_per_rank Optional int = None add_spacing bool = False with_comms bool = False - list list Optional _Action Get all actions given schedule pp_degree num_microbatches The actions returned list lists where each inner list represents rank each element inner list represents action The schedule can specified string which passed into get_schedule_class _PipelineSchedule instance add_spacing with_comms raise ValueError Cannot add spacing view comms same time isinstance schedule str schedule_class = get_schedule_class schedule issubclass schedule _PipelineSchedule schedule_class = schedule raise ValueError f Invalid schedule schedule Create mock PipelineStage mock_pipeline_stage = mock create_autospec PipelineStage instance=True Set values group_rank group_size methods mock_pipeline_stage group_rank = mock_pipeline_stage group_size = pp_degree mock_pipeline_stage submod = None Check num_stages_per_rank valid issubclass schedule_class PipelineScheduleSingle num_stages_per_rank None num_stages_per_rank = assert num_stages_per_rank == stages = mock_pipeline_stage stages num_stages = num_stages_per_rank pp_degree issubclass schedule_class PipelineScheduleMulti num_stages_per_rank None num_stages_per_rank = assert num_stages_per_rank = stages = mock_pipeline_stage _ range num_stages_per_rank stage stages stage num_stages = num_stages_per_rank pp_degree raise ValueError f Invalid schedule schedule_class Instantiate schedule pyrefly ignore bad-instantiation bad-argument-type schedule_instance = schedule_class stages num_microbatches assert schedule_instance pipeline_order None Convert List List _Action all_actions list list Optional _Action = with_comms runtime = _PipelineScheduleRuntime stages num_microbatches runtime _prepare_schedule_with_comms schedule_instance pipeline_order rank range pp_degree all_actions append list runtime pipeline_order_with_comms rank rank range pp_degree all_actions append schedule_instance pipeline_order rank Add spacing add_spacing remove all Nones then respace TODO later we can change schedule creation level use Nones all_actions = action action rank action None rank all_actions all_actions = add_schedule_op_spacing all_actions Return pipeline order all_actions _ComputationTypeVisual __init__ color str text str = width int = color = color width = width text = text Update mapping use _ComputationTypeVisual instances action_type_to_color_mapping = _ComputationType FORWARD _ComputationTypeVisual blue Forward _ComputationType BACKWARD_INPUT _ComputationTypeVisual teal Backward Input _ComputationType BACKWARD_WEIGHT _ComputationTypeVisual green Backward Weight _ComputationType FULL_BACKWARD _ComputationTypeVisual orange Full Backward _ComputationType OVERLAP_F_B _ComputationTypeVisual purple Overlap F+B add_schedule_op_spacing schedule list list Optional _Action - list list Optional _Action Add spacing schedule based dependencies between ranks Before adding operation list function checks there dependencies other ranks If there dependencies other ranks have finished processing required microbatch adds None instead For example Forward microbatch rank depends rank processing Forward microbatch first Args schedule The original schedule list lists where each inner list represents rank each element represents action Returns A new schedule proper spacing based dependencies schedule schedule num_stages = max action stage_index rank_actions schedule action rank_actions action None + num_ranks = len schedule spaced_schedule list list Optional _Action = _ range num_ranks rank_ops = collections deque ops ops schedule Track completion times stage_index action_type microbatch_index - completion_time scheduled_ops dict OpKey int = is_dependency_ready dependency_key OpKey timestep int - bool Check dependency operation has completed given timestep dependency_key scheduled_ops timestep = scheduled_ops dependency_key get_dependencies action _Action - list OpKey Get list dependencies action stage_idx = action stage_index comp_type = action computation_type mb_idx = action microbatch_index Ensure mb_idx None dependency tracking assert mb_idx None f Action action has None microbatch_index First stage forward has no dependencies stage_idx == comp_type == _ComputationType FORWARD Last stage backward depends forward previous stage stage_idx == num_stages - comp_type _ComputationType FULL_BACKWARD _ComputationType BACKWARD_INPUT OpKey stage_idx - _ComputationType FORWARD mb_idx Forward depends previous stage forward comp_type == _ComputationType FORWARD OpKey stage_idx - _ComputationType FORWARD mb_idx Backward depends next stage backward comp_type _ComputationType FULL_BACKWARD _ComputationType BACKWARD_INPUT OpKey stage_idx + _ComputationType FULL_BACKWARD mb_idx OpKey stage_idx + _ComputationType BACKWARD_INPUT mb_idx Weight backward depends input backward comp_type == _ComputationType BACKWARD_WEIGHT OpKey stage_idx _ComputationType BACKWARD_INPUT mb_idx raise RuntimeError f Unknown computation type comp_type is_action_ready action _Action timestep int - bool Check action ready scheduled given timestep For OR dependencies like backward check any dependency satisfied action computation_type _ComputationType FULL_BACKWARD _ComputationType BACKWARD_INPUT _ComputationType BACKWARD_WEIGHT dependencies = get_dependencies action any is_dependency_ready dep timestep dep dependencies For AND dependencies all must satisfied action computation_type == _ComputationType FORWARD dependencies = get_dependencies action all is_dependency_ready dep timestep dep dependencies action computation_type == _ComputationType OVERLAP_F_B assert action sub_actions None f OVERLAP_F_B action action has None sub_actions dep_list list bool = sub_action action sub_actions dep_list append is_action_ready sub_action timestep all dep_list raise RuntimeError f Unknown computation type action computation_type schedule_action action _Action rank int timestep int - int Schedule action completion time spaced_schedule rank append action comp_type = action computation_type comp_time = action_type_to_color_mapping comp_type width completion_time = timestep + comp_time comp_type == _ComputationType OVERLAP_F_B For overlap actions schedule each sub-action cumulative timing assert action sub_actions None f OVERLAP_F_B action action has None sub_actions cumulative_time = sub_action action sub_actions assert sub_action microbatch_index None f Sub-action sub_action has None microbatch_index sub_comp_time = action_type_to_color_mapping sub_action computation_type width cumulative_time += sub_comp_time scheduled_ops OpKey sub_action stage_index sub_action computation_type sub_action microbatch_index = timestep + cumulative_time assert action microbatch_index None f Action action has None microbatch_index scheduled_ops OpKey action stage_index comp_type action microbatch_index = completion_time completion_time Main scheduling loop current_timestep = timesteps_without_progress = rank_completion_times = dict fromkeys range num_ranks while rank_ops print f Current timestep current_timestep Process all operations during timestep until we run out ready operations rank op_queue enumerate rank_ops op_queue continue op_queue = rank_ops rank action = op_queue print f Rank rank action= action None spaced_schedule rank append None op_queue popleft timesteps_without_progress = current_timestep = rank_completion_times rank is_action_ready action current_timestep rank_completion_times rank = schedule_action action rank current_timestep op_queue popleft timesteps_without_progress = Add None ranks waiting rank range num_ranks current_timestep = rank_completion_times rank spaced_schedule rank append None Remove empty queues advance timestep rank_ops = op_queue op_queue rank_ops op_queue current_timestep += timesteps_without_progress += timesteps_without_progress max visual width visual action_type_to_color_mapping values raise RuntimeError No progress made scheduling - possible deadlock spaced_schedule visualize_schedule schedule list list Optional _Action filename Optional str = None - None Visualize schedule using matplotlib The schedule list lists where each inner list represents rank each element inner list represents action The actions represented rectangles different colors based their computation type The filename optional provided plot will saved file Args schedule The schedule visualize filename The filename save plot If provided plot will displayed add_schedule_spacing If True add spacing schedule based dependencies between ranks matplotlib pyplot plt matplotlib patches Rectangle plt rcParams font family = DejaVu Sans any other font available your system num_ranks = len schedule max_actions = max len rank rank schedule Increase figure size provide more space legend fig ax = plt subplots figsize= max_actions + num_ranks + max_draw_position = - Calculate dynamic font size based figure size font_size = min max_actions num_ranks + used_computation = set rank_idx actions enumerate schedule draw_position = Initialize drawing position each rank action actions action None comp_type_color = action_type_to_color_mapping get action computation_type _ComputationTypeVisual black used_computation add action computation_type color = comp_type_color color width = comp_type_color width Check action has sub_actions determine styling action sub_actions None linewidth = Thicker border compound actions text_weight = normal Bold text compound actions linewidth = Default linewidth regular actions text_weight = normal Default text weight Draw rectangle represent action duration rect = Rectangle draw_position num_ranks - rank_idx - width facecolor=color edgecolor= black linewidth=linewidth ax add_patch rect Draw text centered within rectangle ax text draw_position + width num_ranks - rank_idx - + str action ha= center va= center fontsize=font_size color= white weight=text_weight draw_position += width draw_position += Move next max_draw_position = max max_draw_position draw_position ax set_xlim - max_draw_position + ax set_ylim - num_ranks + Add extra space top Set y-ticks middle each rank s row ax set_yticks num_ranks - rank_idx - rank_idx range num_ranks ax set_yticklabels f Rank i i range num_ranks fontsize=font_size ax set_xticklabels Remove grid lines ticks ax grid False Add legend larger font size legend_elements = Rectangle facecolor=action_type_to_color_mapping comp_type color edgecolor= black label=action_type_to_color_mapping comp_type text comp_type used_computation ax legend handles=legend_elements loc= upper right fontsize=font_size Save file filename provided otherwise display plot filename plt savefig filename bbox_inches= tight plt show