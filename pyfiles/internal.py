mypy allow-untyped-defs collections copyreg io pickle sys threading traceback enum Enum torch torch distributed dist torch _C _distributed_rpc _get_current_rpc_agent __all__ = RPCExecMode serialize deserialize PythonUDF RemoteException Thread local tensor tables store tensors while pickling torch Tensor objects _thread_local_tensor_tables = threading local _pickler = pickle Pickler _unpickler = pickle Unpickler RPCExecMode Enum SYNC = sync ASYNC = async ASYNC_JIT = async_jit REMOTE = remote _InternalRPCPickler r This provides serialize deserialize interfaces serialize data binary string + tensor table format So RPC python UDF function args non tensor data will serialized into regular binary string tensor data will put into thread local tensor tables serialization format consistent builtin operator args using JIT pickler This format will make tensor handling C++ much easier e g attach tensor distributed autograd graph C++ __init__ Ignore type error because dispatch_table defined third-party package _dispatch_table = copyreg dispatch_table copy type ignore attr-defined _dispatch_table torch Tensor = _tensor_reducer Used registering customized picklers _class_reducer_dict = _register_reducer obj_class reducer For same only register reducer once obj_class _class_reducer_dict _class_reducer_dict obj_class = reducer classmethod _tensor_receiver cls tensor_index global _thread_local_tensor_tables _thread_local_tensor_tables recv_tables tensor_index _tensor_reducer tensor global _thread_local_tensor_tables _thread_local_tensor_tables send_tables append tensor tensor_index = len _thread_local_tensor_tables send_tables - _InternalRPCPickler _tensor_receiver tensor_index classmethod _py_rref_receiver cls rref_fork_data dist rpc PyRRef _deserialize rref_fork_data _py_rref_reducer py_rref rref_fork_data = py_rref _serialize _InternalRPCPickler _py_rref_receiver rref_fork_data _rref_reducer rref _py_rref_reducer rref classmethod _script_module_receiver cls script_module_serialized Given serialized representation ScriptModule created torch jit save loads returns ScriptModule f = io BytesIO script_module_serialized m = torch jit load f m _script_module_reducer script_module Serializes ScriptModule f = io BytesIO torch jit save script_module f _InternalRPCPickler _script_module_receiver f getvalue serialize obj r Serialize non tensor data into binary string tensor data into tensor table f = io BytesIO p = _pickler f p dispatch_table = _dispatch_table rpc api could accept user picklers inheriting _InternalRPCPickler serialize rref user picklers could have different initialization function _InternalRPCPickler all user picklers should call serialize use _rref_reducer pickle rref python also when _internal_rpc_pickler imported rpc api py rpc RRef compiled yet good place access rpc RRef inside _InternalRPCPickler constructor so putting rref s dispatch table here The value ` rpc remote ` call type ` rpc PyRRef ` The deserialized RRef object RPC receiver side type ` rpc PyRRef ` Ignore type error because dispatch_table defined third-party package p dispatch_table dist rpc PyRRef = _py_rref_reducer type ignore index An RRef created locally RRef Python constructor type ` rpc RRef ` Ignore type error because dispatch_table defined third-party package p dispatch_table dist rpc RRef = _rref_reducer type ignore index Add dispatch pickling ScriptModule its subclass isinstance obj torch jit ScriptModule Ignore type error because dispatch_table defined third-party package p dispatch_table obj __class__ = _script_module_reducer type ignore index Install customized picklers class_name _class_reducer_dict keys p dispatch_table class_name = _class_reducer_dict class_name type ignore index save _thread_local_tensor_tables send_tables nested call global _thread_local_tensor_tables hasattr _thread_local_tensor_tables send_tables old_send_tables = _thread_local_tensor_tables send_tables old_send_tables = None _thread_local_tensor_tables send_tables = p dump obj restore _thread_local_tensor_tables send_tables nested call otherwise clean up table tensors = _thread_local_tensor_tables send_tables old_send_tables None _thread_local_tensor_tables send_tables = old_send_tables del _thread_local_tensor_tables send_tables f getvalue tensors deserialize binary_data tensor_table r Deserialize binary string + tensor table original obj save _thread_local_tensor_tables recv_tables nested call global _thread_local_tensor_tables hasattr _thread_local_tensor_tables recv_tables old_recv_tables = _thread_local_tensor_tables recv_tables old_recv_tables = None _thread_local_tensor_tables recv_tables = tensor_table try unpickler = _unpickler io BytesIO binary_data ret = unpickler load except AttributeError e Occurs when function found module during unpickling except_str = str e + Default RPC pickler does serialize function code Ensure UDFs defined both caller callee modules ret = AttributeError except_str Ensure stack trace gets preserved ret __cause__ = e restore _thread_local_tensor_tables recv_tables nested call otherwise clean up table old_recv_tables None _thread_local_tensor_tables recv_tables = old_recv_tables del _thread_local_tensor_tables recv_tables ret Create _internal_rpc_pickler only once initialize _dispatch_table only once _internal_rpc_pickler = _InternalRPCPickler serialize obj _internal_rpc_pickler serialize obj deserialize binary_data tensor_table _internal_rpc_pickler deserialize binary_data tensor_table _run_function python_udf r This function exclusively called C++ See ` ` torch csrc distributed rpc python_rpc_handler cpp ` ` Runs Python UDF returns its value Wraps any exception ` ` RemoteException ` ` function raises try isinstance python_udf AttributeError raise python_udf result = python_udf func python_udf args python_udf kwargs except Exception e except str = exception info + traceback string except_str = f On _get_current_rpc_agent get_worker_info \n f repr e \n traceback format_exc print except_str file=sys stderr result = RemoteException except_str type e result _handle_exception result isinstance result RemoteException exception_msg = result msg encode utf- decode unicode_escape We wrap exception re-creation here case some exception classes cannot constructed directly string exc = None try exc = result exception_type exception_msg except BaseException e noqa B raise RuntimeError noqa B f Failed create original exception type Error msg str e f Original exception remote side exception_msg e exc None raise exc _build_rpc_profiling_key exec_type func_name current_worker_name dst_worker_name Builds key RPC calls profiled using autograd profiler This will name corresponding Event recorded profiler Args exec_type RPCExecMode Type RPC RRef call func_name str Name function being profiled current_worker_name str Name current worker dst_worker_name str Name destination worker Returns String representing profiling key profile_key = f rpc_ exec_type value func_name current_worker_name - dst_worker_name profile_key _start_record_function exec_type func_name current_worker_name dest_worker_name This function should called RPC RRef functions create RecordFunction object profiling This function also runs before callbacks start profiling though user responsible running appropriate callbacks when function profiled finishes Args exec_type RPCExecMode Type RPC RRef call func_name str Name function being profiled current_worker_name str Name current worker dest_worker_name str Name destination worker Returns An instance ` torch autograd _RecordFunction ` assert torch autograd _profiler_enabled Autograd profiler should enabled profile_key = f rpc_ exec_type value str func_name current_worker_name - dest_worker_name rf = torch autograd _RecordFunction type ignore attr-defined torch autograd _run_before_callbacks rf profile_key type ignore attr-defined rf PythonUDF = collections namedtuple PythonUDF func args kwargs RemoteException = collections namedtuple RemoteException msg exception_type