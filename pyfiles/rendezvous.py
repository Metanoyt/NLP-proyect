mypy allow-untyped-defs try urllib parse urlparse urlunparse except ImportError e raise ImportError urllib cannot found urlparse python no longer supported e numbers os sys collections abc Callable Iterator datetime timedelta typing Optional torch distributed FileStore Store TCPStore constants default_pg_timeout _rendezvous_handlers dict str Callable Iterator tuple Store int int = __all__ = register_rendezvous_handler rendezvous register_rendezvous_handler scheme handler Register new rendezvous handler Before we can run collective algorithms participating processes need find each other exchange information able communicate We call process rendezvous The outcome rendezvous process triplet containing shared key value store rank process total number participating processes If none bundled rendezvous methods apply your execution environment you can opt register your own rendezvous handler Pick unique name use URL scheme identify when calling ` rendezvous ` function Args scheme str URL scheme identify your rendezvous handler handler function Handler invoked when ` rendezvous ` function called URL uses corresponding scheme It must generator function yields triplet global _rendezvous_handlers scheme _rendezvous_handlers raise RuntimeError f Rendezvous handler scheme already registered _rendezvous_handlers scheme = handler Query will have format rank= world_size= converted into rank world_size _query_to_dict query str - dict str str pair pair pair pair split = pair filter None query split _get_use_libuv_from_query_dict query_dict dict str str - bool libuv default backend TCPStore To enable non-libuv backend user can explicitly specify ` ` use_libuv= ` ` URL parameter sys platform == win PyTorch built without libuv support windows so default query_dict get use_libuv os environ get USE_LIBUV == query_dict get use_libuv os environ get USE_LIBUV == _rendezvous_helper url str rank int world_size_opt Optional int kwargs result = urlparse url world_size_opt None world_size = - result scheme == env rank = int os environ get RANK rank If world_size env variable present then dynamic group world_size = int os environ get WORLD_SIZE world_size world_size = world_size_opt rank = - world_size = - world_size_opt None query_dict = _query_to_dict result query assert rank query_dict world_size query_dict f The url url has node-specific arguments rank world_size already rank = - query_dict rank = str rank world_size = - world_size_opt None query_dict world_size = str world_size result = result _replace query=f join f k = v k v query_dict items pyrefly ignore bad-assignment url = urlunparse result result scheme _rendezvous_handlers raise RuntimeError f No rendezvous handler result scheme _rendezvous_handlers result scheme url kwargs rendezvous url str rank int = - world_size int = - kwargs isinstance url str bytes raise RuntimeError f ` url ` must string type url url isinstance rank numbers Integral raise RuntimeError f ` rank ` must integer rank isinstance world_size numbers Integral raise RuntimeError f ` world_size ` must integer world_size pyrefly ignore bad-argument-type _rendezvous_helper url rank world_size kwargs _create_store_from_options backend_options rank store _ _ = next _rendezvous_helper backend_options init_method rank None store _rendezvous_error msg ValueError Error initializing torch distributed using + msg _file_rendezvous_handler url str kwargs _error msg _rendezvous_error file rendezvous + msg result = urlparse url path = result path sys platform == win urllib request full_path = result netloc + result path path = urllib request url pathname full_path path Normalizing empty string produces which expected path = os path normpath path path raise _error path missing query_dict = _query_to_dict result query rank query_dict raise _error rank parameter missing world_size query_dict raise _error world size parameter missing rank = int query_dict rank world_size = int query_dict world_size store = FileStore path world_size yield store rank world_size If configuration invalidated there nothing we can do about raise RuntimeError Unable perform rerendezvous using file method _torchelastic_use_agent_store - bool os environ get TORCHELASTIC_USE_AGENT_STORE None == str True _create_c d_store hostname port rank world_size timeout use_libuv=True - Store Smartly creates c d Store object ` ` rank ` ` based whether we need reuse agent store The TCPStore server assumed hosted ` ` hostname port ` ` By default TCPStore server uses asynchronous implementation ` ` LibUVStoreDaemon ` ` which utilizes libuv If ` ` torchelastic_use_agent_store ` ` ` ` True ` ` then assumed agent leader node rank hosts TCPStore server which endpoint specified given ` ` hostname port ` ` Hence ALL ranks will create TCPStore client e g ` ` start_daemon=False ` ` If ` ` torchelastic_use_agent_store ` ` ` ` False ` ` then rank will host TCPStore multi-tenancy assumed rank s hostname port correctly passed via ` ` hostname ` ` ` ` port ` ` All non-zero ranks will create TCPStore client check port uint _t = port raise ValueError f port must have value port _torchelastic_use_agent_store We create new TCPStore every retry so no need add prefix each attempt TCPStore host_name=hostname port=port world_size=world_size is_master=False timeout=timeout start_daemon = rank == TCPStore host_name=hostname port=port world_size=world_size is_master=start_daemon timeout=timeout multi_tenant=True use_libuv=use_libuv _tcp_rendezvous_handler url str timeout timedelta = default_pg_timeout kwargs _error msg _rendezvous_error tcp rendezvous + msg result = urlparse url result port None raise _error port number missing query_dict = _query_to_dict result query rank query_dict raise _error rank parameter missing world_size query_dict raise _error world size parameter missing rank = int query_dict rank world_size = int query_dict world_size use_libuv = _get_use_libuv_from_query_dict query_dict assert result hostname None store = _create_c d_store result hostname result port rank world_size timeout use_libuv yield store rank world_size If configuration invalidated there nothing we can do about raise RuntimeError Unable perform re-rendezvous using tcp method _env_rendezvous_handler url str timeout timedelta = default_pg_timeout kwargs _error msg _rendezvous_error env rendezvous + msg _env_error var _error f environment variable var expected set _get_env_or_raise env_var str - str env_val = os environ get env_var None env_val raise _env_error env_var env_val result = urlparse url query_dict = _query_to_dict result query rank int world_size int master_port int master_addr str rank query_dict rank = int query_dict rank rank = int _get_env_or_raise RANK world_size query_dict world_size = int query_dict world_size world_size = int _get_env_or_raise WORLD_SIZE master_addr = _get_env_or_raise MASTER_ADDR master_port = int _get_env_or_raise MASTER_PORT use_libuv = _get_use_libuv_from_query_dict query_dict store = _create_c d_store master_addr master_port rank world_size timeout use_libuv yield store rank world_size If configuration invalidated there nothing we can do about raise RuntimeError Unable perform re-rendezvous using env method register_rendezvous_handler tcp _tcp_rendezvous_handler register_rendezvous_handler env _env_rendezvous_handler register_rendezvous_handler file _file_rendezvous_handler