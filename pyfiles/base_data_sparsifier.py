mypy allow-untyped-defs abc copy sys warnings collections defaultdict typing Any Optional torch torch nn torch ao pruning sparsifier base_sparsifier utils torch nn utils parametrize sys warnoptions suppress repeated warnings when being used training loop warnings simplefilter once __all__ = BaseDataSparsifier EMBEDDING_TYPES = nn Embedding nn EmbeddingBag SUPPORTED_TYPES = torch Tensor nn Parameter EMBEDDING_TYPES _Container nn Module pass BaseDataSparsifier base_sparsifier BaseSparsifier r Base Data Sparsifier all Data sparsifiers The abstract accepts raw torch tensors embedding embedding bags refer SUPPORTED_TYPES above prepare sparsification In case mask parametrizations owned user Specifically container object inside maintains mask parametrizations input data Args data_list list tuples list name data tuples sparsify Lookup SUPPORTED_TYPES type data Internally container module handles data sparsification defaults dict default configurations will attached configuration Only keys don t exist ` config ` will updated Example xdoctest +SKIP data_list = tensor_ torch randn tensor_ torch randn defaults = sparsity_level sparsifier = DerivedDataSparsifier data_list = data_list defaults Some sparsifier inherits BaseDataSparsifier new_tensor_to_add = name tensor_ data torch randn sparsity_level sparsifier add_data new_tensor_to_add tensor_ tensor_ will have sparsity_level tensor_ will have sparsity_level= __init__ data_list Optional list tuple str Any = None defaults super __init__ defaults=defaults _container = _Container data_groups dict str dict = defaultdict dict name - config data_list None add data default config here add_data name data defaults name data data_list prepare model config raise NotImplementedError function undefined _extract_weight data extract weight parameter instead underlying data type data torch Tensor nn Parameter data type data EMBEDDING_TYPES data weight add_data name str data reuse_mask=True config r Configures parametrizes internal container model name data Note If data name already exists replaces data While replacing old mask reused when ` reuse_mask=True ` If ` reuse_mask=True ` then replacing data needs have same shape old data By default config replaced data used config replacing data unless something specified config dictionary type data SUPPORTED_TYPES raise AssertionError f specified data type type data supported moment local_args = copy deepcopy defaults local_args update config weight = _extract_weight data Bookkeeping container mask = local_args get mask torch ones_like weight param_class = local_args get parametrization utils FakeSparsity name state If named data already exists - replace warnings warn Replacing existing data same name - Did you mean different name stacklevel= reuse old config old_args = data_groups name local_args = copy deepcopy old_args local_args update config reuse_mask current_data = get_data name=name weight shape = current_data shape raise AssertionError retain old mask shape new data must same previous one mask = get_mask name=name reuse mask instead creating new one _delete_data name=name parameter creates deepcopy weight inside so create buffer _container register_buffer name=name tensor=weight parametrize register_parametrization _container name param_class mask state name mask = mask data_groups name = local_args getattr _container name get_data name str return_original bool = True r Returns weight tensor data Args - name name data returned - return_original returns weight tensor without applying parametrization True - returns sparsified version parametrized name data_groups raise ValueError data specified name does exist return_original parametrize is_parametrized _container name raise ValueError mask squashed - original mask value does exist data = getattr _container parametrizations name original data getattr _container name _convert_mask states sparse_coo=True r Converts mask sparse coo dense tensors depending ` sparse_coo ` argument states = copy deepcopy states state states values sparse_coo state mask = state mask to_sparse_coo state mask = state mask to_dense states state_dict r Returns state optimizer ` dict ` It contains state - contains name - mask mapping data_groups - list containing all sparsity configuration groups key name specifying name data container_state_dict - state dictionary internal container model used sparsification state = _convert_mask state state state data_groups data_groups _container _container state_dict _load_container_from_state states data_groups container_state_dict r This restores state container specifically based data present state data_groups If data parametrized then data would added container then parametrized would just add attribute container name state states items config_name = data_groups get name None config_name None raise RuntimeError f Error loading name check data such name parametrized so parametrize otherwise just set attribute continue parametrized_name = f parametrizations name original parametrized = False data = container_state_dict get name None name container_state_dict parametrization probably removed data = container_state_dict get name parametrized_name container_state_dict so weight parametrized data = container_state_dict get parametrized_name parametrized = True raise RuntimeError f Error loading name _container register_buffer name=name tensor=data parametrized register parameter parametrized mask = state get mask torch ones_like data param_class = data_groups get parametrization utils FakeSparsity change once public_api utils fixed parametrize register_parametrization _container name param_class mask load_state_dict state_dict strict=True r The load_state_dict restores state sparsifier based state_dict Args state_dict - dictionary which current sparsifier needs restored strict - If True - sparsifier reset restored exactly state state_dict If False - current sparsifier reset before loading state_dict i e data added before loading state_dict erased states = copy deepcopy state_dict state data_groups = copy deepcopy state_dict data_groups container_state_dict = copy deepcopy state_dict _container states = _convert_mask states sparse_coo=False convert sparse coo mask dense strict strict load - then reset container _container = _Container _load_container_from_state states data_groups container_state_dict strict states update state data_groups update data_groups __setstate__ state states data_groups data_groups __setstate__ state _container state If container object state then load model container_dict = state pop _container _container = _Container state state = _convert_mask state state sparse_coo=False convert sparse coo mask dense _load_container_from_state state state state data_groups container_dict __dict__ update state __getstate__ state = _convert_mask state defaults defaults state state data_groups data_groups _container _container state_dict __repr__ type ignore override format_string = __class__ __name__ + name sparse_args data_groups items format_string += \n format_string += \tData Group\n format_string += f \t name name \n key sorted sparse_args keys key == data continue format_string += f \t key sparse_args key \n format_string += format_string get_mask name str name state raise ValueError data specified name does exist state name mask squash_mask args leave_parametrized=True names=None kwargs r Squashes sparse masks into appropriate tensors Also accepts list strings squash mask If none squashes mask all keys kwargs names list strings squash mask sparsified true - applies mask before squashing false - does apply mask before squashing names None names = list data_groups keys name names parametrize remove_parametrizations _container name leave_parametrized=leave_parametrized step type ignore override enable_mask_update torch no_grad name config data_groups items get non-sparsified data data = get_data name need name mask otherwise can directly pass mask update_mask name data config abc abstractmethod update_mask name data kwargs type ignore override pass _delete_data name Detaches some data sparsifier Args name str Name data removed sparsifier Note Currently private Kind used helper function when replacing data same name squash_mask names= name leave_parametrized=False do apply mask while deleting delattr _container name state pop name data_groups pop name