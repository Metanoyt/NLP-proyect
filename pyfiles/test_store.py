Owner s oncall distributed datetime os socket struct sys tempfile threading time concurrent futures ThreadPoolExecutor datetime timedelta sys platform torch torch distributed dist torch distributed distributed_c d c d torch distributed rpc rpc torch distributed DistError DistNetworkError DistStoreError torch testing _internal common_distributed MultiThreadedTestCase torch testing _internal common_utils instantiate_parametrized_tests dist is_available print torch distributed available skipping tests file=sys stderr sys exit torch testing _internal common_utils common torch testing _internal common_distributed create_tcp_store skip_if_win tp_transports torch testing _internal common_utils ADDRESS_IN_USE CONNECT_TIMEOUT load_tests retry_on_connect_failures run_tests TestCase load_tests common_utils used automatically filter tests sharding sandcastle This line silences flake warnings load_tests = load_tests noqa PLW platform == darwin LOOPBACK = lo LOOPBACK = lo DEFAULT_HOSTNAME = localhost torch backends cuda matmul allow_tf = False device_type = acc type acc = torch accelerator current_accelerator cpu gpus_for_rank world_size Multigpu tests designed simulate multi nodes multi GPUs each node Nccl backend requires equal #GPUs each process On single node all visible GPUs evenly divided subsets each process only uses subset visible_devices = list range torch accelerator device_count gpus_per_process = torch accelerator device_count world_size gpus_for_rank = rank range world_size gpus_for_rank append visible_devices rank gpus_per_process rank + gpus_per_process gpus_for_rank StoreTestBase _create_store i raise RuntimeError implemented _test_set_get_check fs fs add key fs add key fs add key fs set key value fs add key fs set key value fs add key fs set key value fs add key fs add key fs add key fs add key assertEqual fs num_keys num_keys_total assertEqual b fs get key assertEqual b value fs get key assertEqual b value fs get key assertEqual b value fs get key assertEqual b fs get key assertTrue fs check key assertFalse fs check Randomkey fs set -key assertEqual b fs get -key fs delete_key -key assertEqual fs num_keys num_keys_total test_set_get_check _test_set_get_check _create_store _test_compare_set store missing_key_result = store compare_set cs_key wrong_old_value new_value assertEqual b wrong_old_value missing_key_result store set cs_key value assertEqual b value store get cs_key old_value_result = store compare_set cs_key wrong_old_value new_value assertEqual b value old_value_result assertEqual b value store get cs_key new_value_result = store compare_set cs_key value new_value assertEqual b new_value new_value_result assertEqual b new_value store get cs_key empty_old_value_result = store compare_set cs_key new_value assertEqual b new_value empty_old_value_result assertEqual b new_value store get cs_key test_compare_set _test_compare_set _create_store _test_simple_wait fs assertRaisesRegex RuntimeError t -i imeout fs wait bad_key timedelta seconds= fs add good_key fs wait good_key test_simple_wait _test_simple_wait _create_store _test_append store store has_extended_api Just stores don t support extended APIs store set foo po store append foo tato store append bar po store append bar tato assertEqual b potato store get foo assertEqual b potato store get bar test_append _test_append _create_store _create_store_or_skip_if_no_queues - dist Store store = _create_store try store queue_push test_queue_support except NotImplementedError skipTest Store does support queues store test_queues - None store = _create_store_or_skip_if_no_queues assertFalse store check foo assertEqual store queue_len foo store queue_push foo store queue_push foo assertTrue store check foo assertEqual store queue_len foo store wait foo assertEqual store queue_pop foo b assertEqual store queue_pop foo b assertFalse store check foo assertEqual store queue_len foo test_queues_nonblocking - None store = _create_store_or_skip_if_no_queues assertRaisesRegex dist QueueEmptyError empty store queue_pop foo block=False store queue_push foo assertEqual store queue_pop foo block=False b test_queues_bidirectional - None store = _create_store_or_skip_if_no_queues worker_a local_store = store clone local_store queue_push assertEqual local_store queue_pop b b b worker_b local_store = store clone assertEqual local_store queue_pop b local_store queue_push b b test bidirectional communication ThreadPoolExecutor max_workers= pool futures = pool submit worker_a pool submit worker_b fut futures fut result test_queues_timeout - None store = _create_store_or_skip_if_no_queues store set_timeout timedelta seconds= assertRaisesRegex DistStoreError timeout store queue_pop non_existant _test_multi_set store store has_extended_api Just stores don t support extended APIs store multi_set foo bar po tato assertEqual b po store get foo assertEqual b tato store get bar test_multi_set _test_multi_set _create_store _test_multi_get store store has_extended_api Just stores don t support extended APIs store set foo po store set bar tato v v = store multi_get foo bar assertEqual b po v assertEqual b tato v test_multi_get _test_multi_get _create_store test_clone = _create_store b = clone assertIsInstance b dist Store set foo bar assertEqual b get foo b bar This number keys used test_set_get Adding property instead hardcoding test since some Store implementations will have differing number keys In base case there will keys key key key key key property num_keys_total FileStoreTest TestCase StoreTestBase setUp super setUp file = tempfile NamedTemporaryFile delete=False _create_store store = dist FileStore file name store set_timeout timedelta seconds= store test_init_pg_and_rpc_with_same_file file = tempfile NamedTemporaryFile delete=False Init RPC using file rpc_backend_options = rpc TensorPipeRpcBackendOptions rpc_backend_options init_method = f file file name rpc_backend_options _transports = tp_transports rpc init_rpc worker rank= world_size= rpc_backend_options=rpc_backend_options Init PG using file dist init_process_group gloo rank= world_size= init_method=f file file name dist destroy_process_group assert os path exists file name rpc shutdown os remove file name test_refcount file = tempfile NamedTemporaryFile delete=False store = dist FileStore file name store = dist FileStore file name del store assert os path exists file name del store assert os path exists file name property num_keys_total skip_if_win HashStoreTest TestCase StoreTestBase _create_store store = dist HashStore store set_timeout timedelta seconds= store PrefixStoreTest TestCase setUp delete false FileStore will automatically clean up file file = tempfile NamedTemporaryFile delete=False test_get_underlying_store tcp_store = dist TCPStore host_name=DEFAULT_HOSTNAME port= world_size= is_master=True hash_store = dist HashStore file_store = dist FileStore file name world_size= store tcp_store hash_store file_store subTest f Testing getting underlying_store type store prefix_store = dist PrefixStore prefix store assertEqual prefix_store underlying_store store We do allow passing None underlying store would cause segfault used assertRaises ValueError dist PrefixStore prefix None PrefixFileStoreTest TestCase StoreTestBase setUp super setUp file = tempfile NamedTemporaryFile delete=False filestore = dist FileStore file name prefix = test_prefix filestore set_timeout timedelta seconds= _create_store dist PrefixStore prefix filestore property num_keys_total TCPStoreTest TestCase StoreTestBase _use_libuv = False _create_store store = create_tcp_store use_libuv=self _use_libuv store set_timeout timedelta seconds= store _create_store_with_ws addr world_size create_tcp_store addr world_size wait_for_workers=False use_libuv=self _use_libuv test_address_already_in_use addr = DEFAULT_HOSTNAME port = common find_free_port err_msg_reg = f ^The server socket has failed listen any local port assertRaisesRegex dist DistNetworkError err_msg_reg Use noqa silence flake Need store unused variable here ensure first object destroyed before second object created store = dist TCPStore addr port True use_libuv=self _use_libuv noqa F store = dist TCPStore addr port True use_libuv=self _use_libuv noqa F assertEqual store libuvBackend _use_libuv assertEqual store libuvBackend _use_libuv retry_on_connect_failures test_multitenancy addr = DEFAULT_HOSTNAME port = common find_free_port Use noqa silence flake Need store unused variable here ensure first object destroyed before second object created store = dist TCPStore addr port True multi_tenant=True use_libuv=self _use_libuv type ignore call-arg noqa F store = dist TCPStore addr port True multi_tenant=True use_libuv=self _use_libuv type ignore call-arg noqa F assertEqual store libuvBackend _use_libuv assertEqual store libuvBackend _use_libuv test_repr - None server store = _create_store assertRegex repr store r TCPStore\ r client=TCPClient\ SocketImpl\ fd=\d+ addr=\ localhost\ \d+ remote=\ localhost\ \d+\ \ r server=TCPServer\ port=\d+\ \ client store = dist TCPStore store host store port world_size= is_master=False assertRegex repr store r TCPStore\ r client=TCPClient\ SocketImpl\ fd=\d+ addr=\ localhost\ \d+ remote=\ localhost\ \d+\ \ r server= nullptr \ skip_if_win retry_on_connect_failures test_init_pg_and_rpc_with_same_socket addr = DEFAULT_HOSTNAME port = common find_free_port os environ MASTER_ADDR = addr os environ MASTER_PORT = str port We internally use multi-tenant TCP store Both PG RPC should successfully initialize even when using same socket address os environ USE_LIBUV = _use_libuv dist init_process_group backend= gloo init_method= env rank= world_size= backend_opts = rpc TensorPipeRpcBackendOptions init_method=f tcp addr port _transports=tp_transports rpc init_rpc name= worker rank= world_size= rpc_backend_options=backend_opts del os environ USE_LIBUV assert USE_LIBUV os environ rpc shutdown dist destroy_process_group skip_if_win test_take_over_listen_socket listen_sock socket socket = socket socket socket AF_INET socket SOCK_STREAM listen_sock bind localhost addr port _ = listen_sock getsockname listen_fd = listen_sock detach store = dist TCPStore addr port is_master=True master_listen_fd=listen_fd use_libuv=self _use_libuv assertEqual store libuvBackend _use_libuv store set key value assertEqual b value store get key The TCPStore has keys test_set_get It contains keys added user one additional key used coordinate all workers property num_keys_total _test_numkeys_delkeys fs We start off one init key store coordinate workers assertEqual fs num_keys fs add key fs add key fs add key fs set key value fs add key fs set key value assertEqual fs num_keys fs delete_key key assertEqual fs num_keys fs set_timeout timedelta seconds= assertRaises RuntimeError fs get key fs delete_key key fs delete_key key assertEqual fs num_keys fs set key value assertEqual fs num_keys assertEqual b value fs get key assertEqual b value fs get key test_numkeys_delkeys _test_numkeys_delkeys _create_store _create_client index addr port world_size client_store = dist TCPStore addr port world_size=world_size timeout=timedelta seconds= use_libuv=self _use_libuv assertEqual b value client_store get key client_store set f new_key index f new_value index assertEqual f next_value index encode client_store compare_set f new_key index f new_value index f next_value index _multi_worker_helper world_size addr = DEFAULT_HOSTNAME server_store = _create_store_with_ws addr world_size assertEqual server_store libuvBackend _use_libuv server_store set key value port = server_store port num_indices = world_size world_size i range num_indices _create_client i addr port world_size test_multi_worker_with_fixed_world_size _multi_worker_helper test_multi_worker_with_nonfixed_world_size _multi_worker_helper None test_append store = _create_store assertEqual store libuvBackend _use_libuv store set foo po store append foo tato store append bar po store append bar tato assertEqual b potato store get foo assertEqual b potato store get bar test_multi_set store = _create_store assertEqual store libuvBackend _use_libuv store multi_set foo bar po tato assertEqual b po store get foo assertEqual b tato store get bar test_multi_get store = _create_store assertEqual store libuvBackend _use_libuv store set foo po store set bar tato v v = store multi_get foo bar assertEqual b po v assertEqual b tato v test_store_timeout_on_missing_clients assertRaisesRegex DistStoreError r Timed out after \d+ seconds waiting clients \d+ \d+ clients joined world_size so should timeout dist TCPStore localhost True timeout=timedelta seconds= use_libuv=self _use_libuv when wait_for_workers set then there should no exception raised dist TCPStore localhost True timeout=timedelta seconds= wait_for_workers=False use_libuv=self _use_libuv skip_if_win test_world_size_ _raises assertRaisesRegex ValueError TCPStore world size cannot dist TCPStore localhost world_size= is_master=False test_agent_store - None store = _create_store assertRaisesRegex dist DistNetworkError The server socket has failed listen any local network address dist TCPStore host_name= localhost port=store port world_size= is_master=True use_libuv=self _use_libuv USE_AGENT_STORE = TORCHELASTIC_USE_AGENT_STORE MASTER_PORT = MASTER_PORT os environ USE_AGENT_STORE = os environ MASTER_PORT = str store port second_server = dist TCPStore host_name= localhost port=store port world_size= is_master=True use_libuv=self _use_libuv del os environ USE_AGENT_STORE del os environ MASTER_PORT assertEqual second_server port store port LibUvTCPStoreTest TCPStoreTest _use_libuv = True _create_store store = create_tcp_store use_libuv=True store set_timeout timedelta seconds= store _create_store_with_ws addr world_size create_tcp_store addr world_size wait_for_workers=False use_libuv=True PrefixTCPStoreTest TestCase StoreTestBase setUp super setUp tcpstore = create_tcp_store prefix = test_prefix tcpstore set_timeout timedelta seconds= _create_store dist PrefixStore prefix tcpstore The PrefixTCPStore has keys test_set_get It contains keys added user one additional key used coordinate all workers property num_keys_total test_underlying_non_prefix_store store = _create_store wrapped_store = dist PrefixStore prefix dist PrefixStore prefix store assertEqual tcpstore store _underlying_non_prefix_store assertEqual tcpstore wrapped_store _underlying_non_prefix_store MyPythonStore dist Store __init__ - None super __init__ store = set key value isinstance key str bytes raise AssertionError Expected set called string key type value bytes raise AssertionError Expected set called bytes value store key = value get key value = store get key b type value bytes raise AssertionError Expected get bytes value value add key value new = int store get key + value set key bytes str new encode utf- new compare_set key expected newValue type expected bytes raise AssertionError compare_set expected bytes type newValue bytes raise AssertionError compare_set newValue bytes val = store get key None expected == val val None val = store key = newValue val clone - MyPythonStore PythonStoreTest TestCase test_set_get If we inherit StoreTestBase try use its test_set_get function we would exercise Python API directly instead going through C++ trampoline We care about testing C++ trampoline so run equivalent StoreTestBase test_set_get C++ See ` torch csrc distributed c d init cpp ` definition test function dist _test_python_store MyPythonStore RendezvousTest TestCase test_unknown_handler assertRaisesRegex RuntimeError ^No rendezvous handler dist rendezvous invalid test_url_with_node_params assertRaisesRegex AssertionError has node-specific arguments dist rendezvous file foo rank= world_size= RendezvousEnvTest TestCase retry_on_connect_failures test_nominal os environ WORLD_SIZE = os environ MASTER_ADDR = os environ MASTER_PORT = str common find_free_port Single rank os environ RANK = gen = dist rendezvous env store rank size = next gen assertEqual rank assertEqual size store set key value check get assertEqual b value store get key RendezvousFileTest TestCase test_common_errors assertRaisesRegex ValueError path missing gen = dist rendezvous file rank= world_size= next gen assertRaisesRegex ValueError rank parameter missing gen = dist rendezvous file tmp foo world_size= next gen assertRaisesRegex ValueError size parameter missing gen = dist rendezvous file tmp foo rank= next gen test_nominal tempfile NamedTemporaryFile delete=False file url = f file file name replace os path sep world_size= gen = dist rendezvous url + rank= store rank size = next gen assertEqual rank assertEqual size gen = dist rendezvous url + rank= store rank size = next gen assertEqual rank assertEqual size Set value both stores store set key value store set key value Cross check get assertEqual b value store get key assertEqual b value store get key skip_if_win RendezvousTCPTest TestCase create_tcp_url addr = DEFAULT_HOSTNAME port = common find_free_port url = f tcp addr port d world_size= url test_common_errors assertRaisesRegex ValueError port number missing gen = dist rendezvous tcp rank= world_size= next gen assertRaisesRegex ValueError rank parameter missing gen = dist rendezvous tcp world_size= next gen assertRaisesRegex ValueError size parameter missing gen = dist rendezvous tcp rank= next gen test_dns_timeout assertRaisesRegex DistNetworkError client socket has timed out after dnsnotexist manager gen = dist rendezvous tcp dnsnotexist world_size= rank= timeout=timedelta seconds= next gen assertTrue isinstance manager exception DistError retry_on_connect_failures test_nominal url = create_tcp_url gen = dist rendezvous url + rank= store rank size = next gen assertEqual rank assertEqual size Set value single store store set key value check get assertEqual b value store get key retry_on_connect_failures connect_errors= CONNECT_TIMEOUT ADDRESS_IN_USE test_tcp_store_timeout_set url = create_tcp_url test_store_timeout = timedelta seconds= gen = dist rendezvous url + rank= timeout=timedelta seconds= store _ _ = next gen store set_timeout test_store_timeout should time out s If timeout passed into rendezvous respected will take much longer timeout start = time time assertRaisesRegex DistStoreError wait timeout after ms keys nonexistent key store get nonexistent key end = time time time_diff = end - start assertGreater time_diff test_tcp_store_timeout_doest_break_client url = create_tcp_url test_store_timeout = timedelta seconds= gen = dist rendezvous url + rank= timeout=timedelta seconds= store _ _ = next gen store set_timeout test_store_timeout should time out s If timeout passed into rendezvous respected will take much longer timeout start = time time assertRaisesRegex DistStoreError wait timeout after ms keys the_key store get the_key store set the_key x assertEqual b x store get the_key end = time time time_diff = end - start assertGreater time_diff test_tcp_store_url_with_libuv url = create_tcp_url gen = dist rendezvous url + rank= use_libuv= store _ _ = next gen assertTrue store libuvBackend DummyStore dist Store __init__ - None appends = multi_sets = multi_gets = multi_get_res = super __init__ append key value appends append key value multi_get keys multi_gets append keys multi_get_res pop multi_set keys values multi_sets append keys values has_extended_api True TestPythonStore TestCase test_optional_methods_fail TestStore dist Store pass store = TestStore assertFalse store has_extended_api assertRaisesRegex RuntimeError Not implemented store append foo bar assertRaisesRegex RuntimeError Not implemented store multi_get foo bar assertRaisesRegex RuntimeError Not implemented store multi_set foo bar b v b v test_has_extended_api_passthrough TestStore dist Store pass test_store = TestStore store = dist PrefixStore p test_store assertFalse store has_extended_api assertRaisesRegex RuntimeError Not implemented store append foo bar assertRaisesRegex RuntimeError Not implemented store multi_get foo bar assertRaisesRegex RuntimeError Not implemented store multi_set foo bar b v b v test_has_extended_api_roundtrip store = DummyStore prefix = dist PrefixStore p store assertTrue prefix has_extended_api test_append_roundtrip store = DummyStore prefix = dist PrefixStore p store prefix append foo bar assertEqual len store appends assertEqual p foo b bar store appends test_multi_get_roundtrip store = DummyStore prefix = dist PrefixStore p store store multi_get_res append b x b y res = prefix multi_get foo bar assertEqual len store multi_gets assertEqual p foo p bar store multi_gets assertEqual b x b y res test_multi_set_roundtrip store = DummyStore prefix = dist PrefixStore p store prefix multi_set foo bar b x b y assertEqual len store multi_sets assertEqual p foo p bar store multi_sets assertEqual b x b y store multi_sets test_extended_methods_fallbacks test_store = MyPythonStore store = dist PrefixStore p test_store assertFalse store has_extended_api store append foo b po store append foo b tato assertEqual store get foo b potato store multi_set b b c b d assertEqual store multi_get b foo b c b d b potato TestMultiThreadedWait MultiThreadedTestCase file_store = dist FileStore tempfile NamedTemporaryFile delete=False name hash_store = dist HashStore tcp_store = create_tcp_store use_libuv=False tcp_store_uv = create_tcp_store use_libuv=True property world_size setUp super setUp _spawn_threads _test_wait store store set_timeout timedelta seconds= dist get_rank == store wait key assertEqual b value store get key dist get_rank == store set key value test_wait_hash_store _test_wait hash_store test_wait_file_store _test_wait file_store test_wait_prefix_file_store store = dist PrefixStore pre file_store _test_wait store _test_wait_tcp_store master_store store = master_store dist get_rank == dist TCPStore host_name=master_store host port=master_store port is_master=False wait_for_workers=False use_libuv=False _test_wait store prefix_store = dist PrefixStore pre store _test_wait prefix_store test_wait_tcp_store _test_wait_tcp_store tcp_store test_wait_tcp_store_uv _test_wait_tcp_store tcp_store_uv instantiate_parametrized_tests TestMultiThreadedWait skip_if_win TimeoutTest TestCase tearDown signal super tearDown signal signal signal SIGUSR signal SIG_IGN test_interrupt_doesnt_break_wait signal rank_res = None None run rank my_store nonlocal rank_res try rank == time sleep my_store set foo bar my_store wait foo datetime timedelta seconds= rank_res rank = True except Error e noqa F rank_res rank = e time sleep rank _store = dist TCPStore host_name=DEFAULT_HOSTNAME port= world_size= is_master=True wait_for_workers=False rank _store = dist TCPStore host_name=DEFAULT_HOSTNAME port=rank _store port world_size= is_master=False wait_for_workers=False threads = i range t = threading Thread target=run args= i rank _store rank _store i t start threads append t handler b pass signal signal signal SIGUSR handler time sleep signal pthread_kill threads ident signal SIGUSR t threads t join assertTrue rank_res rank assertTrue rank_res rank InitPgWithNonUvStore TestCase This test shows how use legacy TCPStore non-libuv backend since libuv now default backend tearDown super tearDown os environ pop USE_LIBUV None os environ pop MASTER_ADDR None os environ pop MASTER_PORT None test_with_url_param port = common find_free_port dist init_process_group gloo rank= world_size= init_method=f tcp DEFAULT_HOSTNAME port use_libuv= _run_test test_with_env_var port = common find_free_port os environ USE_LIBUV = os environ MASTER_ADDR = DEFAULT_HOSTNAME os environ MASTER_PORT = str port dist init_process_group gloo rank= world_size= init_method= env _run_test _run_test pg = dist group WORLD store = c d _get_process_group_store pg assertTrue isinstance store dist PrefixStore c d does multiple levels wrapping while isinstance store dist PrefixStore store = store underlying_store assertTrue isinstance store dist TCPStore assertFalse store libuvBackend dist destroy_process_group TestClientProtocol TestCase test_client_connect - None sock = socket socket socket AF_INET socket SOCK_STREAM sock bind localhost port = sock getsockname listen - None sock listen conn _ = sock accept VALIDATE x C F CE assertEqual conn recv b \x \xce\xf \x \x c PING data = conn recv assertEqual data nonce = struct unpack i data assertEqual nonce os getpid send PING nonce response conn sendall data conn close thread = threading Thread target=listen thread start dist TCPStore host_name= localhost port=port world_size= is_master=False timeout=timedelta seconds= wait_for_workers=False thread join __name__ == __main__ device_type = cpu assert torch get_device_module _initialized f test_distributed must have initialized device_type context main process run_tests