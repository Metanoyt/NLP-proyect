Owner s oncall package deploy importlib io BytesIO textwrap dedent unittest skipIf torch nn torch package EmptyMatchError Importer PackageExporter PackageImporter torch package package_exporter PackagingError torch testing _internal common_utils IS_WINDOWS run_tests try common PackageTestCase except ImportError Support case where we run file directly common PackageTestCase TestDependencyAPI PackageTestCase Dependency management API tests - mock - extern - deny test_extern buffer = BytesIO PackageExporter buffer he he extern package_a subpackage module_a he save_source_string foo package_a subpackage module_a buffer seek hi = PackageImporter buffer module_a package_a subpackage module_a_im = hi import_module module_a hi import_module package_a subpackage package_a_im = hi import_module package_a assertIs module_a module_a_im assertIsNot package_a package_a_im assertIs package_a subpackage package_a_im subpackage test_extern_glob buffer = BytesIO PackageExporter buffer he he extern package_a module_ he save_module package_a he save_source_string test_module dedent \ package_a subpackage module_a buffer seek hi = PackageImporter buffer module_a package_a subpackage module_a_im = hi import_module module_a hi import_module package_a subpackage package_a_im = hi import_module package_a assertIs module_a module_a_im assertIsNot package_a package_a_im assertIs package_a subpackage package_a_im subpackage test_extern_glob_allow_empty Test error thrown when extern glob specified allow_empty=True no matching module required during packaging package_a subpackage noqa F buffer = BytesIO assertRaisesRegex EmptyMatchError r did match any modules PackageExporter buffer exporter exporter extern include= package_b allow_empty=False exporter save_module package_a subpackage test_deny Test marking packages deny during export buffer = BytesIO assertRaisesRegex PackagingError denied PackageExporter buffer exporter exporter deny package_a subpackage module_a exporter save_source_string foo package_a subpackage test_deny_glob Test marking packages deny using globs instead package names buffer = BytesIO assertRaises PackagingError PackageExporter buffer exporter exporter deny package_a module_ exporter save_source_string test_module dedent \ package_a subpackage module_a test_mock buffer = BytesIO PackageExporter buffer he he mock package_a subpackage module_a Import something dependso n package_a subpackage he save_source_string foo package_a subpackage buffer seek hi = PackageImporter buffer package_a subpackage _ = package_a subpackage module_a _ = module_a m = hi import_module package_a subpackage r = m result assertRaisesRegex NotImplementedError mocked out r test_mock_glob buffer = BytesIO PackageExporter buffer he he mock package_a module he save_module package_a he save_source_string test_module dedent \ package_a subpackage module_a buffer seek hi = PackageImporter buffer package_a subpackage _ = package_a subpackage module_a _ = module_a m = hi import_module package_a subpackage r = m result assertRaisesRegex NotImplementedError mocked out r test_mock_glob_allow_empty Test error thrown when mock glob specified allow_empty=True no matching module required during packaging package_a subpackage noqa F buffer = BytesIO assertRaisesRegex EmptyMatchError r did match any modules PackageExporter buffer exporter exporter mock include= package_b allow_empty=False exporter save_module package_a subpackage test_pickle_mocked package_a subpackage obj = package_a subpackage PackageASubpackageObject obj = package_a PackageAObject obj buffer = BytesIO assertRaises PackagingError PackageExporter buffer he he mock include= package_a subpackage he intern he save_pickle obj obj pkl obj test_pickle_mocked_all package_a subpackage obj = package_a subpackage PackageASubpackageObject obj = package_a PackageAObject obj buffer = BytesIO PackageExporter buffer he he intern include= package_a he mock he save_pickle obj obj pkl obj test_allow_empty_with_error If error occurs during packaging should shadowed allow_empty error buffer = BytesIO assertRaises ModuleNotFoundError PackageExporter buffer pe Even though we did extern module matches pattern we want show save_module error allow_empty error pe extern foo allow_empty=False pe save_module aodoifjodisfj will error we never get here so technically allow_empty check should raise error However error above more informative what s actually going wrong packaging pe save_source_string bar foo\n test_implicit_intern The save_module APIs should implicitly intern module being saved package_a noqa F buffer = BytesIO PackageExporter buffer he he save_module package_a test_intern_error Failure handle all dependencies should lead error package_a subpackage obj = package_a subpackage PackageASubpackageObject obj = package_a PackageAObject obj buffer = BytesIO assertRaises PackagingError e PackageExporter buffer he he save_pickle obj obj pkl obj assertEqual str e exception dedent Module did match against any action pattern Extern mock intern package_a package_a subpackage Set debug=True when invoking PackageExporter visualization where broken modules coming Interning all dependencies should work PackageExporter buffer he he intern package_a package_a subpackage he save_pickle obj obj pkl obj skipIf IS_WINDOWS extension modules have different file extension windows test_broken_dependency A unpackageable dependency should raise PackagingError create_module name spec = importlib machinery ModuleSpec name is_package=False type ignore arg-type module = importlib util module_from_spec spec ns = module __dict__ ns __spec__ = spec ns __loader__ = ns __file__ = f name so ns __cached__ = None module BrokenImporter Importer __init__ - None modules = foo create_module foo bar create_module bar import_module module_name modules module_name buffer = BytesIO assertRaises PackagingError e PackageExporter buffer importer=BrokenImporter exporter exporter intern foo bar exporter save_source_string my_module foo bar assertEqual str e exception dedent Module C extension module torch package supports Python modules only foo bar Set debug=True when invoking PackageExporter visualization where broken modules coming test_invalid_import An incorrectly-formed should raise PackagingError buffer = BytesIO assertRaises PackagingError e PackageExporter buffer exporter This will fail load exporter save_source_string foo lol assertEqual str e exception dedent Dependency resolution failed foo Context attempted relative beyond top-level package Set debug=True when invoking PackageExporter visualization where broken modules coming test_repackage_mocked_module Re-packaging package contains mocked module should work correctly buffer = BytesIO PackageExporter buffer exporter exporter mock package_a exporter save_source_string foo package_a buffer seek importer = PackageImporter buffer foo = importer import_module foo package_a should mocked out assertRaises NotImplementedError foo package_a get_something Re-package model intern previously-mocked module mock everything buffer = BytesIO PackageExporter buffer importer=importer exporter exporter intern package_a exporter mock exporter save_source_string foo package_a buffer seek importer = PackageImporter buffer foo = importer import_module foo package_a should still mocked out assertRaises NotImplementedError foo package_a get_something test_externing_c_extension Externing c extensions modules should allow us still access them especially those found torch _C buffer = BytesIO The C extension module question F gelu which comes torch _C _nn model = torch nn TransformerEncoderLayer d_model= nhead= dim_feedforward= dropout= batch_first=True activation= gelu norm_first=True PackageExporter buffer e e extern torch e intern e save_pickle model model pkl model buffer seek imp = PackageImporter buffer imp load_pickle model model pkl __name__ == __main__ run_tests