Owner s oncall pt functools itertools math pickle sys collections abc Callable sympy torch torch fx fx sympy core relational is_ge is_gt is_le is_lt torch testing _internal common_device_type skipIf torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests TEST_Z TestCase torch utils _sympy functions FloorDiv Identity OpaqueUnaryFn_cos BitwiseFn_bitwise_and simple_floordiv_gcd torch utils _sympy interp sympy_interp torch utils _sympy numbers int_oo IntInfinity NegativeIntInfinity torch utils _sympy reference PythonReferenceAnalysis ReferenceAnalysis TensorReferenceAnalysis torch utils _sympy singleton_int SingletonInt torch utils _sympy solve INEQUALITY_TYPES mirror_rel_op try_solve torch utils _sympy value_ranges ValueRanges torch _inductor bounds ValueRangeAnalysis torch _inductor index_propagation TypedExpr UNARY_OPS = reciprocal square abs neg exp log sqrt floor ceil BINARY_OPS = truediv floordiv truncdiv TODO NB pow float_pow add mul sub pow pow_by_natural minimum maximum mod bitwise_and bitwise_or BITWISE_OPS = bitwise_and bitwise_or UNARY_BOOL_OPS = not_ BINARY_BOOL_OPS = or_ and_ COMPARE_OPS = eq ne lt gt le ge mix constants powers two primes CONSTANTS = - - sys maxsize - sys maxsize less constants N^ situations LESS_CONSTANTS = - SymPy relational types RELATIONAL_TYPES = sympy Eq sympy Ne sympy Gt sympy Ge sympy Lt sympy Le valid_unary fn v fn == log v = False fn == reciprocal v == False fn == sqrt v False True valid_binary fn b fn == pow sympy will expand x x integral b don t do s big b no imaginary numbers = undefined == b == False fn == pow_by_natural sympy will expand x x integral b don t do s big b b == b == False fn == mod b = False fn div truediv floordiv b == False True generate_range vals itertools product vals repeat= sympy true sympy false == sympy true == sympy false continue continue ranges only admit infinite values interesting == sympy oo == -sympy oo continue yield ValueRanges TestNumbers TestCase test_int_infinity assertIsInstance int_oo IntInfinity assertIsInstance -int_oo NegativeIntInfinity assertTrue int_oo is_integer tests here singleton-ness don t use comparisons against numbers assertIs int_oo + int_oo int_oo assertIs int_oo + int_oo assertIs int_oo - int_oo assertIs -int_oo - -int_oo assertIs -int_oo + -int_oo assertIs -int_oo + -int_oo -int_oo assertIs -int_oo - int_oo -int_oo assertIs + int_oo int_oo assertIs - int_oo -int_oo assertIs int_oo int_oo int_oo assertIs int_oo int_oo assertIs int_oo int_oo assertIs - int_oo -int_oo assertIs -int_oo int_oo -int_oo assertIs -int_oo -int_oo assertIs -int_oo -int_oo assertIs - -int_oo int_oo assertIs int_oo sympy oo assertIs - -int_oo int_oo noqa B assertIs abs int_oo int_oo assertIs abs -int_oo int_oo assertIs int_oo int_oo assertIs -int_oo int_oo assertIs -int_oo -int_oo assertEqual int_oo - assertEqual -int_oo - assertIs int_oo int_oo int_oo assertTrue int_oo == int_oo assertFalse int_oo = int_oo assertTrue -int_oo == -int_oo assertFalse int_oo == assertTrue int_oo = assertFalse int_oo == sys maxsize assertTrue int_oo = sys maxsize assertTrue int_oo = assertTrue int_oo = -int_oo test_relation assertIs sympy Add int_oo int_oo assertFalse -int_oo test_lt_self assertFalse int_oo int_oo assertIs min -int_oo - -int_oo assertIs min -int_oo -int_oo -int_oo test_float_cast assertEqual float int_oo math inf assertEqual float -int_oo -math inf test_mixed_oo_int_oo Arbitrary choice assertTrue int_oo sympy oo assertFalse int_oo sympy oo assertTrue sympy oo int_oo assertFalse sympy oo int_oo assertIs max int_oo sympy oo sympy oo assertTrue -int_oo -sympy oo assertIs min -int_oo -sympy oo -sympy oo TestValueRanges TestCase parametrize fn UNARY_OPS parametrize dtype int float test_unary_ref fn dtype dtype = int sympy Integer float sympy Float dtype v CONSTANTS valid_unary fn v continue subTest v=v v = dtype v ref_r = getattr ReferenceAnalysis fn v r = getattr ValueRangeAnalysis fn v assertEqual r lower is_integer r upper is_integer assertEqual r lower r upper assertEqual ref_r is_integer r upper is_integer assertEqual ref_r r lower test_pow_half ValueRangeAnalysis pow ValueRanges unknown ValueRanges wrap parametrize fn BINARY_OPS parametrize dtype int float test_binary_ref fn dtype to_dtype = int sympy Integer float sympy Float Don t test bitwise methods since value range analysis singleton range may singleton result fn BITWISE_OPS Don t test float int only methods dtype == float fn pow_by_natural mod dtype = to_dtype dtype b itertools product CONSTANTS repeat= valid_binary fn b continue = dtype b = dtype b subTest a=a b=b r = getattr ValueRangeAnalysis fn b r == ValueRanges unknown continue ref_r = getattr ReferenceAnalysis fn b assertEqual r lower is_integer r upper is_integer assertEqual ref_r is_integer r upper is_integer assertEqual r lower r upper assertEqual ref_r r lower test_mul_zero_unknown assertEqual ValueRangeAnalysis mul ValueRanges wrap ValueRanges unknown ValueRanges wrap assertEqual ValueRangeAnalysis mul ValueRanges wrap ValueRanges unknown ValueRanges wrap parametrize fn UNARY_BOOL_OPS test_unary_bool_ref_range fn vals = sympy false sympy true generate_range vals subTest a=a ref_r = getattr ValueRangeAnalysis fn unique = set vals continue subTest =a r = getattr ReferenceAnalysis fn assertIn r ref_r unique add r ref_r lower == ref_r upper assertEqual len unique assertEqual len unique parametrize fn BINARY_BOOL_OPS + BITWISE_OPS test_binary_bool_ref_range fn vals = sympy false sympy true b itertools product generate_range vals repeat= subTest a=a b=b ref_r = getattr ValueRangeAnalysis fn b unique = set b itertools product vals repeat= b b continue subTest =a b =b r = getattr ReferenceAnalysis fn b assertIn r ref_r unique add r ref_r lower == ref_r upper assertEqual len unique assertEqual len unique parametrize fn UNARY_OPS test_unary_ref_range fn TODO bring back sympy oo testing float unary fns vals = CONSTANTS generate_range vals subTest a=a ref_r = getattr ValueRangeAnalysis fn CONSTANTS continue valid_unary fn continue subTest =a r = getattr ReferenceAnalysis fn sympy Integer assertIn r ref_r This takes about s all variants parametrize fn BINARY_OPS + COMPARE_OPS test_binary_ref_range fn TODO bring back sympy oo testing float unary fns vals = LESS_CONSTANTS b itertools product generate_range vals repeat= don t attempt pow exponents too large oo OK fn == pow b upper b upper = sympy oo continue subTest a=a b=b b itertools product LESS_CONSTANTS repeat= b b continue valid_binary fn b continue subTest =a b =b ref_r = getattr ValueRangeAnalysis fn b r = getattr ReferenceAnalysis fn sympy Integer sympy Integer b r is_finite assertIn r ref_r stronger test specially bitwise ops parametrize fn BITWISE_OPS test_bitwise_ref_range fn N^ complexity vals = range - b itertools product generate_range vals repeat= subTest a=a b=b b itertools product vals repeat= b b continue subTest =a b =b ref_r = getattr ValueRangeAnalysis fn b r = getattr ReferenceAnalysis fn b assertIn r ref_r test bitwise ops can take bool arguments bool_vals = sympy true sympy false sympy true sympy false sympy true sympy true sympy true sympy false sympy false sympy true sympy false sympy false b bool_vals subTest a=a b=b ref_r = getattr ValueRangeAnalysis fn b r = getattr ReferenceAnalysis fn b assertIn r ref_r TestSympyInterp TestCase parametrize fn UNARY_OPS + BINARY_OPS + UNARY_BOOL_OPS + BINARY_BOOL_OPS + COMPARE_OPS test_interp fn SymPy does implement truncation Expressions fn div truncdiv minimum maximum mod is_integer = None fn == pow_by_natural is_integer = True x = sympy Dummy x integer=is_integer y = sympy Dummy y integer=is_integer vals = CONSTANTS fn UNARY_BOOL_OPS BINARY_BOOL_OPS vals = True False fn BITWISE_OPS vals = vals + True False arity = fn BINARY_OPS BINARY_BOOL_OPS COMPARE_OPS arity = symbols = x arity == symbols = x y args itertools product vals repeat=arity arity == valid_unary fn args continue arity == valid_binary fn args continue subTest args=args sargs = sympy sympify args sympy_expr = getattr ReferenceAnalysis fn symbols ref_r = getattr ReferenceAnalysis fn sargs Yes I know long-winded way saying xreplace point test sympy_interp r = sympy_interp ReferenceAnalysis dict zip symbols sargs sympy_expr assertEqual ref_r r parametrize fn UNARY_OPS + BINARY_OPS + UNARY_BOOL_OPS + BINARY_BOOL_OPS + COMPARE_OPS test_python_interp_fx fn These never show up symbolic_shapes fn log exp Sympy does support truncation symbolic shapes fn truncdiv mod vals = CONSTANTS fn UNARY_BOOL_OPS BINARY_BOOL_OPS vals = True False fn BITWISE_OPS vals = vals + True False arity = fn BINARY_OPS BINARY_BOOL_OPS COMPARE_OPS arity = is_integer = None fn == pow_by_natural is_integer = True x = sympy Dummy x integer=is_integer y = sympy Dummy y integer=is_integer symbols = x arity == symbols = x y args itertools product vals repeat=arity arity == valid_unary fn args continue arity == valid_binary fn args continue fn == truncdiv args == continue fn pow pow_by_natural args == args = continue fn == floordiv args == continue subTest args=args Workaround mpf symbol error fn == minimum sympy_expr = sympy Min x y fn == maximum sympy_expr = sympy Max x y sympy_expr = getattr ReferenceAnalysis fn symbols arity == trace_f px sympy_interp PythonReferenceAnalysis x px sympy_expr trace_f px py sympy_interp PythonReferenceAnalysis x px y py sympy_expr gm = fx symbolic_trace trace_f assertEqual sympy_interp PythonReferenceAnalysis dict zip symbols args sympy_expr gm args parametrize fn UNARY_OPS + BINARY_OPS + UNARY_BOOL_OPS + BINARY_BOOL_OPS + COMPARE_OPS test_tensor_interp fn Skip operations implemented applicable tensors fn div truncdiv int_truediv mod round_decimal is_integer = None fn == pow_by_natural is_integer = True x = sympy Symbol x integer=is_integer y = sympy Symbol y integer=is_integer vals = CONSTANTS fn UNARY_BOOL_OPS BINARY_BOOL_OPS vals = True False fn BITWISE_OPS vals = vals + True False arity = fn BINARY_OPS BINARY_BOOL_OPS COMPARE_OPS arity = symbols = x arity == symbols = x y args itertools product vals repeat=arity arity == valid_unary fn args continue arity == valid_binary fn args continue subTest args=args tensor_args = torch tensor dtype=torch double isinstance float torch int args try tensor_fn = getattr TensorReferenceAnalysis fn sympy_expr = getattr ReferenceAnalysis fn symbols direct_result = tensor_fn tensor_args interp_result = sympy_interp TensorReferenceAnalysis dict zip symbols tensor_args sympy_expr Ensure both results same dtype comparison direct_result dtype = interp_result dtype direct_result dtype == torch bool interp_result dtype == torch bool direct_result = direct_result torch bool interp_result = interp_result torch bool direct_result = direct_result torch double interp_result = interp_result torch double assertTrue torch allclose direct_result interp_result rtol= e- atol= e- f Mismatch fn args direct= direct_result interp= interp_result fn UNARY_BOOL_OPS + BINARY_BOOL_OPS + COMPARE_OPS assertEqual direct_result dtype torch bool assertEqual interp_result dtype torch bool fn floor_to_int ceil_to_int round_to_int trunc_to_int assertEqual direct_result dtype torch int assertEqual interp_result dtype torch int except NotImplementedError print f Operation fn implemented TensorReferenceAnalysis except Exception e fail f Unexpected error fn args str e type_name_fn type type - str type __name__ parametrize_relational_types types wrapper f Callable parametrize op types RELATIONAL_TYPES name_fn=type_name_fn f wrapper TestSympySolve TestCase _create_integer_symbols - list sympy Symbol sympy symbols b c integer=True test_give_up sympy Eq Ne b c = _create_integer_symbols cases = Not relational operation + b appears both sides Eq + doesn t appear neither side Eq b c + Result sympy And Eq FloorDiv b c Result sympy Or Ne FloorDiv b c case cases e = try_solve case assertEqual e None parametrize_relational_types test_noop op b _ = _create_integer_symbols lhs rhs = b expr = op lhs rhs r = try_solve expr assertNotEqual r None r_expr r_rhs = r assertEqual r_expr expr assertEqual r_rhs rhs parametrize_relational_types test_noop_rhs op b _ = _create_integer_symbols lhs rhs = b mirror = mirror_rel_op op assertNotEqual mirror None expr = op lhs rhs r = try_solve expr assertNotEqual r None r_expr r_rhs = r assertEqual r_expr mirror rhs lhs assertEqual r_rhs lhs _test_cases cases list tuple sympy Basic sympy Basic thing sympy Basic op type sympy Rel kwargs source expected cases r = try_solve source thing kwargs assertTrue r None expected None r None expected None r None r_expr r_rhs = r assertEqual r_rhs expected assertEqual r_expr op thing expected test_addition sympy Eq b c = _create_integer_symbols cases = Eq + b -b Eq + b - b - Eq + c b - c b _test_cases cases Eq parametrize_relational_types sympy Eq sympy Ne test_multiplication_division op b c = _create_integer_symbols cases = op b b op b - b - op b c c b _test_cases cases op parametrize_relational_types INEQUALITY_TYPES test_multiplication_division_inequality op b _ = _create_integer_symbols intneg = sympy Symbol neg integer=True negative=True intpos = sympy Symbol pos integer=True positive=True cases = Divide multiply both sides positive number op intpos intpos op intpos intpos op b - b - b strictly positive nor negative so we can t divide multiply both sides b op b None op b None op b intpos None mirror_cases = Divide multiply both sides negative number op intneg intneg op intneg intneg op - b - - b - mirror_op = mirror_rel_op op assert mirror_op None _test_cases cases op _test_cases mirror_cases mirror_op parametrize_relational_types test_floordiv op sympy Eq Ge Gt Le Lt Ne b c = sympy symbols b c pos = sympy Symbol pos positive=True integer = sympy Symbol integer integer=True Eq FloorDiv pos integer And Ge integer pos Lt integer + pos Eq FloorDiv + pos integer And Ge integer pos Lt integer + pos Ne FloorDiv pos integer Or Lt integer pos Ge integer + pos special_case = FloorDiv turns into And which can t simplified any further Eq Eq FloorDiv pos integer None FloorDiv turns into Or which can t simplified any further Ne Ne FloorDiv pos integer None Gt Gt FloorDiv pos integer integer + pos Ge Ge FloorDiv pos integer integer pos Lt Lt FloorDiv pos integer integer pos Le Le FloorDiv pos integer integer + pos op cases list tuple sympy Basic sympy Basic = b strictly positive op FloorDiv b integer None c strictly positive op FloorDiv pos c None The result might change after FloorDiv transformation Specifically - Ge Gt = Ge - Le Lt = Lt op sympy Gt sympy Ge r_op = sympy Ge op sympy Lt sympy Le r_op = sympy Lt r_op = op _test_cases special_case cases r_op _test_cases special_case None cases r_op floordiv_inequality=False test_floordiv_eq_simplify sympy Eq Le Lt = sympy Symbol positive=True integer=True check expr expected r = try_solve expr assertNotEqual r None r_expr _ = r assertEqual r_expr expected + == ===================================== = + always true + sure check Eq FloorDiv + Lt + - + == ===================================== = - sure - always true check Eq FloorDiv - Le - - skipIf TEST_Z Z installed test_z _proof_floordiv_eq_simplify z sympy Eq Lt = sympy Symbol positive=True integer=True a_ = z Int + == ===================================== = + always true + sure solver = z SolverFor QF_NRA Add assertions a_ solver add a_ expr = Eq FloorDiv + r_expr _ = try_solve expr Check try_solve really returns expected below expected = Lt + - assertEqual r_expr expected Check whether there integer a_ such equation below satisfied solver add expr z ToInt a_ + == = expected a_ + - Assert there s no such integer i e transformation sound r = solver check assertEqual r z unsat test_simple_floordiv_gcd x y z = sympy symbols x y z positive tests assertEqual simple_floordiv_gcd x x x assertEqual simple_floordiv_gcd x assertEqual simple_floordiv_gcd x + y assertEqual simple_floordiv_gcd x + y + z assertEqual simple_floordiv_gcd x x x assertEqual simple_floordiv_gcd x x x assertEqual simple_floordiv_gcd x y x x assertEqual simple_floordiv_gcd x y x y x y assertEqual simple_floordiv_gcd x y x x negative tests assertEqual simple_floordiv_gcd x y + x + y + x + TestSympyFunctions TestCase test_pickle x = OpaqueUnaryFn_cos sympy Symbol r = pickle loads pickle dumps x assertEqual x r x = BitwiseFn_bitwise_and sympy Symbol sympy Symbol b r = pickle loads pickle dumps x assertEqual x r TestSingletonInt TestCase test_basic j = SingletonInt coeff= j _copy = SingletonInt coeff= j = SingletonInt coeff= j x = SingletonInt coeff= test_eq b expected assertEqual sympy Eq b expected assertEqual sympy Ne b expected eq ne test_eq j j True test_eq j j _copy True test_eq j j False test_eq j j x False test_eq j sympy Integer False test_eq j sympy Integer False test_ineq b expected strict=True greater = sympy Gt is_gt strict sympy Ge is_ge less = sympy Lt is_lt strict sympy Le is_le isinstance expected bool expected always True fn greater assertEqual fn b expected assertEqual fn b expected fn less assertEqual fn b expected assertEqual fn b expected fn greater assertRaisesRegex ValueError expected fn b fn less assertRaisesRegex ValueError expected fn b ge le gt lt strict True False _test_ineq = functools partial test_ineq strict=strict _test_ineq j sympy Integer True _test_ineq j sympy Integer indeterminate _test_ineq j j indeterminate _test_ineq j x j True Special cases ge le gt lt ge sympy Ge is_ge assertTrue ge j j assertTrue ge j sympy Integer assertRaisesRegex ValueError indeterminate ge sympy Integer j le sympy Le is_le assertTrue le j j assertTrue le sympy Integer j assertRaisesRegex ValueError indeterminate le j sympy Integer gt sympy Gt is_gt assertFalse gt j j assertFalse gt sympy Integer j only known j = j indeterminate assertRaisesRegex ValueError indeterminate gt j sympy Integer lt sympy Lt is_lt assertFalse lt j j assertFalse lt j sympy Integer assertRaisesRegex ValueError indeterminate lt sympy Integer j mul assertEqual j j x Unfortunately doesn t automatically simplify j since sympy Mul doesn t trigger __mul__ unlike above assertIsInstance sympy Mul j sympy core mul Mul assertRaisesRegex ValueError cannot multiplied j j assertEqual j free_symbols set TestIdentity TestCase test_expand_identity Test removing identity via expansion x = sympy Symbol x arg = x + sympy S One expr = Identity arg expanded = expr expand identity=True assertEqual expanded count Identity assertEqual expanded arg test_cast_identity_int num = expr = Identity num assertEqual num int expr test_cast_identity_float num = expr = Identity num assertEqual num float expr test_cast_identity_illegal sym = Identity sympy Symbol x assertRaises TypeError int sym assertRaises TypeError float sym tup = tup_I = Identity tup assertRaises TypeError int tup_I assertRaises TypeError float tup_I TestTypedExpr TestCase test_typed_expr I = Identity typed_I = TypedExpr I torch int assertEqual typed_I expr instantiate_parametrized_tests TestValueRanges instantiate_parametrized_tests TestSympyInterp instantiate_parametrized_tests TestSympySolve __name__ == __main__ run_tests