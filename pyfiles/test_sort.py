======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_sort py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests __TestCase = CPythonTestCase redirect statements sys importlib abc redirect_imports = test mapping_tests test typinganndata test test_grammar test test_math test test_iter test typinganndata ann_module RedirectImportFinder importlib abc MetaPathFinder find_spec fullname path target=None Check problematic one fullname redirect_imports try Attempt standalone module name = fullname removeprefix test r = importlib import_module name Redirect module sys modules sys modules fullname = r Return module spec found module importlib util find_spec name except ImportError None None Add custom finder sys meta_path sys meta_path insert RedirectImportFinder ======= END DYNAMO PATCH ======= test support random unittest functools cmp_to_key verbose = support verbose nerrors = check tag expected raw compare=None global nerrors verbose print checking tag orig = raw save input case error compare raw sort key=cmp_to_key compare raw sort len expected = len raw print error tag print length mismatch len expected len raw print expected print orig print raw nerrors += i good enumerate expected maybe = raw i good maybe print error tag print out order index i good maybe print expected print orig print raw nerrors += TestBase __TestCase testStressfully Try variety sizes around powers powers sizes = power range n = power sizes extend range n- n+ sizes extend torch _dynamo error_on_graph_break False Complains object maybe_complain = True __init__ i i = i __lt__ other Complains maybe_complain random random verbose print complaining other raise RuntimeError i other i __repr__ Complains d i Stable object __init__ key i key = key index = i __lt__ other key other key __repr__ Stable d d key index n sizes x = list range n verbose print Testing size n s = x check identity x s s = x s reverse check reversed x s s = x random shuffle s check random permutation x s y = x y reverse s = x check reversed via function y s lambda b b - b verbose print Checking against insane comparison function print If implementation isn t careful may segfault s = x s sort key=cmp_to_key lambda b int random random - check insane function left some permutation x s len x = bad_key x raise RuntimeError s = x assertRaises RuntimeError s sort key=bad_key x = Complains i i x s = x random shuffle s Complains maybe_complain = True it_complained = False try s sort except RuntimeError it_complained = True it_complained Complains maybe_complain = False check exception during sort left some permutation x s s = Stable random randrange i i range n augmented = e e index e s augmented sort forced stable because ties broken index x = e e i augmented stable sort s check stability x s test_small_stability itertools product operator itemgetter Exhaustively test stability across all lists small lengths only few distinct elements This can provoke edge cases randomization unlikely find But can grow very expensive quickly so don t overdo NELTS = MAXSIZE = pick = itemgetter length range MAXSIZE + There NELTS length distinct lists t product range NELTS repeat=length xs = list zip t range length Stability forced index each element forced = sorted xs Use key= hide index compares native = sorted xs key=pick assertEqual forced native #============================================================================== TestBugs __TestCase test_bug bug -- list sort crasher If fails most likely outcome core dump Mutations during list sort should raise ValueError torch _dynamo error_on_graph_break False C __lt__ other L random random L pop L append random random L = C i range assertRaises ValueError L sort test_undetected_mutation Python did always detect mutation memorywaster = i range mutating_cmp x y L append L pop x y - x y L = assertRaises ValueError L sort key=cmp_to_key mutating_cmp mutating_cmp x y L append del L x y - x y assertRaises ValueError L sort key=cmp_to_key mutating_cmp memorywaster = memorywaster #============================================================================== TestDecorateSortUndecorate __TestCase test_decorated data = The quick Brown fox Jumped over The lazy Dog split copy = data random shuffle data data sort key=str lower my_cmp x y xlower ylower = x lower y lower xlower ylower - xlower ylower copy sort key=cmp_to_key my_cmp test_baddecorator data = The quick Brown fox Jumped over The lazy Dog split assertRaises TypeError data sort key=lambda x y test_stability data = random randrange i i range copy = data data sort key=lambda t t sort random first field copy sort sort using both fields assertEqual data copy should get same result test_key_with_exception Verify wrapper has been removed data = list range - dup = data assertRaises ZeroDivisionError data sort key=lambda x x assertEqual data dup test_key_with_mutation data = list range k x del data data = range x assertRaises ValueError data sort key=k test_key_with_mutating_del data = list range torch _dynamo error_on_graph_break False SortKiller object __init__ x pass __del__ del data data = range __lt__ other id id other assertRaises ValueError data sort key=SortKiller test_key_with_mutating_del_and_exception data = list range ## dup = data torch _dynamo error_on_graph_break False SortKiller object __init__ x x raise RuntimeError __del__ del data data = list range assertRaises RuntimeError data sort key=SortKiller ## major honking subtlety we can t do ## ## assertEqual data dup ## ## because there reference SortKiller ## traceback time dies we re outside call ## sort so list protection gimmicks out ## date cost some brain cells figure out test_reverse data = list range random shuffle data data sort reverse=True assertEqual data list range - - test_reverse_stability data = random randrange i i range copy = data copy = data my_cmp x y x y = x y x y - x y my_cmp_reversed x y x y = x y y x - y x data sort key=cmp_to_key my_cmp reverse=True copy sort key=cmp_to_key my_cmp_reversed assertEqual data copy copy sort key=lambda x x reverse=True assertEqual data copy #============================================================================== check_against_PyObject_RichCompareBool L ## The idea here exploit fact unsafe_tuple_compare uses ## PyObject_RichCompareBool second elements tuples So we have ## most L sorted L == y y sorted x x L ## This will work long __eq__ = __lt__ all objects L ## which holds all types used below ## ## Testing way ensures optimized implementation remains consistent ## naive implementation even changes made any ## richcompares ## ## This function tests sorting three lists randomly shuffles each one ## L ## x x L ## x x L random seed random shuffle L L_ = L L_ = x x L L_ = x x L L L_ L_ L_ optimized = sorted L reference = y y sorted x x L opt ref zip optimized reference assertIs opt ref #note assertEqual We want ensure identical behavior TestOptimizedCompares __TestCase test_safe_object_compare heterogeneous_lists = foo foo foo foo L heterogeneous_lists assertRaises TypeError L sort assertRaises TypeError x x L sort assertRaises TypeError x x L sort float_int_lists = L float_int_lists check_against_PyObject_RichCompareBool L test_unsafe_object_compare This test ppperry It ensures unsafe_object_compare verifying ms- key_richcompare == tp- richcompare before comparing torch _dynamo error_on_graph_break False WackyComparator int __lt__ other elem __class__ = WackyList int __lt__ other WackyList list pass WackyList list __lt__ other raise ValueError L = WackyList WackyComparator i i i range elem = L - assertRaises ValueError L sort L = WackyList WackyComparator i i i range elem = L - assertRaises ValueError x x L sort The following test also ppperry It ensures unsafe_object_compare handles Py_NotImplemented appropriately torch _dynamo error_on_graph_break False PointlessComparator __lt__ other NotImplemented L = PointlessComparator PointlessComparator assertRaises TypeError L sort assertRaises TypeError x x L sort The following tests go through various types would trigger ms- key_compare = unsafe_object_compare lists = list range + str x x range + \uffff bytes x x range cmp_to_key lambda x y x y x x range L lists check_against_PyObject_RichCompareBool L test_unsafe_latin_compare check_against_PyObject_RichCompareBool str x x range test_unsafe_long_compare check_against_PyObject_RichCompareBool x x range test_unsafe_float_compare check_against_PyObject_RichCompareBool float x x range test_unsafe_tuple_compare This test suggested Tim Peters It verifies tuple comparison respects current tuple compare semantics which do guarantee x x = x x Note we don t have put anything tuples here because check function does tuple test automatically check_against_PyObject_RichCompareBool float nan check_against_PyObject_RichCompareBool float nan _ range test_not_all_tuples assertRaises TypeError False A sort assertRaises TypeError sort assertRaises TypeError sort test_none_in_tuples expected = None None actual = sorted None None assertEqual actual expected #============================================================================== __name__ == __main__ run_tests