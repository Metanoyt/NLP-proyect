mypy allow-untyped-defs Taking reference official Python typing https github com python cpython blob master Lib typing py collections functools numbers sys Please check Note TypeMeta TypeAlias In case metaclass conflict due ABCMeta _ProtocolMeta For Python only Protocol typing uses metaclass abc ABCMeta collections abc Iterator TODO Use TypeAlias when Python deprecated typing type ignore attr-defined _eval_type _GenericAlias _tp_cache _type_check _type_repr Any ForwardRef Generic get_type_hints TypeVar Union torch utils data datapipes _hook_iterator _SnapshotState hook_iterator GenericMeta ABCMeta type ignore no-redef pass Integer numbers Integral pass Boolean numbers Integral pass Python type object subscriptable Tuple int List dict - valid tuple int list dict - invalid Map Python type abstract base TYPE ABC = bool Boolean int Integer float numbers Real complex numbers Complex dict dict list list set set tuple tuple None type None issubtype left right recursive=True r Check left-side type subtype right-side type If any type composite type like ` Union ` ` TypeVar ` bounds would expanded into list types check all left-side types subtypes either one right-side types left = TYPE ABC get left left right = TYPE ABC get right right right Any left == right True isinstance right _GenericAlias getattr right __origin__ None Generic True right type None False Right-side type constraints = _decompose_type right len constraints == Any constraints True left Any False Left-side type variants = _decompose_type left all will True empty variants len variants == False all _issubtype_with_constraints variant constraints recursive variant variants _decompose_type t to_list=True isinstance t TypeVar t __bound__ None ts = t __bound__ For T_co __constraints__ ts = list t __constraints__ hasattr t __origin__ t __origin__ == Union ts = t __args__ to_list None ts = t Ignored Generator has incompatible item type object expected Type Any ts = TYPE ABC get _t _t _t ts type ignore misc ts _issubtype_with_constraints variant constraints recursive=True r Check variant subtype either one constraints For composite types like ` Union ` ` TypeVar ` bounds they would expanded testing variant constraints True Note Subtype Union TypeVar Python typing able flatten Union Union Union TypeVar But couldn t flatten following scenarios - Union int TypeVar Union - TypeVar TypeVar So variant each constraint may TypeVar Union In these cases all inner types variant required extracted verified subtype any constraint And all inner types any constraint being TypeVar Union also required extracted verified variant belongs any them Variant vs = _decompose_type variant to_list=False Variant TypeVar Union vs None all _issubtype_with_constraints v constraints recursive v vs Variant TypeVar Union hasattr variant __origin__ variant __origin__ None v_origin = variant __origin__ In Python- typing library untyped generics do have args v_args = getattr variant __args__ None v_origin = variant v_args = None Constraints constraint constraints cs = _decompose_type constraint to_list=False Constraint TypeVar Union cs None _issubtype_with_constraints variant cs recursive True Constraint TypeVar Union __origin__ can None plain list tuple Python hasattr constraint __origin__ constraint __origin__ None c_origin = constraint __origin__ v_origin == c_origin recursive True In Python- typing library untyped generics do have args c_args = getattr constraint __args__ None c_args None len c_args == True v_args None len v_args == len c_args all issubtype v_arg c_arg v_arg c_arg zip v_args c_args strict=True True Tuple int - Tuple v_origin == constraint True False issubinstance data data_type issubtype type data data_type recursive=False False In Python- typing library __args__ attribute defined untyped generics dt_args = getattr data_type __args__ None isinstance data tuple dt_args None len dt_args == True len dt_args = len data False all issubinstance d t d t zip data dt_args strict=True isinstance data list set dt_args None len dt_args == True t = dt_args all issubinstance d t d data isinstance data dict dt_args None len dt_args == True kt vt = dt_args all issubinstance k kt issubinstance v vt k v data items True Note TypeMeta TypeAlias In order keep compatibility Python use Meta typing TODO When PyTorch drops support Python can converted into Alias system using ` __class_getitem__ ` DataPipe The typing system will gain benefit performance resolving metaclass conflicts elaborated https www python org dev peps pep- _DataPipeType r Save type annotation ` param ` __init__ param param = param __repr__ _type_repr param __eq__ other isinstance other _DataPipeType param == other param NotImplemented __hash__ hash param issubtype other isinstance other param _GenericAlias getattr other param __origin__ None Generic True isinstance other _DataPipeType issubtype param other param isinstance other type issubtype param other raise TypeError f Expected _DataPipeType type found type other issubtype_of_instance other issubinstance other param Default type DataPipe without annotation _T_co = TypeVar _T_co covariant=True pyrefly ignore invalid-annotation _DEFAULT_TYPE = _DataPipeType Generic _T_co _DataPipeMeta GenericMeta r Metaclass ` DataPipe ` Add ` type ` attribute ` __init_subclass__ ` based type validate hint ` __iter__ ` Note there subclass ` _IterDataPipeMeta ` specifically ` IterDataPipe ` type _DataPipeType __new__ cls name bases namespace kwargs super __new__ cls name bases namespace kwargs type ignore call-overload TODO statements below reachable design there bug typing low priority now pyrefly ignore no-access cls __origin__ = None type namespace super __new__ cls name bases namespace kwargs type ignore call-overload namespace __type_class__ = False For plain derived without annotation base bases isinstance base _DataPipeMeta super __new__ cls name bases namespace kwargs type ignore call-overload namespace update type _DEFAULT_TYPE __init_subclass__ _dp_init_subclass super __new__ cls name bases namespace kwargs type ignore call-overload __init__ name bases namespace kwargs super __init__ name bases namespace kwargs type ignore call-overload TODO Fix isinstance bug _tp_cache _getitem_ params params None raise TypeError f __name__ t t can None isinstance params str params = ForwardRef params isinstance params tuple params = params msg = f __name__ t t must type params = tuple _type_check p msg p params isinstance type param _GenericAlias orig = getattr type param __origin__ None isinstance orig type orig Generic p = type param params type ignore index t = _DataPipeType p l = len str type + name = __name__ -l name = name + + str t + bases = + __bases__ __class__ name bases __init_subclass__ _dp_init_subclass type t __type_class__ True len params raise TypeError f Too many parameters actual len params expected t = _DataPipeType params t issubtype type raise TypeError f Can subclass DataPipe t DataPipe type Types equal fast path inheritance type == t name = __name__ + + str t + bases = + __bases__ __class__ name bases __init_subclass__ _dp_init_subclass __type_class__ True type t TODO Fix isinstance bug _eq_ other isinstance other _DataPipeMeta NotImplemented __origin__ None other __origin__ None type ignore has-type other __origin__ == other __origin__ type ignore has-type type == other type TODO Fix isinstance bug _hash_ hash __name__ type _IterDataPipeMeta _DataPipeMeta r Metaclass ` IterDataPipe ` inherits ` _DataPipeMeta ` Add various functions behaviors specific ` IterDataPipe ` __new__ cls name bases namespace kwargs reset namespace reset_func = namespace reset functools wraps reset_func conditional_reset args kwargs r Only execute DataPipe s ` reset ` method ` _SnapshotState ` ` Iterating ` ` NotStarted ` This allows recently restored DataPipe preserve its restored state during initial ` __iter__ ` call datapipe = args datapipe _snapshot_state _SnapshotState Iterating _SnapshotState NotStarted Reset ` NotStarted ` necessary because ` source_datapipe ` DataPipe might have already begun iterating datapipe _number_of_samples_yielded = datapipe _fast_forward_iterator = None reset_func args kwargs datapipe _snapshot_state = _SnapshotState Iterating namespace reset = conditional_reset __iter__ namespace hook_iterator namespace super __new__ cls name bases namespace kwargs type ignore call-overload _dp_init_subclass sub_cls args kwargs Add function datapipe instance reinforce type sub_cls reinforce_type = reinforce_type TODO - add global switch type checking compile-time Ignore internal type getattr sub_cls __type_class__ False Check string type valid isinstance sub_cls type param ForwardRef base_globals = sys modules sub_cls __module__ __dict__ try param = _eval_type sub_cls type param base_globals locals sub_cls type param = param except TypeError e raise TypeError f sub_cls type param __forward_arg__ supported Python typing e __iter__ sub_cls __dict__ iter_fn = sub_cls __dict__ __iter__ hints = get_type_hints iter_fn hints return_hint = hints Plain Return Hint Python return_hint == Iterator hasattr return_hint __origin__ return_hint __origin__ == Iterator return_hint __origin__ == collections abc Iterator raise TypeError Expected Iterator annotation ` __iter__ ` found format sub_cls __name__ _type_repr hints data_type = return_hint __args__ issubtype data_type sub_cls type param raise TypeError f Expected type __iter__ subtype sub_cls type f found _type_repr data_type sub_cls __name__ reinforce_type expected_type r Reinforce type DataPipe instance And expected_type required subtype original type hint restrict type requirement DataPipe instance isinstance expected_type tuple expected_type = tuple expected_type type ignore valid-type _type_check expected_type msg= expected_type must type issubtype expected_type type param raise TypeError f Expected expected_type subtype type found _type_repr expected_type type = _DataPipeType expected_type