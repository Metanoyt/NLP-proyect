mypy ignore-errors Dictionary-related variable tracking classes PyTorch Dynamo This module implements variable tracking different types dictionary-like objects - Regular Python dictionaries dict - Ordered dictionaries collections OrderedDict - Default dictionaries collections defaultdict - Dictionary views keys values - Sets frozensets implemented internally using dictionaries These classes responsible tracking dictionary operations during graph compilation maintaining proper guards dictionary mutations key existence checks They handle dictionary creation modification key value access view operations while ensuring correct behavior compiled code through appropriate guard installation The implementation uses special _HashableTracker wrapper handle dictionary keys while preserving proper aliasing semantics Sets implemented dictionaries None values efficiency code reuse collections functools inspect operator types collections abc Hashable py_Hashable typing Optional TYPE_CHECKING torch _subclasses fake_tensor is_fake graph_break_hints polyfills variables bytecode_transformation create_call_function create_instruction exc raise_observed_exception unimplemented_v guards GuardBuilder install_guard source is_constant_source is_from_local_source utils cmp_name_to_op_mapping dict_items dict_keys dict_values istype raise_args_mismatch specialize_symnode base ValueMutationNew VariableTracker constant ConstantVariable lists ListIteratorVariable TYPE_CHECKING torch _dynamo codegen PyCodegen torch _dynamo symbolic_convert InstructionTranslator Adding new supported within keys ConstDictVariable - Add its tracker type is_hashable - perhaps Define how compared _HashableTracker _eq_impl was_instancecheck_override obj type obj __dict__ get __instancecheck__ False raise_unhashable arg tx=None tx None torch _dynamo symbolic_convert InstructionTranslator tx = InstructionTranslator current_tx raise_observed_exception TypeError tx args= ConstantVariable f unhashable type type arg realize is_hashable x NB - performing isinstance check LazVT realizes VT accidentally inserting guard To avoid lazyVT ` is_hashable ` methods looks underlying value without realizing VT Consider updating lazyVT ` is_hashable ` method you see unnecessary guarding key VT isinstance x variables LazyVariableTracker x is_realized x is_hashable True isinstance x variables TensorVariable Tensors hashable they have example_value fake tensor Most VT s should have one It d nice some point we could assert they all have one x as_proxy node meta get example_value None isinstance x variables TupleVariable all is_hashable e e x items isinstance x variables FrozenDataClassVariable all is_hashable e e x fields values isinstance x variables UserDefinedObjectVariable was_instancecheck_override x value inspect getattr_static x value __hash__ int __hash__ isinstance x value int isinstance x value py_Hashable isinstance x variables BuiltinVariable variables SymNodeVariable variables ConstantVariable variables EnumVariable variables FrozensetVariable variables UserDefinedClassVariable variables UserFunctionVariable variables SkipFunctionVariable variables misc NumpyVariable variables NNModuleVariable variables UnspecializedNNModuleVariable variables MethodWrapperVariable variables TorchInGraphFunctionVariable variables TypingVariable variables FunctoolsPartialVariable variables WeakRefVariable variables TorchHigherOrderOperatorVariable ConstDictVariable VariableTracker CONTAINS_GUARD = GuardBuilder DICT_CONTAINS _nonvar_fields = user_cls VariableTracker _nonvar_fields _HashableTracker Auxiliary opaque internal wraps VariableTracker makes hashable This should seen touched anything outside ConstDictVariable its children Note s also fine put VTs into dictionaries sets doing so does take into account aliasing __init__ vt - None We specialize SymNodes vt = specialize_symnode vt TODO Temporarily remove figure out what keys we breaking add proper support them is_hashable vt raise_unhashable vt vt = vt property underlying_value isinstance vt variables LazyVariableTracker vt is_realized vt is_hashable vt original_value isinstance vt variables TensorVariable x = vt as_proxy node meta example_value isinstance vt variables TupleVariable Hashable = ConstDictVariable _HashableTracker x = tuple Hashable e underlying_value e vt items isinstance vt variables NNModuleVariable vt value isinstance vt variables UnspecializedNNModuleVariable vt value isinstance vt variables UserFunctionVariable vt get_function isinstance vt variables WeakRefVariable Access underlying value inside referent_vt key representation Hashable = ConstDictVariable _HashableTracker Hashable vt referent_vt underlying_value isinstance vt variables FrozenDataClassVariable Hashable = ConstDictVariable _HashableTracker fields_values = k Hashable v underlying_value k v vt fields items variables FrozenDataClassVariable HashWrapper vt python_type fields_values isinstance vt variables UserDefinedObjectVariable The re module Python + has dictionary _cache object key ` _ZeroSentinel int ` python test dynamo test_unittest py CPythonTestLongMessage test_baseAssertEqual vt value x = vt as_python_constant x __hash__ hash underlying_value staticmethod _eq_impl b TODO Put utils share between variables builtin py here type_a type_b = type type b issubclass type_a type_b issubclass type_b type_a False isinstance tuple Hashable = ConstDictVariable _HashableTracker len == len b all Hashable _eq_impl u v u v zip b is_fake b == b __eq__ other ConstDictVariable _HashableTracker - bool Hashable = ConstDictVariable _HashableTracker assert isinstance other Hashable ConstantVariable is_literal other type other isinstance other Hashable Hashable _eq_impl underlying_value other underlying_value constant Hashable _eq_impl underlying_value other __init__ items dict VariableTracker VariableTracker user_cls=dict kwargs - None clone pass these arguments kwargs they re recreated few lines below original_items kwargs kwargs pop original_items should_reconstruct_all kwargs kwargs pop should_reconstruct_all super __init__ kwargs Hashable = ConstDictVariable _HashableTracker Keys will just HashableTrackers when cloning any other case they ll VariableTrackers assert all isinstance x VariableTracker Hashable isinstance v VariableTracker x v items items make_hashable key key isinstance key Hashable Hashable key dict_cls = _get_dict_cls_from_user_cls user_cls items = dict_cls make_hashable x v x v items items need reconstruct everything dictionary intermediate value pop delitem executed should_reconstruct_all = is_from_local_source source original_items = items copy user_cls = user_cls _get_dict_cls_from_user_cls user_cls accepted_dict_types = dict collections OrderedDict collections defaultdict avoid executing user code user_cls dict subclass user_cls accepted_dict_types dict_cls = user_cls Subclass dict object dict_cls = next base base user_cls __mro__ base accepted_dict_types assert dict_cls accepted_dict_types dict_cls Use dict instead call defaultdict make_hashable x v would fail defaultdict expects callable first argument dict_cls collections defaultdict dict_cls = dict dict_cls as_proxy k vt as_proxy v as_proxy k v items items debug_repr + join f k vt debug_repr v debug_repr k v items items + as_python_constant k vt as_python_constant v as_python_constant k v items items keys_as_python_constant install_dict_keys_match_guard k vt as_python_constant v k v items items python_type user_cls __contains__ vt - bool assert isinstance vt VariableTracker Hashable = ConstDictVariable _HashableTracker is_hashable vt Hashable vt items isinstance items Hashable vt variables DeletedVariable len - int sum isinstance x variables DeletedVariable x items values has_new_items - bool should_reconstruct_all any is_new_item original_items get key vt value key value items items is_new_item value other compare id realized values both values lazy VTs value value is_realized other is_realized id value realize = id other realize id value = id other reconstruct_kvs_into_new_dict codegen Build dictionary contains keys values num_args = key value items items We can safely call realize here won t introduce any new guards item = original_items get key vt is_new_item item value should_reconstruct_all codegen key vt codegen value num_args += codegen append_output create_instruction BUILD_MAP arg=num_args reconstruct codegen PyCodegen user_cls collections OrderedDict emit ` OrderedDict constructed_dict ` codegen add_push_null lambda codegen extend_output codegen create_load_python_module collections codegen create_load_attr OrderedDict reconstruct_kvs_into_new_dict codegen codegen extend_output create_call_function False reconstruct_kvs_into_new_dict codegen getitem_const_raise_exception_if_absent tx InstructionTranslator arg VariableTracker key = ConstDictVariable _HashableTracker arg key items raise_observed_exception KeyError tx items key getitem_const tx InstructionTranslator arg VariableTracker key = ConstDictVariable _HashableTracker arg key items msg = f Dictionary key arg value found during tracing unimplemented_v gb_type= key found dict context=f Key arg value explanation=msg hints= Check key exists dictionary before accessing graph_break_hints USER_ERROR items key maybe_getitem_const arg VariableTracker key = ConstDictVariable _HashableTracker arg key items None items key realize_key_vt arg VariableTracker Realize LazyVT particular index assert arg key = ConstDictVariable _HashableTracker arg index = tuple items keys index key original_key_vt = tuple original_items keys index isinstance original_key_vt variables LazyVariableTracker original_key_vt realize install_dict_keys_match_guard source install_guard make_guard GuardBuilder DICT_KEYS_MATCH install_dict_contains_guard tx args Key guarding - These cases consider The dict has been mutated In case we would have already inserted DICT_KEYS_MATCH guard so we can skip args source None This happens const keys Here we have insert DICT_CONTAINS guard args source None This can happen non-const VTs contains=True In case we can access lazyVT original_items selectively realize b contains=False There no easy way selectively apply DICT_NOT_CONTAINS guard because our guard represented via trees Be conservative add DICT_KEYS_MATCH guard ConstantVariable source tx output side_effects is_modified contains = args args source None isinstance args ConstantVariable install_guard make_guard functools partial type CONTAINS_GUARD key=args value invert=not contains args source contains realize_key_vt args install_dict_keys_match_guard call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker NB - Both key value LazyVariableTrackers beginning So we have insert guards when dict method accessed For simple we conservative overguard We skip guard only get __getitem__ because key guard will inserted corresponding value VT For __contains__ we add DICT_CONTAINS guard But all other methods we insert DICT_KEYS_MATCH guard conservative BuiltinVariable ConstantVariable Hashable = ConstDictVariable _HashableTracker arg_hashable = args is_hashable args name == __init__ temp_dict_vt = variables BuiltinVariable dict call_dict tx args kwargs tx output side_effects mutation items update temp_dict_vt items ConstantVariable create None name == __getitem__ Key guarding - Nothing do LazyVT value will take care len args = raise_args_mismatch tx name args f len args args getitem_const_raise_exception_if_absent tx args name == items args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs install_dict_keys_match_guard source tx output guard_on_key_order add source DictItemsVariable name == keys len args raise_args_mismatch tx name args f len args args install_dict_keys_match_guard source tx output guard_on_key_order add source DictKeysVariable name == values args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs install_dict_keys_match_guard source tx output guard_on_key_order add source args kwargs raise_observed_exception TypeError tx DictValuesVariable name == copy install_dict_keys_match_guard args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs clone items=self items copy mutation_type=ValueMutationNew source=None name == __len__ args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs install_dict_keys_match_guard ConstantVariable create len items name == __setitem__ is_mutable arg_hashable raise_unhashable args install_dict_keys_match_guard kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs tx output side_effects mutation items Hashable args = args ConstantVariable create None name == __delitem__ arg_hashable is_mutable install_dict_keys_match_guard should_reconstruct_all = True tx output side_effects mutation items __delitem__ Hashable args ConstantVariable create None name == get len args raise_args_mismatch tx name args f len args args arg_hashable raise_unhashable args args install_dict_contains_guard tx args len args == default given None ConstantVariable create None args Key guarding - Nothing do getitem_const tx args name == pop is_mutable len args raise_args_mismatch tx name args f len args args arg_hashable raise_unhashable args args missing item default value Install no DICT_CONTAINS guard install_dict_contains_guard tx args len args == default given raise KeyError raise_observed_exception KeyError tx args should_reconstruct_all = True tx output side_effects mutation items pop Hashable args name == popitem is_mutable issubclass user_cls dict issubclass user_cls collections OrderedDict len args raise_args_mismatch tx name items msg = ConstantVariable create popitem dictionary empty raise_observed_exception KeyError tx args= msg user_cls collections OrderedDict len args == last kwargs len args == isinstance args ConstantVariable last = args value v = kwargs get last isinstance v ConstantVariable last = v value raise_args_mismatch tx name k v = items popitem last=last k v = items popitem should_reconstruct_all = True tx output side_effects mutation variables TupleVariable k vt v name == clear args kwargs raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs should_reconstruct_all = True tx output side_effects mutation items clear ConstantVariable create None name == update is_mutable In general call looks like ` update b x= y= ` Either ` b ` kwargs omittable both install_dict_keys_match_guard has_arg = len args == has_kwargs = len kwargs has_arg has_kwargs tx output side_effects mutation has_arg isinstance args ConstDictVariable NB - Guard all keys other dict ensure correctness args install_dict_keys_match_guard dict_vt = args dict_vt = BuiltinVariable call_custom_dict tx dict args items update dict_vt items has_kwargs Handle kwargs kwargs = Hashable ConstantVariable create k v k v kwargs items items update kwargs ConstantVariable create None super call_method tx name args kwargs name == __contains__ len args raise_args_mismatch tx name more than args kwargs f len args args len kwargs kwargs arg_hashable raise_unhashable args install_dict_contains_guard tx args contains = args ConstantVariable create contains name == setdefault is_mutable len args raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs arg_hashable raise_unhashable args install_dict_keys_match_guard kwargs len args raise_args_mismatch tx name most args kwargs f len args args len kwargs kwargs value = maybe_getitem_const args value None value len args == x = ConstantVariable create None x = args tx output side_effects mutation items Hashable args = x x name == move_to_end install_dict_keys_match_guard tx output side_effects mutation args raise_observed_exception KeyError tx last = True len args == isinstance args ConstantVariable last = args value kwargs last kwargs isinstance kwargs last ConstantVariable last = kwargs get last value key = Hashable args items move_to_end key last=last ConstantVariable create None name == __eq__ istype ConstDictVariable don t let Set use function len args = raise_args_mismatch tx name args f len args args variables UserFunctionVariable polyfills dict___eq__ call_function tx args name == __ne__ ConstantVariable create call_method tx __eq__ args kwargs value name == __or__ len args = raise_args_mismatch tx name args f len args args other = args Method resolution binops works follow using __or__ example dict __or__ dict = dict dict __or__ subclass NotImplemented Check subclass implements __ror__ = forward call subclass __ror__ dict Let s forward call __ror__ yet because __ror__ can implemented C i e OrderedDict subclass which Dynamo cannot trace istype other variables UserDefinedDictVariable other call_obj_hasattr tx __ror__ value other call_method tx __ror__ kwargs The three dict types Dynamo can handle dict OrderedDict defaultdict TODO guilhermeleobas check should builtin py call_or_ istype other ConstDictVariable variables UserDefinedDictVariable msg = f unsupported operand type s &#124; python_type __name__ f other python_type __name__ raise_observed_exception TypeError tx args= msg OrderedDict overloads __ror__ ts = user_cls other user_cls user_cls = collections OrderedDict any issubclass t collections OrderedDict t ts dict install_dict_keys_match_guard new_dict_vt = clone items=self items copy mutation_type=ValueMutationNew source=None user_cls=user_cls NB - Guard all keys other dict ensure correctness args install_dict_keys_match_guard new_dict_vt items update args items new_dict_vt name == __ior__ call_method tx update args kwargs name == __iter__ source is_constant_source source tx output guard_on_key_order add source ListIteratorVariable unpack_var_sequence tx mutation_type=ValueMutationNew super call_method tx name args kwargs unpack_var_sequence tx install_dict_keys_match_guard x vt x items keys call_obj_hasattr tx name dict allow setting arbitrary attributes OrderedDict defaultdict allow arbitrary setattr deletion default attrs any user_cls t t dict collections OrderedDict collections defaultdict hasattr user_cls name ConstantVariable create True user_cls dict ConstantVariable create False msg = f hasattr user_cls supported unimplemented_v gb_type= unsupported hasattr operation context=f Class user_cls explanation=msg hints= Consider using regular dictionary instead graph_break_hints SUPPORTABLE clone kwargs install_dict_keys_match_guard super clone kwargs MappingProxyVariable VariableTracker proxies original dict_vt __init__ dv_dict ConstDictVariable kwargs - None super __init__ kwargs assert isinstance dv_dict ConstDictVariable dv_dict = dv_dict python_type types MappingProxyType unpack_var_sequence tx dv_dict unpack_var_sequence tx reconstruct codegen PyCodegen load types MappingProxyType source msg = f Preexisting MappingProxyVariable source source cannot reconstructed because connection original dict will lost unimplemented_v gb_type= mapping proxy cannot reconstructed context=f Source source explanation=msg hints= Use mapping proxy constructed same ` torch compile ` region graph_break_hints SUPPORTABLE codegen add_push_null lambda codegen extend_output codegen create_load_python_module types codegen create_load_attr MappingProxyType codegen dv_dict codegen extend_output create_call_function False call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker source tx output side_effects has_existing_dict_mutation msg = A dict has been modified while we have existing mappingproxy object A mapping proxy object name suggest proxies mapping object usually dict If original dict object mutates reflected proxy object well For existing proxy object we do know original dict points Therefore correctness we graph break when there dict mutation we trying access proxy object unimplemented_v gb_type= mapping proxy affected dictionary mutation context=f Source source Dict mutation detected explanation=msg hints= Avoid modifying dictionaries might referenced mapping proxy objects Or avoid using mapping proxy objects after modifying its underlying dictionary dv_dict call_method tx name args kwargs call_obj_hasattr tx InstructionTranslator name str - VariableTracker python_type types MappingProxyType ConstantVariable create name types MappingProxyType __dict__ super call_obj_hasattr tx name NNModuleHooksDictVariable ConstDictVariable Special avoid adding any guards nn module hook ids install_dict_keys_match_guard pass install_dict_contains_guard tx args pass DefaultDictVariable ConstDictVariable __init__ items user_cls default_factory=None kwargs - None super __init__ items user_cls kwargs assert user_cls collections defaultdict default_factory = default_factory is_python_constant Return false unsupported defaults This ensures bad handler path taken BuiltinVariable getitem default_factory list tuple dict items False super is_python_constant debug_repr f defaultdict default_factory debug_repr super debug_repr staticmethod is_supported_arg arg isinstance arg variables BuiltinVariable arg fn list tuple dict set isinstance arg variables functions BaseUserFunctionVariable call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __getitem__ len args = raise_args_mismatch tx name args f len args args args getitem_const tx args default_factory None raise KeyError f args default_var = default_factory call_function tx super call_method tx __setitem__ args default_var kwargs default_var super call_method tx name args kwargs reconstruct codegen emit ` defaultdict default_factory new_dict ` codegen add_push_null lambda codegen extend_output codegen create_load_python_module collections codegen create_load_attr defaultdict codegen default_factory reconstruct_kvs_into_new_dict codegen codegen extend_output create_call_function False TODO Implementing via inheritance rather than composition footgun because method calls dict will route back set implementation which almost assuredly wrong SetVariable ConstDictVariable We model sets dictionary None values CONTAINS_GUARD = GuardBuilder SET_CONTAINS __init__ items list VariableTracker kwargs - None items = dict fromkeys items SetVariable _default_value super __init__ items kwargs debug_repr items set + join k vt debug_repr k items keys + property set_items set items keys staticmethod _default_value Variable fill he keys dictionary ConstantVariable create None as_proxy k vt as_proxy k set_items python_type set as_python_constant k vt as_python_constant k set_items reconstruct codegen PyCodegen codegen foreach x vt x set_items codegen append_output create_instruction BUILD_SET arg=len set_items _fast_set_method tx fn args kwargs try res = fn x as_python_constant x args k v as_python_constant k v kwargs items except Exception exc raise_observed_exception type exc tx args=list map ConstantVariable create exc args VariableTracker build tx res call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker We forward calls dictionary model utils check_constant_args name isdisjoint union intersection difference symmetric_difference check_constant_args args kwargs python_type set py_type = python_type _fast_set_method tx getattr py_type name args kwargs name == __init__ temp_set_vt = variables BuiltinVariable set call_set tx args kwargs tx output side_effects mutation items clear items update temp_set_vt items ConstantVariable create None name == add kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs name = __setitem__ args = args SetVariable _default_value name == pop kwargs args raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs Choose item random pop via Dict pop method try result = set_items pop vt except KeyError e raise_observed_exception KeyError tx args=list map ConstantVariable create e args super call_method tx name result kwargs result name == isdisjoint kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs variables UserFunctionVariable polyfills set_isdisjoint call_function tx args name == intersection kwargs raise_args_mismatch tx name kwargs f len kwargs kwargs variables UserFunctionVariable polyfills set_intersection call_function tx args name == intersection_update kwargs raise_args_mismatch tx name kwargs f len kwargs kwargs variables UserFunctionVariable polyfills set_intersection_update call_function tx args name == union kwargs raise_args_mismatch tx name kwargs f len kwargs kwargs variables UserFunctionVariable polyfills set_union call_function tx args name == difference kwargs raise_args_mismatch tx name f Expect kwargs Actual len kwargs kwargs variables UserFunctionVariable polyfills set_difference call_function tx args name == difference_update kwargs raise_args_mismatch tx name kwargs f len kwargs kwargs variables UserFunctionVariable polyfills set_difference_update call_function tx args name == symmetric_difference kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs variables UserFunctionVariable polyfills set_symmetric_difference call_function tx args name == symmetric_difference_update kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs variables UserFunctionVariable polyfills set_symmetric_difference_update call_function tx args name == update is_mutable kwargs raise_args_mismatch tx name kwargs f len kwargs kwargs variables UserFunctionVariable polyfills set_update call_function tx args name == remove kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs args raise_observed_exception KeyError tx args=args super call_method tx pop args kwargs name == discard kwargs len args = raise_args_mismatch tx name args kwargs f len args args len kwargs kwargs args super call_method tx pop args kwargs ConstantVariable create value=None name issubset issuperset len args = raise_args_mismatch tx name args f len args args op = issubset operator le issuperset operator ge other = args realize istype other SetVariable other = variables BuiltinVariable set call_function tx other variables BuiltinVariable op get name call_function tx other name __and__ __or__ __xor__ __sub__ m = __and__ intersection __or__ union __xor__ symmetric_difference __sub__ difference get name isinstance args SetVariable variables UserDefinedSetVariable msg = ConstantVariable create f unsupported operand type s name python_type_name args python_type_name raise_observed_exception TypeError tx args= msg call_method tx m args kwargs name __iand__ __ior__ __ixor__ __isub__ isinstance args SetVariable variables UserDefinedSetVariable msg = ConstantVariable create f unsupported operand type s name python_type_name args python_type_name raise_observed_exception TypeError tx args= msg m = __iand__ intersection_update __ior__ update __ixor__ symmetric_difference_update __isub__ difference_update get name call_method tx m args kwargs name == __eq__ isinstance args SetVariable variables UserDefinedSetVariable ConstantVariable create False r = call_method tx symmetric_difference args kwargs ConstantVariable create len r set_items == name cmp_name_to_op_mapping isinstance args SetVariable variables UserDefinedSetVariable ConstantVariable create NotImplemented ConstantVariable create cmp_name_to_op_mapping name set_items args set_items super call_method tx name args kwargs getitem_const tx InstructionTranslator arg VariableTracker raise RuntimeError Illegal getitem set install_dict_keys_match_guard Already EQUALS_MATCH guarded pass install_dict_contains_guard tx args super install_dict_contains_guard tx args FrozensetVariable SetVariable __init__ items list VariableTracker kwargs - None super __init__ items kwargs debug_repr items frozenset + join k vt debug_repr k items keys + property set_items items keys python_type frozenset as_python_constant frozenset k vt as_python_constant k set_items reconstruct codegen PyCodegen codegen foreach x vt x set_items codegen add_push_null lambda codegen extend_output codegen create_load_global frozenset codegen extend_output create_call_function False call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name add pop update remove discard clear raise RuntimeError f Illegal call_method name frozenset name == __init__ frozenset immutable Calling __init__ again shouldn t have any effect In s = frozenset In s __init__ In s frozenset ConstantVariable create None name copy difference intersection symmetric_difference r = super call_method tx name args kwargs FrozensetVariable r items super call_method tx name args kwargs DictKeySetVariable SetVariable __init__ items list VariableTracker kwargs - None super __init__ items kwargs debug_repr items dict_keys dict_keys + join k vt debug_repr k items keys + install_dict_keys_match_guard Already EQUALS_MATCH guarded pass install_dict_contains_guard tx args Already EQUALS_MATCH guarded pass property set_items items python_type dict_keys as_python_constant dict fromkeys k vt as_python_constant k set_items None keys call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name add pop update remove discard clear raise RuntimeError f Illegal call_method name dict_keys super call_method tx name args kwargs DictViewVariable VariableTracker Models _PyDictViewObject This abstract Subclasses will override kv items method kv Optional str = None __init__ dv_dict ConstDictVariable kwargs - None super __init__ kwargs assert kv keys values items assert isinstance dv_dict ConstDictVariable dv_dict = dv_dict property view_items getattr dv_dict items kv property view_items_vt Returns iterable unpacked items Implement subclasses raise NotImplementedError unpack_var_sequence tx view_items_vt reconstruct codegen PyCodegen codegen dv_dict codegen load_method kv codegen call_method call_obj_hasattr tx name name python_type __dict__ ConstantVariable create True ConstantVariable create False call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __len__ dv_dict call_method tx name args kwargs name == __iter__ ListIteratorVariable view_items_vt mutation_type=ValueMutationNew super call_method tx name args kwargs DictKeysVariable DictViewVariable kv = keys property set_items set view_items property view_items_vt Returns iterable unpacked items x vt x view_items python_type dict_keys call_method tx name args list VariableTracker kwargs dict str VariableTracker - VariableTracker name == __contains__ dv_dict call_method tx name args kwargs name __and__ __iand__ __or__ __ior__ __sub__ __isub__ __xor__ __ixor__ These methods always returns set m = getattr set_items name r = m args set_items SetVariable r name cmp_name_to_op_mapping isinstance args SetVariable DictKeysVariable ConstantVariable create NotImplemented ConstantVariable create cmp_name_to_op_mapping name set_items args set_items super call_method tx name args kwargs DictValuesVariable DictViewVariable DictValuesVariable iterable cannot compared kv = values property view_items_vt list view_items python_type dict_values DictItemsVariable DictViewVariable kv = items property view_items_vt Returns iterable unpacked items variables TupleVariable k vt v k v view_items python_type dict_items call_method tx name args kwargs TODO guilhermeleobas This should actually check args implements mapping protocol name == __eq__ len args = raise_args_mismatch tx name args f len args args isinstance args DictItemsVariable dv_dict call_method tx __eq__ args dv_dict ConstantVariable create False super call_method tx name args kwargs