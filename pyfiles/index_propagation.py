mypy allow-untyped-defs This file implements IndexPropagation ops handler which wraps underlying handler add limited form constant propagation well propagation sympy expressions downstream ops index_expr calls For example say we have IR tmp = ops index_expr x torch int tmp = ops constant torch int tmp = ops mul tmp tmp tmp = ops indirect_indexing tmp x_size tmp = ops load buf tmp The underlying handler would just see ops load buf x This limited set operators handled sympy expression printers So simple operations like minimum maximum cannot translated SymPy expressions yet despite sympy Min sympy Max existing itertools collections abc Sequence dataclasses dataclass typing Any Literal Optional overload Union typing_extensions TypeAlias sympy torch torch _prims_common dtype_to_type is_integer_dtype torch utils _sympy functions FloorDiv ModularIndexing Where torch utils _sympy value_ranges bound_sympy ValueRanges ops_handler DefaultHandler sizevars statically_known_true utils generate_assert virtualized V _ExprType = Union sympy Expr float int bool _is_constant val _ExprType isinstance val sympy Basic val is_number isinstance val int float bool upper_bound val _ExprType bound_sympy val upper isinstance val sympy Expr val dataclass TypedExpr A SymPy expression associated type expr _ExprType dtype torch dtype is_constant _is_constant expr __post_init__ _is_constant expr expr = expr isinstance expr sympy Expr expr = expr expand identity=True expr = dtype_to_type dtype expr is_integer_dtype dtype bits = torch iinfo dtype bits dtype is_signed expr = expr + bits - expr = expr bits dtype is_signed expr = expr - bits - expr = expr SymPyOps An ops handler where all IR values SymPy expressions When value cannot represented SymPy expression method either defined returns NotImplemented staticmethod identity value Any - Any value staticmethod constant value Union int float bool dtype torch dtype - TypedExpr TypedExpr value dtype staticmethod index_expr value Union sympy Expr int dtype torch dtype - TypedExpr TypedExpr value dtype staticmethod to_dtype value TypedExpr dtype torch dtype src_dtype Optional torch dtype = None use_compute_types bool = False - TypedExpr TypedExpr value expr dtype staticmethod abs x TypedExpr - TypedExpr TypedExpr abs x expr x dtype type ignore arg-type staticmethod square x TypedExpr - TypedExpr TypedExpr x expr x expr x dtype staticmethod add x TypedExpr y TypedExpr - TypedExpr result_type = torch promote_types x dtype y dtype TypedExpr x expr + y expr result_type staticmethod sub x TypedExpr y TypedExpr - TypedExpr result_type = torch promote_types x dtype y dtype TypedExpr x expr - y expr result_type staticmethod mul x TypedExpr y TypedExpr - TypedExpr result_type = torch promote_types x dtype y dtype TypedExpr x expr y expr result_type staticmethod neg x TypedExpr - TypedExpr TypedExpr -x expr x dtype staticmethod floordiv x TypedExpr y TypedExpr - TypedExpr result_type = torch promote_types x dtype y dtype is_integer_dtype result_type NotImplemented TypedExpr FloorDiv x expr y expr result_type staticmethod mod x TypedExpr y TypedExpr - Optional TypedExpr result_type = torch promote_types x dtype y dtype is_integer_dtype result_type NotImplemented result_expr = ModularIndexing x expr sympy S One y expr TypedExpr result_expr result_type staticmethod remainder x TypedExpr y TypedExpr - Optional TypedExpr result_type = torch promote_types x dtype y dtype is_integer_dtype result_type NotImplemented x_expr = sympy sympify x expr y_expr = sympy sympify y expr In these cases remainder Python == remainder C++ so transformation sound x_expr is_nonnegative None x_expr is_nonnegative == y_expr is_positive result_expr = ModularIndexing x expr sympy S One y expr TypedExpr result_expr result_type NotImplemented staticmethod minimum x TypedExpr y TypedExpr - TypedExpr result_type = torch promote_types x dtype y dtype TypedExpr sympy Min x expr y expr result_type staticmethod maximum x TypedExpr y TypedExpr - TypedExpr result_type = torch promote_types x dtype y dtype TypedExpr sympy Max x expr y expr result_type dataclass IndexPropVar value Any Either IR value TypedExpr is_symbolic true is_symbolic bool = False staticmethod new_symbolic expr TypedExpr - IndexPropVar IndexPropVar expr is_symbolic=True __post_init__ assert is_symbolic isinstance value TypedExpr Symbolic IndexPropVar must contain TypedExpr IndexPropResult TypeAlias = Union IndexPropVar tuple IndexPropResult IndexPropagation DefaultHandler Ops wrapper tries propagate constant index_expr values through computation This aims maximize compile time simplification possible convert indirect indexing arange into normal static indexing __init__ inner Any iter_ranges dict sympy Symbol sympy Expr indirect_var_ranges dict sympy Symbol sympy Expr - None _inner = inner shape_env = V graph sizevars shape_env var_to_range = k ValueRanges upper_bound v - k v iter_ranges items var_to_range = tuple itertools chain shape_env var_to_range items var_to_range items NOTE intentionally kept reference so caller can update in-place indirect_var_ranges = indirect_var_ranges axioms = x s iter_ranges items axioms append = x axioms append x s axioms = tuple axioms + shape_env get_axioms materialize_expr expr sympy Expr dtype torch dtype - Any Construct new constant index_expr SymPy expression _is_constant expr val = dtype_to_type dtype expr _inner constant val dtype _inner index_expr expr dtype unwrap Union Any IndexPropVar - Any isinstance list tuple tuple unwrap v v isinstance IndexPropVar Prefer sympy representation possible is_symbolic materialize_expr value expr value dtype value wrap - IndexPropResult isinstance list tuple tuple wrap v v IndexPropVar overload fallback name Literal indirect_indexing args Sequence Any kwargs dict str Any - IndexPropVar overload fallback name str args Sequence Any kwargs dict str Any - IndexPropResult fallback name str args Sequence Any kwargs dict str Any - IndexPropResult Fallback wrapped handler new_args = unwrap args new_kwargs = k unwrap v k v kwargs items wrap getattr _inner name new_args new_kwargs propagate_sympy name str args Sequence Any kwargs dict str Any - IndexPropResult Build new SymPy expression ops call unwrap Union Any IndexPropVar - Any isinstance IndexPropVar value new_args = unwrap args new_kwargs = k unwrap v k v kwargs items new_expr = getattr SymPyOps name new_args new_kwargs is_valid_expr = new_expr NotImplemented Inductor doesn t expect floating point sympy expressions allow floating point constants propagated new_expr is_constant new_expr expr is_integer is_valid_expr fallback name args kwargs IndexPropVar new_symbolic new_expr _default name str args tuple Any kwargs dict str Any - Any hasattr SymPyOps name fallback name args kwargs var_arguments = itertools chain args kwargs values isinstance IndexPropVar all v is_symbolic v var_arguments fallback name args kwargs propagate_sympy name args kwargs statically_true e Given some iter_ranges function given expression returns whether true false using value ranges guard knowledge runtime_asserts FIXME I think may entirely right we may able use all runtime_asserts If issue just use guards ` axioms ` The proper way handling would have global shape_env adds runtime_asserts they happen code Then should used SimplifyIndexing perform wrap_expr CSEProxy check_bounds elide upper lower bounds also indirect_indexing var_to_range = var_to_range k ValueRanges upper_bound v - k v indirect_var_ranges items pyrefly ignore bad-argument-type statically_known_true shape_env e axioms var_to_range indirect_indexing index Union Any IndexPropVar size Any check bool = True wrap_neg=True - Any isinstance index IndexPropVar index is_symbolic If we find something we can convert into direct indexing we do so We still need perhaps wrap expression add bound checks We want do constant folding we don t allow fuse kernels into indirect indexing expr = sympy sympify index value expr TODO Perhaps move logic simplify indexing pass wrap_expr expr Positive negative mixed statically_true = expr expr statically_true expr expr + size Where expr expr + size expr Sometimes s easier prove = expr than weaker -size = expr can_prove_lower = statically_true = expr statically_true -size = expr can_prove_upper = statically_true expr size wrap_neg expr = wrap_expr expr generate_assert check fallback check_bounds expr size dict lower=not can_prove_lower upper=not can_prove_upper expr indirect_var = fallback indirect_indexing index size check wrap_neg value indirect_var