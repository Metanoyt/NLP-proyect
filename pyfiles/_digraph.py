mypy allow-untyped-defs collections deque DiGraph Really simple unweighted directed graph data structure track dependencies The API pretty much same networkx so you add something just copy their API __init__ Dict node - dict arbitrary attributes _node = Nested dict node - successor node - nothing didn t implement edge data _succ = Nested dict node - predecessor node - nothing _pred = Keep track order which nodes added graph _node_order = _insertion_idx = add_node n kwargs Add node graph Args n node Can we any object valid dict key kwargs any attributes you want attach node n _node _node n = kwargs _succ n = _pred n = _node_order n = _insertion_idx _insertion_idx += _node n update kwargs add_edge u v Add edge graph between nodes ` ` u ` ` ` ` v ` ` ` ` u ` ` ` ` v ` ` will created they do already exist add nodes add_node u add_node v add edge _succ u v = True _pred v u = True successors n Returns iterator over successor nodes n try iter _succ n except KeyError e raise ValueError f The node n digraph e predecessors n Returns iterator over predecessors nodes n try iter _pred n except KeyError e raise ValueError f The node n digraph e property edges Returns iterator over all edges u v graph n successors _succ items succ successors yield n succ property nodes Returns dictionary all nodes their attributes _node __iter__ Iterate over nodes iter _node __contains__ n Returns True ` ` n ` ` node graph False otherwise try n _node except TypeError False forward_transitive_closure src str - set str Returns set nodes reachable src result = set src working_set = deque src while len working_set cur = working_set popleft n successors cur n result result add n working_set append n result backward_transitive_closure src str - set str Returns set nodes reachable src reverse direction result = set src working_set = deque src while len working_set cur = working_set popleft n predecessors cur n result result add n working_set append n result all_paths src str dst str Returns subgraph rooted src shows all paths dst result_graph = DiGraph First compute forward transitive closure src all things reachable src forward_reachable_from_src = forward_transitive_closure src dst forward_reachable_from_src result_graph Second walk reverse dependencies dst adding each node output graph iff also present forward_reachable_from_src we don t use backward_transitive_closures optimization purposes working_set = deque dst while len working_set cur = working_set popleft n predecessors cur n forward_reachable_from_src result_graph add_edge n cur only explore further its reachable src working_set append n result_graph to_dot first_path dst str - list str Returns list nodes show first path resulted dst being added graph path = while dst path append dst candidates = _pred dst keys dst min_idx = None candidate candidates idx = _node_order get candidate None idx None break min_idx None idx min_idx min_idx = idx dst = candidate list reversed path to_dot - str Returns dot representation graph Returns A dot representation graph edges = \n join f f - t f t edges f \ digraph G rankdir = LR node shape=box edges