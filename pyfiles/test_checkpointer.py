Owner s oncall distributed checkpointing os shutil tempfile concurrent futures Future unittest mock Mock torch torch distributed checkpoint _experimental checkpoint_process CheckpointProcess CheckpointProcessConfig torch distributed checkpoint _experimental checkpoint_reader CheckpointReader torch distributed checkpoint _experimental checkpoint_writer CheckpointWriter CheckpointWriterConfig torch distributed checkpoint _experimental checkpointer AsyncCheckpointer Checkpointer SyncCheckpointer torch distributed checkpoint _experimental staging CheckpointStagerConfig DefaultStager torch distributed checkpoint _experimental types RankInfo torch testing _internal common_utils run_tests TestCase subprocess_init_fn name str parent_pid int - None Initialize subprocess async checkpointer tests assert name == test-async-checkpointer f Unexpected subprocess name name assert os getpid = parent_pid This supposed run different process assert os getppid == parent_pid This supposed run child main process ckpt_writer_init_fn kwargs - CheckpointWriter Initialize CheckpointWriter subprocess CheckpointWriter config=kwargs get config rank_info=kwargs get rank_info TestCheckpointer TestCase Parameterized tests work both sync async checkpointers setUp Create temporary directory checkpoints temp_dir = tempfile mkdtemp Create real objects testing rank_info = RankInfo global_world_size= global_rank= writer_config = CheckpointWriterConfig Create reader testing reader = CheckpointReader rank_info=self rank_info Create test state dictionary state_dict = model torch nn Linear state_dict optimizer param_groups lr epoch step tearDown Clean up temporary directory shutil rmtree temp_dir _create_sync_checkpointer - SyncCheckpointer Create synchronous checkpointer writer = CheckpointWriter config=self writer_config rank_info=self rank_info SyncCheckpointer writer reader _create_async_checkpointer - AsyncCheckpointer Create asynchronous checkpointer Create staging config async operations Use conservative settings avoid CUDA issues test environment stager_config = CheckpointStagerConfig use_async_staging=True use_pinned_memory=False Disable avoid CUDA memory issues use_shared_memory=True use_non_blocking_copy=False Disable avoid CUDA issues Create process config process_config = CheckpointProcessConfig subprocess_init_timeout_secs= subprocess_shutdown_timeout_secs= Create stager checkpoint_stager = DefaultStager stager_config Create checkpoint process checkpoint_process = CheckpointProcess rank_info=self rank_info config=process_config subprocess_init_fn=subprocess_init_fn subprocess_init_args= test-async-checkpointer os getpid checkpoint_writer_init_fn=ckpt_writer_init_fn checkpoint_writer_init_args= config writer_config rank_info rank_info Wait process initialization checkpoint_process process_creation_future result AsyncCheckpointer checkpoint_stager=checkpoint_stager checkpoint_process=checkpoint_process reader=self reader _get_checkpointers Get both sync async checkpointers parameterized testing sync _create_sync_checkpointer async _create_async_checkpointer _save_checkpoint checkpointer Checkpointer path state_dict kwargs Save checkpoint handle both sync async values result = checkpointer save path state_dict kwargs None None result None result _wait_for_save stage_future write_future Wait save operation complete write_future None write_future result stage_future None stage_future result test_save_and_load_basic Test basic save load functionality both sync async checkpointer_type checkpointer _get_checkpointers subTest checkpointer_type=checkpointer_type try checkpoint_path = os path join temp_dir f checkpoint_ checkpointer_type Save checkpoint stage_future write_future = _save_checkpoint checkpointer checkpoint_path state_dict _wait_for_save stage_future write_future Verify checkpoint file exists checkpoint_file = os path join checkpoint_path f checkpoint_ rank_info global_rank pt assertTrue os path exists checkpoint_file Load checkpoint using checkpointer loaded_state_dict = checkpointer load checkpoint_path Verify loaded state dictionary assertIn model loaded_state_dict assertIn optimizer loaded_state_dict assertEqual loaded_state_dict epoch assertEqual loaded_state_dict step finally checkpointer close test_load_with_map_location Test loading map_location both sync async checkpointer_type checkpointer _get_checkpointers subTest checkpointer_type=checkpointer_type try checkpoint_path = os path join temp_dir f checkpoint_map_ checkpointer_type Save checkpoint stage_future write_future = _save_checkpoint checkpointer checkpoint_path state_dict _wait_for_save stage_future write_future Load map_location loaded_state_dict = checkpointer load checkpoint_path default_map_location= cpu Verify loaded state dictionary assertIn model loaded_state_dict assertEqual loaded_state_dict epoch finally checkpointer close test_partial_load Test partial loading both sync async checkpointer_type checkpointer _get_checkpointers subTest checkpointer_type=checkpointer_type try checkpoint_path = os path join temp_dir f checkpoint_partial_ checkpointer_type Save full checkpoint stage_future write_future = _save_checkpoint checkpointer checkpoint_path state_dict _wait_for_save stage_future write_future Create partial state dictionary partial_state_dict = model torch nn Linear state_dict epoch None Load only keys partial_state_dict loaded_state_dict = checkpointer load checkpoint_path state_dict=partial_state_dict Verify partial loading worked assertIn model loaded_state_dict assertIn epoch loaded_state_dict assertEqual loaded_state_dict epoch assertNotIn step loaded_state_dict assertNotIn optimizer loaded_state_dict finally checkpointer close test_load_strict_mode Test strict mode loading both sync async checkpointer_type checkpointer _get_checkpointers subTest checkpointer_type=checkpointer_type try checkpoint_path = os path join temp_dir f checkpoint_strict_ checkpointer_type Save checkpoint limited keys limited_state_dict = model torch nn Linear state_dict stage_future write_future = _save_checkpoint checkpointer checkpoint_path limited_state_dict _wait_for_save stage_future write_future Try load more keys than exist checkpoint partial_state_dict = model torch nn Linear state_dict missing_key None Should raise error strict mode assertRaises RuntimeError cm checkpointer load checkpoint_path state_dict=partial_state_dict strict=True assertIn missing keys str cm exception Should work without strict mode loaded_state_dict = checkpointer load checkpoint_path state_dict=partial_state_dict strict=False assertIn model loaded_state_dict finally checkpointer close test_save_with_kwargs Test save additional kwargs both sync async checkpointer_type checkpointer _get_checkpointers subTest checkpointer_type=checkpointer_type try checkpoint_path = os path join temp_dir f checkpoint_kwargs_ checkpointer_type For sync checkpointer we can pass arbitrary kwargs writer For async checkpointer we test without kwargs avoid conflicts checkpointer_type == sync Sync checkpointer passes kwargs directly writer so arbitrary kwargs OK stage_future write_future = _save_checkpoint checkpointer checkpoint_path state_dict custom_arg= test_value another_arg= Async checkpointer has complex kwargs handling between stager writer Just test basic save without kwargs avoid conflicts stage_future write_future = _save_checkpoint checkpointer checkpoint_path state_dict _wait_for_save stage_future write_future Verify checkpoint created checkpoint_file = os path join checkpoint_path f checkpoint_ rank_info global_rank pt assertTrue os path exists checkpoint_file finally checkpointer close test_nested_dict_partial_load Test loading nested dictionaries partially both sync async checkpointer_type checkpointer _get_checkpointers subTest checkpointer_type=checkpointer_type try Create checkpoint nested dictionaries nested_state_dict = model layer weight torch randn bias torch randn layer weight torch randn bias torch randn metadata epoch step checkpoint_path = os path join temp_dir f checkpoint_nested_ checkpointer_type Save nested state dict stage_future write_future = _save_checkpoint checkpointer checkpoint_path nested_state_dict _wait_for_save stage_future write_future Create partial state dictionary nested structure partial_state_dict = model layer weight None Only request layer weight metadata epoch None Only request metadata epoch Load only keys partial_state_dict loaded_state_dict = checkpointer load checkpoint_path state_dict=partial_state_dict Verify nested keys correctly loaded assertIn model loaded_state_dict assertIn layer loaded_state_dict model assertIn weight loaded_state_dict model layer assertIn metadata loaded_state_dict assertIn epoch loaded_state_dict metadata Verify values loaded correctly assertTrue torch allclose loaded_state_dict model layer weight nested_state_dict model layer weight assertEqual loaded_state_dict metadata epoch Verify keys partial_state_dict loaded assertNotIn layer loaded_state_dict model assertNotIn step loaded_state_dict metadata finally checkpointer close TestAsyncCheckpointerSpecific TestCase Tests specific AsyncCheckpointer functionality setUp Create temporary directory checkpoints temp_dir = tempfile mkdtemp Create real objects testing rank_info = RankInfo global_world_size= global_rank= writer_config = CheckpointWriterConfig Create reader testing reader = CheckpointReader rank_info=self rank_info Create test state dictionary state_dict = model torch nn Linear state_dict optimizer param_groups lr epoch step tearDown Clean up temporary directory shutil rmtree temp_dir _create_async_checkpointer - AsyncCheckpointer Helper method create AsyncCheckpointer real components Create staging config async operations Use conservative settings avoid CUDA issues test environment stager_config = CheckpointStagerConfig use_async_staging=True use_pinned_memory=False Disable avoid CUDA memory issues use_shared_memory=True use_non_blocking_copy=False Disable avoid CUDA issues Create process config process_config = CheckpointProcessConfig subprocess_init_timeout_secs= subprocess_shutdown_timeout_secs= Create stager checkpoint_stager = DefaultStager stager_config Create checkpoint process checkpoint_process = CheckpointProcess rank_info=self rank_info config=process_config subprocess_init_fn=subprocess_init_fn subprocess_init_args= test-async-checkpointer os getpid checkpoint_writer_init_fn=ckpt_writer_init_fn checkpoint_writer_init_args= config writer_config rank_info rank_info Wait process initialization checkpoint_process process_creation_future result AsyncCheckpointer checkpoint_stager=checkpoint_stager checkpoint_process=checkpoint_process reader=self reader test_async_returns_futures Test async save returns futures checkpointer = _create_async_checkpointer checkpoint_path = os path join temp_dir checkpoint_futures try Save checkpoint asynchronously result = checkpointer save checkpoint_path state_dict Verify futures returned assertIsInstance result tuple assertEqual len result stage_future write_future = result assertIsInstance stage_future Future assertIsInstance write_future Future Wait completion stage_future result write_future result finally checkpointer close test_async_sequential_saves_wait Test sequential async saves wait previous operations checkpointer = _create_async_checkpointer try First save checkpoint_path = os path join temp_dir checkpoint_seq_ stage_future write_future = checkpointer save checkpoint_path state_dict Second save should wait first complete checkpoint_path = os path join temp_dir checkpoint_seq_ modified_state_dict = state_dict copy modified_state_dict epoch = stage_future write_future = checkpointer save checkpoint_path modified_state_dict Wait both complete write_future result write_future result Verify both checkpoints created correct content checkpoint_file = os path join checkpoint_path f checkpoint_ rank_info global_rank pt checkpoint_file = os path join checkpoint_path f checkpoint_ rank_info global_rank pt assertTrue os path exists checkpoint_file assertTrue os path exists checkpoint_file loaded = torch load checkpoint_file loaded = torch load checkpoint_file assertEqual loaded epoch assertEqual loaded epoch finally checkpointer close test_async_multiple_saves_ordering Test multiple async saves maintain proper ordering checkpointer = _create_async_checkpointer try Create multiple state dicts state_dicts = epoch model torch nn Linear state_dict epoch model torch nn Linear state_dict epoch model torch nn Linear state_dict Save multiple checkpoints futures = checkpoint_paths = i state_dict enumerate state_dicts checkpoint_path = os path join temp_dir f multi_ i checkpoint_paths append checkpoint_path stage_future write_future = checkpointer save checkpoint_path state_dict futures append stage_future write_future Wait all complete stage_future write_future futures write_future result Verify all checkpoints exist have correct content i checkpoint_path enumerate checkpoint_paths checkpoint_file = os path join checkpoint_path f checkpoint_ rank_info global_rank pt assertTrue os path exists checkpoint_file loaded = torch load checkpoint_file assertEqual loaded epoch i finally checkpointer close test_async_error_handling Test error handling async operations Create checkpointer mocked components simulate errors mock_stager = Mock mock_process = Mock mock_reader = Mock Mock staging completed future mock_staging_future = Future mock_staging_future set_result staged data mock_stager stage return_value = mock_staging_future Mock process write raise error mock_write_future = Future mock_write_future set_exception RuntimeError Write failed mock_process write return_value = mock_write_future checkpointer = AsyncCheckpointer checkpoint_stager=mock_stager checkpoint_process=mock_process reader=mock_reader try This should raise immediately stage_future write_future = checkpointer save tmp test state_dict But waiting write future should raise error assertRaises RuntimeError cm write_future result assertIn Write failed str cm exception finally checkpointer close test_async_future_results Test results returned async futures checkpointer = _create_async_checkpointer checkpoint_path = os path join temp_dir checkpoint_results try Save checkpoint stage_future write_future = checkpointer save checkpoint_path state_dict Both futures should complete successfully stage_result = stage_future result write_result = write_future result Stage result wrapped wrap_future so returns None success This intentional - stage_future indicates completion data access assertIsNone stage_result Write result should None success indicator assertIsNone write_result finally checkpointer close __name__ == __main__ run_tests