mypy allow-untyped-defs collections logging typing Any Optional Union torch torch _export verifier SpecViolationError torch _guards detect_fake_mode torch _library fake_class_registry FakeScriptObject torch _subclasses fake_tensor unset_fake_temporarily torch export exported_program ArgumentSpec CustomObjArgument ExportGraphSignature InputKind InputSpec TensorArgument torch fx _symbolic_trace _ConstantAttributeType torch fx graph_module _get_attr log = logging getLogger __name__ ConstantAttrMap collections abc MutableMapping A mapping understands how use module constants tensors ScriptObjects FakeScriptObjects keys We store tensors FakeScriptObjects normally ScriptObjects stored hash because different torch ScriptObjects can point same underlying value we guarantee they will ` hash ` same value s case __init__ - None Underlying dict we use implement mapping _constant_attrs dict Union int torch Tensor FakeScriptObject torch utils _pytree TreeSpec list Any = Map hash ScriptObject ScriptObject itself Used APIs like ` __iter__ ` should look like they re returning original ScriptObjects _script_object_map dict int torch ScriptObject = __getitem__ key _ConstantAttributeType - Any real_key = hash key isinstance key torch ScriptObject key assert isinstance real_key int torch Tensor FakeScriptObject _constant_attrs real_key __setitem__ key _ConstantAttributeType value we shouldn t actually call should go add instead handle aliasing raise NotImplementedError Directly setting values ConstantAttrMap supported please use add key value instead The same key can mapped multiple values handling constant aliasing add key _ConstantAttributeType value Any - None isinstance key torch ScriptObject hash key _constant_attrs _constant_attrs hash key = _constant_attrs hash key append value _script_object_map hash key = key isinstance key torch Tensor FakeScriptObject key _constant_attrs _constant_attrs key = _constant_attrs key append value raise TypeError f Expected key tensor ScriptObject got type key __delitem__ key _ConstantAttributeType real_key = hash key isinstance key torch ScriptObject key del _constant_attrs real_key __iter__ key _constant_attrs isinstance key int yield _script_object_map key yield key __len__ len _constant_attrs __contains__ key object - bool real_key = hash key isinstance key torch ScriptObject key real_key _constant_attrs get_constant_fqn node torch fx Node constant_name str - str The FQN constant tensor state dict should correspond module where constant tensor originally used len node meta nn_module_stack == constant_name parent_fqn = list node meta nn_module_stack values - len parent_fqn f parent_fqn constant_name constant_name _get_first_fqn const_attrs ConstantAttrMap key _ConstantAttributeType - Any fqns = const_attrs get key fqns fqns None _unused_constant node torch fx Node - Optional list torch fx Node If there tensor constant created while tracing here how graph looks like _tensor_constant num_users= = get_attr target=_tensor_constant lift_fresh_copy num_users= = call_function target=torch ops aten lift_fresh_copy default args = _tensor_constant detach_ num_users= = call_function target=torch ops aten detach_ default args = lift_fresh_copy To check see tensor constant being used we want traverse detach node see s actually being used This function returns None constant being used otherwise returns lift_fresh detach node removed later noqa B len node users None lift_fresh_node = next iter node users keys lift_fresh_node op == call_function lift_fresh_node target torch ops aten lift_fresh default torch ops aten lift_fresh_copy default None len lift_fresh_node users None Case lift node used anywhere len lift_fresh_node users == lift_fresh_node node detach_node = next iter lift_fresh_node users keys detach_node op == call_function detach_node target torch ops aten detach_ default torch ops aten detach default None len detach_node users None Case Lift node s child used anywhere detach_node lift_fresh_node node lift_constants_pass gm torch fx GraphModule graph_signature ExportGraphSignature constant_attrs ConstantAttrMap - dict str _ConstantAttributeType Takes graph module graph signature modifies them inplace lift any constants tensors custom classes inputs graph Returns dictionary names constants Arguments gm torch fx GraphModule The graph module containing graph constants lift graph_signature ExportGraphSignature This graph signature will mutated add additional CONSTANT_TENSOR CUSTOM_OBJ inputs constant_attrs ConstantAttr A mapping constant value its fully-qualified path ` gm ` This used maintain consistent location constants between original module exported version Returns A dictionary fqn = constant value all_constants dict str _ConstantAttributeType = input_specs = graph_signature input_specs num_custom_obj = sum input_spec kind == InputKind CUSTOM_OBJ input_spec input_specs num_tensor_constants = sum input_spec kind == InputKind CONSTANT_TENSOR input_spec input_specs fake_mode = detect_fake_mode tuple node meta val node gm graph nodes node op == placeholder first_user_input_loc first_user_input = next iter gm graph nodes used_target_names = set input_nodes = node node gm graph nodes node op == placeholder assert len input_nodes == len input_specs i node input_spec enumerate zip input_nodes input_specs used_target_names add input_spec target input_spec kind == InputKind USER_INPUT first_user_input = node first_user_input_loc = i break lifted_objs = ConstantAttrMap renamed_targets = node list gm graph nodes node op == get_attr nodes_to_remove = _unused_constant node Remove node s being used node_rm nodes_to_remove gm graph erase_node node_rm continue constant_val = _get_attr gm node target These hashable gonna lifted so we can skip them earlier isinstance constant_val torch fx GraphModule continue LoweredBackendModule type constant_val __name__ continue AOTInductorRunnerWrapper type constant_val __name__ continue isinstance constant_val torch utils _pytree TreeSpec continue constant_val lifted_objs We already lifted constant elsewhere Just rewrite uses get_attr point already-existing placeholder node const_placeholder_node = _get_first_fqn lifted_objs constant_val node replace_all_uses_with const_placeholder_node gm graph erase_node node renamed_targets node name = const_placeholder_node name continue For ScriptObject Tensor FakeScriptObject constants First check constant attribute some module consulting ` constant_attrs ` map If use fqn keeps its location consistent eager module If s ` constant_attrs ` map means s inline constant e g x + torch tensor thus did have specific location eager module In case just generate some name attach module which used isinstance constant_val torch ScriptObject FakeScriptObject constant_kind = InputKind CUSTOM_OBJ constant_fqn = _get_first_fqn constant_attrs constant_val constant_fqn None constant_name = constant_fqn replace _ constant_name = f lifted_custom_ num_custom_obj constant_fqn = get_constant_fqn node constant_name while constant_fqn used_target_names num_custom_obj += constant_name = f lifted_custom_ num_custom_obj constant_fqn = get_constant_fqn node constant_name num_custom_obj += isinstance constant_val torch Tensor Remove parameterness constant_val isinstance constant_val torch nn Parameter log debug s created when tracing s parameter But s registered register_parameter export will treat constant tensor str node target str node meta get stack_trace unknown stack We get real data out parameter disabling surrounding fake mode unset_fake_temporarily constant_val = constant_val data constant_kind = InputKind CONSTANT_TENSOR constant_fqn = _get_first_fqn constant_attrs constant_val constant_fqn None constant_name = constant_fqn replace _ constant_name = f lifted_tensor_ num_tensor_constants constant_fqn = get_constant_fqn node constant_name while constant_fqn used_target_names num_tensor_constants += constant_name = f lifted_tensor_ num_tensor_constants constant_fqn = get_constant_fqn node constant_name num_tensor_constants += raise SpecViolationError f getattr node node referencing unsupported type type constant_val gm graph inserting_before first_user_input Insert constant node before first user input const_placeholder_node = gm graph placeholder constant_name match target name its node name case there name collision suffix added node name fx const_placeholder_node target = const_placeholder_node name k v node meta items const_placeholder_node meta k = v Once FQN has been used remove nn_module_stack stack_trace const_placeholder_node meta pop nn_module_stack const_placeholder_node meta pop stack_trace None input_spec_arg ArgumentSpec isinstance constant_val torch Tensor fake_mode None const_placeholder_node meta val = fake_mode from_tensor constant_val static_shapes=True const_placeholder_node meta val constant = constant_val const_placeholder_node meta val = constant_val input_spec_arg = TensorArgument name=const_placeholder_node name isinstance constant_val torch _C ScriptObject class_fqn = constant_val _type qualified_name type ignore attr-defined const_placeholder_node meta val = CustomObjArgument constant_fqn class_fqn input_spec_arg = CustomObjArgument name=const_placeholder_node name class_fqn=class_fqn isinstance constant_val FakeScriptObject class_fqn = constant_val script_class_name const_placeholder_node meta val = CustomObjArgument constant_fqn class_fqn constant_val input_spec_arg = CustomObjArgument name=const_placeholder_node name class_fqn=class_fqn fake_val=constant_val raise SpecViolationError f tried lift unsupported type type constant_val node node format_node lifted_objs add constant_val const_placeholder_node node replace_all_uses_with const_placeholder_node gm graph erase_node node renamed_targets node name = const_placeholder_node name Add constant buffer graph signature graph_signature input_specs insert first_user_input_loc InputSpec kind=constant_kind arg=input_spec_arg target=constant_fqn constant_val constant_attrs fqn constant_attrs constant_val all_constants fqn = constant_val all_constants constant_fqn = constant_val first_user_input_loc += spec graph_signature output_specs spec arg name renamed_targets spec arg name = renamed_targets spec arg name all_constants rewrite_script_object_meta gm torch fx GraphModule - dict str _ConstantAttributeType When tracing we produce graph FakeScriptObject meta val For now we rewrie meta val placeholder CustomObjArgument constants dict str _ConstantAttributeType = node gm graph nodes val node meta continue old_meta = node meta val isinstance old_meta torch ScriptObject class_fqn = old_meta _type qualified_name type ignore attr-defined new_meta = CustomObjArgument node name class_fqn constants node name = old_meta node meta val = new_meta isinstance old_meta FakeScriptObject class_fqn = old_meta script_class_name type ignore attr-defined new_meta = CustomObjArgument node name class_fqn old_meta constants node name = old_meta node meta val = new_meta constants _materialize_and_lift_constants gm torch fx GraphModule export_graph_signature ExportGraphSignature constant_attrs ConstantAttrMap - dict str _ConstantAttributeType constants = rewrite_script_object_meta gm constants update lift_constants_pass gm export_graph_signature constant_attrs constants