mypy allow-untyped-defs __future__ annotations logging collections abc Callable Sequence typing Any onnxscript ir torch torch fx torch onnx _internal exporter _registration _schemas logger = logging getLogger __name__ Define utilities convert PyTorch data types so users do need specify manually _TORCH_DTYPE_TO_ONNX_COMPATIBLE dict torch dtype ir DataType = torch bfloat ir DataType BFLOAT torch bool ir DataType BOOL torch complex ir DataType DOUBLE torch complex ir DataType FLOAT torch float ir DataType FLOAT torch float ir DataType FLOAT torch float ir DataType DOUBLE torch float _e m fn ir DataType FLOAT E M FN torch float _e m fnuz ir DataType FLOAT E M FNUZ torch float _e m ir DataType FLOAT E M torch float _e m fnuz ir DataType FLOAT E M FNUZ torch float _e m fn_x ir DataType FLOAT E M torch int ir DataType INT torch int ir DataType INT torch int ir DataType INT torch int ir DataType INT torch uint ir DataType UINT torch uint ir DataType UINT torch uint ir DataType UINT torch uint ir DataType UINT _torch_dtype_to_onnx_compatible_dtype dtype torch dtype - ir DataType _TORCH_DTYPE_TO_ONNX_COMPATIBLE dtype _attribute_type_compatible_with_arg attr _schemas AttributeParameter value ir Value &#124; int &#124; float &#124; bool &#124; Sequence int &#124; Sequence float &#124; None - bool Check attribute type compatible argument isinstance value bool attr type ir AttributeType INT isinstance value str attr type ir AttributeType STRING isinstance value int attr type ir AttributeType INT ir AttributeType FLOAT isinstance value float attr type ir AttributeType FLOAT isinstance value complex False isinstance value Sequence attr type ir AttributeType INTS all isinstance i int i value attr type ir AttributeType FLOATS all isinstance i int float i value isinstance value torch dtype attr type ir AttributeType INT isinstance value torch device torch memory_format torch layout attr type ir AttributeType STRING value None attr required An optional attribute supplied True False _param_type_compatible_with_arg param _schemas Parameter value ir TypeProtocol &#124; str &#124; int &#124; float &#124; complex &#124; Sequence int &#124; Sequence float &#124; None assigned_types dict str ir TypeProtocol - bool Handle Python types first isinstance value bool noqa SIM param type_constraint allowed_types ir TensorType ir DataType BOOL True isinstance value int param type_constraint allowed_types ir TensorType ir DataType INT ir TensorType ir DataType INT ir TensorType ir DataType INT ir TensorType ir DataType INT ir TensorType ir DataType INT Int inputs can casted float too ir TensorType ir DataType FLOAT E M ir TensorType ir DataType FLOAT E M FN ir TensorType ir DataType FLOAT E M FNUZ ir TensorType ir DataType FLOAT E M ir TensorType ir DataType FLOAT E M FNUZ ir TensorType ir DataType FLOAT ir TensorType ir DataType FLOAT ir TensorType ir DataType DOUBLE True isinstance value float param type_constraint allowed_types ir TensorType ir DataType FLOAT E M ir TensorType ir DataType FLOAT E M FN ir TensorType ir DataType FLOAT E M FNUZ ir TensorType ir DataType FLOAT E M ir TensorType ir DataType FLOAT E M FNUZ ir TensorType ir DataType FLOAT ir TensorType ir DataType FLOAT ir TensorType ir DataType DOUBLE True isinstance value complex param type_constraint allowed_types ir TensorType ir DataType FLOAT ir TensorType ir DataType DOUBLE ir TensorType ir DataType COMPLEX ir TensorType ir DataType COMPLEX True isinstance value str noqa SIM param type_constraint allowed_types ir TensorType ir DataType STRING True isinstance value list tuple param type_constraint allowed_types ir TensorType ir DataType INT ir TensorType ir DataType INT ir TensorType ir DataType FLOAT ir TensorType ir DataType DOUBLE ir SequenceType ir TensorType ir DataType INT ir SequenceType ir TensorType ir DataType INT ir SequenceType ir TensorType ir DataType FLOAT ir SequenceType ir TensorType ir DataType DOUBLE all isinstance i int i value We will just allow any fx node trust overload handles True param type_constraint allowed_types ir TensorType ir DataType FLOAT ir TensorType ir DataType DOUBLE ir SequenceType ir TensorType ir DataType FLOAT ir SequenceType ir TensorType ir DataType DOUBLE all isinstance i int float i value We will just allow any fx node trust overload handles True value None param required An optional parameter supplied True isinstance value ir TypeProtocol False Then check tensor types param type_constraint name assigned_types If typevar already bound check value has same type assigned_type = assigned_types param type_constraint name assigned_type == value If typevar bound bind value type value param type_constraint allowed_types TODO Maybe just check dtype Being more strict here now assigned_types param type_constraint name = value True False _get_type_from_tensor tensor torch Tensor &#124; torch SymBool &#124; torch SymInt &#124; torch SymFloat &#124; Sequence torch Tensor - ir TypeProtocol isinstance tensor torch Tensor ir TensorType _torch_dtype_to_onnx_compatible_dtype tensor dtype isinstance tensor torch SymBool ir TensorType ir DataType BOOL isinstance tensor torch SymInt ir TensorType ir DataType INT isinstance tensor torch SymFloat ir TensorType ir DataType FLOAT Handle sequences first_tensor = next item item tensor item None None first_tensor None ir SequenceType ir TensorType ir DataType UNDEFINED ir SequenceType ir TensorType _torch_dtype_to_onnx_compatible_dtype first_tensor dtype _get_first_tensor_in_node_list nodes Sequence torch fx Node &#124; Any - torch Tensor &#124; None node nodes isinstance node torch fx Node val node meta isinstance node meta val torch Tensor node meta val None _get_named_fx_node_args node torch fx Node - dict str torch fx node Argument assert hasattr node target _schema torch_schema torch FunctionSchema = node target _schema type ignore union-attr node_args = arg schema_arg zip node args torch_schema arguments node_args schema_arg name = arg node_args update node kwargs node_args get_matching_overload node torch fx Node overloads Sequence _registration OnnxDecompMeta - tuple Callable &#124; None str Get overload matches node s arguments Args node The node match overloads The OnnxDecompMeta overloads their signatures match against Returns A tuple containing matched overload string describing reason failure success hasattr node target _schema FIXME justinchuby When target builtin we should instead Match only inputs positionally Figure out how do right now we assume all inputs named overloads onnx_function The node target does have schema Return first one named_args = _get_named_fx_node_args node FIXME Handle when we don t know names arguments schema_args dict str torch Argument = arg name arg arg node target _schema arguments type ignore union-attr failure_messages list str = overload overloads assigned_types dict str ir TypeProtocol = fail_reason = overload signature None When overload does have signature we assume custom op should matched overload onnx_function The overload does have signature Assuming custom op matching param overload signature param name schema_args param required We don t need handle variadic inputs there none A required parameter supplied fail_reason = Required parameter supplied break Get argument param name named_args Provided Node args arg = named_args param name param name schema_args schema_args param name has_default_value Provided schema args arg = schema_args param name default_value param has_default Provided ONNX op definition arg = param default type ignore assignment fail_reason = Parameter provided break isinstance param _schemas Parameter isinstance arg torch Tensor arg = _get_type_from_tensor arg type ignore assignment isinstance arg list tuple any isinstance t torch fx Node t arg first_tensor = _get_first_tensor_in_node_list arg type ignore arg-type assert first_tensor None FIXME Handle symfloat here arg = ir SequenceType _get_type_from_tensor first_tensor type ignore assignment isinstance arg torch fx Node meta_val = arg meta val arg = _get_type_from_tensor meta_val type ignore assignment TODO Handle None attributes FIXME Handle symfloat etc Handle tensors Python values _param_type_compatible_with_arg param arg assigned_types type ignore arg-type fail_reason = f Parameter type compatible argument param= ` param ` f assigned_types= ` assigned_types ` arg= ` arg ` break isinstance param _schemas AttributeParameter _attribute_type_compatible_with_arg param arg type ignore arg-type fail_reason = f Attribute type compatible argument param= ` param ` arg= ` arg ` break raise TypeError f Unknown parameter type type param fail_reason overload onnx_function Successfully matched overload failure_messages append f - Failed match overload ` overload ` fail_reason None f All overloads did match node ` node format_node ` \n + \n join failure_messages _arg_has_complex_dtype arg - bool Check node has complex dtype recursively isinstance arg torch fx Node val arg meta isinstance arg meta val torch Tensor torch is_complex arg meta val True isinstance arg list any _arg_has_complex_dtype item item arg False dispatch node torch fx Node registry _registration ONNXRegistry - tuple Callable &#124; None str Dispatch node ONNX function based node s target ONNX registry Args node The node dispatch registry The ONNX registry use dispatching Returns A tuple containing matched ONNX function string describing reason failure success TODO Handle when node does have target decomp_metas = registry get_decomps node target type ignore arg-type Determine node has complex inputs is_complex = any _arg_has_complex_dtype arg arg node args any _arg_has_complex_dtype arg arg node kwargs values is_complex decomp_metas = decomp decomp decomp_metas decomp is_complex decomp_metas None No decompositions registered complex-valued input decomp_metas = decomp decomp decomp_metas decomp is_complex decomp_metas None No decompositions registered real-valued input len decomp_metas == decomp_metas onnx_function Fast path Only one decomposition defined overload message = get_matching_overload node decomp_metas overload message