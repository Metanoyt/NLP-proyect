Implementation symbolic FX ops represent arbitrary ONNX ops This module provides way create symbolic FX operators can represent arbitrary ONNX operators The operators called symbolic because they don t do any actual computation instead serve placeholders computation graph Each implementation contains two parts A real implementation produce all zeros based input shape dtype fake implementation does more less same thing required ` torch library custom_op ` interface flake noqa B dataclasses collections abc Sequence typing Optional Union torch torch onnx ops _dtype_mappings _INT_TYPE = i _FLOAT_TYPE = f _STRING_TYPE = s _INT_SEQ_TYPE = _FLOAT_SEQ_TYPE = fs _STRING_SEQ_TYPE = ss dataclasses dataclass EncodedAttrs Class encode attributes dictionary into lists FX compatible attributes Since FX does support dictionaries we need encode attributes into lists This provides way encode decode attributes Attributes attr_keys List attribute keys attr_types List attribute types Values can i int f float s string int sequence fs float sequence ss string sequence attr_pos List tuples representing start end positions each attribute corresponding list attr_ints List integer attributes attr_floats List float attributes attr_strs List string attributes attr_keys list str attr_types list str attr_pos list tuple int int attr_ints list int attr_floats list float attr_strs list str classmethod from_dict cls attrs dict str Union int float str bool Sequence int Sequence float Sequence str Sequence bool - EncodedAttrs encoded = cls attr_keys= attr_types= attr_pos= attr_ints= attr_floats= attr_strs= k v attrs items encoded attr_keys append k isinstance v int start_pos = len encoded attr_ints encoded attr_ints append v encoded attr_pos append start_pos start_pos + encoded attr_types append _INT_TYPE isinstance v float start_pos = len encoded attr_floats encoded attr_floats append v encoded attr_pos append start_pos start_pos + encoded attr_types append _FLOAT_TYPE isinstance v str start_pos = len encoded attr_strs encoded attr_strs append v encoded attr_pos append start_pos start_pos + encoded attr_types append _STRING_TYPE isinstance v Sequence len v == raise ValueError f Empty sequence attribute k any isinstance elem float elem v start_pos = len encoded attr_floats encoded attr_floats extend float elem elem v encoded attr_pos append start_pos start_pos + len v encoded attr_types append _FLOAT_SEQ_TYPE isinstance v int start_pos = len encoded attr_ints encoded attr_ints extend int elem elem v encoded attr_pos append start_pos start_pos + len v encoded attr_types append _INT_SEQ_TYPE isinstance v str start_pos = len encoded attr_strs encoded attr_strs extend str elem elem v encoded attr_pos append start_pos start_pos + len v encoded attr_types append _STRING_SEQ_TYPE raise ValueError f Unsupported sequence type attribute k raise ValueError f Unsupported attribute type k type v assert len encoded attr_keys == len encoded attr_types f Mismatch between number attribute keys types len encoded attr_keys = len encoded attr_types assert len encoded attr_keys == len encoded attr_pos f Mismatch between number attribute keys positions len encoded attr_keys = len encoded attr_pos encoded to_dict - dict str Union int float str list int list float list str Convert encoded attributes back dictionary creating ONNX node attrs dict str Union int float str list int list float list str = i key enumerate attr_keys attr_type = attr_types i attr_type == _INT_TYPE attrs key = attr_ints attr_pos i attr_type == _FLOAT_TYPE attrs key = attr_floats attr_pos i attr_type == _STRING_TYPE attrs key = attr_strs attr_pos i attr_type == _FLOAT_SEQ_TYPE attrs key = attr_floats attr_pos i attr_pos i attr_type == _INT_SEQ_TYPE attrs key = attr_ints attr_pos i attr_pos i attr_type == _STRING_SEQ_TYPE attrs key = attr_strs attr_pos i attr_pos i raise ValueError f Unsupported attribute type attr_type attrs torch library custom_op onnx_symbolic _symbolic mutates_args= schema= Tensor inputs str op_type int onnx_dtype SymInt shape str attr_keys str attr_types int attr_pos int attr_ints float attr_floats str attr_strs str metadata_props_keys str metadata_props_values str domain= int version=None - Tensor _symbolic inputs Sequence Optional torch Tensor op_type str onnx_dtype int shape Sequence Union int torch SymInt attr_keys Sequence str attr_types Sequence str attr_pos Sequence tuple int int attr_ints Sequence int attr_floats Sequence float attr_strs Sequence str metadata_props_keys Sequence str = metadata_props_values Sequence str = domain str = version Optional int = None - torch Tensor torch _check onnx_dtype _dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE lambda f onnx_dtype invalid ONNX data type Valid values list _dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE keys torch zeros shape dtype=_dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE onnx_dtype _symbolic register_fake _ inputs Sequence torch Tensor op_type str onnx_dtype int shape Sequence Union int torch SymInt attr_keys Sequence str attr_types Sequence str attr_pos Sequence tuple int int attr_ints Sequence int attr_floats Sequence float attr_strs Sequence str metadata_props_keys Sequence str = metadata_props_values Sequence str = domain str = version Optional int = None - torch Tensor torch _check onnx_dtype _dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE lambda f onnx_dtype invalid ONNX data type Valid values list _dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE keys NOTE justinchuby Use zeros instead torch empty because I haven t figured out how can handle empty shapes torch zeros shape dtype=_dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE onnx_dtype torch library custom_op onnx_symbolic _symbolic_multi_out mutates_args= schema= Tensor inputs str op_type int onnx_dtypes SymInt shapes str attr_keys str attr_types int attr_pos int attr_ints float attr_floats str attr_strs str metadata_props_keys str metadata_props_values str domain= int version=None - Tensor _symbolic_multi_out inputs Sequence Optional torch Tensor op_type str onnx_dtypes Sequence int shapes Sequence Sequence Union int torch SymInt attr_keys Sequence str attr_types Sequence str attr_pos Sequence tuple int int attr_ints Sequence int attr_floats Sequence float attr_strs Sequence str metadata_props_keys Sequence str = metadata_props_values Sequence str = domain str = version Optional int = None - list torch Tensor outputs = torch _check len shapes == len onnx_dtypes lambda f Number shapes len shapes must match number ONNX dtypes len onnx_dtypes shape onnx_dtype zip shapes onnx_dtypes torch _check onnx_dtype _dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE lambda f onnx_dtype invalid ONNX data type Valid values list _dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE keys outputs append torch zeros shape dtype=_dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE onnx_dtype outputs _symbolic_multi_out register_fake _ inputs Sequence torch Tensor op_type str onnx_dtypes Sequence int shapes Sequence Sequence Union int torch SymInt attr_keys Sequence str attr_types Sequence str attr_pos Sequence tuple int int attr_ints Sequence int attr_floats Sequence float attr_strs Sequence str metadata_props_keys Sequence str = metadata_props_values Sequence str = domain str = version Optional int = None - list torch Tensor outputs = torch _check len shapes == len onnx_dtypes lambda f Number shapes len shapes must match number ONNX dtypes len onnx_dtypes shape onnx_dtype zip shapes onnx_dtypes torch _check onnx_dtype _dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE lambda f onnx_dtype invalid ONNX data type Valid values list _dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE keys NOTE justinchuby Use zeros instead torch empty because I haven t figured out how can handle empty shapes outputs append torch zeros shape dtype=_dtype_mappings ONNX_DTYPE_TO_TORCH_DTYPE onnx_dtype outputs