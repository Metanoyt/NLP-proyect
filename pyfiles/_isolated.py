Isolated calls methods may segfault __future__ annotations multiprocessing os warnings typing Any TYPE_CHECKING TypeVar TypeVarTuple Union Unpack typing_extensions ParamSpec TYPE_CHECKING collections abc Callable _P = ParamSpec _P _R = TypeVar _R _Ts = TypeVarTuple _Ts _IS_WINDOWS = os name == nt _call_function_and_return_exception func Callable Unpack _Ts _R args tuple Unpack _Ts kwargs dict str Any - Union _R Exception Call function exception there one try pyrefly ignore bad-argument-type func args kwargs except Exception e e safe_call func Callable _P _R args _P args kwargs _P kwargs - _R Call function separate process Args func The function call args The positional arguments pass function kwargs The keyword arguments pass function Returns The value function Raises Exception If function raised exception _IS_WINDOWS On Windows we cannot create new process fork warnings warn f A new process created func Windows stacklevel= func args kwargs multiprocessing get_context fork Pool pool It important fork process here prevent main logic running again when user does place under ` __name__ == __main__ ` block result = pool apply_async _call_function_and_return_exception func args kwargs result = result get timeout= isinstance result Exception raise result result