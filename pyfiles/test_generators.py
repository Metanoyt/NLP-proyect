======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_generators py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests __TestCase = CPythonTestCase redirect statements sys importlib abc redirect_imports = test mapping_tests test typinganndata test test_grammar test test_math test test_iter test typinganndata ann_module RedirectImportFinder importlib abc MetaPathFinder find_spec fullname path target=None Check problematic one fullname redirect_imports try Attempt standalone module name = fullname removeprefix test r = importlib import_module name Redirect module sys modules sys modules fullname = r Return module spec found module importlib util find_spec name except ImportError None None Add custom finder sys meta_path sys meta_path insert RedirectImportFinder ======= END DYNAMO PATCH ======= copy gc pickle sys doctest unittest weakref inspect types test support try _testcapi except ImportError _testcapi = None This tests make sure SIGINT arrives just before we send into yield chain KeyboardInterrupt raised innermost generator see bpo- unittest skipUnless _testcapi None hasattr _testcapi raise_SIGINT_then_send_None needs _testcapi raise_SIGINT_then_send_None SignalAndYieldFromTest __TestCase generator yield generator generator try yield except KeyboardInterrupt PASSED FAILED test_raise_and_yield_from gen = generator gen send None try _testcapi raise_SIGINT_then_send_None gen except BaseException _exc exc = _exc assertIs type exc StopIteration assertEqual exc value PASSED FinalizationTest __TestCase test_frame_resurrect A generator frame can resurrected generator s finalization gen nonlocal frame try yield finally frame = sys _getframe g = gen wr = weakref ref g next g del g support gc_collect assertIs wr None assertTrue frame del frame support gc_collect test_refcycle A generator caught refcycle gets finalized anyway old_garbage = gc garbage finalized = False gen nonlocal finalized try g = yield yield finally finalized = True g = gen next g g send g assertGreater sys getrefcount g assertFalse finalized del g support gc_collect assertTrue finalized assertEqual gc garbage old_garbage test_lambda_generator bpo- gh- Test lambda returning generator behaves like equivalent function f = lambda yield assertIsInstance f types GeneratorType assertEqual next f g yield test yield f = lambda yield g g yield g f = lambda yield f g yield f gen_fun f g f g f g gen = gen_fun assertEqual next gen assertRaises StopIteration cm gen send assertEqual cm exception value GeneratorTest __TestCase test_name func yield check generator names gen = func assertEqual gen __name__ func assertEqual gen __qualname__ GeneratorTest test_name locals func modify generator names gen __name__ = name gen __qualname__ = qualname assertEqual gen __name__ name assertEqual gen __qualname__ qualname generator names must string cannot deleted assertRaises TypeError setattr gen __name__ assertRaises TypeError setattr gen __qualname__ assertRaises TypeError delattr gen __name__ assertRaises TypeError delattr gen __qualname__ modify names function creating generator func __qualname__ = func_qualname func __name__ = func_name gen = func assertEqual gen __name__ func_name assertEqual gen __qualname__ func_qualname unnamed generator gen = x x range assertEqual gen __name__ genexpr assertEqual gen __qualname__ GeneratorTest test_name locals genexpr test_copy f yield g = f assertRaises TypeError copy copy g test_pickle f yield g = f proto range pickle HIGHEST_PROTOCOL + assertRaises TypeError pickle PicklingError pickle dumps g proto test_send_non_none_to_new_gen f yield g = f assertRaises TypeError g send assertEqual next g test_handle_frame_object_in_creation #Attempt expose partially constructed frames #See https github com python cpython issues cb args inspect stack gen yield thresholds = gc get_threshold gc callbacks append cb gc set_threshold try gen finally gc set_threshold thresholds gc callbacks pop Sneaky __del__ inspect stack sneaky = Sneaky sneaky _s = Sneaky sneaky _s _s = sneaky gc set_threshold try del sneaky gen finally gc set_threshold thresholds test_ag_frame_f_back async f yield ag = f assertIsNone ag ag_frame f_back test_cr_frame_f_back async f pass cr = f assertIsNone cr cr_frame f_back cr close Suppress RuntimeWarning test_gi_frame_f_back f yield gi = f assertIsNone gi gi_frame f_back test_issue gen_raises yield raise ValueError loop try _ gen_raises True False except ValueError pass #This should raise loop unittest expectedFailure test_genexpr_only_calls_dunder_iter_once Iterator __init__ val = __next__ val == raise StopIteration val += val No __iter__ method C __iter__ Iterator assertEqual list i i C ModifyUnderlyingIterableTest __TestCase iterables = range range frozenset non_iterables = None j genexpr x x range genfunc gen x yield x gen range process_tests get_generator obj iterables g_obj = get_generator obj subTest g_obj=g_obj obj=obj assertListEqual list g_obj list obj g_iter = get_generator iter obj subTest g_iter=g_iter obj=obj assertListEqual list g_iter list obj err_regex = object iterable obj non_iterables g_obj = get_generator obj subTest g_obj=g_obj assertRaisesRegex TypeError err_regex list g_obj test_modify_f_locals modify_f_locals g local obj g gi_frame f_locals local = obj g get_generator_genexpr obj modify_f_locals genexpr obj get_generator_genfunc obj modify_f_locals genfunc obj process_tests get_generator_genexpr process_tests get_generator_genfunc test_new_gen_from_gi_code new_gen_from_gi_code g obj generator_func = types FunctionType g gi_code generator_func obj get_generator_genexpr obj new_gen_from_gi_code genexpr obj get_generator_genfunc obj new_gen_from_gi_code genfunc obj process_tests get_generator_genexpr process_tests get_generator_genfunc ExceptionTest __TestCase Tests issue check currently handled exception correctly saved restored PyEval_EvalFrameEx test_except_throw store_raise_exc_generator try assertIsNone sys exception yield except Exception exc exception raised gen throw exc assertIsInstance sys exception ValueError assertIsNone exc __context__ yield ensure exception lost assertIsInstance sys exception ValueError yield we should able raise back ValueError raise make = store_raise_exc_generator next make try raise ValueError except Exception exc try make throw exc except Exception pass next make assertRaises ValueError cm next make assertIsNone cm exception __context__ assertIsNone sys exception test_except_next gen assertIsInstance sys exception ValueError yield done g = gen try raise ValueError except Exception assertEqual next g done assertIsNone sys exception test_except_gen_except gen try assertIsNone sys exception yield we called except ValueError TypeError must inherit ValueError its context raise TypeError except TypeError exc assertIsInstance sys exception TypeError assertEqual type exc __context__ ValueError here we still called except ValueError assertIsInstance sys exception ValueError yield assertIsNone sys exception yield done g = gen next g try raise ValueError except Exception next g assertEqual next g done assertIsNone sys exception test_nested_gen_except_loop gen i range assertIsInstance sys exception TypeError yield doing outer try raise TypeError except x gen yield x try raise ValueError except Exception x outer assertEqual x doing assertEqual sys exception None test_except_throw_exception_context gen try try assertIsNone sys exception yield except ValueError we called except ValueError assertIsInstance sys exception ValueError raise TypeError except Exception exc assertIsInstance sys exception TypeError assertEqual type exc __context__ ValueError we still called except ValueError assertIsInstance sys exception ValueError yield assertIsNone sys exception yield done g = gen next g try raise ValueError except Exception exc g throw exc assertEqual next g done assertIsNone sys exception test_except_throw_bad_exception E Exception __new__ cls args kwargs cls boring_generator yield gen = boring_generator err_msg = should have returned instance BaseException assertRaisesRegex TypeError err_msg gen throw E assertRaises StopIteration next gen generator assertRaisesRegex TypeError err_msg yield gen = generator next gen assertRaises StopIteration gen throw E test_gen_ _arg_deprecation_warning g yield gen = g assertWarns DeprecationWarning assertRaises TypeError gen throw TypeError TypeError None test_stopiteration_error See also PEP gen raise StopIteration yield assertRaisesRegex RuntimeError raised StopIteration next gen test_tutorial_stopiteration Raise StopIteration stops generator too f yield raise StopIteration yield never reached g = f assertEqual next g assertRaisesRegex RuntimeError raised StopIteration next g test_return_tuple g yield gen = g assertEqual next gen assertRaises StopIteration cm gen send assertEqual cm exception value test_return_stopiteration g yield gen = g assertEqual next gen assertRaises StopIteration cm gen send StopIteration assertIsInstance cm exception value StopIteration assertEqual cm exception value value GeneratorCloseTest __TestCase test_close_no_return_value f yield gen = f gen send None assertIsNone gen close test_close_return_value f try yield close raises GeneratorExit here which caught except GeneratorExit gen = f gen send None assertEqual gen close test_close_not_catching_exit f yield close raises GeneratorExit here which isn t caught therefore propagates -- no value gen = f gen send None assertIsNone gen close test_close_not_started f try yield except GeneratorExit gen = f assertIsNone gen close test_close_exhausted f try yield except GeneratorExit gen = f next gen assertRaises StopIteration next gen assertIsNone gen close test_close_closed f try yield except GeneratorExit gen = f gen send None assertEqual gen close assertIsNone gen close test_close_raises f try yield except GeneratorExit pass raise RuntimeError gen = f gen send None assertRaises RuntimeError gen close test_close_releases_frame_locals See gh- Foo pass f = Foo f_wr = weakref ref f genfn = f yield g = genfn next g del f g close support gc_collect assertIsNone f_wr GeneratorThrowTest __TestCase test_exception_context_with_yield f try raise KeyError except Exception yield gen = f gen send None assertRaises ValueError cm gen throw ValueError context = cm exception __context__ assertEqual type context context args KeyError test_exception_context_with_yield_inside_generator Check context also available inside generator yield opposed outside f try raise KeyError except Exception try yield except Exception exc assertEqual type exc ValueError context = exc __context__ assertEqual type context context args KeyError yield b gen = f gen send None actual = gen throw ValueError This ensures assertions inside executed assertEqual actual b test_exception_context_with_yield_from f yield g try raise KeyError except Exception yield f gen = g gen send None assertRaises ValueError cm gen throw ValueError context = cm exception __context__ assertEqual type context context args KeyError test_exception_context_with_yield_from_with_context_cycle Check trying create exception context cycle https bugs python org issue has_cycle = None f yield g exc nonlocal has_cycle try raise exc except Exception try yield f except Exception exc has_cycle = exc exc __context__ yield exc = KeyError gen = g exc gen send None gen throw exc This also distinguishes initial has_cycle=None assertEqual has_cycle False test_throw_after_none_exc_type g try raise KeyError except KeyError pass try yield except Exception raise RuntimeError gen = g gen send None assertRaises RuntimeError cm gen throw ValueError GeneratorStackTraceTest __TestCase check_stack_names frame expected names = while frame name = frame f_code co_name Stop checking frames when we get our test helper name startswith check_ name startswith call_ break names append name frame = frame f_back assertEqual names expected check_yield_from_example call_method f check_stack_names sys _getframe f g try yield except Exception pass check_stack_names sys _getframe f g g check_stack_names sys _getframe g yield f check_stack_names sys _getframe g gen = g gen send None try call_method gen except StopIteration pass test_send_with_yield_from call_send gen gen send None check_yield_from_example call_send test_throw_with_yield_from call_throw gen gen throw RuntimeError check_yield_from_example call_throw YieldFromTests __TestCase test_generator_gi_yieldfrom assertEqual inspect getgeneratorstate gen_b inspect GEN_RUNNING assertIsNone gen_b gi_yieldfrom yield assertEqual inspect getgeneratorstate gen_b inspect GEN_RUNNING assertIsNone gen_b gi_yieldfrom b assertIsNone gen_b gi_yieldfrom yield assertIsNone gen_b gi_yieldfrom yield assertIsNone gen_b gi_yieldfrom gen_b = b assertEqual inspect getgeneratorstate gen_b inspect GEN_CREATED assertIsNone gen_b gi_yieldfrom gen_b send None assertEqual inspect getgeneratorstate gen_b inspect GEN_SUSPENDED assertEqual gen_b gi_yieldfrom gi_code co_name gen_b send None assertEqual inspect getgeneratorstate gen_b inspect GEN_SUSPENDED assertIsNone gen_b gi_yieldfrom = gen_b Exhaust generator assertEqual inspect getgeneratorstate gen_b inspect GEN_CLOSED assertIsNone gen_b gi_yieldfrom tutorial_tests = Let s try simple generator f yield yield i f print i g = f next g next g Falling off end stops generator next g Traceback most recent call last File stdin line File stdin line g StopIteration also stops generator f yield yield never reached g = f next g next g Traceback most recent call last File stdin line File stdin line f StopIteration next g once stopped can t resumed Traceback most recent call last File stdin line StopIteration However StopIteration exactly equivalent g try except yield list g g try raise StopIteration except yield print list g This may surprising first g try finally yield list g Let s create alternate range function implemented generator yrange n i range n yield i list yrange Generators always most recent caller creator r = yrange print creator next r r caller r = creator i r print caller i caller creator caller caller caller caller Generators can call other generators zrange n i yrange n yield i list zrange The examples PEP pep_tests = Specification Yield Restriction A generator cannot resumed while actively running g i = next me yield i me = g next me Traceback most recent call last File string line g ValueError generator already executing Specification Return Note isn t always equivalent raising StopIteration difference lies how enclosing try except constructs treated For example f try except yield print list f because any function simply exits f try raise StopIteration except yield print list f because StopIteration captured bare except any exception Specification Generators Exception Propagation f g yield f zero division exception propagates yield we ll never get here k = g next k Traceback most recent call last File stdin line File stdin line g File stdin line f ZeroDivisionError integer division modulo zero next k generator cannot resumed Traceback most recent call last File stdin line StopIteration Specification Try Except Finally f try yield try yield yield never get here except ZeroDivisionError yield yield raise except yield yield raise above stops except yield yield try x = finally yield yield print list f Guido s binary tree example A binary tree Tree __init__ label left=None right=None label = label left = left right = right __repr__ level= indent= s = level indent + repr label left s = s + \\n + left __repr__ level+ indent right s = s + \\n + right __repr__ level+ indent s __iter__ inorder Create Tree list tree list n = len list n == i = n Tree list i tree list i tree list i+ Show off create tree t = tree ABCDEFGHIJKLMNOPQRSTUVWXYZ A recursive generator generates Tree labels in-order inorder t t x inorder t left yield x yield t label x inorder t right yield x Show off create tree t = tree ABCDEFGHIJKLMNOPQRSTUVWXYZ Print nodes tree in-order x t print +x end= A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A non-recursive generator inorder node stack = while node while node left stack append node node = node left yield node label while node right try node = stack pop except IndexError yield node label node = node right Exercise non-recursive generator x t print +x end= A B C D E F G H I J K L M N O P Q R S T U V W X Y Z Examples Iterator-List Python-Dev c l py email_tests = The difference between yielding None returning g i range yield None yield None list g None None None None Ensure explicitly raising StopIteration acts like any other exception try except like g yield try raise StopIteration except yield yield list g Next one posted c l py gcomb x k Generate all combinations k elements list x k len x k == yield first rest = x x A combination does doesn t contain first If does remainder k- comb rest c gcomb rest k- c insert first yield c If doesn t contain first s k comb rest c gcomb rest k yield c seq = list range k range len seq + print d-combs s k seq c gcomb seq k print c -combs -combs -combs -combs -combs -combs From Iterators list about types these things g yield type g function i = g type i generator s s dir i s startswith _ close gi_code gi_frame gi_running gi_suspended gi_yieldfrom send throw test support HAVE_DOCSTRINGS print i __next__ __doc__ HAVE_DOCSTRINGS Implement next Implement next iter i i True types isinstance i types GeneratorType True And more added later i gi_running type i gi_frame frame i gi_running = Traceback most recent call last AttributeError attribute gi_running generator objects writable g yield me gi_running me = g me gi_running next me me gi_running A clever union-find implementation c l py due David Eppstein Sent Friday June PM To python-list python org Subject Re PEP Simple Generators disjointSet __init__ name name = name parent = None generator = generate generate while parent yield x parent generator yield x find next generator union parent parent raise ValueError Sorry I m root parent = parent __str__ name names = ABCDEFGHIJKLM sets = disjointSet name name names roots = sets random gen = random Random while s sets print s- s s s find end= print len roots s = gen choice roots roots remove s s = gen choice roots s union s print merged s into s break A- A B- B C- C D- D E- E F- F G- G H- H I- I J- J K- K L- L M- M merged K into B A- A B- B C- C D- D E- E F- F G- G H- H I- I J- J K- B L- L M- M merged A into F A- F B- B C- C D- D E- E F- F G- G H- H I- I J- J K- B L- L M- M merged E into F A- F B- B C- C D- D E- F F- F G- G H- H I- I J- J K- B L- L M- M merged D into C A- F B- B C- C D- C E- F F- F G- G H- H I- I J- J K- B L- L M- M merged M into C A- F B- B C- C D- C E- F F- F G- G H- H I- I J- J K- B L- L M- C merged J into B A- F B- B C- C D- C E- F F- F G- G H- H I- I J- B K- B L- L M- C merged B into C A- F B- C C- C D- C E- F F- F G- G H- H I- I J- C K- C L- L M- C merged F into G A- G B- C C- C D- C E- G F- G G- G H- H I- I J- C K- C L- L M- C merged L into C A- G B- C C- C D- C E- G F- G G- G H- H I- I J- C K- C L- C M- C merged G into I A- I B- C C- C D- C E- I F- I G- I H- H I- I J- C K- C L- C M- C merged I into H A- H B- C C- C D- C E- H F- H G- H H- H I- H J- C K- C L- C M- C merged C into H A- H B- H C- H D- H E- H F- H G- H H- H I- H J- H K- H L- H M- H Emacs turd Fun tests sufficiently warped notions fun fun_tests = Build up recursive Sieve Eratosthenes generator firstn g n next g i range n intsfrom i while yield i i += firstn intsfrom exclude_multiples n ints i ints i n yield i firstn exclude_multiples intsfrom sieve ints prime = next ints yield prime not_divisible_by_prime = exclude_multiples prime ints p sieve not_divisible_by_prime yield p primes = sieve intsfrom firstn primes Another famous problem generate all integers form i j k increasing order where i j k = Trickier than may look first Try writing without generators correctly without generating internal results each result output times n g i g yield n i firstn times intsfrom merge g h ng = next g nh = next h while ng nh yield ng ng = next g ng nh yield nh nh = next h yield ng ng = next g nh = next h The following works doing whale lot redundant work -- s clear how get internal uses m share single generator Note me_times etc each need see every element result sequence So example where lazy lists more natural you can look head lazy list any number times m yield me_times = times m me_times = times m me_times = times m i merge merge me_times me_times me_times yield i Don t print too many these -- implementation above extremely inefficient each call m leads recursive calls turn each those more so so until we ve descended enough levels satisfy print stmts Very odd when I printed lines results below managed screw up Win s malloc usual way i e heap grew over Mb so Win started fragmenting address space looked like very slow leak result = m i range print firstn result Heh Here s one way get shared list complete excruciating namespace renaming trick The pretty part times merge functions can reused as-is because they only assume their stream arguments iterable -- LazyList same generator times LazyList __init__ g sofar = fetch = g __next__ __getitem__ i sofar fetch = sofar fetch while i = len sofar sofar append fetch sofar i m yield Gack m below actually refers LazyList me_times = times m me_times = times m me_times = times m i merge merge me_times me_times me_times yield i Print many these you like -- implementation memory- efficient m = LazyList m i range print m j j range i i+ Ye olde Fibonacci generator LazyList style fibgen b sum g h while yield next g + next h tail g next g throw first away x g yield x yield yield b s sum iter fib tail iter fib yield s fib = LazyList fibgen firstn iter fib Running after your tail itertools tee new version The algorithms m Hamming Fibonacci presented above both examples whole family FP functional programming algorithms where function produces returns list while production algorithm suppose list already produced recursively calling itself For these algorithms work they must - produce least first element without presupposing existence rest list - produce their elements lazy manner To work efficiently beginning list must recomputed over over again This ensured most FP languages built-in feature In python we have explicitly maintain list already computed results abandon genuine recursivity This what had been attempted above LazyList One problem keeps list all generated results therefore continually grows This partially defeats goal generator concept viz produce results only needed instead producing them all thereby wasting memory Thanks itertools tee now clear how get internal uses m share single generator itertools tee m _m yield n merge times m merge times m times m yield n m = _m m m m mRes = tee m mRes = m i range print firstn The tee function does just what we want It internally keeps generated result long has been consumed all duplicated iterators whereupon deleted You can therefore print hamming sequence during hours without increasing memory usage very little The beauty recursive running-after-their-tail FP algorithms quite straightforwardly expressed Python idiom Ye olde Fibonacci generator tee style fib _isum g h while yield next g + next h _fib yield yield next fibTail throw first away res _isum fibHead fibTail yield res realfib = _fib fibHead fibTail fibRes = tee realfib fibRes firstn fib syntax_tests mostly provokes SyntaxErrors Also fiddling #if hackery syntax_tests = These fine f yield f try yield finally pass f try try except ZeroDivisionError yield except pass finally pass f try try yield except ZeroDivisionError yield except try x = finally yield except list f f yield type f generator f yield type f generator f yield type f generator f yield None type f generator f try x== pass try except SyntaxError pass while x += yield don t blink f b c d e pass except x = type f generator f g yield type f NoneType f C __init__ yield f yield type f NoneType f yield type f generator This one caused crash see SF bug f i range try continue finally yield i g = f print next g print next g print next g print next g Traceback most recent call last StopIteration Test gi_code attribute f yield g = f g gi_code f __code__ True next g next g Traceback most recent call last StopIteration g gi_code f __code__ True Test __name__ attribute repr f yield g = f g __name__ f repr g doctest +ELLIPSIS generator object f Lambdas shouldn t have their usual behavior x = lambda yield list x x = lambda yield yield list x conjoin simple backtracking generator named honor Icon s conjunction control structure Pass list no-argument functions iterable objects Easiest explain example assume function list x y z passed Then conjoin acts like g values = None values x values y values z yield values So some -lists values may generated each time we successfully get into innermost loop If iterator fails exhausted before then backtracks get next value nearest enclosing iterator one left starts all over again next slot pumps fresh iterator Of course most useful when iterators have side-effects so which values can generated each slot depend values iterated previous slots simple_conjoin gs values = None len gs gen i i = len gs yield values values i gs i x gen i+ yield x x gen yield x That works fine recursing level checking i against len gs each item produced inefficient By doing manual loop unrolling across generator boundaries s possible eliminate most overhead This isn t worth bother general generators conjoin core building block some CPU-intensive generator applications conjoin gs n = len gs values = None n Do one loop nest time recursively until loop nests remaining divisible gen i i = n yield values n-i ip = i+ values i gs i x gen ip yield x x _gen i yield x Do three loop nests time recursing only least three more remain Don t call directly internal optimization gen s use _gen i assert i n n-i == ip ip ip = i+ i+ i+ g g g = gs i ip ip = n These last three so we can yield values directly values i g values ip g values ip g yield values At least loop nests remain peel off recurse rest values i g values ip g values ip g x _gen ip yield x x gen yield x And one more approach For backtracking apps like Knight s Tour solver below number backtracking levels can enormous one level per square Knight s Tour so e g x board needs levels In such cases Python likely run out stack space due recursion So here s recursion-free version conjoin too NOTE WELL This allows large problems solved only trivial demands stack space Without explicitly resumable generators much harder achieve OTOH much slower up factor than fancy unrolled recursive conjoin flat_conjoin gs rename conjoin run tests instead n = len gs values = None n iters = None n _StopIteration = StopIteration make local because caught lot i = while Descend try while i n = iters i = gs i __next__ values i = i += except _StopIteration pass assert i == n yield values Backtrack until older iterator can resumed i -= while i = try values i = iters i Success Start fresh next level i += break except _StopIteration Continue backtracking i -= assert i break A conjoin-based N-Queens solver Queens __init__ n n = n rangen = range n Assign unique int each column diagonal columns n those range n NW-SE diagonals n- these i-j unique invariant along each smallest i-j - n- = -n so add n- shift - based NE-SW diagonals n- these i+j unique invariant along each smallest i+j largest n- For each square compute bit vector columns diagonals covers each row compute function generates possibilities columns row rowgenerators = i rangen rowuses = j &#124; column ordinal n + i-j + n- &#124; NW-SE ordinal n + n- + i+j NE-SW ordinal j rangen rowgen rowuses=rowuses j rangen uses = rowuses j uses used == used &#124; = uses yield j used = ~uses rowgenerators append rowgen Generate solutions solve used = row col conjoin rowgenerators yield row col printsolution row col n = n assert n == len row col sep = + + -+ n print sep i range n squares = j range n squares row col i = Q print &#124; + &#124; join squares + &#124; print sep A conjoin-based Knight s Tour solver This pretty sophisticated e g when used flat_conjoin above passing hard= constructor x Knight s Tour found quickly -- note we re creating s thousands generators then lengthy Knights __init__ m n hard= m n = m n solve will set up succs i list square #i s successors succs = succs = Remove i each its successor s successor lists i e successors can t go back i again Return we can detect makes solution impossible remove_from_successors i len=len If we remove all exits free square we re dead even we move next we can t leave again If we create square one exit we must visit next somebody will have visit since there s only one adjacent there won t way leave again Finally we create more than one free square single exit we can only move one them next leaving other one dead end ne = ne = i succs i s = succs i s remove i e = len s e == ne += e == ne += ne == ne Put i back each its successor s successor lists add_to_successors i i succs i succs i append i Generate first move first m n Since we re looking cycle doesn t matter where we start Starting corner makes nd move easy corner = coords index remove_from_successors corner lastij = corner yield corner add_to_successors corner Generate second moves second corner = coords index assert lastij == corner i e we started corner m n assert len succs corner == assert coords index succs corner assert coords index succs corner Only two choices Whichever we pick other must square picked move m n s only way get back Save its index final so moves before last know must kept free i j = coords index i j final = coords index -i -j final = final remove_from_successors succs final append corner lastij = yield succs final remove corner add_to_successors Generate moves through m n- advance len=len If some successor has only one exit must take Else favor successors fewer exits candidates = i succs lastij e = len succs i assert e remove_from_successors pruning flawed e == candidates = e i break candidates append e i candidates sort e i candidates i = final remove_from_successors i lastij = i yield i add_to_successors i Generate moves through m n- Alternative version using stronger more expensive heuristic order successors Since backtracking levels m n poor move early can take eons undo Smallest square board which matters lot x advance_hard vmid= m- hmid= n- len=len If some successor has only one exit must take Else favor successors fewer exits Break ties via max distance board centerpoint favor corners edges whenever possible candidates = i succs lastij e = len succs i assert e remove_from_successors pruning flawed e == candidates = e i break i j = index coords i d = i - vmid + j - hmid candidates append e -d i candidates sort e d i candidates i = final remove_from_successors i lastij = i yield i add_to_successors i Generate last move last assert final succs lastij yield final m n squaregenerators = first squaregenerators = first second + \ hard advance_hard advance m n - + \ last coords index i j assert = i m assert = j n i n + j index coords index assert = index m n divmod index n _init_board succs = succs del succs m n = m n c i = coords index offsets = - - - - - - - - rangen = range n i range m j rangen s = c i i+io j+jo io jo offsets = i+io m = j+jo n succs append s Generate solutions solve _init_board x conjoin squaregenerators yield x printsolution x m n = m n assert len x == m n w = len str m n format = + str w + d squares = None n i range m k = i x i j = index coords i squares i j = format k k += sep = + + - w + + n print sep i range m row = squares i print &#124; + &#124; join row + &#124; print sep conjoin_tests = Generate -bit binary numbers order This illustrates dumbest- possible use conjoin just generate full cross-product c conjoin lambda iter print c For efficiency typical backtracking apps conjoin yields same list object each time So you want save away full account its generated sequence you need copy its results gencopy iterator x iterator yield x n range all = list gencopy conjoin lambda iter n print n len all all == n all - == n True True True True True True True True True True True True True True True True True True True True And run -queens solver q = Queens LIMIT = count = row col q solve count += count = LIMIT print Solution count q printsolution row col Solution +-+-+-+-+-+-+-+-+ &#124; Q &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; &#124; Q &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; Q &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; &#124; &#124; Q &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; Q &#124; &#124; &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; &#124; &#124; &#124; Q &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; Q &#124; &#124; &#124; &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; Q &#124; &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ Solution +-+-+-+-+-+-+-+-+ &#124; Q &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; &#124; &#124; Q &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; Q &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; Q &#124; &#124; &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; &#124; &#124; &#124; Q &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; Q &#124; &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; Q &#124; &#124; &#124; &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ &#124; &#124; &#124; &#124; &#124; Q &#124; &#124; &#124; &#124; +-+-+-+-+-+-+-+-+ print count solutions all solutions all And run Knight s Tour x board Note there about solutions even x board so don t dare run exhaustion k = Knights LIMIT = count = x k solve count += count = LIMIT print Solution count k printsolution x break Solution + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + Solution + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; &#124; + --- + --- + --- + --- + --- + --- + --- + --- + --- + --- + weakref_tests = \ Generators weakly referencable weakref gen yield foo wr = weakref ref gen wr gen True p = weakref proxy gen Generator-iterators weakly referencable well gi = gen wr = weakref ref gi wr gi True p = weakref proxy gi list p foo coroutine_tests = \ test support gc_collect Sending value into started generator f print yield yield g = f next g g send Sending value into new generator produces TypeError f send foo Traceback most recent call last TypeError can t send non-None value just-started generator Yield itself yields None f yield list f None Yield allowed only outermost iterable generator expression f list i i yield type f generator A yield expression augmented assignment coroutine seq count = while count count += yield seq append count seq = c = coroutine seq next c print seq c send print seq c send print seq c send print seq Check some syntax errors yield expressions f=lambda yield yield Traceback most recent call last SyntaxError yield outside function f=lambda yield yield Traceback most recent call last SyntaxError yield outside function yield Traceback most recent call last SyntaxError yield outside function f x = yield = y Traceback most recent call last SyntaxError assignment yield expression possible f yield bar = y Traceback most recent call last SyntaxError cannot assign yield expression here Maybe you meant == instead = f yield bar += y Traceback most recent call last SyntaxError yield expression illegal expression augmented assignment Now check some throw conditions f while True try print yield except ValueError v print caught ValueError s v sys g = f next g g throw ValueError type only caught ValueError g throw ValueError xyz value only caught ValueError xyz warnings old_filters = warnings filters copy warnings filterwarnings ignore category=DeprecationWarning Filter DeprecationWarning regarding type val tb signature throw Deprecation warnings re-enabled below g throw ValueError ValueError value+matching type caught ValueError g throw ValueError TypeError mismatched type rewrapped caught ValueError g throw ValueError ValueError None explicit None traceback caught ValueError g throw ValueError foo bad args Traceback most recent call last TypeError instance exception may have separate value g throw ValueError foo bad args Traceback most recent call last TypeError throw third argument must traceback object g throw abc Traceback most recent call last TypeError exceptions must classes instances deriving BaseException str g throw Traceback most recent call last TypeError exceptions must classes instances deriving BaseException int g throw list Traceback most recent call last TypeError exceptions must classes instances deriving BaseException type throw g exc try raise exc except g throw sys exc_info throw g ValueError do traceback included caught ValueError g send throw g TypeError terminate generator Traceback most recent call last TypeError print g gi_frame None g send Traceback most recent call last StopIteration g throw ValueError throw closed generator Traceback most recent call last ValueError f throw ValueError throw just-opened generator Traceback most recent call last ValueError warnings filters = old_filters Re-enable DeprecationWarning type val tb exception representation deprecated may removed future version Python Plain raise inside generator should preserve traceback The traceback should have levels - g throw - f - f try yield except raise g = f try except ZeroDivisionError v try g throw v except Exception w tb = w __traceback__ levels = while tb levels += tb = tb tb_next levels Now let s try closing generator f try yield except GeneratorExit print exiting g = f next g g close exiting g close should no-op now f close close just-opened generator should fine f yield even simpler generator f close close before opening g = f next g g close close normally And finalization f try yield finally print exiting g = f next g del g gc_collect For PyPy other GCs exiting GeneratorExit caught except Exception f try yield except Exception print except finally print finally g = f next g del g gc_collect For PyPy other GCs finally Now let s try some ill-behaved generators f try yield except GeneratorExit yield foo g = f next g g close Traceback most recent call last RuntimeError generator ignored GeneratorExit g close Our ill-behaved code should invoked during GC support catch_unraisable_exception cm g = f next g del g cm unraisable exc_type == RuntimeError generator ignored GeneratorExit str cm unraisable exc_value cm unraisable exc_traceback None True True True And errors thrown during closing should propagate f try yield except GeneratorExit raise TypeError fie g = f next g g close Traceback most recent call last TypeError fie Ensure various yield expression constructs make their enclosing function generator f x += yield type f generator f x = yield type f generator f lambda x= yield type f generator f d d yield = d yield b = data = g = f data type g generator g send None data g send b data try g send except StopIteration pass data refleaks_tests = Prior adding cycle-GC support itertools tee code would leak references We add standard suite so routine refleak-tests would trigger starts being uncleanable again itertools leak gen __iter__ __next__ item g = gen head tail = itertools tee g g item = head head = leak Make sure also test involvement tee-internal teedataobject which stores returned items item = next This test leaked one point due generator finalization destruction It copied Lib test leakers test_generator_cycle py before file removed leak gen while True yield g g = gen leak This test isn t really generator related rather exception-in-cleanup related The coroutine tests above just happen cause exception generator s __del__ tp_del method We can also test explicitly without generators We do have redirect stderr avoid printing warnings doublecheck we actually tested what we wanted test test support Leaker __del__ invoke message raise RuntimeError message invoke del failed support catch_unraisable_exception cm l = Leaker del l cm unraisable object == Leaker __del__ cm unraisable exc_type == RuntimeError str cm unraisable exc_value == del failed cm unraisable exc_traceback None True True True True These refleak tests should perhaps testfile their own test_generators just happened test drew these out __test__ = tut tutorial_tests pep pep_tests email email_tests fun fun_tests syntax syntax_tests conjoin conjoin_tests weakref weakref_tests coroutine coroutine_tests refleaks refleaks_tests load_tests loader tests pattern ======= BEGIN Dynamo patch ======= suite = doctest DocTestSuite test suite Dynamically change base test __class__ = type test __class__ __name__ __TestCase test __class__ tests addTests suite ======= END DYNAMO PATCH ======= tests __name__ == __main__ run_tests