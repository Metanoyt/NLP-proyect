mypy allow-untyped-defs collections operator collections abc Mapping functools reduce __all__ = merge merge_with valmap keymap itemmap valfilter keyfilter itemfilter assoc dissoc assoc_in update_in get_in _get_factory f kwargs factory = kwargs pop factory dict kwargs raise TypeError f f __name__ got unexpected keyword argument kwargs popitem factory merge dicts kwargs Merge collection dictionaries merge one two one two Later dictionaries have precedence merge See Also merge_with len dicts == isinstance dicts Mapping dicts = dicts factory = _get_factory merge kwargs rv = factory d dicts rv update d rv merge_with func dicts kwargs Merge dictionaries apply function combined values A key may occur more than one dict all values mapped key will passed function list such func val val merge_with sum merge_with first doctest +SKIP See Also merge len dicts == isinstance dicts Mapping dicts = dicts factory = _get_factory merge_with kwargs result = factory d dicts k v d items k result result k = v result k append v valmap func result factory valmap func d factory=dict Apply function values dictionary bills = Alice Bob valmap sum bills doctest +SKIP Alice Bob See Also keymap itemmap rv = factory rv update zip d keys map func d values rv keymap func d factory=dict Apply function keys dictionary bills = Alice Bob keymap str lower bills doctest +SKIP alice bob See Also valmap itemmap rv = factory rv update zip map func d keys d values rv itemmap func d factory=dict Apply function items dictionary accountids = Alice Bob itemmap reversed accountids doctest +SKIP Alice Bob See Also keymap valmap rv = factory rv update map func d items rv valfilter predicate d factory=dict Filter items dictionary value iseven = lambda x x == d = valfilter iseven d See Also keyfilter itemfilter valmap rv = factory k v d items predicate v rv k = v rv keyfilter predicate d factory=dict Filter items dictionary key iseven = lambda x x == d = keyfilter iseven d See Also valfilter itemfilter keymap rv = factory k v d items predicate k rv k = v rv itemfilter predicate d factory=dict Filter items dictionary item isvalid item k v = item k == v d = itemfilter isvalid d See Also keyfilter valfilter itemmap rv = factory item d items predicate item k v = item rv k = v rv assoc d key value factory=dict Return new dict new key value pair New dict has d key set value Does modify initial dictionary assoc x x x assoc x y doctest +SKIP x y d = factory d update d d key = value d dissoc d keys kwargs Return new dict given key s removed New dict has d key deleted each supplied key Does modify initial dictionary dissoc x y y x dissoc x y y x dissoc x y Ignores missing keys x factory = _get_factory dissoc kwargs d = factory len keys len d d update d key keys key d del d key remaining = set d remaining difference_update keys k remaining d k = d k d assoc_in d keys value factory=dict Return new dict new potentially nested key value pair purchase = name Alice order items Apple Orange costs credit card - - - assoc_in purchase order costs doctest +SKIP credit card - - - name Alice order costs items Apple Orange update_in d keys lambda x value value factory update_in d keys func default=None factory=dict Update value potentially nested dictionary inputs d - dictionary which operate keys - list tuple giving location value changed d func - function operate value If keys == k kX d k kX == v update_in returns copy original dictionary v replaced func v does mutate original dictionary If k key d update_in creates nested dictionaries depth specified keys innermost value set func default inc = lambda x x + update_in inc transaction = name Alice purchase items Apple Orange costs credit card - - - update_in transaction purchase costs sum doctest +SKIP credit card - - - name Alice purchase costs items Apple Orange updating value when k d update_in str default= bar bar update_in foo inc foo ks = iter keys k = next ks rv = inner = factory rv update d pyrefly ignore not-iterable key ks k d d = d k dtemp = factory dtemp update d d = dtemp = factory inner k = inner = dtemp k = key k d inner k = func d k inner k = func default rv get_in keys coll default=None no_default=False Returns coll i i iX where i i iX ==keys If coll i i iX cannot found returns ` ` default ` ` unless ` ` no_default ` ` specified then raises KeyError IndexError ` ` get_in ` ` generalization ` ` operator getitem ` ` nested data structures such dictionaries lists transaction = name Alice purchase items Apple Orange costs credit card - - - get_in purchase items transaction Apple get_in name transaction Alice get_in purchase total transaction get_in purchase items apple transaction get_in purchase items transaction get_in purchase total transaction get_in y no_default=True Traceback most recent call last KeyError y See Also itertoolz get operator getitem try reduce operator getitem keys coll except KeyError IndexError TypeError no_default raise default getter index isinstance index list len index == index = index lambda x x index index operator itemgetter index lambda x operator itemgetter index groupby key seq Group collection key function names = Alice Bob Charlie Dan Edith Frank groupby len names doctest +SKIP Bob Dan Alice Edith Frank Charlie iseven = lambda x x == groupby iseven doctest +SKIP False True Non-callable keys imply grouping member groupby gender name Alice gender F name Bob gender M name Charlie gender M doctest +SKIP F gender F name Alice M gender M name Bob gender M name Charlie Not confused ` ` itertools groupby ` ` See Also countby callable key key = getter key d = collections defaultdict lambda append type ignore var-annotated item seq d key item item rv = k v d items rv k = v __self__ type ignore var-annotated attr-defined rv first seq The first element sequence first ABC A next iter seq