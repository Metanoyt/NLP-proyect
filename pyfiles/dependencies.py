abc dataclasses itertools logging re collections abc Iterable Sequence typing Any Callable Optional TypeVar Union typing_extensions Self unittest mock patch sympy torch torch _inductor utils get_free_symbols torch fx experimental symbolic_shapes free_symbols free_unbacked_symbols torch utils _ordered_set OrderedSet utils _sympy symbol make_symbol SymT codegen common index_prevent_reordering ops_handler DefaultHandler utils get_dtype_size reduction_num_outputs sympy_index_symbol sympy_subs VarRanges virtualized ReductionType V T = TypeVar T log = logging getLogger __name__ is_indirect = re compile r indirect &#124; tmp search Dep abc ABC name str index sympy Expr abc abstractmethod get_free_symbol_uses unbacked_only bool = False - OrderedSet sympy Symbol pass abc abstractmethod rename renames dict str str - Self pass abc abstractmethod get_numel - sympy Expr pass abc abstractmethod numbytes_hint - int pass abc abstractmethod has_unbacked_symbols - bool pass abc abstractmethod is_contiguous - bool pass normalize_with_stride_order prefix str = t - Self dataclasses dataclass frozen=True MemoryDep Dep pyrefly ignore bad-override name str pyrefly ignore bad-override index sympy Expr var_names tuple sympy Symbol size tuple sympy Expr mode Optional str = None get_free_symbol_uses unbacked_only bool = False - OrderedSet sympy Symbol get_free_symbols index unbacked_only &#124; get_free_symbols size unbacked_only &#124; get_free_symbols var_names unbacked_only __repr__ - str maybe_mode = mode None maybe_mode = f mode f MemoryDep name r index ranges maybe_mode property num_vars - int len var_names decide_loop_order_to_match other MemoryDep - Optional list int Can None able decide loop orders assert num_vars == other num_vars ignore broadcast now since broadcast causes extra strides which makes hard decide correct loop orders num_vars = len index free_symbols None other num_vars = len other index free_symbols None bail out any size For size == s empty tensor any strides dimension equivalent Skip simplicity may matter much For size == cause cause tie strides different dimensions Also when we first time create LoopBody ComputedBuffer simplify_and_reorder we can dependencies index_vars_squeeze which should already sqeeuze size == dimensions any s == s == s itertools chain size other size None Extract strides both expression self_strides = V graph sizevars stride_hints index var_names other_strides = V graph sizevars stride_hints other index other var_names Even shape contains no some complex index expression may still have duplicate stride values Here example https gist github com shunting e ec aa e ec d ab We don t reorder loop these cases now theory we could improve algorithm detect correct loop orders len OrderedSet self_strides = len self_strides len OrderedSet other_strides = len other_strides log debug unable decide loop order self_dep= s v s other_dep= s self_strides= s v s other_strides= s other self_strides other_strides None May happen other follows MemoryDep addmm_ d + d + d d d d None MemoryDep addmm_ d + d + d d d d None OrderedSet self_strides = OrderedSet other_strides None stride_to_index = s i i s enumerate self_strides order = stride_to_index s s other_strides assert OrderedSet order == OrderedSet range num_vars order get_offset - sympy Expr Return offset setting every variable sympy_subs index dict fromkeys var_names normalize - MemoryDep Normalize merging loops The different normalize_with_stride_order method does reorder loops while normalize_with_stride_order reorder loops based stride order MemoryDep name _RecordLoadStoreInner _normalize index ranges type ignore arg-type mode normalize_with_stride_order prefix str = t - MemoryDep r Used decide two MemoryDep does equal due different loop orders More specifically when dep dep equal we can normalize both check they equal after If yes then mismatch caused different loop orders here avoid circular torch _inductor ir strides = V graph sizevars stride_hints index var_names pick loop order stride ordered decreasingly order = sorted range len strides key=strides __getitem__ reverse=True stride_reorder = ir same_reorder order sizes = size var_names = var_names new_reordered_sizes = stride_reorder sizes new_reordered_var_names = stride_reorder var_names new_simplified_sizes reindex _prune = V graph sizevars _simplify_loops new_reordered_var_names new_reordered_sizes index_prevent_reordering index new_reordered_var_names new_reordered_sizes now let s create new symbols passed prefix var_ranges add_var = var_builder prefix replacement = dict zip new_reordered_var_names reindex add_var x x new_simplified_sizes new_index = sympy_subs sympy expand index replacement type ignore arg-type next PR out = MemoryDep name new_index tuple var_ranges keys tuple var_ranges values type ignore arg-type out property ranges - dict sympy Symbol sympy Expr c c dict zip var_names size simplify_with_ranges - MemoryDep MemoryDep name=self name index=V graph sizevars simplify_with_ranges index ranges var_names=self var_names size=self size mode=self mode get_numel - sympy Expr is_indirect numel = V graph get_numel name vars OrderedSet sympy Basic = OrderedSet index free_symbols numel = sympy S One var size zip var_names size var vars numel = numel size numel type ignore return-value rename renames dict str str - MemoryDep name renames MemoryDep renames name index var_names=self var_names size=self size mode=self mode numbytes_hint - int try V graph sizevars size_hint get_numel get_dtype_size V graph get_dtype name except NotImplementedError NoneLayout has_unbacked_symbols - bool len free_unbacked_symbols get_numel is_contiguous - bool isinstance index sympy Integer True isinstance index sympy Symbol index var_names stride _for_last_dim result_for_complex_expression bool = True - bool Whether stride last dimension python test inductor test_torchinductor_opinfo py -k test_comprehensive_masked_scatter_cuda_float will exercise thru corner case len var_names == True terms = index args isinstance index sympy Add index last_sym = var_names - term terms term == last_sym True Having stride last dimension bad perf False isinstance term sympy Mul len term args == term args == last_sym isinstance term args int sympy Integer term args False result_for_complex_expression is_scalar - bool isinstance index sympy Symbol index var_names is_indirect isinstance index int sympy Integer is_indirect - bool any is_indirect v name v index free_symbols type ignore attr-defined dataclasses dataclass frozen=True StarDep Dep pyrefly ignore bad-override name str mode Optional str = None depends entire buffer property pyrefly ignore bad-override index - sympy Expr raise NotImplementedError StarDep does have index get_numel - sympy Expr V graph get_numel name type ignore return-value rename renames dict str str - StarDep name renames StarDep renames name mode get_free_symbol_uses unbacked_only bool = False - OrderedSet sympy Symbol OrderedSet numbytes_hint - int try V graph sizevars size_hint get_numel get_dtype_size V graph get_dtype name except NotImplementedError NoneLayout MultiOutputLayout etc has_unbacked_symbols - bool len free_unbacked_symbols get_numel is_contiguous - bool False is_scalar - bool False is_indirect - bool False Used tracking mutation ordering A reads buffer B mutates B must ordered after A This useful variety reasons For example A s read never actually used we can eliminate Another case A s buffer ends up being fused away we never need materialize buffer dataclasses dataclass frozen=True WeakDep Dep Fake dependency unused buffer pyrefly ignore bad-override name str Buffer doing mutation mutating_buf str WeakDep s also used add dependencies prevent some specific reordering E g collectives global ordering But other pass guarantees proper ordering its logic This additional fake deps will holding optimizations This flag used identify those additional deps is_fake bool = False get_free_symbol_uses unbacked_only bool = False - OrderedSet sympy Symbol OrderedSet property pyrefly ignore bad-override index - sympy Expr raise NotImplementedError WeakDep does have index get_numel - sympy Expr sympy S One rename renames dict str str - WeakDep name renames WeakDep renames name mutating_buf is_fake numbytes_hint - int Purely inserted ordering actual dep has_unbacked_symbols - bool False is_contiguous - bool False dataclasses dataclass frozen=True IndexExprDep index sympy Expr type ignore assignment var_names tuple sympy Symbol size tuple sympy Expr dataclasses dataclass ReadWrites reads OrderedSet Dep writes OrderedSet Dep index_exprs OrderedSet IndexExprDep range_vars Optional list sympy Expr = None var_ranges Optional VarRanges = None rename renames dict str str - ReadWrites ReadWrites OrderedSet dep rename renames dep reads OrderedSet dep rename renames dep writes index_exprs range_vars var_ranges with_read dep Union Dep OrderedSet Dep - ReadWrites assert isinstance dep WeakDep StarDep OrderedSet isinstance dep OrderedSet dep = OrderedSet dep ReadWrites OrderedSet union reads dep writes index_exprs range_vars var_ranges merge other ReadWrites - ReadWrites reads = OrderedSet union reads other reads writes = OrderedSet union writes other writes index_exprs = OrderedSet union index_exprs other index_exprs ReadWrites reads - writes writes index_exprs staticmethod merge_list read_writes list ReadWrites - ReadWrites all_writes = OrderedSet union rw writes rw read_writes all_reads = OrderedSet union rw reads rw read_writes - all_writes all_index_exprs = OrderedSet union rw index_exprs rw read_writes ReadWrites all_reads all_writes all_index_exprs remove_reads rem_reads OrderedSet Dep - ReadWrites ReadWrites reads - rem_reads writes index_exprs range_vars var_ranges reads_and_writes - Iterable Dep itertools chain reads writes buffer_names ignore_integer_index bool = True - OrderedSet str Integer index used load_seed names OrderedSet str = OrderedSet dep reads_and_writes isinstance dep MemoryDep continue ignore_integer_index isinstance dep index int sympy Integer names add dep name names get_free_symbol_uses unbacked_only bool = False - OrderedSet sympy Symbol result OrderedSet sympy Symbol = OrderedSet dep reads_and_writes result &#124; = dep get_free_symbol_uses unbacked_only result _RecordLoadStoreInner V MockHandler type ignore name-defined __init__ var_ranges VarRanges normalize bool - None super __init__ _reads OrderedSet Dep = OrderedSet _writes OrderedSet MemoryDep = OrderedSet _index_exprs OrderedSet IndexExprDep = OrderedSet _var_ranges VarRanges = var_ranges _should_normalize bool = normalize staticmethod drop_unused_symbols index Union int sympy Expr var_names list sympy Expr sizes list sympy Expr - None Reduction has last reduced dim its sizes downstream users won t Normalize away isinstance index sympy Expr index can int free_symbols = index free_symbols while var_names var_names - free_symbols var_names pop sizes pop classmethod _normalize cls index sympy Expr var_ranges VarRanges - tuple sympy Expr tuple sympy Symbol tuple sympy Expr Try further simplify indexes even simplify_loops didn t convert simplest form because interference different indexing formulas index_vars = var_ranges keys sizes = tuple var_ranges values type ignore assignment new_sizes reindex _prune = V graph sizevars _simplify_loops index_vars sizes index_prevent_reordering index index_vars sizes assign new variables each dimension deal numbering mismatches d d d could become d d -- which won t match d d new_vars add_var = var_builder canonicalization_prefix replacement = dict zip index_vars reindex add_var x x new_sizes index = sympy_subs sympy expand index replacement new_vars = new_vars keys new_sizes = new_sizes cls drop_unused_symbols index new_vars new_sizes index tuple new_vars tuple new_sizes type ignore arg-type canonicalize index sympy Expr - tuple sympy Expr tuple sympy Symbol tuple sympy Expr _should_normalize sizes = V graph sizevars simplify x x _var_ranges values var_names = k k v zip _var_ranges keys sizes v = sizes = v v sizes v = drop_unused_symbols index var_names sizes index tuple var_names tuple sizes type ignore return-value arg-type var_ranges = k V graph sizevars simplify v k v _var_ranges items TODO jansel explore further normalization k free_symbols _normalize index var_ranges load name str index sympy Expr - None _reads add MemoryDep name canonicalize index load_seed name str index int - None assert isinstance index int load name sympy Integer index store name str index sympy Expr value str mode Optional str = None - None _writes add MemoryDep name canonicalize index mode=mode store_reduction name str index sympy Expr value str - None store name index f store_reduction value index_expr index sympy Expr dtype Optional torch dtype - None _index_exprs add IndexExprDep canonicalize index bucketize values T boundaries tuple str sympy Expr sympy Expr sympy Expr boundary_indices T indexing_dtype torch dtype right bool sorter Optional tuple str sympy Expr = None sorter_indices Optional T = None - None Records names buffers bucketize will read _reads add StarDep boundaries sorter None _reads add StarDep sorter RecordLoadStore V KernelFormatterHandler type ignore name-defined __init__ var_ranges VarRanges normalize bool - None parent_handler = _RecordLoadStoreInner var_ranges=var_ranges normalize=normalize super __init__ parent_handler=parent_handler TODO check call sites var_builder prefix str - tuple VarRanges Callable sympy Expr sympy Symbol cnt = itertools count var_ranges VarRanges = add_var length sympy Expr - sympy Symbol v = sympy_index_symbol f prefix next cnt var_ranges v = length v var_ranges add_var index_vars_no_squeeze argsizes Sequence sympy Expr prefix str - tuple list list sympy Symbol VarRanges var_ranges add_var = var_builder prefix args list list sympy Symbol = list map add_var size size argsizes args var_ranges index_vars_squeeze argsizes Sequence sympy Expr prefix str = d - tuple list Sequence sympy Expr VarRanges ir SqueezeView var_ranges add_var = var_builder prefix args list Sequence sympy Expr = new_sizes list Sequence sympy Expr = size argsizes new_size reindex = SqueezeView squeezer size new_sizes append new_size args append reindex list map add_var new_size args var_ranges extract_read_writes fn Callable Any argsizes Sequence sympy Expr normalize bool = False prefix str = d hidden_args Sequence list sympy Expr = - ReadWrites args var_ranges = index_vars_squeeze argsizes prefix=prefix loop_body LoopBody isinstance fn LoopBody inner = extract_loop_body_with_args fn args hidden_args type ignore list-item var_ranges normalize Slow path tracing function rw = RecordLoadStore var_ranges normalize=normalize V set_ops_handler rw fn args hidden_args inner = rw parent_handler normalize range_vars = Number vars could differ due normalization range_vars = itertools chain from_iterable args ReadWrites pyrefly ignore missing-attribute OrderedSet inner _reads pyrefly ignore missing-attribute OrderedSet inner _writes pyrefly ignore missing-attribute inner _index_exprs range_vars var_ranges extract_loop_body_with_args fn Any args list list sympy Expr var_ranges VarRanges normalize bool = False - _RecordLoadStoreInner loop_body MemoryUsageType Fast path avoid tracing when we already have LoopBody inner = _RecordLoadStoreInner var_ranges=var_ranges normalize=normalize name_to_index = fn indexing_from_args args fn indirect_vars mimic ` tmpX ` naming tracing gives us repl = v make_symbol SymT TMP i i v enumerate fn indirect_vars name_to_index = k sympy_subs v repl k v name_to_index items type ignore arg-type entry fn memory_usage MemoryUsageType LOAD inner load entry buffer_name name_to_index entry index_name type ignore arg-type entry fn memory_usage MemoryUsageType LOAD_SEED inner load_seed entry buffer_name int name_to_index entry index_name type ignore arg-type entry fn memory_usage MemoryUsageType STORE inner store entry buffer_name name_to_index entry index_name None type ignore arg-type entry mode entry fn memory_usage MemoryUsageType STORE_REDUCTION inner store_reduction entry buffer_name name_to_index entry index_name None type ignore arg-type entry fn memory_usage MemoryUsageType INDEX_EXPR inner index_expr name_to_index entry index_name None entry fn memory_usage MemoryUsageType BUCKETIZE All matters we record buffer name so place boundaries name position ensure s recorded inner bucketize None entry buffer_name None None None None None type ignore arg-type None type ignore arg-type fn memory_usage MemoryUsageType CHECK_BOUNDS intentionally skipped inner extract_input_node_reduction_ranges input_node torch _inductor ir IRNode - tuple Optional list sympy Expr Optional list sympy Expr Returns size reduction size all inputs sizes reduction_sizes exist all same It s possible node has multiple inputs some Reduction nodes others Pointwise nodes In case reduction_sizes Reduction nodes need same Otherwise returns None None ir ComputedBuffer ExternKernel Loops size Optional list sympy Expr reduction_size Optional list sympy Expr isinstance input_node get_defining_op ComputedBuffer Input node has already been realized Return its size reduction_size size = input_node get_size reduction_size = input_node get_reduction_size len reduction_size size reduction_size None None isinstance input_node data data Loops type ignore attr-defined Other IRNodes do have reduction_ranges None None There one issue what there views permutations between input node its dependent realized nodes The current method still uses reduction ranges dependent realized node which ideal Is there way check whether there permutations between reads = input_node get_reads reduction_size Optional list sympy Expr = None size Optional list sympy Expr = None while reduction_size None len reads seen OrderedSet str = OrderedSet new_reads list Dep = read reads isinstance read MemoryDep continue read name seen continue seen add read name buffer = V graph try_get_buffer read name buffer None continue op = buffer get_defining_op op None isinstance op ExternKernel continue isinstance op ComputedBuffer len op get_reduction_size reduction_size None reduction_size = op get_reduction_size size = op get_size reduction_size = op get_reduction_size size = op get_size None None new_reads extend op get_reads reads == new_reads size reduction_size reads = OrderedSet new_reads size reduction_size canonicalization_prefix - str c ops handler which computes all free symbols IR FreeSymbolsOpsHandler DefaultHandler symbols OrderedSet sympy Symbol __init__ unbacked_only bool = True - None symbols = OrderedSet get_symbols = free_unbacked_symbols unbacked_only free_symbols _default name str args tuple Any kwargs dict str Any - Any itertools chain args kwargs values isinstance sympy Expr sympy logic boolalg Boolean symbols &#124; = get_symbols indirect_indexing index_var Any size Union int sympy Expr check bool = True wrap_neg bool = True - sympy Symbol assert isinstance index_var sympy Expr sympy logic boolalg Boolean symbols &#124; = get_symbols size sympy_index_symbol f str index_var frexp x Any - tuple None None scan dtypes Any combine_fn Any values Sequence Any - tuple None None len values sort dtypes Any values Sequence Any stable Any descending Any - tuple None None len values reduction dtype torch dtype src_dtype torch dtype reduction_type ReductionType value Union None tuple None - Union None tuple None num_values = reduction_num_outputs reduction_type None num_values num_values None masked mask Any body Callable Any other Any - None assert callable body masked body must always callable The body can make additional calls e g ops indirect_indexing body extract_free_symbols fn Callable Any index Sequence sympy Expr rindex Optional Sequence sympy Expr = None unbacked_only bool = True - OrderedSet sympy Symbol ir FlexibleLayout args = index rindex rindex None index handler = FreeSymbolsOpsHandler unbacked_only NB I cargo culted allow_indexing patch here I don t understand why people do all over V set_ops_handler handler patch object FlexibleLayout allow_indexing True fn args handler symbols