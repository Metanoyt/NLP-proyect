Handle details subprocess calls retries given benchmark run mypy ignore-errors dataclasses json os pickle signal subprocess time uuid typing Optional TYPE_CHECKING Union core api AutoLabels core types Label core utils get_temp_dir worker main WORKER_PATH WorkerFailure WorkerOutput WorkerTimerArgs WorkerUnpickler TYPE_CHECKING PopenType = subprocess Popen bytes PopenType = subprocess Popen Mitigate https github com pytorch pytorch issues _ENV = MKL_THREADING_LAYER=GNU _PYTHON = python PYTHON_CMD = f _ENV _PYTHON We must specify ` bash ` so ` source activate ` always works SHELL = bin bash dataclasses dataclass frozen=True WorkOrder Spec schedule work benchmark runner label Label autolabels AutoLabels timer_args WorkerTimerArgs source_cmd Optional str = None timeout Optional float = None retries int = __hash__ - int id __str__ - str json dumps label label autolabels autolabels as_dict num_threads timer_args num_threads _BenchmarkProcess Wraps subprocess Popen given WorkOrder _work_order WorkOrder _cpu_list Optional str _proc PopenType Internal bookkeeping _communication_file str _start_time float _end_time Optional float = None _retcode Optional int _result Optional Union WorkerOutput WorkerFailure = None __init__ work_order WorkOrder cpu_list Optional str - None _work_order = work_order _cpu_list = cpu_list _start_time = time time _communication_file = os path join get_temp_dir f uuid uuid pkl open _communication_file wb f pickle dump _work_order timer_args f _proc = subprocess Popen cmd stdout=subprocess PIPE stderr=subprocess STDOUT shell=True executable=SHELL clone - _BenchmarkProcess _BenchmarkProcess _work_order _cpu_list property cmd - str cmd list str = _work_order source_cmd None cmd extend _work_order source_cmd cmd append _ENV _cpu_list None cmd extend f GOMP_CPU_AFFINITY= _cpu_list taskset -- cpu-list _cpu_list cmd extend _PYTHON WORKER_PATH -- communication-file _communication_file join cmd property duration - float _end_time time time - _start_time property result - Union WorkerOutput WorkerFailure _maybe_collect assert _result None _result poll - Optional int _maybe_collect _retcode interrupt - None Soft interrupt Allows subprocess cleanup _proc send_signal signal SIGINT terminate - None Hard interrupt Immediately SIGTERM subprocess _proc terminate _maybe_collect - None _result None We ve already collected results _retcode = _proc poll _retcode None ` _proc ` still running open _communication_file rb f result = WorkerUnpickler f load_output isinstance result WorkerOutput _retcode Worker managed complete designated task worker process did finish cleanly result = WorkerFailure Worker failed silently isinstance result WorkerTimerArgs Worker failed did write result so we re left original TimerArgs Grabbing all stdout stderr isn t ideal we don t have better way determine what keep proc_stdout = _proc stdout assert proc_stdout None result = WorkerFailure failure_trace=proc_stdout read decode utf- _result = result _end_time = time time Release communication file os remove _communication_file InProgress Used benchmark runner track outstanding jobs This handles bookkeeping timeout + retry logic _proc _BenchmarkProcess _timeouts int = __init__ work_order WorkOrder cpu_list Optional str _work_order = work_order _proc = _BenchmarkProcess work_order cpu_list property work_order - WorkOrder _proc _work_order property cpu_list - Optional str _proc _cpu_list property proc - _BenchmarkProcess NB For cleanup only _proc property duration - float _proc duration check_finished - bool _proc poll None True timeout = work_order timeout timeout None _proc duration timeout False _timeouts += max_attempts = _work_order retries + _timeouts max_attempts print f \nTimeout _work_order label _work_order autolabels f Attempt _timeouts max_attempts _proc interrupt _proc = _proc clone False raise subprocess TimeoutExpired cmd=self _proc cmd timeout=timeout property result - Union WorkerOutput WorkerFailure _proc result __hash__ - int id