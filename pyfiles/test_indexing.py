Owner s module dynamo functools operator re sys warnings itertools product unittest expectedFailure xfail skipIf skipif SkipTest pytest pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests skipIfTorchDynamo TEST_WITH_TORCHDYNAMO TestCase xpassIfTorchDynamo_np TEST_WITH_TORCHDYNAMO numpy np numpy testing assert_ assert_array_equal assert_equal assert_warns HAS_REFCOUNT torch _numpy np torch _numpy testing assert_ assert_array_equal assert_equal assert_warns HAS_REFCOUNT skip = functools partial skipif True instantiate_parametrized_tests TestIndexing TestCase test_index_no_floats = np array assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda assert_raises IndexError lambda - assert_raises IndexError lambda - assert_raises IndexError lambda - assert_raises IndexError lambda - assert_raises IndexError lambda - assert_raises IndexError lambda - assert_raises IndexError lambda - assert_raises IndexError lambda - assert_raises IndexError lambda - assert_raises IndexError lambda - Note torch validates index arguments depth-first so will prioritise raising TypeError over IndexError e g = np array IndexError only integers slices ` ` ellipsis ` ` numpy newaxis ` None ` integer boolean arrays valid indices t = torch as_tensor identical t TypeError slice indices must integers None have __index__ method assert_raises IndexError TypeError lambda assert_raises IndexError TypeError lambda test_slicing_no_floats = np array start float assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda stop float assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda step float assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda mixed assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda assert_raises TypeError lambda should still get DeprecationWarning step = assert_raises TypeError lambda skip reason= torch allows slicing non- d array components test_index_no_array_to_index No non-scalar arrays = np array assert_raises TypeError lambda Conversely using scalars doesn t raise NumPy e g i = np int i i i array shape= dtype=int test_none_index ` None ` index adds newaxis = np array assert_equal None np newaxis assert_equal None ndim ndim + skip test_empty_tuple_index Empty tuple index creates view = np array assert_equal assert_ tensor _base tensor = np array assert_ isinstance np int_ test_same_kind_index_casting Indexes should cast same-kind safe even somewhat unsafe So test various different code paths index = np arange u_index = index astype np uint i e cast default uint indexing dtype arr = np arange assert_array_equal arr index arr u_index arr u_index = np arange assert_array_equal arr np arange arr = np arange reshape assert_array_equal arr index arr u_index arr u_index = np arange None assert_array_equal arr np arange None repeat axis= arr = np arange reshape assert_array_equal arr u_index u_index arr index index test_empty_fancy_index Empty list index creates empty array same dtype weird shape = np array assert_equal assert_equal dtype dtype b = np array dtype=np intp assert_equal assert_equal dtype dtype b = np array assert_raises IndexError __getitem__ b test_ellipsis_index = np array assert_ assert_equal ` ` ` ` numpy Slicing ellipsis can skip arbitrary number dimensions assert_equal assert_equal assert_equal Slicing ellipsis always results array scalar assert_equal np array Assignment ` Ellipsis ` -d arrays b = np array b Ellipsis = assert_equal b xpassIfTorchDynamo_np torch_ np array does have base attribute test_ellipsis_index_ = np array assert_ assert_equal ` ` ` ` numpy assert_ base test_single_int_index Single integer index selects one row = np array assert_equal assert_equal - Index out bounds produces IndexError assert_raises IndexError __getitem__ Index overflow produces IndexError Note torch raises RuntimeError here assert_raises IndexError ValueError __getitem__ test_single_bool_index Single boolean index = np array assert_equal np array True None assert_equal np array False None test_boolean_shape_mismatch arr = np ones index = np array True assert_raises IndexError arr __getitem__ index index = np array False assert_raises IndexError arr __getitem__ index index = np zeros dtype=bool assert_raises IndexError arr __getitem__ index assert_raises IndexError arr __getitem__ slice None index test_boolean_indexing_onedim Indexing -dimensional array boolean array length one = np array b = np array True dtype=bool assert_equal b boolean assignment b = assert_equal skip reason= NP_VER fails CI test_boolean_assignment_value_mismatch A boolean assignment should fail when shape values cannot broadcast subscription see also gh- = np arange f v - = v assert_raises RuntimeError ValueError TypeError f assert_raises RuntimeError ValueError TypeError f assert_raises RuntimeError ValueError TypeError f test_boolean_indexing_twodim Indexing -dimensional array -dimensional boolean array = np array b = np array True False True False True False True False True assert_equal b assert_equal b assert_equal b b boolean assignment b = assert_equal test_boolean_indexing_list Regression test It s use-after-free bug which test won t directly catch will show up valgrind = np array b = True False True Two variants test because first takes fast path assert_equal b assert_equal None b test_reverse_strides_and_subspace_bufferinit This tests strides reversed simple subspace fancy indexing = np ones b = np zeros dtype=np intp - c = np arange - b = c If strides reversed arange comes last assert_equal This also tests subspace buffer initialized = np ones c = np arange reshape - b = c assert_equal test_reversed_strides_result_allocation Test bug when calculating output strides result array when subspace size test other cases well = np arange None i = np arange - assert_array_equal i i copy C = np arange reshape - test_uncontiguous_subspace_assignment During development there bug activating skip logic based ndim instead size = np full - b = np full - = np arange reshape T b = np arange reshape T copy assert_equal b skip reason= torch does limit dims test_too_many_fancy_indices_special_case Just documents behaviour small limitation = np ones NPY_MAXDIMS assert_raises IndexError __getitem__ np array test_scalar_array_bool NumPy bools can used boolean index python ones yet = np array assert_equal np bool_ True np array True assert_equal np bool_ False np array False After deprecating bools integers = np array assert_equal True None assert_equal True None assert_ np may_share_memory True test_everything_returns_views Before ` ` would itself = np arange assert_ assert_ assert_ test_broaderrors_indexing = np zeros assert_raises IndexError __getitem__ assert_raises IndexError __setitem__ test_trivial_fancy_out_of_bounds = np zeros ind = np ones dtype=np intp ind - = assert_raises IndexError __getitem__ ind assert_raises IndexError RuntimeError __setitem__ ind ind = np ones dtype=np intp ind = assert_raises IndexError __getitem__ ind assert_raises IndexError RuntimeError __setitem__ ind test_trivial_fancy_not_possible Test fast path trivial assignment incorrectly used when index contiguous D see also gh- = np arange idx = np arange dtype=np intp reshape assert_array_equal idx idx case must go into fast path note idx non-contiguous none D array here idx = - res = np arange res = - res = - assert_array_equal res test_memory_order This necessary preserve Memory layouts more complex indices simple = np arange b = np arange reshape T assert_ b flags f_contiguous Takes different implementation branch = reshape - assert_ b flags f_contiguous skipIfTorchDynamo XXX flaky depends implementation details test_small_regressions Reference count intp index checks = np array HAS_REFCOUNT refcount = sys getrefcount np dtype np intp item setting always checks indices separate function np array dtype=np intp = np array dtype=np uint = assert_raises IndexError __setitem__ np array dtype=np intp assert_raises IndexError __setitem__ np array dtype=np uint HAS_REFCOUNT assert_equal sys getrefcount np dtype np intp refcount test_tuple_subclass arr = np ones A tuple subclass should also nd-index TupleSubclass tuple __slots__ = index = index = TupleSubclass index assert_ arr index shape == Unlike non nd-index assert_ arr index shape = xpassIfTorchDynamo_np reason= XXX low-prio behaviour support test_broken_sequence_not_nd_index See https github com numpy numpy issues If we have object which claims sequence fails item getting should converted nd-index tuple If object happens valid index otherwise should work This object here very dubious probably bad though SequenceLike __index__ __len__ __getitem__ item raise IndexError Not possible arr = np arange assert_array_equal arr SequenceLike arr SequenceLike also test field indexing does segfault similar reason indexing structured array arr = np zeros dtype= f i f i assert_array_equal arr SequenceLike arr SequenceLike test_indexing_array_weird_strides See also gh- shapes used here come issue create correct size iterator buffering size x = np ones x = np ones ind = np arange None None None ind = np broadcast_to ind single advanced index case assert_array_equal x ind x ind copy higher dimensional advanced index zind = np zeros dtype=np intp assert_array_equal x ind zind x ind copy zind test_indexing_array_negative_strides From gh- core dumps negative strides used iteration arro = np zeros arr = arro - - slices = slice None arr slices = assert_array_equal arr parametrize index True False np array parametrize num parametrize original_ndim test_too_many_advanced_indices index num original_ndim These limitations based number arguments we can process For ` num= ` all boolean cases result actually define use NpyIter NPY_MAXARGS limits technical reasons isinstance index np ndarray original_ndim num unskipped cases fail because assigning too many indices raise SkipTest torch does limit dims arr = np ones original_ndim pytest raises IndexError arr index num pytest raises IndexError arr index num = test_nontuple_ndindex = np arange reshape assert_equal np array assert_equal np array raise SkipTest torch happily consumes non-tuple sequences multi-axis indices i e slices index whereas NumPy invalidates them assumedly keep things simple This invalidation behaviour just too niche bother emulating assert_raises IndexError __getitem__ slice None instantiate_parametrized_tests TestBroadcastedAssignments TestCase assign ind val ind = val test_prepending_ones = np zeros = np ones Fancy subspace without transpose = np ones = np ones Fancy without subspace broadcasting = np ones test_prepend_not_one assign = assign s_ = np s_ = np zeros Too large only ones try assign s_ np ones except Exception e assertTrue isinstance e ValueError RuntimeError assert_raises ValueError RuntimeError assign s_ np ones assert_raises ValueError RuntimeError assign s_ np ones test_simple_broadcasting_errors assign = assign s_ = np s_ = np zeros try assign s_ np zeros except Exception e assertTrue isinstance e ValueError RuntimeError try assign s_ np zeros except Exception e assertTrue isinstance e ValueError RuntimeError assert_raises ValueError RuntimeError assign s_ np zeros assert_raises ValueError RuntimeError assign s_ np zeros assert_raises ValueError RuntimeError assign s_ np zeros parametrize index slice None test_broadcast_error_reports_correct_shape index values = np zeros will never broadcast below arr = np zeros pytest raises ValueError RuntimeError e arr index = values shape = arr index shape r_inner_shape = join f side side shape - + str shape - assert re search rf \ \ r_inner_shape \ \ $ str e value test_index_is_larger Simple case fancy index broadcasting index = np zeros = assert_ == all test_broadcast_subspace = np zeros v = np arange None b = np arange - b = v assert_ - == v all TestFancyIndexingCast TestCase xpassIfTorchDynamo_np reason= XXX low-prio support assigning complex values floating arrays test_boolean_index_cast_assign Setup boolean index float arrays shape = bool_index = np zeros shape astype bool bool_index = True zero_array = np zeros shape Assigning float fine zero_array bool_index = np array assert_equal zero_array np ComplexWarning moved np exceptions numpy = np exceptions only available numpy = has_exceptions_ns = hasattr np exceptions ComplexWarning = np exceptions ComplexWarning has_exceptions_ns np ComplexWarning Fancy indexing works although we get cast warning assert_warns ComplexWarning zero_array __setitem__ np array + j assert_equal zero_array No complex part Cast complex float throwing away imaginary portion assert_warns ComplexWarning zero_array __setitem__ bool_index np array j assert_equal zero_array xfail reason= XXX requires broadcast broadcast_to TestMultiIndexingAutomated TestCase These tests use code mimic C-Code indexing selection NOTE This still lacks tests complex item setting If you change behavior indexing you might want modify these tests try more combinations Behavior written match numpy version though first version matched Only tuple indices supported mimicking code tested writing Error types should match most time long there only one error For multiple errors what gets raised will usually same one They tested Update - - It probably worth maintaining test indefinitely can dropped maintenance becomes burden setupUp = np arange np prod reshape b = np empty complex_indices = skip Ellipsis Boolean indices up -d some special cases eating up dimensions also need test all False np array True False False np array True False False True np array False False False False Some slices slice - slice slice - - slice None None - Some Fancy indexes np empty dtype=np intp empty can broadcast np array - np array np array - dtype=np dtype intp np array - dtype=np int np zeros dtype=int trigger too large array np array invalid datatype Some simpler indices still cover bit more simple_indices = Ellipsis None - np array True skip Very simple ones fill rest fill_indices = slice None None _get_multi_index arr indices Mimic multi dimensional indexing Parameters ---------- arr ndarray Array indexed indices tuple index objects Returns ------- out ndarray An array equivalent indexing operation always copy ` arr indices ` should identical no_copy bool Whether indexing operation requires copy If ` True ` ` np may_share_memory arr arr indices ` should ` True ` some exceptions scalars possibly -d arrays Notes ----- While function may mostly match errors normal indexing generally case in_indices = list indices indices = False fancy boolean index no_copy = True number fancy scalar indexes consecutive num_fancy = number dimensions indexed fancy index fancy_dim = NOTE This funny twist probably OK change The boolean array has illegal indexes allowed broadcast fancy-indices -sized This variable catch case error_unless_broadcast_to_empty = False We need handle Ellipsis make arrays indices also check fancy indexing set no_copy ndim = ellipsis_pos = None define here mostly replace all first i indx enumerate in_indices indx None continue isinstance indx np ndarray indx dtype == bool no_copy = False indx ndim == raise IndexError boolean indices can have higher dimensions ndim += indx ndim fancy_dim += indx ndim continue indx Ellipsis ellipsis_pos None ellipsis_pos = i continue do increment ndim counter raise IndexError isinstance indx slice ndim += continue isinstance indx np ndarray This could open changes numpy numpy should maybe raise error casting intp safe It rejects np array index same ie np take Note importance empty lists changing here try indx = np array indx dtype=np intp except ValueError raise IndexError None in_indices i = indx indx dtype kind = b indx dtype kind = i raise IndexError arrays used indices must integer boolean type indx ndim = no_copy = False ndim += fancy_dim += arr ndim - ndim we can t take more dimensions then we have even -d arrays since makes sense We will raise error later unless broadcasting error occurs first raise IndexError ndim == None in_indices Well we have no indexes one Ellipsis This legal arr copy no_copy ellipsis_pos None in_indices ellipsis_pos ellipsis_pos + = slice None None arr ndim - ndim ax indx enumerate in_indices isinstance indx slice convert index array indx = np arange indx indices arr shape ax indices append s indx continue indx None like taking slice one element new axis indices append n np array dtype=np intp arr = arr reshape arr shape ax + + arr shape ax continue isinstance indx np ndarray indx dtype == bool indx shape = arr shape ax ax + indx ndim raise IndexError try flat_indx = np ravel_multi_index np nonzero indx arr shape ax ax + indx ndim mode= raise except Exception error_unless_broadcast_to_empty = True fill s instead raise error later flat_indx = np array indx sum dtype=np intp concatenate axis into single one indx ndim = arr = arr reshape arr shape ax + np prod arr shape ax ax + indx ndim + arr shape ax + indx ndim indx = flat_indx This could changed -d boolean index can make sense even outside -d indexed array case Note originally could interpreted integer full integer special case raise IndexError If index singleton bounds check done before broadcasting This used different indx ndim == indx = arr shape ax indx -arr shape ax raise IndexError indx ndim == The index scalar This used two fold fancy indexing active check done later possibly after broadcasting away earlier Now always done indx = arr shape ax indx -arr shape ax raise IndexError len indices indices - == f ax = ellipsis_pos NOTE There could still have been -sized Ellipsis between them Checked ellipsis_pos indices - append indx We have fancy index after existing one NOTE A -d array triggers well while one may expect trigger since scalar would considered fancy indexing num_fancy += indices append f indx num_fancy no_copy We have flush fancy indexes left new_indices = indices axes = list range arr ndim fancy_axes = new_indices insert f ni = ai = indx indices ni += indx == f new_indices extend indx del new_indices ni ni -= ax range ai ai + len indx fancy_axes append ax axes remove ax ai += len indx - axis we indices = new_indices now we need transpose arr arr = arr transpose fancy_axes + axes We only have one f index now arr transposed accordingly Now handle newaxis reshaping ax = indx indices indx == f len indx == continue First all reshape arr combine fancy axes into one orig_shape = arr shape orig_slice = orig_shape ax ax + len indx arr = arr reshape arr shape ax + np prod orig_slice astype int + arr shape ax + len indx Check broadcasting works res = np broadcast indx unfortunately indices might out bounds So check first use mode= wrap then However only there any indices res size = error_unless_broadcast_to_empty raise IndexError _indx _size zip indx orig_slice _indx size == continue np any _indx = _size np any _indx -_size raise IndexError len indx == len orig_slice np prod orig_slice == Work around crash IndexError wrap some -sized cases try mi = np ravel_multi_index indx orig_slice mode= raise except Exception exc This happens -sized orig_slice sometimes here ValueError indexing gives raise IndexError invalid index into -sized exc mi = np ravel_multi_index indx orig_slice mode= wrap Maybe never happens raise ValueError arr = arr take mi ravel axis=ax try arr = arr reshape arr shape ax + mi shape + arr shape ax + except ValueError too many dimensions probably raise IndexError None ax += mi ndim continue If we here we have D array take arr = arr take indx axis=ax ax += arr no_copy _check_multi_index arr index Check multi index item getting simple setting Parameters ---------- arr ndarray Array indexed must reshaped arange index tuple indexing objects Index being tested Test item getting try mimic_get no_copy = _get_multi_index arr index except Exception e HAS_REFCOUNT prev_refcount = sys getrefcount arr assert_raises type e arr __getitem__ index assert_raises type e arr __setitem__ index HAS_REFCOUNT assert_equal prev_refcount sys getrefcount arr _compare_index_result arr index mimic_get no_copy _check_single_index arr index Check single index item getting simple setting Parameters ---------- arr ndarray Array indexed must arange index indexing object Index being tested Must single index tuple indexing objects see also ` _check_multi_index ` try mimic_get no_copy = _get_multi_index arr index except Exception e HAS_REFCOUNT prev_refcount = sys getrefcount arr assert_raises type e arr __getitem__ index assert_raises type e arr __setitem__ index HAS_REFCOUNT assert_equal prev_refcount sys getrefcount arr _compare_index_result arr index mimic_get no_copy _compare_index_result arr index mimic_get no_copy Compare mimicked result indexing result raise SkipTest torch does support subclassing arr = arr copy indexed_arr = arr index assert_array_equal indexed_arr mimic_get Check we got view unless its -sized -d array then its view does matter indexed_arr size = indexed_arr ndim = assert_ np may_share_memory indexed_arr arr == no_copy Check reference count original array HAS_REFCOUNT no_copy refcount increases one assert_equal sys getrefcount arr assert_equal sys getrefcount arr Test non-broadcast setitem b = arr copy b index = mimic_get + b size == nothing compare here no_copy indexed_arr ndim = change indexed_arr in-place manipulate original indexed_arr += assert_array_equal arr b Use fact array originally arange arr flat indexed_arr ravel += assert_array_equal arr b test_boolean = np array assert_equal np array True np array True = assert_equal NOTE This different normal broadcasting arr boolean_array works like multi index Which means aligned left This probably correct consistency arr boolean_array also no broadcasting done all _check_multi_index np zeros_like dtype=bool _check_multi_index np zeros_like dtype=bool _check_multi_index np zeros_like dtype=bool None test_multidim Automatically test combinations complex indexes nd st spot simple ones one other spot warnings catch_warnings This so np array True accepted full integer index when running file separately warnings filterwarnings error DeprecationWarning np VisibleDeprecationWarning moved np exceptions numpy = np exceptions only available numpy = has_exceptions_ns = hasattr np exceptions VisibleDeprecationWarning = noqa F np exceptions VisibleDeprecationWarning has_exceptions_ns np VisibleDeprecationWarning FIXME rec should use VisibleDeprecationWarning instead warnings filterwarnings error np VisibleDeprecationWarning isskip idx isinstance idx str idx == skip simple_pos tocheck = fill_indices complex_indices fill_indices fill_indices tocheck simple_pos = simple_indices index product tocheck index = tuple i i index isskip i _check_multi_index index _check_multi_index b index Check very simple item getting _check_multi_index _check_multi_index b Also check simple cases too many indices assert_raises IndexError __getitem__ assert_raises IndexError __setitem__ assert_raises IndexError __getitem__ assert_raises IndexError __setitem__ test_ d = np arange index complex_indices _check_single_index index TestFloatNonIntegerArgument TestCase These test ` ` TypeError ` ` raised when you try use non-integers arguments indexing slicing e g ` ` ` ` ` ` ` ` other functions like ` ` array reshape - ` ` test_valid_indexing These should raise no errors = np array np array test_valid_slicing These should raise no errors = np array test_non_integer_argument_errors = np array assert_raises TypeError np reshape - assert_raises TypeError np reshape np array - assert_raises TypeError np take assert_raises TypeError RuntimeError np take np float skip reason= torch doesn t have scalar types distinct element-wise behaviours test_non_integer_sequence_multiplication NumPy scalar sequence multiply should work non-integers mult b b assert_raises TypeError mult np float following should OK mult np int_ test_reduce_axis_float_index d = np zeros assert_raises TypeError np min d assert_raises TypeError np min d assert_raises TypeError np min d assert_raises TypeError np min d TestBooleanIndexing TestCase Using boolean integer argument indexing error test_bool_as_int_argument_errors = np array assert_raises TypeError np reshape True - Note operator index np array True does work boolean array thus also deprecated same message assert_warns DeprecationWarning operator index np True_ assert_raises TypeError np take args= False raise SkipTest torch consumes boolean tensors ints no bother raising here assert_raises TypeError np reshape np bool_ True - assert_raises TypeError operator index np array True test_boolean_indexing_weirdness Weird boolean indexing things = np ones assert False True shape == assert True True True shape == assert_raises IndexError lambda False test_boolean_indexing_fast_path These used either give wrong error incorrectly give no error = np ones This used incorrectly work give array shape idx = np array False pytest raises IndexError idx This used incorrectly give ValueError operands could broadcast together idx = np array False + True pytest raises IndexError idx This same used The above two should work like idx = np array False pytest raises IndexError idx This used give ValueError non-broadcastable operand = np ones idx = np array True False pytest raises IndexError idx TestArrayToIndexDeprecation TestCase Creating index array -D error test_array_to_index_error so no exception expected The raising effectively tested above = np array assert_raises TypeError RuntimeError np take raise SkipTest Multi-dimensional tensors indexable just long they only contain single element no bother raising here assert_raises TypeError operator index np array raise SkipTest torch consumes tensors ints no bother raising here assert_raises TypeError np reshape - TestNonIntegerArrayLike TestCase Tests array_likes only valid can safely cast integer For instance lists give IndexError when they cannot safely cast integer skip reason= torch consumes floats way falling back its deprecated __index__ behaviour no bother raising here test_basic = np arange assert_raises IndexError __getitem__ assert_raises IndexError __getitem__ The following valid __getitem__ TestMultipleEllipsisError TestCase An index can only have single ellipsis xfail reason= torch currently consumes multiple ellipsis no bother raising here See https github com pytorch pytorch issues #issue- test_basic = np arange assert_raises IndexError lambda assert_raises IndexError __getitem__ Ellipsis assert_raises IndexError __getitem__ Ellipsis __name__ == __main__ run_tests