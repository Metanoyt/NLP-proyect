mypy allow-untyped-defs torch fx experimental graph_gradual_typechecker Refine torch fx experimental unification unify Var type ignore attr-defined torch fx tensor_type TensorType infer_symbolic_types_single_pass traced Calls our symbolic inferencer once r = Refine traced r refine mgu = unify_eq r constraints substitute_all_types traced graph mgu infer_symbolic_types traced Calls our symbolic inferencer twice This useful when one pass enough infer all information such case braodcasting r = Refine traced r refine mgu = unify_eq r constraints substitute_all_types traced graph mgu r = Refine traced r refine mgu = unify_eq r constraints substitute_all_types traced graph mgu r symbolic_relations convert_eq list_of_eq Convert equality constraints right format used unification library lhs = rhs = eq list_of_eq lhs append eq lhs rhs append eq rhs tuple lhs tuple rhs unify_eq list_of_eq Apply unification set equality constraints lhs rhs = convert_eq list_of_eq unify lhs rhs substitute_solution_one_type mapping t Apply most general unifier type isinstance t Var t mapping keys mapping t t isinstance t TensorType new_type = typ t __args__ typ mapping keys new_type append mapping typ new_type append typ TensorType tuple new_type isinstance t list new_type = typ t new_type append substitute_solution_one_type mapping typ new_type isinstance t tuple new_type = typ t new_type append substitute_solution_one_type mapping typ tuple new_type t substitute_all_types graph mapping Apply most general unifier all types graph till reaching fixed point If input output graph same we converge flag = True while flag flag = False k mapping old_mapping_val = mapping k mapping k mapping keys new_key = mapping k mapping k = mapping new_key old_mapping_val = mapping k flag = True n graph nodes n type = substitute_solution_one_type mapping n type check_for_type_equality g g A check equality used fixed points We do use graph equality instead type equality n m zip g nodes g nodes n type = m type False True