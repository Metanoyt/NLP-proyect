This module provides functionality tracking managing regions computational graphs It supports graph optimization identifying grouping similar regions based their structure behavior The module implements algorithms Tracking nodes their relationships computational graph Identifying identical similar regions across graph Managing graph regions optimization purposes Supporting deduplication other graph transformation passes The core functionality revolves around GraphRegionTracker which maintains mappings between nodes their duplicates enabling efficient graph analysis optimization operations __future__ annotations copyreg io logging math operator pickle collections defaultdict deque dataclasses fields typing Any Optional TYPE_CHECKING TypeVar torch _logging torch fx torch _subclasses fake_tensor FakeTensor torch utils _ordered_set OrderedSet torch utils _pytree tree_flatten graph_utils _get_flat_args_unique T = TypeVar T TYPE_CHECKING collections abc Callable symbolic_convert InstructionTranslatorBase Node = torch fx Node Region = list Node IdenticalNodes = list Node GlobalStateKey = tuple bool bool int tuple bool bool tuple bool bool torch dtype bool bool bool bool log = logging getLogger __name__ graph_expansion_log = torch _logging getArtifactLogger __name__ graph_region_expansion debug_log msg str args - None type ignore no-untyped-def graph_expansion_log debug msg args _extract_tensor_metadata_for_node_hash x torch Tensor - tuple Callable T T tuple Any torch _inductor codecache _ident extract_tensor_metadata_for_cache_key out = metadata = extract_tensor_metadata_for_cache_key x field fields metadata out append getattr metadata field name _ident tuple out NodeHashException Exception pass InputPickler pickle Pickler __init__ - None torch _inductor codecache _ident stream = io BytesIO _stream = stream super __init__ stream dispatch_table = copyreg dispatch_table copy dispatch_table update FakeTensor _extract_tensor_metadata_for_node_hash torch SymInt lambda x _ident str x torch SymBool lambda x _ident str x torch SymFloat lambda x _ident str x fast = True dumps obj Any - bytes Pickle object byte string try dump obj _stream getvalue except TypeError AttributeError e raise NodeHashException e finally _stream seek _stream truncate _extract_args arg Any - Any isinstance arg Node arg meta get example_value isinstance arg torch Tensor int arg None _normalize_args node Node - tuple tuple str tuple Optional Any flat_args _ = tree_flatten node args sorted_kwargs = sorted node kwargs items key=operator itemgetter sorted_keys = tuple sorted node kwargs keys flat_kwargs _ = tree_flatten sorted_kwargs all_args = flat_args + flat_kwargs sorted_keys tuple _extract_args arg arg all_args _sort_with_ref_region index_to_rank dict int int regions list list Any - None sort topologically we need handle edge cases where some nodes have no dependencies so first we map each node its ranking ref_region = regions sorted_indices = sorted range len ref_region key=lambda i index_to_rank i region regions region = region i i sorted_indices get_global_state_key - GlobalStateKey torch is_grad_enabled torch is_inference_mode_enabled torch get_num_threads torch _C _get_cublas_allow_fp _reduced_precision_reduction torch _C _get_cublas_allow_bf _reduced_precision_reduction torch get_default_dtype torch are_deterministic_algorithms_enabled torch _C _get_cublas_allow_tf torch is_deterministic_algorithms_warn_only_enabled torch _C _autograd _saved_tensors_hooks_is_enabled type ignore attr-defined This typical BFS caveat node s children need explicitly added add_children method The flow yield node check s valid all regions valid discard continue onto next node Note iterates backward through graph looking args kwargs node BackwardBfsArgIter __init__ origin Node - None _cur Optional Node = origin _queue deque Optional Node = deque staticmethod create origin Node - BackwardBfsArgIter = BackwardBfsArgIter origin add_children origin pop origin node since origin region does need considered addition assert next next - Optional Node ret = _cur _queue _cur = None _cur = _queue popleft ret peek - Optional Node _cur add_children node Node - None flat_args = _get_flat_args_unique node arg flat_args isinstance arg Node _append arg _append arg Node - None _cur None _cur = arg _queue append arg __str__ - str f BackwardBfsArgIter cur= _cur queue= _queue GraphRegionTracker GraphRegionTracker tracks each node added output graph generates key based source location instruction pointer input shapes global state time node inserted into graph Nodes same key grouped together list identical nodes value node_to_duplicates hash_to_duplicates Dict str IdenticalNodes - A dictionary mapping key list identical nodes node_to_duplicates Dict Node IdenticalNodes - A dictionary mapping node list identical nodes belongs input_pickler InputPickler - An instance InputPickler used generate node hash __init__ - None hash_to_duplicates dict str IdenticalNodes = defaultdict list node_to_duplicates dict Node IdenticalNodes = Note position flattened args kwargs list node_to_mutated_arg_positions dict Node OrderedSet int = input_pickler = InputPickler _hash_node filename str lineno int instruction_pointer Optional int node Node - str torch _inductor codecache sha _hash key = get_global_state_key filename lineno instruction_pointer _normalize_args node sha _hash input_pickler dumps key _is_identical n Node n Node - bool n node_to_duplicates n node_to_duplicates node_to_duplicates n node_to_duplicates n n n track_node tx InstructionTranslatorBase node Node - None The main entry point tracking node This function will hash node argument group nodes same hash together It updates hash_to_duplicates node_to_duplicates dictionaries track new node try node node_to_duplicates don t allow nodes added twice duplicates = hash_to_duplicates _hash_node tx f_code co_filename tx lineno tx instruction_pointer node duplicates append node node_to_duplicates node = duplicates except NodeHashException e log debug Unable hash node s exception s node e noqa G track_node_mutations node Node flat_args_kwargs list Any id_to_initial_version dict int int - None This function tracks which argument positions mutated given node Subgraph HOP does support input mutations today so we will skip regions which have inputs mutated mutated_arg_positions = OrderedSet int i arg enumerate flat_args_kwargs val_id = id arg val_id id_to_initial_version id_to_initial_version val_id = arg _version mutated_arg_positions add i mutated_arg_positions node_to_mutated_arg_positions node = mutated_arg_positions add_node_mutation node Node arg_pos int - None node node_to_mutated_arg_positions node_to_mutated_arg_positions node add arg_pos node_to_mutated_arg_positions node = OrderedSet arg_pos get_identical_regions graph torch fx Graph - list list Region This function responsible extracting largest regions identical nodes given graph Note This function assumes nodes have been tracked track_node provided graph argument The algorithm proceeds follows The nodes tracked via track_node above organized into region groups The initial region groups look like IdenticalNode IdenticalNode IdenticalNode each sublist called region For each region group starting topologically latest region group inner regions gradually expanded one node time flattened args kwargs node each region provided all regions group nodes being added also identical ie have same key computed track_node This checked verifying two nodes have same identical node list node_to_duplicates topological_ranking = node i i node enumerate graph nodes region_groups_with_rank = needed detect replacing region will create cycles node_to_recursive_ancestors = _populate_recursive_ancestor_map graph Create region groups region group group regions all identical In initial state each region group single node we discard groups only single region We track topological ranking start groups later graph reason we will necessarily create largest groups first group hash_to_duplicates values len group region_group = min_rank = math inf pyrefly ignore bad-assignment node group some nodes aren t topo ranking node topological_ranking min_rank = min min_rank topological_ranking node region_group append node len region_group region_groups_with_rank append region_group min_rank region_groups_with_rank sort key=lambda rg -rg region_groups = rg rg _ region_groups_with_rank We start regions later graph expand them earlier result we will create largest regions first they won t overlap seen_nodes set Node = set region_group region_groups fully_expand_region_group region_group seen_nodes node_to_recursive_ancestors _is_identical sort topologically we need handle edge cases where some nodes have no dependencies so first we map each node its ranking ref_region = region_group index_to_rank = index topological_ranking n index n enumerate ref_region _sort_with_ref_region index_to_rank region_group region_group region_group region_groups len region_group __str__ - str f GraphRegionTracker hash_to_duplicates= hash_to_duplicates node_to_duplicates= node_to_duplicates RegionWrapper Holds state regions e g ancestors new candidate nodes consideration __init__ region Region node_to_recursive_ancestors dict Node set Node - None assert len region == all regions should start one node node = region node_to_recursive_ancestors = node_to_recursive_ancestors iter = BackwardBfsArgIter create node nodes_unique = OrderedSet node ancestors = set node_to_recursive_ancestors node region = region next_candidate - Optional Node iter next will_inclusion_create_cycle node Node - bool external_users = user user node users user nodes_unique user external_users user ancestors True False add node Node - None nodes_unique add node region append node iter add_children node ancestors update node_to_recursive_ancestors node fully_expand_region_group regions list Region seen_nodes set Node node_to_recursive_ancestors dict Node set Node is_identical_fn Callable Node Node bool - None debug_log -------------------------------------------------- debug_log expanding new region group s regions All regions should start node assert all len region == region regions region_wrappers = RegionWrapper region node_to_recursive_ancestors region regions nodes_to_add = OrderedSet Node current_node = region_wrappers next_candidate No children current_node None Loop incrementally adding new nodes each region regions only expanded node add valid ALL regions while current_node add_to_all_regions = region_wrappers will_inclusion_create_cycle current_node nodes_to_add clear nodes_to_add add current_node region_wrapper region_wrappers candidate = region_wrapper next_candidate debug_log -------------------- debug_log considering candidate s cur_node s candidate current_node candidate add_to_all_regions add_to_all_regions = False continue debug_log candidate previously claimed nodes s candidate seen_nodes debug_log is_identical s is_identical_fn candidate current_node add_to_all_regions = candidate seen_nodes candidate nodes_to_add candidate op = placeholder candidate op = get_attr is_identical_fn candidate current_node region_wrapper will_inclusion_create_cycle candidate nodes_to_add add candidate debug_log f add_to_all_regions add_to_all_regions debug_log -------------------- add_to_all_regions assert len region_wrappers == len nodes_to_add Number nodes add must equal number regions region_wrapper node zip region_wrappers nodes_to_add region_wrapper add node debug_log adding s s children node debug_log s s node args list node kwargs items seen_nodes add node current_node = region_wrappers next_candidate Ensure regions sorted topological order region regions region reverse debug_log end expand new region group s regions debug_log -------------------------------------------------- _populate_recursive_ancestor_map graph torch fx Graph - dict Node set Node node_to_recursive_ancestors dict Node set Node = node graph nodes node_to_recursive_ancestors node = set node graph nodes all_args = _get_flat_args_unique node arg all_args isinstance arg Node node_to_recursive_ancestors node update node_to_recursive_ancestors arg node_to_recursive_ancestors node add arg node_to_recursive_ancestors