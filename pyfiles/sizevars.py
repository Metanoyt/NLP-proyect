mypy allow-untyped-defs functools itertools logging collections defaultdict collections abc Iterable Sequence typing Any Callable cast Optional Union sympy sympy Expr torch fx experimental symbolic_shapes free_symbols has_free_unbacked_symbols ShapeEnv torch utils _ordered_set OrderedSet torch utils _sympy functions FloorDiv ModularIndexing torch utils _sympy symbol symbol_is_type SymT torch utils _sympy value_ranges bound_sympy IntInfinity ValueRanges runtime runtime_utils is_power_of_ utils has_free_symbols sympy_index_symbol sympy_index_symbol_with_prefix sympy_subs VarRanges virtualized V log = logging getLogger __name__ statically_known_true shape_env ShapeEnv expr Union sympy Basic bool axioms Optional tuple sympy Expr = None var_to_range Optional tuple tuple sympy Symbol ValueRanges Any = None - bool expr True False bool expr try simplified = shape_env _maybe_evaluate_static expr axioms=axioms var_to_range=var_to_range simplified None bool simplified except Exception log debug Could simplify s expr exc_info=True False This little awkward because ShapeEnv doing most heavy lifting some cases we should directly passing through ShapeEnv there some extra inductor logic needs handled here SizeVarAllocator A manages symbolic size variables their relationships This works ShapeEnv handle symbolic shape expressions simplify them provide utilities guarding checking evaluating symbolic expressions It also manages precomputed replacements stride calculations tensor operations __init__ shape_env=None - None super __init__ Note can lead bugs Reasoning APIs depends existing information shape_env For example var_to_ranges can t empty shape_env None shape_env = ShapeEnv shape_env = shape_env var_to_val = shape_env var_to_val var_to_hint_override = shape_env var_to_hint_override replacements dict sympy Symbol Expr = shape_env replacements unbacked_replacements Optional dict Expr Expr = None Maps dynamic sizes have precomputed host kernel args The basic idea we have some complicated sympy expression f s we may choose precompute host then replace all occurrences sympy expression ps so when we codegen we simply reference ps directly without repeating f s Unlike regular size variables ps variables cannot guarded upon so we asked guard Sympy expression which potentially could have already had precomputed replacement we obligated invert precomputed replacements inv_precomputed_replacements precomputed_replacements dict Expr sympy Symbol = inv_precomputed_replacements dict sympy Symbol Expr = stride_vars = make_stride_vars_cache simplify_with_ranges = make_simplify_with_ranges_cache _simplify_loops = make_simplify_loops_cache simplify expr Expr sympy expand expr xreplace replacements make_simplify_with_ranges_cache - Callable Expr VarRanges Expr _simplify_with_ranges can expensive cache its results cache dict tuple Any Expr = replacement_count = len replacements simplify_with_ranges expr Expr var_ranges VarRanges - Expr nonlocal replacement_count replacement_count = len replacements new replacements invalidates cached results cache clear replacement_count = len replacements key = expr var_ranges items result = cache get key result None result = _simplify_with_ranges expr var_ranges cache key = result result = expr cache result var_ranges items = result result simplify_with_ranges make_simplify_loops_cache _simplify_with_ranges can expensive cache its results cache dict tuple Any Any = replacement_count = len replacements simplify_loops index_vars sizes index_formulas nonlocal replacement_count replacement_count = len replacements new replacements invalidates cached results cache clear replacement_count = len replacements key = index_vars sizes index_formulas result = cache get key result None result = _simplify_loops_impl index_vars sizes index_formulas cache key = result result simplify_loops _simplify_with_ranges expr Expr var_ranges VarRanges - Expr Simplify indexing expression knowledge ranges iteration variables expr = join_dimensions simplify expr original_expr = expr var_to_range = dict shape_env var_to_range var_to_range update k ValueRanges max v - has_free_symbols v IntInfinity k v var_ranges items var expr free_symbols var var_to_range var_to_range var = ValueRanges IntInfinity var_to_range_tuple = cast tuple tuple sympy Symbol ValueRanges sympy Expr tuple var_to_range items axioms = var upper_bound var_ranges items axioms append = var axioms append var upper_bound axioms = tuple axioms + shape_env get_axioms statically_known expr evaluated = shape_env _maybe_evaluate_static expr pyrefly ignore bad-argument-type axioms=axioms var_to_range=var_to_range_tuple bool evaluated remove_zero_terms base divisor Symbols smaller than divisor zero statically_known base = base v base free_symbols v var_ranges var smaller than divisor can removed rest guaranteed multiple divisor rest = sympy Wild _rest exclude= v m = base match v + rest m v m rest free_symbols gcd = sympy gcd m rest divisor gcd == divisor statically_known v divisor base = m rest base visit_indexing_div base divisor FloorDiv remove_zero_terms base divisor divisor visit_modular_indexing base divisor modulus base = remove_zero_terms base divisor can_remove_mod = statically_known base = statically_known base modulus divisor can_remove_mod FloorDiv base divisor ModularIndexing base divisor modulus expr has ModularIndexing expr = expr replace ModularIndexing sympy Wild base integer=True sympy Wild divisor integer=True sympy Wild modulus integer=True visit_modular_indexing expr has FloorDiv expr = expr replace FloorDiv sympy Wild base integer=True sympy Wild divisor integer=True visit_indexing_div expr = original_expr _simplify_with_ranges expr var_ranges expr _simplify_loops_impl index_vars list sympy Symbol sizes index_formulas Try remove many axis loop iterations possible removing size== dimensions fuse contiguous dimensions into single loop If channel_last = True we will prevent last dim fused other dims sizes = list map simplify sizes strides = index_formulas may contain boolean expressions e g s which strides don t make sense so we ignore them here NOTE These expressions may still block merging dims sound substitution test performed can_merge_dims stride_vars x index_vars isinstance x sympy Expr len index_vars x index_formulas assert len sizes == len strides len sizes len strides i range len sizes sizes i == remove dim sizes i = None can_merge_dims b k range len strides simplify strides k sizes == simplify strides k b approximate test passed try sound version va = index_vars vb = index_vars b m = sympy_index_symbol _merge_tester m = sympy_index_symbol _merge_tester NOTE can t sub vb= here case va vb appears expression which case both expr expr would zero expr = sympy_subs index_formulas k va m sizes vb m expr = sympy_subs index_formulas k va vb m + m simplify expr == simplify expr continue False True changed = True while changed changed = False i j itertools product reversed range len sizes reversed range len sizes i == j sizes i None sizes j None continue can_merge_dims i j changed = True sizes i = sizes i sizes j sizes j = None reindex index = list reversed index new_index = size sizes size None new_index append sympy S Zero new_index append pop assert new_index prune index assert len index == len sizes i i s zip index sizes s None x x sizes x None reindex prune Note - On Statically Known The statically_known_ family functions below NEVER guard they could True asked questions can answered without guarding otherwise they False Those similar statically_known_true symbolic_shapes py operate sympy expressions instead symnodes statically_known_true expr Union sympy Basic bool - bool Returns true expression always true symbolically via guards false otherwise Never add guards throw data dependent errors statically_known_true shape_env expr statically_known_equals left Union Expr int right Union Expr int - bool Returns bool indicating sound optimize left right equal statically_known_true sympy Eq left right type ignore arg-type statically_known_list_equals left Sequence Expr right Sequence Expr - bool Returns bool indicating sound optimize left right lists equal len left == len right all statically_known_equals l r l r zip left right statically_known_leq left Expr right Union Expr int - bool Returns bool indicating sound optimize left less than equal right expr = left = right statically_known_true expr statically_known_geq left Expr right Union Expr int - bool Returns bool indicating sound optimize left greater than equal right expr = left = right statically_known_true expr statically_known_lt left Expr right Union Expr int - bool Returns bool indicating sound optimize left less than right expr = left right statically_known_true expr statically_known_gt left Expr right Union Expr int - bool Returns bool indicating sound optimize left greater than right expr = left right statically_known_true expr statically_known_multiple_of numerator Expr denominator Union Expr int - bool Return bool indicating sound optimize numerator being multiple denominator The reason we skip compute here avoid cost trying eval symbolically see https github com sympy sympy issues has_free_unbacked_symbols numerator has_free_unbacked_symbols denominator False len free_symbols numerator False expr = sympy Eq numerator denominator statically_known_true expr type ignore arg-type statically_known_power_of_ expr Expr - bool Returns bool indicating x known power isinstance expr sympy Integer is_power_of_ int expr The expect check functions require you ALREADY KNOW particular condition holds They similar expect_true symbolic_shapes py torch check operates sympy expressions instead symnodes expect_true expr Expr - bool Use when you already know expr true should true want ensure guards runtime assertions place ensure compiled function Unlike check WON T raise error expr isn t actually true check Note expect_true statically_known_true expr shape_env guard_or_defer_runtime_assert expr sizevars expect_true True check expr Expr - None Use when you already know expr true should true want ensure guards runtime assertions place ensure compiled function Unlike expect_true WILL raise error expr isn t actually true check Note expect_true expr = sympy_subs expr inv_precomputed_replacements assert expect_true expr check_equals left Expr right Expr - None check sympy Eq left right check sympy Eq left right left check_equals_and_simplify left Expr right Expr - Expr check sympy Eq left right returns left after applying inv_precomputed_replacements check sympy Eq left right sympy_subs left inv_precomputed_replacements check_leq left Expr right Expr - None check sympy Le left right check_lt left Expr right Expr - None check sympy Lt left right Similar functions guard_or_false guard_or_true symbolic_shapes py operates sympy expressions instead symnodes see Note guard_or_ guard_or_false left torch fx experimental _config exp_config exp_config backed_size_oblivious static_val = shape_env _maybe_evaluate_static left static_val None static_val False evaluate_expr left fallback_value=False guard_or_true left torch fx experimental _config exp_config exp_config backed_size_oblivious static_val = shape_env _maybe_evaluate_static left static_val None static_val True evaluate_expr left fallback_value=True The evaluate functions evaluate some symbolic sympy expression NB necessarily Expr what concrete result guarding expression being result NB write evaluate_expr sympy Lt b rather than evaluate_expr b will ensure you actually have sympy ified expression will prevent you incorrectly writing evaluate_expr == b which does wrong thing b sympy expression evaluate_expr left Union Expr sympy logic boolalg Boolean size_oblivious bool = False fallback_value Optional bool = None - bool assert isinstance left Expr sympy logic boolalg Boolean type left shape_env evaluate_expr sympy sympify left size_oblivious=size_oblivious fallback_value=fallback_value is_size_one_or_false size Expr - bool Return True size equals Unbacked symbolic sizes False without introducing guard guard_or_false sympy Eq size evaluate_min left Expr right Expr - Expr smaller left right guard choice isinstance left Expr left = sympy_subs left inv_precomputed_replacements type ignore arg-type isinstance right Expr right = sympy_subs right inv_precomputed_replacements type ignore arg-type try lv = size_hint_or_throw left rv = size_hint_or_throw right except TypeError unbacked symints left == right statically_known_leq left right left statically_known_leq right left right gcd = sympy gcd left right left == gcd handle ` min u u ` etc left right == gcd right raise TypeError f evaluate_min left right unbacked symints None lv = rv check_leq left right left check_leq right left right evaluate_max left Expr right Expr - Expr larger left right guard choice Always choose opposite eval min consistency This means min b max b produce same guards min_val = evaluate_min left right right min_val left left guard_int expr Union Expr int - int Similar guard_int symbolic_shapes py except function works SymPy expressions instead SymNodes It extracts value represented expr shapeEnv specialize compiled graph Raises error result cannot determined due unhinted unbacked symbols isinstance expr int expr val = size_hint_or_throw expr check_equals expr sympy Integer val int val guard_int_seq left Sequence Union Expr int - list int Apply guard_int sequence inputs guard_int x x left remove_precomputed_replacements expr Expr - Expr any symbol_is_type s SymT PRECOMPUTED_SIZE s expr free_symbols type ignore attr-defined sympy_subs expr inv_precomputed_replacements type ignore arg-type expr symbolic_hint expr Union Expr int hint_override Optional int = None Only flip flag you don t plan guarding adding runtime asserts based value promise only use value heuristic nature use_user_provided_hint_override bool = False - Union Expr int isinstance expr int expr Substitute all hints into expr leave unbacked symints alone expr = simplify expr isinstance expr Expr assert isinstance expr int expr free_symbols = expr free_symbols free_symbols try int expr type ignore return-value except TypeError expr inf nan I hint_override hint_override expr = remove_precomputed_replacements expr use_user_provided_hint_override expr = sympy_subs expr var_to_hint_override sympy_subs expr var_to_val size_hint expr Union Expr int fallback Optional int = None hint_override Optional int = None - int out = symbolic_hint expr hint_override=hint_override use_user_provided_hint_override=fallback None isinstance out int sympy Integer fallback None Use provided heuristic fallback hint unbacked_sym_vrs = s shape_env var_to_range get s None s out free_symbols all vr None vr unbacked_sym_vrs values hint_vr = bound_sympy out unbacked_sym_vrs type ignore arg-type isinstance hint_vr lower int sympy Integer fallback = max fallback int hint_vr lower isinstance hint_vr upper int sympy Integer fallback = min fallback int hint_vr upper fallback try int out except Exception log debug failed s out raise size_hint_or_throw expr Union Expr int - int Like size_hint there s no fallback unbacked symints so throws out = symbolic_hint expr try int out except Exception log debug failed s out exc_info=True raise size_hints exprs Iterable Union Expr int fallback Optional int = None hint_override Optional int = None - tuple int tuple size_hint x fallback=fallback hint_override=hint_override x exprs size_hints_or_throw exprs Iterable Union Expr int - tuple int Like size_hints there s no fallback unbacked symints so throws tuple size_hint_or_throw x x exprs _lru_cache fn maxsize=None Wrapper around functools lru_cache clears when replacements has been invalidated fn_cache = functools lru_cache maxsize fn prior_len = len replacements functools wraps fn wrapper args kwargs nonlocal prior_len prior_len = len replacements prior_len = len replacements fn_cache cache_clear fn_cache args kwargs wrapper make_stride_vars_cache cache = _lru_cache _stride_vars stride_vars index Expr vars Sequence sympy Symbol support_vars Optional Sequence sympy Symbol = None - list Expr support_vars support_vars = vars cache index tuple vars tuple support_vars stride_vars _stride_vars index Expr vars Sequence sympy Symbol support_vars Sequence sympy Symbol - list Expr Convert indexing expression back into strides NOTE This only valid index standard strided offset calculation e g ModularIndexing i + would give stride - because index wraps around after first element strides = index = simplify index remove any offset index = index - sympy_subs index v sympy S Zero v support_vars v = i range len vars drop all other dims index_dim = sympy_subs index support_vars j sympy S Zero j range len support_vars vars i = support_vars j support_vars j = v = vars i v == strides append sympy S Zero TODO jansel should we use sympy diff here strides append sympy_subs index_dim v sympy S One - sympy_subs index_dim v sympy S Zero strides _get_unbacked_replacements - dict Expr Expr unbacked_replacements None unbacked_replacements CanonicalExprFinder Purpose A disjoint-set union-find data structure can canonical expression group equivalent expressions - The canonical expression must come input eq_graph - The heuristics used choose leader determines which expression becomes canonical expression Problem Given any unbacked expression we should able find size_hint unbacked expression adheres ShapeEnv s deferred runtime assertions Otherwise we may generate conflicting size hints In other words even though we know u + s == u we may generate size hints such size_hint u + s = size_hint u NOTE At time only deferred runtime asserts equalities i e Eq lhs rhs considered data structure Examples - u + u == then find_expr u + u == find_expr - u + u == s then find_expr u + u == find_expr s - u + s == u then find_expr u + s == find_expr u Inputs - equality_graph An adjacency set expressions where edge connects two expressions found equal each other The edges sourced ShapeEnv s deferred_runtime_asserts Usage - Call union_expr b merge b into single set which shares same canonical expression - Call find_expr x find canonical expression x __init__ eq_graph dict Expr OrderedSet Expr eq_graph = eq_graph expressions = list eq_graph keys reverse_expressions = expr i i expr enumerate expressions Each node its own leader parent initially leader = list range len expressions Track rank union-by-rank rank = len expressions Takes each edge undirected graph starts merging them _build_canonical_expr_mapping _build_canonical_expr_mapping expr edges eq_graph items adj edges union_expr expr adj union_expr Expr b Expr union reverse_expressions reverse_expressions b union int b int rootA = find rootB = find b rootA == rootB False already connected leader other = choose_leader rootA rootB leader other = leader rank leader += rank other True find_expr expr Expr parent = find reverse_expressions expr expressions parent find x int Path compression leader x = x leader x = find leader x leader x choose_leader int b int The leader will become canonical expression Here heuristics used choosing leader Backed expression constants preferred over unbacked expr Simpler sub-expr when one contains other Higher frequency across equalities deferred runtime assertions Rank size set Fallback sympy Basic compare _choose x int y int - bool lhs rhs = expressions x expressions y Prefer replacing unbacked exprs backed expressions constants Examples u + s == s + s then leader s + s u == then leader any_unbacked_lhs = has_free_unbacked_symbols lhs any_unbacked_rhs = has_free_unbacked_symbols rhs any_unbacked_lhs = any_unbacked_rhs bool any_unbacked_rhs Handles cases where LHS contains RHS In other words RHS sub-expression LHS For example s Max u == Max u then leader Max u lhs has rhs False rhs has lhs True Prefer expressions come up more often degrees_lhs = len eq_graph lhs degrees_rhs = len eq_graph rhs degrees_lhs = degrees_rhs degrees_lhs degrees_rhs Try apply union-by-rank optimization flatten leader trees rank x = rank y rank x rank y Fallback sympy Basic compare deterministic ordering lhs compare rhs == - _choose b b b Build undirected graph using ShapeEnv s deferred runtime assertions equality_graph dict Expr OrderedSet Expr = defaultdict OrderedSet assertions shape_env deferred_runtime_asserts values assertion assertions isinstance assertion expr sympy Equality We re ignoring other relationals now If you need account relationals then you may need solver solution continue lhs = sympy sympify assertion expr lhs sympify helps ints rhs = sympy sympify assertion expr rhs equality_graph lhs add rhs equality_graph rhs add lhs Use undirected graph create DSU data structure so we can query canonical expression uf = CanonicalExprFinder equality_graph Start building unbacked replacements mapping using CanonicalExprFinder The mapping Expr its canonical Expr unbacked_replacements = expr equality_graph keys canonical_expr = uf find_expr expr expr = canonical_expr unbacked_replacements expr = canonical_expr unbacked_replacements functools lru_cache noqa B _sub_unbacked_exprs expr Expr - Expr s fine cache fn since singleton replacements = _get_unbacked_replacements consider making threshold configurable sub_cnt_limit = sub_cnt = while sub_cnt sub_cnt_limit new_expr = expr subs replacements new_expr == expr new_expr expr = sympy factor new_expr sub_cnt += log warning Substitution limit d reached w s sub_cnt_limit expr expr atomically_apply_size_hint expr Union Expr int fallback Optional int = None hint_override Optional int = None - Union Expr int isinstance expr int sympy Integer int expr has_free_unbacked_symbols expr Make sure substitute factored version e g s + u instead s + u expr = _sub_unbacked_exprs sympy factor expr For multiple expressions depend unbacked symint we want compute them consistently size hint we have chosen So recursively compute expressions via size hints contained symbols For example u u - == fallback fallback - assert isinstance expr Expr type expr free_symbols = expr free_symbols size_dict = symbol V graph sizevars size_hint symbol fallback=fallback hint_override=hint_override symbol free_symbols expr subs size_dict offset_var index Expr vars Sequence sympy Symbol - Expr Extract offset part indexing expression index = simplify index sympy_subs index v sympy S Zero v vars v = stride_hints index Expr vars Sequence sympy Symbol support_vars Optional Sequence sympy Symbol = None - list int v index free_symbols symbol_is_type v SymT INDIRECT type ignore attr-defined index = sympy_subs index v type ignore dict-item result = s stride_vars index vars support_vars try result append size_hint_or_throw s except TypeError result append result stride_order index Expr vars list sympy Symbol - list int strides = tuple map abs stride_hints index vars order = list range len strides order sort key=lambda x strides x == strides x order lookup_precomputed_size expr Expr - Expr isinstance expr int sympy Symbol sympy Number expr is_number expr is_symbol expr expr = remove_precomputed_replacements expr expr precomputed_replacements sym = sympy_index_symbol_with_prefix SymT PRECOMPUTED_SIZE len precomputed_replacements precomputed_replacements expr = sym inv_precomputed_replacements sym = expr precomputed_replacements expr free_symbols - OrderedSet sympy Symbol OrderedSet var_to_val keys - OrderedSet replacements keys combine_modular_indexing_pairs index sympy Expr - sympy Expr A pair special ModularIndexing can combined E g ModularIndexing ModularIndexing x b We can simplify ModuleIndexing x b x non negative integer b positive integers multiple b _check_args x div mod is_first isinstance div sympy Integer isinstance mod sympy Integer False div = False mod = False is_first first ModularIndexing should contains nested ModularIndex isinstance x ModularIndexing False second ModularIndexing should contains non-negative symbol isinstance x sympy Symbol statically_known_geq x False True isinstance index ModularIndexing x div mod = index args _check_args x div mod True index x div mod = x args _check_args x div mod False index mod mod = index ModularIndexing x mod index expand_floor_div index sympy Expr - Union bool tuple sympy Expr sympy Expr Expand FloorDiv entire expression so expression may simplified E g D contiguous tensor shape b index variables x x index expression x b + x can easily combined But index expression x b + x can By expanding FloorDiv entire expression we get x b + x This transformation allows us merge loops numerator Return false optimization can applied Return new expression denominator otherwise The original expression will equivalent new_expression denominator isinstance index sympy Add False terms = index args len terms False floor_div_index = - varlist = factorlist = idx term enumerate terms isinstance term sympy Mul For dynamic shape term like s x has child nodes - A integer - A symbol s - A symbol x Skip now len term args = False factor var = term args varlist append var factorlist append factor isinstance factor sympy Integer isinstance var sympy Symbol False It s easier reason about correceness transformation non-negative integers statically_known_geq var False isinstance term FloorDiv var factor = term args isinstance factor sympy Integer isinstance var sympy Symbol False statically_known_geq var False floor_div_index = can handle multi FloorDiv yet False floor_div_index = idx varlist append var factor denominator factorlist append factor False floor_div_index False Construct new expression remember denominator denominator = factorlist floor_div_index new_index = sympy S Zero var factor idx zip varlist factorlist itertools count idx == floor_div_index new_index += var new_index += factor denominator var new_index denominator join_dimensions expr Expr - Expr isinstance expr sympy Add expr has ModularIndexing expr fast exit path _join_dimensions_cached expr functools lru_cache _join_dimensions_cached expr Expr - Expr ModularIndexing i + ModularIndexing i becomes ModularIndexing i ModularIndexing i + FloorDiv i becomes i This type pattern can come view operations assert isinstance expr sympy Add scale = sympy Wild scale exclude= integer=True base = sympy Wild base integer=True divisor = sympy Wild divisor integer=True mod = sympy Wild modulus integer=True mod = sympy Wild modulus integer=True term expr args m = term match scale ModularIndexing base divisor mod m term expr args m = term match m scale m mod ModularIndexing m base m divisor m mod mod m term = term expr = join_dimensions expr - term - term + m scale ModularIndexing m base m divisor m mod m mod expr term expr args m = term match scale ModularIndexing base divisor mod m term expr args m = term match m scale m mod FloorDiv m base m divisor m mod m None case success we get empty dict here expr = join_dimensions expr - term - term + m scale FloorDiv m base m divisor expr expr SimplifyIndexing V WrapperHandler type ignore name-defined A wrapper around virtualize ops uses var range information simplify ModularIndexing FloorDiv __init__ inner var_ranges VarRanges - None super __init__ inner name = SimplifyIndexing _simplify Callable Expr Expr = lambda index V graph sizevars simplify_with_ranges index var_ranges load name str index sympy Expr _inner load name _simplify index store name index value mode=None _inner store name _simplify index value mode=mode store_reduction name index value _inner store_reduction name _simplify index value index_expr index dtype _inner index_expr _simplify index dtype check_bounds index size lower upper _inner check_bounds _simplify index size lower upper