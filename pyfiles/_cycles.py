mypy allow-untyped-defs gc sys typing Any NamedTuple Optional types weakref json tempfile NamedTemporaryFile torch torch cuda _memory_viz _frames_fmt _block_extra atexit logging logger = logging getLogger __name__ observe_garbage observer enabled = True disable when GC runs during exit things like ` sys ` will already unloaded so we have disable callback avoid hitting errors nonlocal enabled enabled = False atexit register disable gc_callback phase info nonlocal enabled enabled phase == start gc set_debug gc DEBUG_SAVEALL phase == stop orig_trace = sys getprofile self_return = False do_collect args kwargs nonlocal enabled self_return self_return = True sys setprofile orig_trace enabled = False try things gc garbage have survived collection so free them we have collect generation greater than them might _also_ free other stuff we don t want miss stuff So we have now force gc highest level here report all what we found _then_ we can free up info generation = gc collect observer gc garbage gc garbage clear we have re-run GC clean up cycles we saved before gc set_debug before = torch cuda memory_allocated gc collect after = torch cuda memory_allocated before = after logger warning CUDA Memory changed during GC d bytes freed before - after finally enabled = True orig_trace None orig_trace args kwargs sys setprofile do_collect gc callbacks append gc_callback provide way disarm callback remove gc callbacks remove gc_callback remove Function visualize cycles adapted refcycle Copyright Mark Dickinson Licensed under Apache License Version License you may use file except compliance License You may obtain copy License http www apache org licenses LICENSE- Unless required applicable law agreed writing software distributed under License distributed AS IS BASIS WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND either express implied See License specific language governing permissions limitations under License _get_cell_type f x=None lambda x type f __closure__ CellType = _get_cell_type annotated_references obj Return known information about references held given object Returns mapping referents lists descriptions Note there may more than one edge leading any particular referent hence need list Descriptions currently strings references dict int list str = add_reference name obj references setdefault id obj append name add_attrs attrs attr attrs hasattr obj attr add_reference attr getattr obj attr add_cell_references try add_attrs cell_contents except ValueError cell_contents empty accessing raises ValueError case there no object annotate pass add_function_references add_attrs __defaults__ __closure__ __globals__ __code__ __name__ __module__ __doc__ __qualname__ __annotations__ __kwdefaults__ add_sequence_references position item enumerate obj add_reference f position item add_dict_references key value obj items add_reference key key add_reference f repr key value add_set_references elt obj add_reference element elt add_bound_method_references add_attrs __self__ __func__ im_class add_weakref_references For subclasses weakref we can t reliably distinguish callback any other attributes type obj weakref ref referents = gc get_referents obj len referents == target = referents add_reference __callback__ target add_frame_references f_locals = obj f_locals add_attrs f_back f_code f_builtins f_globals f_trace f_locals Some badly-behaved code replaces f_locals dict something doesn t support full dict interface So we only continue annotation f_locals Python dict type f_locals dict name local obj f_locals items add_reference f local name local add_getset_descriptor_references add_attrs __objclass__ __name__ __doc__ type_based_references = tuple add_sequence_references list add_sequence_references dict add_dict_references set add_set_references frozenset add_set_references types FunctionType add_function_references types FrameType add_frame_references CellType add_cell_references types MethodType add_bound_method_references weakref ref add_weakref_references types GetSetDescriptorType add_getset_descriptor_references type_ type obj __mro__ type_ type_based_references type_based_references type_ add_attrs __dict__ __class__ isinstance obj type add_attrs __mro__ references ############################################################################### Object annotations BASE_TYPES = int float complex type None str bytes FRAME_FILENAME_LIMIT = object_annotation obj Return string used Graphviz nodes The string should short informative possible format_sequence obj body = join repr x isinstance x BASE_TYPES type x __name__ x obj len obj body = f body len obj - body For basic types use repr isinstance obj BASE_TYPES repr obj type obj __name__ == function f function\n obj __name__ isinstance obj types MethodType try func_name = obj __func__ __qualname__ except AttributeError func_name = anonymous f instancemethod\n func_name isinstance obj list f format_sequence obj isinstance obj tuple f format_sequence obj isinstance obj dict f dict len obj isinstance obj types ModuleType f module\n obj __name__ isinstance obj type f type\n obj __name__ isinstance obj weakref ref referent = obj referent None weakref dead referent f weakref id x id referent x isinstance obj types FrameType filename = obj f_code co_filename len filename FRAME_FILENAME_LIMIT filename = + filename - FRAME_FILENAME_LIMIT - f frame\n filename obj f_lineno f object\n type obj __module__ type obj __name__ Node NamedTuple label str context Optional str root bool referrents list tuple str int create_graph objects context=None filter=None context None context = cuda_allocation_context filter None filter = is_cuda_tensor objects = obj obj objects isinstance obj weakref ProxyTypes nodes = Node object_annotation obj context obj filter obj obj objects node_referrers list list int = obj objects id_to_node = id obj i i obj enumerate objects obj objects fidx = id_to_node id obj f = nodes fidx references = annotated_references obj referrent gc get_referents obj rid = id referrent tidx = id_to_node get rid tidx None continue labels = references get rid node_referrers tidx append fidx label labels f referrents append label tidx to_search = i i n enumerate nodes n root to_keep = set while to_search idx = to_search pop idx to_keep continue to_keep add idx referrers = node_referrers idx to_search extend referrers id_to_filtered_id dict int int = filtered list Any = i n enumerate nodes i to_keep id_to_filtered_id i = len id_to_filtered_id filtered append n n filtered n referrents = label id_to_filtered_id idx label idx n referrents idx id_to_filtered_id filtered escape n json dumps n is_cuda_tensor obj isinstance obj torch Tensor obj device type == cuda isinstance obj torch _subclasses FakeTensor cuda_allocation_context snapshot = torch cuda memory _snapshot addr_to_frame = seg snapshot segments addr = seg address blk seg blocks blk state == active_allocated frames _real_size = _block_extra blk addr_to_frame addr = frames addr += blk size object_context obj is_cuda_tensor obj addr = obj untyped_storage data_ptr frames = addr_to_frame get addr frames None \n join _frames_fmt frames full_filename=True None object_context to_dot nodes lines = digraph GraphName node shape=rect rankdir=LR i n enumerate nodes lines append f i label= escape n label color= red n root black i f enumerate nodes label j f referrents lines append f i - j label = escape label lines append \n \n join lines _template = DOCTYPE html html head style body margin padding overflow hidden #container display flex flex-direction column height vh #main flex height vh overflow clip #preContainer flex height vh overflow auto pre margin padding px style head body div id= container div id= main div div id= preContainer pre id= stacktrace Mouse over tensor objects see where they allocated pre div div script src= https cdnjs cloudflare com ajax libs viz js viz-lite js script script let dot = $ DOT let image = Viz dot format svg totalMemory let main = document getElementById main main innerHTML = image let svg = main firstElementChild Panning zooming logic let isPanning = false let startX startY let viewBox = x y width parseFloat svg getAttribute width height parseFloat svg getAttribute height svg removeAttribute width svg removeAttribute height function updateViewBox svg setAttribute viewBox ` $ viewBox x $ viewBox y $ viewBox width $ viewBox height ` updateViewBox svg setAttribute preserveAspectRatio xMidYMid meet svg addEventListener mousedown function e isPanning = true startX = e clientX startY = e clientY svg addEventListener mousemove function e isPanning const dx = e clientX - startX viewBox width svg clientWidth const dy = e clientY - startY viewBox height svg clientHeight viewBox x -= dx viewBox y -= dy startX = e clientX startY = e clientY updateViewBox svg addEventListener mouseup function isPanning = false svg addEventListener mouseleave function isPanning = false svg addEventListener wheel function e e preventDefault const zoomFactor = const zoomAmount = e deltaY + zoomFactor - zoomFactor Calculate mouse position relative SVG const rect = svg getBoundingClientRect const mouseX = e clientX - rect left const mouseY = e clientY - rect top const mouseXRel = mouseX svg clientWidth const mouseYRel = mouseY svg clientHeight Adjust viewBox zoom around mouse position const newWidth = viewBox width zoomAmount const newHeight = viewBox height zoomAmount viewBox x += viewBox width - newWidth mouseXRel viewBox y += viewBox height - newHeight mouseYRel viewBox width = newWidth viewBox height = newHeight updateViewBox $ LISTENERS script body html _listener_template = document getElementById node id addEventListener mouseover function event document getElementById stacktrace textContent = stack to_html nodes listeners = i n enumerate nodes n context None continue s = _listener_template format id=str i + stack=escape f n label \n n context pyrefly ignore bad-argument-type listeners append s dot = to_dot nodes _template replace $ DOT repr dot replace $ LISTENERS \n join listeners observe_tensor_cycles callback torch cuda memory _record_memory_history max_entries= observer garbage garbage any is_cuda_tensor obj obj garbage logger info No CUDA Tensors found garbage callback to_html create_graph garbage observe_garbage observer warn_tensor_cycles Install warning reports whenever cycle holding CUDA memory observed The warning produces html file visualizes cycle links stack frame allocated CUDA tensor Reference cycles freed cycle collector rather than being cleaned up when objects cycle first become unreachable If cycle points tensor CUDA memory tensor will freed until garbage collection runs Accumulation CUDA allocations can lead out memory errors OOMs well non-deterministic allocation behavior which harder debug logger info Watching Python reference cycles CUDA Tensors write_and_log html NamedTemporaryFile w suffix= html delete=False f f write html logger warning Reference cycle includes CUDA Tensor see visualization cycle s f name observe_tensor_cycles write_and_log