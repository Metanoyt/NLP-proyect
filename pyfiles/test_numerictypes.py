Owner s module dynamo functools itertools sys unittest skipIf skipif pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests skipIfTorchDynamo TEST_WITH_TORCHDYNAMO TestCase xpassIfTorchDynamo_np TEST_WITH_TORCHDYNAMO numpy np numpy testing assert_ torch _numpy np torch _numpy testing assert_ skip = functools partial skipif True xpassIfTorchDynamo_np reason= We do distinguish between scalar array types Thus scalars can upcast arrays TestCommonType TestCase test_scalar_loses res = np find_common_type f f i f assert_ res == f test_scalar_loses res = np find_common_type f f i assert_ res == f test_scalar_wins res = np find_common_type f f i c assert_ res == c test_scalar_wins res = np find_common_type u i i f assert_ res == f test_scalar_wins doesn t go up f purpose res = np find_common_type u i i f assert_ res == f TestIsSubDType TestCase scalar types can promoted into dtypes wrappers = np dtype lambda x x test_both_abstract assert_ np issubdtype np floating np inexact assert_ np issubdtype np inexact np floating test_same cls np float np int w w itertools product wrappers repeat= assert_ np issubdtype w cls w cls test_subclass note we cannot promote floating dtype would turn into concrete type w wrappers assert_ np issubdtype w np float np floating assert_ np issubdtype w np float np floating test_subclass_backwards w wrappers assert_ np issubdtype np floating w np float assert_ np issubdtype np floating w np float test_sibling_class w w itertools product wrappers repeat= assert_ np issubdtype w np float w np float assert_ np issubdtype w np float w np float test_nondtype_nonscalartype See gh- gh- which introduced deprecation fix These tests directly taken gh- assert np issubdtype np float float assert np issubdtype np float f assert np issubdtype np int int following correct spellings np integer np floating np complexfloating respectively assert np issubdtype np int int np int never np int_ assert np issubdtype np float float assert np issubdtype np complex complex assert np issubdtype np float float assert np issubdtype np float f Test same correct first datatype abstract one case int float complex assert np issubdtype np float float assert np issubdtype np float f assert np issubdtype np int int assert np issubdtype np int np integer assert np issubdtype np float np floating assert np issubdtype np complex np complexfloating assert np issubdtype np float float assert np issubdtype np float f xpassIfTorchDynamo_np reason= We do have need np core numerictypes Our type aliases _dtypes py TestBitName TestCase test_abstract assert_raises ValueError np core numerictypes bitname np floating skip reason= Docstrings scalar types yet skipif sys flags optimize reason= no docstrings present inspect when PYTHONOPTIMIZE Py_OptimizeFlag TestDocStrings TestCase test_platform_dependent_aliases np int np int_ assert_ int np int_ __doc__ np int np longlong assert_ int np longlong __doc__ instantiate_parametrized_tests TestScalarTypeNames TestCase gh- numeric_types = np byte np short np intc np int_ np longlong NB torch does properly have longlong np ubyte np half np single np double np csingle np cdouble test_names_are_unique none above may aliases each other assert len set numeric_types == len numeric_types names must unique names = t __name__ t numeric_types assert len set names == len names parametrize t numeric_types test_names_reflect_attributes t Test names correspond where type under ` ` np ` ` assert getattr np t __name__ t skipIfTorchDynamo XXX weird some names OK parametrize t numeric_types test_names_are_undersood_by_dtype t Test dtype constructor maps names back type assert np dtype t __name__ type t __name__ == __main__ run_tests