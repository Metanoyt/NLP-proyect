Owner s module inductor operator torch torch fx fx torch _inductor augmented_graph_helper AugmentedGraphHelper torch testing _internal common_utils TestCase torch utils _ordered_set OrderedSet TestAugmentedGraphHelper TestCase Test suite AugmentedGraphHelper dependency merge management setUp Create simple graph structure testing Create torch fx Graph multiple nodes graph = fx Graph Create placeholder nodes inputs x = graph placeholder x y = graph placeholder y Create computation nodes specific names easy reference node_a = graph call_function torch add args= x y name= A node_b = graph call_function torch mul args= node_a x name= B node_c = graph call_function torch sub args= node_a y name= C node_d = graph call_function torch div args= node_b node_c name= D node_e = graph call_function operator neg args= node_d name= E node_f = graph call_function torch abs args= node_e name= F node_g = graph call_function torch relu args= node_f name= G node_h = graph call_function torch sigmoid args= node_g name= H Create output graph output node_h Create mapping nodes name easier access tests nodes = node graph nodes hasattr node name node name A B C D E F G H nodes node name = node Get all nodes compute ancestors all_nodes = list graph nodes node_ancestors = _collect_node_ancestors graph Create tracker ancestors tracker = AugmentedGraphHelper graph node_ancestors=self node_ancestors _collect_node_ancestors graph fx Graph - dict fx Node OrderedSet fx Node Collect all ancestors each node collections defaultdict torch utils _ordered_set OrderedSet ancestors dict fx Node OrderedSet fx Node = defaultdict OrderedSet node graph nodes input_node node all_input_nodes ancestors node add input_node ancestors node &#124; = ancestors input_node ancestors get_deps node Helper get dependencies node list getattr node args ========== Basic Functionality Tests ========== test_initial_state Test nodes start singletons node all_nodes merge_set = tracker merge_sets node assertEqual merge_set node assertEqual len merge_set test_simple_merge Test merging two nodes node_a = nodes A node_b = nodes B merge_nodes tracker node_a node_b Both should same merge set assertEqual tracker merge_sets node_a node_a node_b assertEqual tracker merge_sets node_b node_a node_b assertEqual tracker merge_sets node_a tracker merge_sets node_b test_transitive_merge Test merging already merged nodes node_a = nodes A node_b = nodes B node_c = nodes C node_d = nodes D Merge A-B C-D separately node node_b node_c node_d tracker merge_to_set node_a node expected_set = node_a node_b node_c node_d node node_a node_b node_c node_d assertEqual tracker merge_sets node expected_set merge_nodes tracker nodes n nodes tracker merge_to_set nodes n test_unmerge_node Test removing node its merge set node_a = nodes A node_b = nodes B node_c = nodes C Merge all three merge_nodes tracker node_a node_b node_c assertEqual len tracker merge_sets node_a Unmerge B tracker unmerge_node node_b B should singleton assertEqual tracker merge_sets node_b node_b A C should still together assertEqual tracker merge_sets node_a node_a node_c assertEqual tracker merge_sets node_c node_a node_c test_unmerge_from_singleton Test unmerging node s already singleton node_a = nodes A Should no-op tracker unmerge_node node_a assertEqual tracker merge_sets node_a node_a ========== Dependency Propagation Tests ========== test_merged_deps_collection Test dependencies collected all merged nodes node_a = nodes A node_b = nodes B node_c = nodes C B already depends A x graph construction C already depends A y graph construction Merge B C merge_nodes tracker node_b node_c Get merged deps B - should include deps both B C deps = tracker get_merged_deps node_b Should include all dependencies both nodes assertIn node_a deps From both B C assertIn x deps From B assertIn y deps From C test_extra_deps_with_merge Test extra dependencies work correctly merged nodes node_a = nodes A node_b = nodes B node_c = nodes C node_d = nodes D Add extra dep A C tracker add_extra_dep n=node_a dep=node_c Merge A B merge_nodes tracker node_a node_b Add extra dep D merged node via B tracker add_extra_dep n=node_d dep=node_b D should depend B through extra deps deps = tracker get_merged_deps node_d assertIn node_b deps A should still have its dep C deps = tracker get_merged_deps node_a assertIn node_c deps ========== Path Finding Tests ========== test_has_path_direct Test path finding direct dependencies In our graph B depends A node_a = nodes A node_b = nodes B assertTrue tracker has_path node_a node_b assertFalse tracker has_path node_b node_a test_has_path_transitive Test path finding through multiple nodes In our graph A - B - D A - C - D - E node_a = nodes A node_e = nodes E assertTrue tracker has_path node_a node_e assertFalse tracker has_path node_e node_a test_has_path_through_merge Test path finding when nodes merged Create new graph specific test graph = fx Graph x = graph placeholder x = graph call_function torch neg args= x name= A b = graph call_function torch abs args= name= B c = graph call_function torch relu args= x name= C d = graph call_function torch sigmoid args= c name= D graph output d tracker = AugmentedGraphHelper graph Initially no path B D assertFalse tracker has_path b d Merge B C tracker merge_to_set b c Now there should path B C - D assertTrue tracker has_path b d test_has_path_with_extra_deps Test path finding extra dependencies graph = fx Graph x = graph placeholder x = graph call_function torch neg args= x name= A b = graph call_function torch abs args= name= B c = graph call_function torch relu args= x name= C d = graph call_function torch sigmoid args= c name= D graph output d tracker = AugmentedGraphHelper graph Initially no path B D assertFalse tracker has_path b d tracker add_extra_dep n=c dep=b Now there should path B C - D assertTrue tracker has_path b d ========== Cycle Detection Tests ========== test_no_cycle_in_dag Test DAG has no cycles Our original graph DAG should have no cycles assertFalse tracker has_cycle test_simple_cycle_detection Test detection simple cycle Create graph cycle graph = fx Graph x = graph placeholder x We can t create true cycles fx Graph directly we can simulate extra_deps = graph call_function torch neg args= x b = graph call_function torch abs args= c = graph call_function torch relu args= b graph output c tracker = AugmentedGraphHelper graph assertFalse tracker has_cycle Add extra dep create cycle - c tracker add_extra_dep n=a dep=c assertTrue tracker has_cycle test_cycle_through_merge Test merging can create cycles Create specific graph test graph = fx Graph x = graph placeholder x = graph call_function torch neg args= x b = graph call_function torch abs args= c = graph call_function torch relu args= x d = graph call_function torch sigmoid args= c graph output d tracker = AugmentedGraphHelper graph Add extra dep d - tracker add_extra_dep n=a dep=d Now - b c - d - Merging b c would create cycle tracker merge_to_set b c assertTrue tracker has_cycle test_cycle_with_extra_deps Test cycle detection extra dependencies node_a = nodes A node_b = nodes B B already depends A naturally Add reverse dependency create cycle tracker add_extra_dep n=node_a dep=node_b assertTrue tracker has_cycle test_multiple_merge_unmerge Test sequence merge unmerge operations nodes = nodes c c A B C D E Merge A B C merge_nodes tracker nodes assertEqual len tracker merge_sets nodes Merge D E merge_nodes tracker nodes assertEqual len tracker merge_sets nodes Merge two groups via B D try merge_nodes tracker nodes nodes thrown = False except AssertionError thrown = True assertTrue thrown Unmerge C tracker unmerge_node nodes assertEqual len tracker merge_sets nodes assertEqual tracker merge_sets nodes nodes Unmerge A tracker unmerge_node nodes assertEqual tracker merge_sets nodes nodes assertEqual len tracker merge_sets nodes ========== Dependency Transfer Tests ========== test_transfer_with_cross_deps Test transfer when erased nodes depend each other old_start - old_wait both get replaced Should become new_start - new_wait graph = fx Graph x = graph placeholder x old_start = graph call_function torch relu args= x name= old_start old_wait = graph call_function torch abs args= x name= old_wait compute = graph call_function torch neg args= old_wait name= compute graph output compute tracker = AugmentedGraphHelper graph Add cross-dependency old_start - old_wait tracker add_extra_dep n=old_wait dep=old_start Add extra dep compute - old_wait tracker add_extra_dep n=compute dep=old_wait Create replacements new_start = graph call_function torch sigmoid args= x name= new_start new_wait = graph call_function torch tanh args= x name= new_wait Transfer both once tracker transfer_erased_node_deps old_start new_start old_wait new_wait new_wait should depend new_start cross-dep redirected correctly assertIn new_start tracker extra_deps new_wait compute should depend new_wait assertIn new_wait tracker extra_deps compute Old nodes should cleaned up assertEqual len tracker extra_deps old_start assertEqual len tracker extra_deps old_wait assertEqual len tracker extra_uses old_start assertEqual len tracker extra_uses old_wait test_transfer_preserves_external_deps Test external dependencies preserved correctly external - old old - external Should become external - new new - external graph = fx Graph x = graph placeholder x external = graph call_function torch relu args= x name= external old = graph call_function torch abs args= x name= old old = graph call_function torch neg args= x name= old external = graph call_function torch sigmoid args= x name= external graph output external tracker = AugmentedGraphHelper graph Add deps old - external external - old tracker add_extra_dep n=old dep=external tracker add_extra_dep n=external dep=old Create new nodes new = graph call_function torch tanh args= x name= new new = graph call_function torch exp args= x name= new Transfer tracker transfer_erased_node_deps old new old new assertIn external tracker extra_deps new assertIn new tracker extra_deps external assertNotIn old tracker extra_deps external test_transfer_with_merge_sets Test transfer when nodes have merge sets graph = fx Graph x = graph placeholder x old_a = graph call_function torch relu args= x name= old_a old_b = graph call_function torch abs args= x name= old_b dep = graph call_function torch neg args= x name= dep user = graph call_function torch sigmoid args= x name= user graph output user tracker = AugmentedGraphHelper graph Merge old_a old_b tracker merge_to_set old_a old_b Add deps old_a - dep user - old_a tracker add_extra_dep n=old_a dep=dep tracker add_extra_dep n=user dep=old_a Create new node new = graph call_function torch tanh args= x name= new Transfer only need specify one merge set tracker transfer_erased_node_deps old_a new new should have dep dep assertIn dep tracker extra_deps new user should depend new assertIn new tracker extra_deps user Both old nodes should cleaned up assertEqual len tracker extra_deps old_a assertEqual len tracker extra_deps old_b test_transfer_multiple_merge_sets_with_chain Test transferring multiple merge sets depend each other Setup node singleton node node merged other_node singleton node node merged Dependencies node - node other_node - node node - other_node Transfer node node - new_ _ node node - new_ _ Expected new_ _ - node other_node - new_ _ new_ _ - other_node graph = fx Graph x = graph placeholder x Create nodes node = graph call_function torch relu args= x name= node node = graph call_function torch abs args= x name= node node = graph call_function torch neg args= x name= node other_node = graph call_function torch sigmoid args= x name= other_node node = graph call_function torch tanh args= x name= node node = graph call_function torch exp args= x name= node graph output other_node tracker = AugmentedGraphHelper graph Merge node node tracker merge_to_set node node Merge node node tracker merge_to_set node node Add dependencies tracker add_extra_dep n=node dep=node node - node tracker add_extra_dep n=other_node dep=node other_node - node tracker add_extra_dep n=node dep=other_node node - other_node Create replacement nodes new_ _ = graph call_function torch sin args= x name= new_ _ new_ _ = graph call_function torch cos args= x name= new_ _ Transfer both merge sets atomically tracker transfer_erased_node_deps node new_ _ This will transfer both node node node new_ _ This will transfer both node node Verify new_ _ should depend node assertIn node tracker extra_deps new_ _ Verify other_node should depend new_ _ node assertIn new_ _ tracker extra_deps other_node assertNotIn node tracker extra_deps other_node Verify new_ _ should depend other_node assertIn other_node tracker extra_deps new_ _ Verify old nodes cleaned up assertEqual len tracker extra_deps node assertEqual len tracker extra_deps node assertEqual len tracker extra_deps node assertEqual len tracker extra_deps node Verify bidirectional consistency assertIn new_ _ tracker extra_uses node assertIn other_node tracker extra_uses new_ _ assertIn new_ _ tracker extra_uses other_node __name__ == __main__ torch _inductor test_case run_tests run_tests