mypy allow-untyped-defs inspect logging collections abc Callable functools wraps queue Queue torch nn nn torch fx _compatibility compatibility torch fx graph_module GraphModule torch fx passes infra pass_base PassResult logger = logging getLogger __name__ logger setLevel logging WARNING __all__ = pass_result_wrapper this_before_that_pass_constraint PassManager compatibility is_backward_compatible=False pass_result_wrapper fn Callable - Callable Wrapper passes which currently do PassResult This wrapper makes them PassResult containing modified object True modified flag Args fn Callable Module Any Returns wrapped_fn Callable Module PassResult fn None pyrefly ignore bad-return None wraps fn wrapped_fn gm res = fn gm res None PassResult gm True isinstance res PassResult res isinstance res nn Module PassResult res True inspect isfunction fn wrapped_fn __name__ = type fn __name__ wrapped_fn _validate_pass_schedule_constraint constraint Callable Callable Callable bool passes list Callable - None i enumerate passes j b enumerate passes i + constraint b continue raise RuntimeError f pass schedule constraint violated Expected before b f found index i b index j pass f list _topological_sort_passes passes list Callable constraints list Callable - list Callable Args passes Passes we ordering constraints Constraints applied these passes Returns A sorted list callables boolean circular dependency existed len constraints == passes Construct graph mapping nodes list their users graph dict Callable list Callable = p p passes indegree_map dict Callable int = dict fromkeys passes candidates Queue = Queue passes b passes == b continue constraint constraints constraint b graph b append indegree_map += indegree_map == candidates put visited dict Callable bool = dict fromkeys passes False sorted_passes list Callable = while candidates empty p = candidates get sorted_passes append p visited p = True n graph p visited n indegree_map n -= indegree_map n == candidates put n Check there unvisited nodes aka cycles graph cycle_passes = list filter lambda p indegree_map p = indegree_map keys len cycle_passes = error = f Circular dependency detected within following passes cycle_passes raise RuntimeError error sorted_passes compatibility is_backward_compatible=False this_before_that_pass_constraint Callable Callable - Callable Defines partial order depends function where ` ` must occur before ` ` For example following pass list constraint list would invalid ` ` ` passes = pass_b pass_a constraints = this_before_that_pass_constraint pass_a pass_b ` ` ` Args Callable pass which should occur first Callable pass which should occur later Returns depends_on Callable Object Object bool depends_on Callable b Callable = b = depends_on compatibility is_backward_compatible=False PassManager Construct PassManager Collects passes constraints This defines pass schedule manages pass constraints pass execution Args passes Optional List Callable List passes A pass callable which modifies object returns PassResult constraint Optional List Callable List constraints A constraint callable which takes two passes A B returns True A depends B False otherwise See implementation ` this_before_that_pass_constraint ` example steps int Max number times we run passes default = run_checks_after_each_pass bool Whether run checks linting after each pass suppress_check_failures bool Whether raise errors when running checks passes list Callable nn Module PassResult constraints list Callable Callable Callable bool _validated bool = False steps int = __init__ passes=None constraints=None steps=None run_checks_after_each_pass bool = False suppress_check_failures bool = False passes = passes constraints = constraints steps steps = steps run_checks_after_each_pass = run_checks_after_each_pass suppress_check_failures = suppress_check_failures add_pass _pass Callable Adds pass into current list passes passes append _pass _validated = False add_constraint constraint Callable Adds constraint into current list constraints constraints append constraint _validated = False validate_constraints Validates current pass schedule defined ` passes ` valid according all constraints ` constraints ` _validated constraint constraints _validate_pass_schedule_constraint constraint passes _validated = True solve_constraints Finds valid traversal order based given constraints orders passes based order If circular dependency exists between constraints steps = then we will raise error because steps = means we will re-run passes allowing circular dependencies passes = _topological_sort_passes passes constraints _validated = True add_checks check Callable - None Adds function which takes runs various checks given graph module This function run before after each pass ` run_checks_after_each_pass ` flag enabled sig = inspect signature check len list sig parameters values = raise TypeError PassManager check function should only take one variable module setattr check check noqa B check module nn Module - None pass __call__ module nn Module - PassResult Runs list passes order based ` passes ` given graph module Each time pass run checks linting will run graph module ` run_checks_after_each_pass ` set If module graph module we will run list passes until graph stops changing until ` steps ` number times Order passes based constraints _validated solve_constraints Check graph invariants check module Run set passes ` steps ` number times until graph stops changing overall_modified = False _ range steps modified = False Run set passes graph module i fn enumerate passes fn_name = fn __name__ inspect isfunction fn type fn __name__ logger debug Running pass s fn_name try res = fn module isinstance res PassResult hasattr res graph_module raise TypeError f The result pass fn_name should type PassResult + Please wrap pass_result_wrapper module = res graph_module modified = modified res modified isinstance module GraphModule logger debug Graph after pass s s fn_name module graph module recompile Check graph invariants run_checks_after_each_pass check module except Exception e prev_pass_names = p __name__ inspect isfunction p type p __name__ p passes i msg = f An error occurred when running fn_name pass after following passes prev_pass_names raise Exception msg e noqa TRY If graph no longer changes then we can stop running these passes overall_modified = overall_modified modified modified break PassResult module overall_modified