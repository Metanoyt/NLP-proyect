Owner s module dynamo sys torch torch _dynamo test_case torch _dynamo testing torch _dynamo config torch _dynamo testing make_test_cls_with_patches try test_ctx_manager pass except ImportError test_aot_autograd test_ctx_manager test_export test_functions test_higher_order_ops test_misc test_modules test_repros test_sdpa test_subgraphs pass test_classes = make_nested_cls cls suffix = _nested_graph_breaks cls_prefix = NestedGraphBreaks test_class = make_test_cls_with_patches cls cls_prefix suffix config debug_force_nested_calls True config debug_force_graph_break_on_leaf_return True config debug_disable_compile_counter True xfail_prop= _expected_failure_nested_graph_breaks test_classes test_class __name__ = test_class REMOVING THIS LINE WILL STOP TESTS FROM RUNNING globals test_class __name__ = test_class test_class __module__ = __name__ test_class tests = test_ctx_manager CtxManagerTests test_functions FunctionTests test_misc MiscTests test_repros ReproTests test_modules NNModuleTests test_subgraphs SubGraphTests test_higher_order_ops HigherOrderOpTests test_higher_order_ops FuncTorchHigherOrderOpTests test_aot_autograd AotAutogradFallbackTests test_sdpa TestSDPA test = None test tests make_nested_cls test del test use test_side_effects_globals global global global global = torch zeros NestedGraphBreakTests torch _dynamo test_case TestCaseWithNestedGraphBreaks test_single_graph_break NOTE marking f f f global prevents them being freevars global f f f f x x = x + torch _dynamo graph_break x + f x f x + + f x f x + + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_single_graph_break_repeat global f f f f x x = x + torch _dynamo graph_break x + f x tmp = f x + tmp = f x + tmp + tmp f x f x + + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros dtype=torch long res = f x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_doubly_nested_graph_break global f f f f x x = x + torch _dynamo graph_break x + f x x = x + torch _dynamo graph_break f x + + f x f x + + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_differing_arg_nums global f f f f f x x x = x + x torch _dynamo graph_break x + f x x x x f x + x x + x + f x x f x x + x x + + f x f x x + + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_differing_locals_nums global f f f f x loc = x + torch _dynamo graph_break loc + f x loc = x + loc = x + f x + loc + loc f x loc = x + loc = x + loc = x + loc = x + f x + loc + loc + loc + loc cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_counters global f f f f f x x = x + torch _dynamo graph_break x + f x f x + + f x x = x + _ range x = f x x + torch compile backend= eager f x f x + + assertEqual f torch zeros torch zeros + assertEqual len torch _dynamo utils counters graph_break test_supported_ctx_manager global check check_disabled f f f torch _dynamo disable check_disabled value assert torch is_grad_enabled == value check value assert torch is_grad_enabled == value f x torch no_grad x = x + check False check_disabled False check False x + f x torch enable_grad x = x + check True check_disabled True check True f x + f x torch no_grad x = x + check False check_disabled False check False f x + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count includes set_grad_enabled ops assertEqual cnts op_count test_inactive_ctx_manager global check f f f check value assert torch is_grad_enabled == value f x ctx x = x + ctx = torch no_grad torch no_grad stack value time graph break ctx = torch no_grad torch _dynamo graph_break x = x + torch _dynamo graph_break ctx check False ctx check False ctx check False x + f x ctx x = x + ctx = torch no_grad x = f x torch no_grad ctx check False ctx check False x + f x x = x + ctx = torch no_grad x = f x torch no_grad ctx check False x + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count torch _dynamo config patch recompile_limit= fail_on_recompile_limit_hit=True test_no_recompiles global f f f f x x = x + torch _dynamo graph_break x + f x x = x + x = f x torch _dynamo graph_break x + f x x = x + f x + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count test_cells f x cell = x + cell = x + f x x nonlocal cell cell = x + x + cell += f x nonlocal cell cell cell += cell += torch _dynamo graph_break x + cell + cell + cell f x + x cell f x + x + + cell cell outer x f x cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts outer x = torch zeros res = outer x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_dead_nested_cells global f f f f x cell cell += x = x + cell torch _dynamo graph_break x + cell f cell = inner x x += x = f x cell x + inner f x f x + + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res If we don t handle dead cells nested functions correctly frame_count will increase since we also graph break when we attempt codegen inner The exact issue side_effects failing codegen inner s cell s creation So when we try codegen cells resume functions we end up trying codegen CellVariable without source which leads graph break we can t resume assertEqual cnts frame_count assertEqual cnts op_count test_cells_double_graph_break f x cell = x + f x nonlocal cell cell += torch _dynamo graph_break torch _dynamo graph_break x + cell f x + cell outer x f x cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts outer x = torch zeros res = outer x ref = opt_fn x assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_side_effects_cells cell cell cell cell = torch zeros f nonlocal cell cell += torch _dynamo graph_break cell + cell f nonlocal cell cell += f + cell + cell f f cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f cell = torch zeros cell = torch zeros + cell = torch zeros cell = torch zeros + res = f res = res + tuple x clone x cell cell cell cell cell = torch zeros cell = torch zeros + cell = torch zeros cell = torch zeros + ref = opt_fn ref = ref + tuple x clone x cell cell cell cell assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_side_effects_globals global f f f global global global global global f global global global += torch _dynamo graph_break global + global f global global global += f + global + global f x x + f cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch ones global = torch zeros global = torch zeros + global = torch zeros global = torch zeros + res = f x global clone global global clone global global = torch zeros global = torch zeros + global = torch zeros global = torch zeros + ref = opt_fn x global clone global global clone global assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_side_effects_globals_different_module global f f _test_nested_graph_breaks_helper try _test_nested_graph_breaks_helper except ImportError _test_nested_graph_breaks_helper f x x = x + torch _dynamo graph_break x + f x x = x + x = _test_nested_graph_breaks_helper fn x f x + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f _test_nested_graph_breaks_helper reset_state x = torch zeros res = f x _test_nested_graph_breaks_helper global clone _test_nested_graph_breaks_helper reset_state ref = opt_fn x _test_nested_graph_breaks_helper global clone assertEqual ref res assertEqual cnts frame_count assertEqual cnts op_count test_nested_graph_break_in_loop global f f f f f f x i x = x + i == torch _dynamo graph_break x + f x i x = x + x = f x i x + f x i range x = f x i x f x x = x + x = f x x + f x x = x + x = f x x + cnts = torch _dynamo testing CompileCounter dynamic=True prevent unnecessary recompiles opt_fn = torch _dynamo optimize backend=cnts dynamic=True f x = torch zeros res = f x ref = opt_fn x assertEqual ref res skip frame due nested graph break loop frames f +f frames f +f i == frame f +f i = assertEqual cnts frame_count additions f +f x additions f +f i == i = assertEqual cnts op_count assertEqual torch _dynamo utils counters frames total test_nested_graph_break_in_try_block NOTE also tests nested step_graph_break global f f f f f f x x = x + torch _dynamo graph_break x + f x x = x + x = f x x + f x x = x + try x = x + x = f x x = x + finally pass x + f x x = x + x = f x x + f x x = x + x = f x x + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res skip frame due graph break try block frames f +f + first part f frames f +f assertEqual cnts frame_count additions f +f + first part f additions f +f assertEqual cnts op_count assertEqual torch _dynamo utils counters frames total test_nested_step_unsupported global f f f f x x + f x x = x + torch _dynamo step_unsupported f x + f x x = x + f x + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res frame start f + start f frame f frame end f assertEqual cnts frame_count all ops except + assertEqual cnts op_count assertEqual torch _dynamo utils counters frames total test_generator_nested_graph_break gen x yield x + torch _dynamo graph_break yield x + fn x x = x + list gen x cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts fn x = torch zeros res = fn x NOTE we enable nested graph breaks inlined generators we expect some sort internal dynamo failure ref = opt_fn x assertEqual ref res fn should skipped assertEqual cnts frame_count outer x x = x + fn x + cnts clear torch compiler reset opt_fn = torch _dynamo optimize backend=cnts outer x = torch zeros res = outer x ref = opt_fn x assertEqual ref res only outer should traced assertEqual cnts frame_count assertEqual cnts op_count test_return_after_graph_break_nested With improper implementation returning immediately after nested graph break may skip rest top-level frame f inner x x += inner x torch compile backend= eager f inner x result = f inner x x += result None x += result x test normal graph break x = torch zeros inner x x += torch _dynamo graph_break ref = f inner x assertEqual ref torch zeros + test step graph break x = torch zeros inner x x += torch _dynamo step_unsupported ref = f inner x assertEqual ref torch zeros + test store attr graph break NOTE we do manual bytecode generation hack since only RETURN_ instruction can follow STORE_ATTR RETURN_CONST which removed + make sure inner s code options compatible instructions below global y y pass inner x x attr = y attr = new_inst = torch _dynamo bytecode_transformation create_instruction insts = new_inst LOAD_CONST argval= new_inst LOAD_CONST argval= new_inst LOAD_GLOBAL argval= y NOTE should cause graph break - change y doesn t work new_inst STORE_ATTR argval= attr new_inst RETURN_VALUE sys version_info = insts = new_inst RESUME arg= + insts code_keys = torch _dynamo bytecode_transformation get_code_keys code_options = k getattr inner __code__ k k code_keys _ inner _code = torch _dynamo bytecode_transformation clean_and_assemble_instructions insts code_keys code_options inner __code__ = inner _code torch _dynamo utils counters clear x = torch zeros ref = f inner x assertEqual ref torch zeros + make sure we re actually STORE_ATTR graph breaking assertEqual len torch _dynamo utils counters graph_break dynamic branching harder test - other tests should enough cover test every function returning torch compiler disable inner x x += x inner x x += inner x torch compile backend= eager f x x += f inner x x = torch zeros ref = f x assertEqual ref torch zeros + test_return_after_graph_break_deep_nested torch compiler disable f x x + f x f x + f x f x + f x x = f x + x + f x f x + f x f x + f x x = f x + x + torch compile backend= eager f x f x + x = torch zeros ref = f x assertEqual ref torch zeros + check only resume functions created assertEqual len torch _dynamo utils counters resumes name resume_in_f resume_in_f assertTrue any name key key torch _dynamo utils counters resumes keys test_disable_nested_graph_breaks global f f f f f f x x = x + torch _dynamo graph_break x + f x f x + + NOTE since disable_nested_graph_breaks decorator implemented context manager we don t need separately test context manager usage torch _dynamo disable_nested_graph_breaks f x f x + + f x f x + + f x f x + + cnts = torch _dynamo testing CompileCounter opt_fn = torch _dynamo optimize backend=cnts f x = torch zeros res = f x ref = opt_fn x assertEqual ref res frames each f +f f f f assertEqual cnts frame_count assertEqual cnts op_count __name__ == __main__ torch _dynamo test_case run_tests run_tests