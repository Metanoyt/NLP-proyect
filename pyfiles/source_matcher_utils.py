logging os collections abc Callable dataclasses dataclass field typing Any Optional torch fx _compatibility compatibility torch fx graph Graph torch fx node Node __all__ = get_source_partitions check_subgraphs_connected SourcePartition Set ` PYTORCH_MATCHER_LOGLEVEL=INFO ` see debug logs _init_logger - logging Logger logger = logging getLogger __name__ level = os environ get PYTORCH_MATCHER_LOGLEVEL WARNING upper logger setLevel level console = logging StreamHandler formatter = logging Formatter filename s message s console setFormatter formatter console setLevel level add handlers logger logger addHandler console logger propagate = False logger logger = _init_logger compatibility is_backward_compatible=False dataclass SourcePartition Nodes particular partition nodes list Node The source these nodes decomposed source Any Nodes graph needed inputs partition These do include params partition input_nodes list Node = field default_factory=list Nodes partition being used nodes outside partition output_nodes list Node = field default_factory=list Parameters being used params list Node = field default_factory=list compatibility is_backward_compatible=False type ignore misc get_source_partitions graph Graph wanted_sources list Any filter_fn Optional Callable Node bool = None - dict Any list SourcePartition Args graph The graph we want partition wanted_sources List sources nodes decomposed source This can function ex torch nn functional linear leaf module type ex torch nn Linear Returns Dictionary mapping sources given list SourcePartitions correspond list nodes decomposed given source modules dict type dict str list Node = node graph nodes The metadata source_fn should contain tuple unique name source source function node decomposed function type module node decomposed leaf module TODO Bypass torch_fn when source_fn_stack because now torch_fn can different source_fn_stack example add_ node decomposed batch norm We should remove check source_fn_stack after we fix torch_fn T source_fn_st = node meta get source_fn_stack None None torch_fn = node meta get torch_fn None None node_fqn source_fn = torch_fn source_fn_name = source_fn split source_fn_name wanted_sources diff_modules = modules setdefault source_fn_name partition = diff_modules setdefault node_fqn partition append node source_fn_st = node meta get source_fn_stack None None source_fn = source_fn_st - source_fn wanted_sources diff_modules = modules setdefault source_fn partition = diff_modules setdefault source_fn partition append node make_partition nodes list Node module_type type - SourcePartition input_nodes = set output_nodes = set params = set node nodes arg node args isinstance arg Node arg nodes arg op = get_attr input_nodes add arg node op == get_attr params add node get_attr nodes won t output nodes continue user node users keys user nodes output_nodes add node SourcePartition nodes module_type list input_nodes list output_nodes list params type ignore arg-type ret dict type Any list SourcePartition = filter_fn each partition we apply filter_fn filter out all partitions doesn t satisfy filter condition filtered_modules = tp name_to_partition modules items filtered_name_to_partition = name partition name partition name_to_partition items all map filter_fn partition filtered_modules tp = filtered_name_to_partition modules = filtered_modules k v modules items ret k = make_partition partition k partition v values ret compatibility is_backward_compatible=False type ignore misc check_subgraphs_connected subgraph SourcePartition subgraph SourcePartition - bool Given two subgraphs A B form list nodes checks A has nodes connecting least one node B -- aka there exists node B uses node A other way around node reversed subgraph nodes user node users keys user subgraph nodes True False