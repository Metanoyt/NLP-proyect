mypy allow-untyped-defs collections inspect typing types GenericAlias typing Optional Union torch torch device dtype Tensor types torch utils _exposed_in exposed_in opaque_object _OPAQUE_TYPES is_opaque_type OpaqueType OpaqueTypeStr This used negative test test_custom_ops py TestTypeConversion test_type_eval _TestTensor = torch Tensor exposed_in torch library infer_schema prototype_function typing Callable mutates_args op_name Optional str = None - str r Parses schema given function type hints The schema inferred function s type hints can used define new operator We make following assumptions None outputs alias any inputs each other &#124; String type annotations device dtype Tensor types without library specification &#124; assumed torch Similarly string type annotations Optional List Sequence Union &#124; without library specification assumed typing &#124; Only args listed ` ` mutates_args ` ` being mutated If ` ` mutates_args ` ` unknown &#124; assumes all inputs operator being mutates Callers e g custom ops API responsible checking these assumptions Args prototype_function The function which infer schema its type annotations op_name Optional str The name operator schema If ` ` name ` ` None then name included inferred schema Note input schema ` ` torch library Library define ` ` requires operator name mutates_args unknown &#124; Iterable str The arguments mutated function Returns The inferred schema Example foo_impl x torch Tensor - torch Tensor x sin infer_schema foo_impl op_name= foo mutates_args= foo Tensor x - Tensor infer_schema foo_impl mutates_args= Tensor x - Tensor UNKNOWN_MUTATES = unknown pf_globals = prototype_function __globals__ pf_locals = None TODO Once our minimum version py + pass ` eval_str=True ` inspect signature we no longer need deal stringified annotations below sig = inspect signature prototype_function error_fn what raise ValueError f infer_schema func what Got func signature sig convert_type_string annotation_type str try eval annotation_type pf_globals pf_locals except Exception error_fn f Unsupported type annotation annotation_type It type unstringify_types tys tuple Union type object str - tuple tuple typing Any bool res = changed = False ty tys ty ty_changed = unstringify_type ty res append ty changed &#124; = ty_changed changed tuple res True tys False type ignore return-value unstringify_type ty Union type object str - tuple typing Any bool Dig through generic type contains stringified type convert real type The second value indicates type contained string isinstance ty str convert_type_string ty True origin = typing get_origin ty args args_changed = unstringify_types typing get_args ty args_changed GenericAlias origin args True ty False params = seen_args = set saw_kwarg_only_arg = False idx name param enumerate sig parameters items supported_param param error_fn We do support positional-only args varargs varkwargs param kind == inspect Parameter KEYWORD_ONLY The first time we see kwarg-only arg add schema saw_kwarg_only_arg params append saw_kwarg_only_arg = True param annotation inspect Parameter empty error_fn f Parameter name must have type annotation The annotation might converted string annotation we convert actual type annotation_type _ = unstringify_type param annotation schema_type = None annotation_type SUPPORTED_PARAM_TYPES is_opaque_type annotation_type schema_type = _OPAQUE_TYPES annotation_type annotation_type == torch _C ScriptObject error_fn f Parameter name s type cannot inferred schema ScriptObject Please manually specify schema using ` schema= ` kwarg actual type ScriptObject hasattr annotation_type __origin__ annotation_type __origin__ tuple list_type = tuple_to_list annotation_type example_type_str = \n\n Only suggest list type type supported list_type SUPPORTED_PARAM_TYPES keys example_type_str = f For example list_type \n\n error_fn f Parameter name has unsupported type param annotation f We do support Tuple inputs schema As workaround please try use List instead f example_type_str f The valid types SUPPORTED_PARAM_TYPES keys error_fn f Parameter name has unsupported type param annotation f The valid types SUPPORTED_PARAM_TYPES keys schema_type = SUPPORTED_PARAM_TYPES annotation_type assert schema_type None type mutates_args str mutates_args = UNKNOWN_MUTATES raise ValueError mutates_args must either sequence names arguments mutated string unknown schema_type startswith Tensor schema_type = f Tensor idx schema_type len Tensor name mutates_args schema_type startswith Tensor error_fn f Parameter name mutable_args only Tensors collections Tensors can mutated schema_type = f Tensor idx schema_type len Tensor seen_args add name param default inspect Parameter empty pyrefly ignore bad-argument-type params append f schema_type name default_repr = None param default None isinstance param default int float bool default_repr = str param default isinstance param default str torch device default_repr = f param default isinstance param default torch dtype dtype_repr = str param default torch_dot = torch assert dtype_repr startswith torch_dot default_repr = dtype_repr len torch_dot error_fn f Parameter name has unsupported default value type type param default f Please file issue GitHub so we can prioritize pyrefly ignore bad-argument-type params append f schema_type name = default_repr mutates_args = UNKNOWN_MUTATES mutates_args_not_seen = set mutates_args - seen_args len mutates_args_not_seen error_fn f mutates_args_not_seen mutates_args found f custom op s signature f mutates_args should contain names all args f custom op mutates just string unknown you don t know return_annotation _ = unstringify_type sig return_annotation ret = parse_return return_annotation error_fn op_name None f op_name join params - ret f join params - ret derived_types base_type Union type typing _SpecialForm cpp_type str list_base bool optional_base_list bool optional_list_base bool result list tuple Union type typing _SpecialForm GenericAlias str = base_type cpp_type pyrefly ignore not-a-type typing Optional base_type f cpp_type derived_seq_types typ Union type typing _SpecialForm typing Sequence typ type ignore valid-type noqa UP typing List typ type ignore valid-type noqa UP GenericAlias collections abc Sequence typ GenericAlias list typ list_base result extend seq_typ f cpp_type seq_typ derived_seq_types base_type optional_base_list result extend seq_typ f cpp_type pyrefly ignore not-a-type seq_typ derived_seq_types typing Optional base_type optional_list_base result extend typing Optional seq_typ f cpp_type seq_typ derived_seq_types base_type result get_supported_param_types pyrefly ignore bad-assignment data list tuple Union type typing _SpecialForm str bool bool bool = python type schema type type variant type variant type variant Tensor Tensor True True False int SymInt True False True float float True False True bool bool True False True str str False False False types Number Scalar True False False dtype ScalarType False False False device Device False False False OpaqueType OpaqueTypeStr False False False result = line data result extend derived_types line dict result SUPPORTED_RETURN_TYPES = Tensor Tensor typing List Tensor Tensor noqa UP list Tensor Tensor int SymInt float float bool bool types Number Scalar parse_return annotation error_fn annotation None annotation inspect Parameter empty error_fn No type annotation provided Please add one origin = typing get_origin annotation origin tuple annotation SUPPORTED_RETURN_TYPES keys error_fn f Return has unsupported type annotation f The valid types SUPPORTED_RETURN_TYPES pyrefly ignore index-error SUPPORTED_RETURN_TYPES annotation args = typing get_args annotation arg args arg SUPPORTED_RETURN_TYPES error_fn f Return has unsupported type annotation f The valid types SUPPORTED_RETURN_TYPES output_ty = join SUPPORTED_RETURN_TYPES arg arg args use represent tuple single element len args == output_ty = + output_ty + + output_ty + SUPPORTED_PARAM_TYPES = get_supported_param_types supported_param param inspect Parameter - bool param kind inspect Parameter POSITIONAL_OR_KEYWORD inspect Parameter KEYWORD_ONLY tuple_to_list tuple_type type tuple - type list Convert ` tuple_type ` into list type same type arguments Assumes ` tuple_type ` typing Tuple type type_args = getattr tuple_type __args__ None Account different python versions e g python would give python would give None tuple_type typing Tuple noqa UP tuple_type tuple type_args == type_args None Handle case empty tuple type list len type_args == General case create List same type arguments list type_args type ignore valid-type len type_args == type_args Ellipsis list type_args type ignore valid-type list typing Union tuple type_args type ignore misc return-value