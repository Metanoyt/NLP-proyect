Owner s module dynamo Test functions D array set operations unittest expectedFailure xfail skipIf numpy pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests subtest TEST_WITH_TORCHDYNAMO TestCase xpassIfTorchDynamo_np If we going trace through these we should use NumPy If testing eager mode we use torch _numpy TEST_WITH_TORCHDYNAMO numpy np numpy ediff d d intersect d setdiff d setxor d union d unique numpy testing assert_array_equal assert_equal assert_raises_regex torch _numpy np torch _numpy unique torch _numpy testing assert_array_equal assert_equal skipIf numpy __version__ reason= NP_VER fails NumPy x skipIf True reason= TODO implement these ops instantiate_parametrized_tests TestSetOps TestCase test_intersect d unique inputs = np array b = np array ec = np array c = intersect d b assume_unique=True assert_array_equal c ec non-unique inputs = np array b = np array ed = np array c = intersect d b assert_array_equal c ed assert_array_equal intersect d test_intersect d_array_like See gh- Test __array__ np arange = Test res = intersect d assert_array_equal res res = intersect d assert_array_equal res test_intersect d_indices unique inputs = np array b = np array c i i = intersect d b assume_unique=True return_indices=True ee = np array assert_array_equal c ee assert_array_equal i ee assert_array_equal b i ee non-unique inputs = np array b = np array c i i = intersect d b return_indices=True ef = np array assert_array_equal c ef assert_array_equal i ef assert_array_equal b i ef non d unique inputs = np array b = np array c i i = intersect d b assume_unique=True return_indices=True ui = np unravel_index i shape ui = np unravel_index i b shape ea = np array assert_array_equal ea ui assert_array_equal ea b ui non d assumed uniqueinputs = np array b = np array c i i = intersect d b return_indices=True ui = np unravel_index i shape ui = np unravel_index i b shape ea = np array assert_array_equal ea ui assert_array_equal ea b ui test_setxor d = np array b = np array ec = np array c = setxor d b assert_array_equal c ec = np array b = np array ec = np array c = setxor d b assert_array_equal c ec = np array b = np array ec = np array c = setxor d b assert_array_equal c ec assert_array_equal setxor d test_ediff d zero_elem = np array one_elem = np array two_elem = np array assert_array_equal ediff d zero_elem assert_array_equal ediff d zero_elem to_begin= assert_array_equal ediff d zero_elem to_end= assert_array_equal - ediff d zero_elem to_begin=- to_end= assert_array_equal ediff d one_elem assert_array_equal ediff d two_elem assert_array_equal ediff d two_elem to_begin= to_end= assert_array_equal ediff d two_elem to_begin= to_end= assert_array_equal ediff d two_elem to_end= assert_array_equal ediff d two_elem to_end= assert_array_equal ediff d two_elem to_begin= assert_array_equal ediff d two_elem to_begin= parametrize ary prepend append expected should fail because trying cast np nan standard floating point value into integer array np array dtype=np int None np nan to_end should fail because attempting downcast int type subtest np array dtype=np int np array dtype=np float None to_begin should fail because attempting cast two special floating point values integers both sides ary ` to_begin ` error message impl checks first np array dtype=np int np nan np nan to_begin test_ediff d_forbidden_type_casts ary prepend append expected verify resolution gh- specifically raise appropriate Exception when attempting append prepend incompatible type msg = f dtype ` expected ` must compatible assert_raises_regex TypeError msg ediff d ary=ary to_end=append to_begin=prepend parametrize ary prepend append expected np array dtype=np int will cast int under same kind rule + np array dtype=np int np array dtype=np float np array dtype=np float None np array dtype=np float np array dtype=np int np array dtype=np int np array dtype=np int - np array - dtype=np int test_ediff d_scalar_handling ary prepend append expected maintain backwards-compatibility scalar prepend append behavior ediff d following fix gh- actual = np ediff d ary=ary to_end=append to_begin=prepend assert_equal actual expected assert actual dtype == expected dtype skipIf True reason= NP_VER fails NumPy x parametrize kind None sort table test_isin kind tests d cover most isin s behavior d removed would need change those tests test isin instead _isin_slow b b = np asarray b flatten tolist b isin_slow = np vectorize _isin_slow otypes= bool excluded= assert_isin_equal b x = np isin b kind=kind y = isin_slow b assert_array_equal x y multidimensional arrays both arguments = np arange reshape b = np array assert_isin_equal b array-likes both arguments c = d = assert_isin_equal c d zero-d array f = np array assert_isin_equal f b assert_isin_equal f assert_isin_equal f f scalar assert_isin_equal b assert_isin_equal assert_isin_equal empty array-like kind = table An empty list will become float which invalid kind= table x = assert_isin_equal x b assert_isin_equal x assert_isin_equal x x empty array various types dtype bool np int np float kind == table dtype == np float continue dtype np int np float ar = np array dtype=dtype dtype bool ar = np array True False False empty_array = np array dtype=dtype assert_isin_equal empty_array ar assert_isin_equal ar empty_array assert_isin_equal empty_array empty_array parametrize kind None sort table test_in d kind we use two different sizes b array here test two different paths d mult One check without np array make sure lists handled correct = b = mult ec = np array True False True True c = d b assume_unique=True kind=kind assert_array_equal c ec = ec = np array False False True True c = d b assume_unique=True kind=kind assert_array_equal c ec = ec = np array True False True False c = d b assume_unique=True kind=kind assert_array_equal c ec = np array b = mult ec = False True False True True True True True True False True False False False c = d b kind=kind assert_array_equal c ec b = b + mult ec = True True True True True True True True True True True False True True c = d b kind=kind assert_array_equal c ec = np array b = np array mult ec = np array True False True True c = d b kind=kind assert_array_equal c ec = np array b = np array mult ec = np array True False True True True c = d b kind=kind assert_array_equal c ec = np array b = np array mult ec = np array False False c = d b kind=kind assert_array_equal c ec = np array b = np array ec = np array False c = d b kind=kind assert_array_equal c ec kind None sort assert_array_equal d kind=kind test_in d_char_array = np array b c d e c e b b = np array c ec = np array True False True False False True False False c = d b assert_array_equal c ec parametrize kind None sort table test_in d_invert kind Test d s invert parameter We use two different sizes b array here test two different paths d mult = np array b = mult assert_array_equal np invert d b kind=kind d b invert=True kind=kind float kind None sort mult = np array dtype=np float b = mult b = np array b dtype=np float assert_array_equal np invert d b kind=kind d b invert=True kind=kind parametrize kind None sort table test_in d_ravel kind Test d ravels its input arrays This documented behavior however The test ensure consistentency = np arange reshape b = np arange reshape long_b = np arange reshape ec = np array False False False True True True assert_array_equal d b assume_unique=True kind=kind ec assert_array_equal d b assume_unique=False kind=kind ec assert_array_equal d long_b assume_unique=True kind=kind ec assert_array_equal d long_b assume_unique=False kind=kind ec test_in d_hit_alternate_algorithm Hit standard isin code integers Need extreme range hit standard code This hits without use kind= table = np array e dtype=np int b = np array e dtype=np int expected = np array dtype=bool assert_array_equal expected d b assert_array_equal np invert expected d b invert=True = np array dtype=np int b = np array e dtype=np int ec = np array True False True True c = d b assume_unique=True assert_array_equal c ec parametrize kind None sort table test_in d_boolean kind Test d works boolean input = np array True False b = np array False False False expected = np array False True assert_array_equal expected d b kind=kind assert_array_equal np invert expected d b invert=True kind=kind parametrize kind None sort test_in d_timedelta kind Test d works timedelta input rstate = np random RandomState = rstate randint size= b = rstate randint size= truth = d b a_timedelta = astype timedelta s b_timedelta = b astype timedelta s assert_array_equal truth d a_timedelta b_timedelta kind=kind test_in d_table_timedelta_fails = np array dtype= timedelta s b = Make sure raises value error assert_raises ValueError d b kind= table parametrize dtype dtype np int np int np int np int parametrize kind None sort table test_in d_mixed_dtype dtype dtype kind Test d works expected mixed dtype input is_dtype _signed = np issubdtype dtype np signedinteger ar = np array dtype=dtype is_dtype _signed ar = np array - dtype=dtype ar = np array dtype=dtype expected = np array True True False False expect_failure = kind == table any dtype == np int dtype == np int dtype == np int dtype == np int expect_failure assert_raises RuntimeError match= exceed maximum d ar ar kind=kind assert_array_equal d ar ar kind=kind expected parametrize kind None sort table test_in d_mixed_boolean kind Test d works expected bool int input dtype np typecodes AllInteger = np array True False False dtype=bool b = np array dtype=dtype expected = np array False True True dtype=bool assert_array_equal d b kind=kind expected b = b expected = np array True True True True dtype=bool assert_array_equal d b kind=kind expected test_in d_first_array_is_object ar = None ar = np array expected = np array False result = np d ar ar assert_array_equal result expected test_in d_second_array_is_object ar = ar = np array None expected = np array False result = np d ar ar assert_array_equal result expected test_in d_both_arrays_are_object ar = None ar = np array None expected = np array True result = np d ar ar assert_array_equal result expected xfail test_in d_both_arrays_have_structured_dtype Test arrays structured data type containing integer field field dtype ` object ` allowing arbitrary Python objects dt = np dtype field int field object ar = np array None dtype=dt ar = np array None dtype=dt expected = np array True result = np d ar ar assert_array_equal result expected test_in d_with_arrays_containing_tuples ar = np array dtype=object ar = np array dtype=object expected = np array True True result = np d ar ar assert_array_equal result expected result = np d ar ar invert=True assert_array_equal result np invert expected An integer added end array make sure array builder will create array tuples after s created integer removed There s bug array constructor doesn t handle tuples properly adding integer fixes ar = np array dtype=object ar = ar - ar = np array dtype=object ar = ar - expected = np array True True result = np d ar ar assert_array_equal result expected result = np d ar ar invert=True assert_array_equal result np invert expected ar = np array dtype=object ar = ar - ar = np array dtype=object expected = np array True False result = np d ar ar assert_array_equal result expected result = np d ar ar invert=True assert_array_equal result np invert expected test_in d_errors Test d raises expected errors Error ` kind ` one sort table None ar = np array ar = np array assert_raises ValueError d ar ar kind= quicksort Error ` kind= table ` does work non-integral arrays obj_ar = np array b dtype=object obj_ar = np array b dtype=object assert_raises ValueError d obj_ar obj_ar kind= table dtype np int np int ar = np array - dtype=dtype The range array will overflow overflow_ar = np array - np iinfo dtype max dtype=dtype Error ` kind= table ` will trigger runtime error there integer overflow expected when computing range ar assert_raises RuntimeError d ar overflow_ar kind= table Non-error ` kind=None ` will trigger runtime error there integer overflow will switch ` sort ` algorithm result = np d ar overflow_ar kind=None assert_array_equal result True + False result = np d ar overflow_ar kind= sort assert_array_equal result True + False test_union d = np array b = np array ec = np array c = union d b assert_array_equal c ec Tests gh- arguments union d should flattened they already D x = np array y = np array ez = np array z = union d x y assert_array_equal z ez assert_array_equal union d test_setdiff d = np array b = np array ec = np array c = setdiff d b assert_array_equal c ec = np arange b = np arange ec = np array c = setdiff d b assert_array_equal c ec assert_array_equal setdiff d = np array np uint assert_equal setdiff d dtype np uint test_setdiff d_unique = np array b = np array expected = np array actual = setdiff d b assume_unique=True assert_equal actual expected test_setdiff d_char_array = np array b c b = np array b s assert_array_equal setdiff d b np array c test_manyways = np array b = np array c = setxor d b aux = intersect d b aux = union d b c = setdiff d aux aux assert_array_equal c c instantiate_parametrized_tests TestUnique TestCase skipIf TEST_WITH_TORCHDYNAMO int numpy __version__ = fails dynamo numpy = test_unique_ d check_all b i i c dt base_msg = check failed type msg = base_msg format values dt v = unique assert_array_equal v b msg msg = base_msg format return_index dt v j = unique True False False assert_array_equal v b msg assert_array_equal j i msg msg = base_msg format return_inverse dt v j = unique False True False assert_array_equal v b msg assert_array_equal j i msg msg = base_msg format return_counts dt v j = unique False False True assert_array_equal v b msg assert_array_equal j c msg msg = base_msg format return_index return_inverse dt v j j = unique True True False assert_array_equal v b msg assert_array_equal j i msg assert_array_equal j i msg msg = base_msg format return_index return_counts dt v j j = unique True False True assert_array_equal v b msg assert_array_equal j i msg assert_array_equal j c msg msg = base_msg format return_inverse return_counts dt v j j = unique False True True assert_array_equal v b msg assert_array_equal j i msg assert_array_equal j c msg msg = base_msg format return_index return_inverse return_counts dt v j j j = unique True True True assert_array_equal v b msg assert_array_equal j i msg assert_array_equal j i msg assert_array_equal j c msg = b = i = i = c = np multiply test numeric arrays types = types extend np typecodes AllInteger types extend np typecodes AllFloat dt types dt FD RuntimeError unique implemented ComplexFloat continue aa = np array dt bb = np array b dt check_all aa bb i i c dt test ticket RuntimeError unique implemented ComplexFloat aa = + j - j assert_array_equal np unique aa - j + j test ticket = unq = inv = = unique assert_array_equal unq _inv = unique return_inverse=True assert_array_equal unq assert_array_equal _inv inv test ticket = _idx = np unique return_index=True _inv = np unique return_inverse=True _idx _inv = np unique return_index=True return_inverse=True assert_equal _idx dtype np intp assert_equal _inv dtype np intp assert_equal _idx dtype np intp assert_equal _inv dtype np intp xpassIfTorchDynamo_np reason= unique nans test_unique_ d_ test ticket - float = np nan np nan ua = np nan ua_idx = ua_inv = ua_cnt = assert_equal np unique ua assert_equal np unique return_index=True ua ua_idx assert_equal np unique return_inverse=True ua ua_inv assert_equal np unique return_counts=True ua ua_cnt test ticket - complex = - j np nan + j complex np nan complex np nan ua = + j - j complex np nan ua_idx = ua_inv = ua_cnt = assert_equal np unique ua assert_equal np unique return_index=True ua ua_idx assert_equal np unique return_inverse=True ua ua_inv assert_equal np unique return_counts=True ua ua_cnt test gh- all_nans = np nan ua = np nan ua_idx = ua_inv = ua_cnt = assert_equal np unique all_nans ua assert_equal np unique all_nans return_index=True ua ua_idx assert_equal np unique all_nans return_inverse=True ua ua_inv assert_equal np unique all_nans return_counts=True ua ua_cnt test_unique_axis_errors assert_raises np AxisError unique np arange axis= assert_raises np AxisError unique np arange axis=- test_unique_axis_list msg = Unique failed list lists inp = inp_arr = np asarray inp assert_array_equal unique inp axis= unique inp_arr axis= msg assert_array_equal unique inp axis= unique inp_arr axis= msg xpassIfTorchDynamo_np _run_axis_tests xfails message torch has different unique ordering behaviour test_unique_axis types = types extend np typecodes AllInteger types extend np typecodes AllFloat dtype types _run_axis_tests dtype msg = Non-bitwise-equal booleans test failed data = np arange dtype=np uint reshape - view bool result = np array False True True True dtype=bool assert_array_equal unique data axis= result msg msg = Negative zero equality test failed data = np array - - - - result = np array - assert_array_equal unique data axis= result msg parametrize axis - test_unique_ d_with_axis axis x = np array uniq = unique x axis=axis assert_array_equal uniq xpassIfTorchDynamo_np reason= unique return_index test_unique_axis_zeros issue single_zero = np empty shape= dtype=np int uniq idx inv cnt = unique single_zero axis= return_index=True return_inverse=True return_counts=True there s element shape along axis assert_equal uniq dtype single_zero dtype assert_array_equal uniq np empty shape= assert_array_equal idx np array assert_array_equal inv np array assert_array_equal cnt np array there s elements shape along axis uniq idx inv cnt = unique single_zero axis= return_index=True return_inverse=True return_counts=True assert_equal uniq dtype single_zero dtype assert_array_equal uniq np empty shape= assert_array_equal idx np array assert_array_equal inv np array assert_array_equal cnt np array test complicated shape shape = multiple_zeros = np empty shape=shape axis range len shape expected_shape = list shape shape axis == expected_shape axis = expected_shape axis = assert_array_equal unique multiple_zeros axis=axis np empty shape=expected_shape test_unique_sort_order_with_axis These tests fail sorting along axis done treating subarrays unsigned byte strings See gh- fmt = sort order incorrect integer type s dt bhil = np array - dt b = np unique axis= assert_array_equal b fmt dt _run_axis_tests dtype data = np array astype dtype msg = Unique d array axis= failed result = np array assert_array_equal unique data result astype dtype msg msg = Unique d array axis= failed result = np array assert_array_equal unique data axis= result astype dtype msg msg = Unique d array axis= failed result = np array assert_array_equal unique data axis= result astype dtype msg e g x = np array np unique x axis= torch unique torch as_tensor x dim= msg = Unique d array axis= failed data d = np array astype dtype result = np take data d axis= assert_array_equal unique data d axis= result msg uniq idx inv cnt = unique data axis= return_index=True return_inverse=True return_counts=True msg = Unique s return_index=True failed axis= assert_array_equal data idx uniq msg msg = Unique s return_inverse=True failed axis= assert_array_equal uniq inv data msg = Unique s return_counts=True failed axis= assert_array_equal cnt np array msg uniq idx inv cnt = unique data axis= return_index=True return_inverse=True return_counts=True msg = Unique s return_index=True failed axis= assert_array_equal data idx uniq msg = Unique s return_inverse=True failed axis= assert_array_equal uniq inv data msg = Unique s return_counts=True failed axis= assert_array_equal cnt np array msg skipIf True reason= NP_VER fails CI older NumPy xpassIfTorchDynamo_np reason= unique return_index nans test_unique_nanequals issue = np array np nan np nan np nan unq = np unique not_unq = np unique equal_nan=False assert_array_equal unq np array np nan assert_array_equal not_unq np array np nan np nan np nan __name__ == __main__ run_tests