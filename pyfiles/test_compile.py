Owner s module inductor os shlex subprocess sys unittest mock torch torch _dynamo dynamo _inductor inductor torch _inductor codecache write torch _inductor cpp_builder CppBuilder CppOptions torch _inductor test_case run_tests TestCase torch _inductor utils gen_gm_and_inputs torch fx symbolic_trace torch fx experimental proxy_tensor make_fx torch testing _internal inductor_utils HAS_CPU _IS_MACOS = sys platform startswith darwin _IS_WINDOWS = sys platform == win safe_command_output cmd timeout= try subprocess check_output cmd stderr=subprocess STDOUT text=True timeout=timeout shell=isinstance cmd str strip except subprocess CalledProcessError e f run failed（ error code e returncode ） e output strip except subprocess TimeoutExpired runt timeout MyModule torch nn Module __init__ - None super __init__ = torch nn Linear b = torch nn Linear relu = torch nn ReLU forward x x = relu x x = torch sigmoid b x x MyModule MyModule forward x takes dict list b = x key result super forward + b MyModule MyModule forward x super forward x TestStandaloneInductor TestCase These test check you can call TorchInductor directly without going through TorchDynamo test_inductor_via_fx mod = MyModule eval inp = torch randn correct = mod inp mod_opt = inductor compile symbolic_trace mod inp actual = mod_opt inp assertEqual actual correct test_inductor_via_fx_tensor_return mod = MyModule eval inp = torch randn correct = mod inp mod_opt = inductor compile symbolic_trace mod inp actual = mod_opt inp assertEqual actual correct test_inductor_via_fx_dict_input mod = MyModule eval inp = key torch randn torch randn correct = mod inp mod_opt = inductor compile symbolic_trace mod inp actual = mod_opt inp assertEqual actual correct test_inductor_via_make_fx mod = MyModule eval inp = torch randn correct = mod inp mod_opt = inductor compile make_fx mod inp inp actual = mod_opt inp assertEqual actual correct test_inductor_via_bare_module mod = MyModule eval inp = torch randn correct = mod inp no FX graph all mod must list tuple case mod_opt = inductor compile mod inp actual = mod_opt inp assertEqual actual correct test_inductor_via_export mod = MyModule eval inp = torch randn correct = mod inp gm _ = dynamo export mod inp aten_graph=True mod_opt = inductor compile gm inp actual = mod_opt inp assertEqual actual correct test_inductor_via_export mod = MyModule eval inp = key torch randn torch randn correct = mod inp gm _ = dynamo export mod inp mod_opt = inductor compile gm inp actual = mod_opt inp assertEqual actual correct test_inductor_via_op_with_multiple_outputs x = torch randn x = x = torch randn x = torch randn x = e- mod inp = gen_gm_and_inputs torch ops aten native_layer_norm default x x x x x mod_opt = inductor compile mod inp assertEqual mod inp mod_opt inp mock patch dict os environ TORCHINDUCTOR_DEBUG_SYMBOL test_inductor_generate_debug_symbol cpp_code = int main _ source_path = write cpp_code cpp build_option = CppOptions cpp_builder = CppBuilder name= test_symbol sources=source_path output_dir=os path dirname source_path BuildOption=build_option cpp_builder build binary_path = cpp_builder get_target_file_path When we turn generate debug symbol On Windows should create module_name pdb file It helps debug WinDBG On Linux should create some debug sections binary file check_linux_debug_section module_path str check_cmd = shlex split f readelf -S module_path output = safe_command_output check_cmd has_debug_sym = debug_info output assertEqual has_debug_sym True check_windows_pdb_exist module_path str file_name_no_ext = os path splitext module_path file_name_pdb = f file_name_no_ext pdb has_pdb_file = os path exists file_name_pdb assertEqual has_pdb_file True _IS_WINDOWS check_windows_pdb_exist binary_path _IS_MACOS pass MacOS sure should works check_linux_debug_section binary_path __name__ == __main__ HAS_CPU run_tests