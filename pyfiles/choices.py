__future__ annotations copy logging functools lru_cache typing Any Optional TYPE_CHECKING Union torch torch _inductor config torch _inductor choices InductorChoices torch _inductor kernel_template_choice KernelTemplateChoice torch _inductor template_heuristics params DictKernelTemplateParams log = logging getLogger __name__ TYPE_CHECKING collections abc Generator torch _inductor codegen common KernelTemplate torch _inductor kernel_inputs KernelInputs torch _inductor select_algorithm ExternKernelChoice LookupTableChoices InductorChoices InductorChoices subclass uses lookup table when available otherwise falls back parent All lookup functionality contained within can customized overriding methods _get_lookup_table - dict str list dict str Any Get template lookup table config Override method use custom lookup table sources database API etc torch cuda is_available config lookup_table table None config lookup_table table staticmethod lru_cache _get_device_key device torch device - Optional str Generate device key lookup table indexing For CPU devices returns None For CUDA devices returns props gcnArchName string device type = cuda only cuda devices supported indicates system use device None Get CUDA device properties props = torch cuda get_device_properties device index props gcnArchName staticmethod _generate_kernel_inputs_key kernel_inputs KernelInputs - str Generate key based input node properties scalars The key includes dtype size stride information each input node plus scalar values key=value pairs separated signs Get node information using existing methods dtypes = kernel_inputs dtypes shapes = kernel_inputs shapes_hinted strides = kernel_inputs strides_hinted Create tuple dtype shape_list stride_list each node node_info = tuple dtype list shape list stride dtype shape stride zip dtypes shapes strides Create base key node information fmt_key = str node_info Add scalar information present kernel_inputs _scalars Sort scalars consistent key generation join scalar_parts = f key = value key value sorted kernel_inputs _scalars items scalars_key = join scalar_parts fmt_key = f fmt_key + scalars_key f fmt_key make_lookup_key kernel_inputs KernelInputs op_name str include_device bool = False - Optional str Create flattened lookup key kernel inputs operation name Override method customize key generation Args kernel_inputs KernelInputs object containing input nodes scalars op_name Operation name e g mm addmm include_device Whether include device key generated key Returns A string key combining device optional operation input information device = kernel_inputs device dev_key = _get_device_key device dev_key None The system does run when dev_key None regardless whether include_device True False None include_device dev_key = None Generate input key using our staticmethod input_key = _generate_kernel_inputs_key kernel_inputs Create flattened lookup key dev_key None key_parts = dev_key input_key op_name key_parts = input_key op_name + join key_parts make_lookup_key_variants kernel_inputs KernelInputs op_name str - tuple Optional str Optional str Generate both device-specific device-agnostic lookup keys Override method customize key variant generation Args kernel_inputs KernelInputs object containing input nodes scalars op_name Operation name e g mm addmm Returns Tuple device_key device_agnostic_key Either may None generation fails device_key = make_lookup_key kernel_inputs op_name include_device=True device_agnostic_key = make_lookup_key kernel_inputs op_name include_device=False device_key device_agnostic_key staticmethod _entry_is_valid cfg dict str Any template_id str template_hash_map Optional dict str Optional str - bool Check config entry valid based template hash validation Args cfg Configuration dictionary may contain template_hash field template_id The template identifier template_hash_map Optional mapping template_uid src_hash validation Returns True config valid should kept False should filtered out If hash checking disabled no hash map provided keep config config lookup_table check_src_hash template_hash_map True template_hash = template_hash_map get template_id config_hash = cfg get template_hash Both hashes present - validate they match template_hash None config_hash None config_hash = template_hash log warning Hash validation failed template s config_hash= s = template_hash= s Template code may have changed Filtering out config s template_id config_hash template_hash k v k v cfg items k = template_hash False log debug Hash validation passed template s hash= s template_id template_hash True Config has no hash - keep config_hash None log debug Config template s has no hash - keeping template_hash= s template_id template_hash True Template has no hash - keep config log debug Template s has no src_hash - keeping config hash s template_id config_hash True lookup_template_configs kernel_inputs KernelInputs op_name str template_uids list str template_hash_map Optional dict str Optional str = None - dict str list dict str Any Unified function look up template configurations multiple templates Override method customize lookup logic Args kernel_inputs KernelInputs object containing input nodes scalars op_name Operation name e g mm addmm template_uids List template identifiers e g mm tma decompose_k template_hash_map Optional mapping template_uid src_hash validation Returns No lookup table use no matches found any template template_uid config config Matches found filtered configurations lookup_table = _get_lookup_table lookup_table log debug Lookup table no table configured CUDA unavailable Try both key variants device-specific first then device-agnostic If both exist device-specific takes priority device_key device_agnostic_key = make_lookup_key_variants kernel_inputs op_name config_list = key_type key device-specific device_key device-agnostic device_agnostic_key key None config_list = lookup_table get key config_list log debug Lookup table found d configs using s key s s len config_list key_type key op_name break log debug Lookup table no match s tried keys s s table has d keys op_name device_key device_agnostic_key len lookup_table log debug Lookup table found d configs s templates s len config_list op_name template_uids Group configs template_id configs_by_template dict str list dict str Any = cfg config_list isinstance cfg dict raise ValueError f Config op_name operation dictionary cfg template_id cfg raise ValueError f Config op_name operation missing required template_id field cfg template_id = cfg template_id template_id template_uids template_id configs_by_template configs_by_template template_id = configs_by_template template_id append cfg Check template hashes clean up template_id field result = template_id matching_configs configs_by_template items filtered_configs = cfg matching_configs Check template hash using helper function _entry_is_valid cfg template_id template_hash_map continue Return copy config we don t want modify original cconfig = copy deepcopy cfg Lastly we have throw out template_id s valid kwarg just used identify which template entry belongs del cconfig template_id Similarly template_hash valid kwarg cconfig pop template_hash None filtered_configs append cconfig filtered_configs result template_id = filtered_configs result _finalize_template_configs template_choices dict str Generator KernelTemplateChoice None None kernel_inputs KernelInputs templates list Union KernelTemplate ExternKernelChoice op_name str kwarg_overrides Optional dict str dict str Any = None - list KernelTemplateChoice Check lookup table hits use those found otherwise fall back parent Collect template src_hashes validation template_uids = template uid template templates template_hash_map = template templates src_hash = getattr template src_hash None template_hash_map template uid = src_hash log debug Choices attempting lookup s d templates op_name len template_uids Single batch lookup all templates lookup_results = lookup_template_configs kernel_inputs op_name template_uids template_hash_map Early exit no lookup table no matches lookup_results Empty dict log info LookupChoices lookup miss s using fallback op_name _fallback template_choices kernel_inputs templates op_name kwarg_overrides log info LookupChoices lookup hit s - found d d templates s op_name len lookup_results len template_uids list lookup_results keys Create KTCs only templates lookup entries _create_lookup_choices lookup_results templates kernel_inputs op_name _fallback template_choices dict str Generator KernelTemplateChoice None None kernel_inputs KernelInputs templates list Union KernelTemplate ExternKernelChoice op_name str kwarg_overrides Optional dict str dict str Any = None - list KernelTemplateChoice Fallback parent no lookup table no matches NOTE broken out so subclasses able override handle explicitly situations where lookup take had miss vs overriding entire logic super _finalize_template_configs template_choices kernel_inputs templates op_name kwarg_overrides _create_lookup_choices lookup_results dict str list dict str Any templates list Union KernelTemplate ExternKernelChoice kernel_inputs KernelInputs op_name str - list KernelTemplateChoice Create KernelTemplateChoice objects lookup results using parent s get_ktc method templates_by_uid = template uid template template templates lookup_choices list KernelTemplateChoice = template_uid configs lookup_results items template = templates_by_uid template_uid Use parent s get_ktc method get generator then get first base KTC ktc_generator = get_ktc kernel_inputs template op_name try base_ktc = next ktc_generator except StopIteration No configs heuristic skip template continue For each lookup config create KTC override kwargs c configs lookup_ktc = KernelTemplateChoice template=base_ktc template use ones lookup table params=DictKernelTemplateParams c extra_kwargs=base_ktc extra_kwargs layout=base_ktc layout inputs=base_ktc inputs lookup_choices append lookup_ktc lookup_choices