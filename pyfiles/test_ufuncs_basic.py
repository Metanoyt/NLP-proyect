Owner s module dynamo Poking around ufunc casting broadcasting dtype out behavior The goal validate numpy tests should work when replacing numpy no torch _numpy np operator unittest skipIf skip SkipTest pytest raises assert_raises torch testing _internal common_utils instantiate_parametrized_tests parametrize run_tests TEST_WITH_TORCHDYNAMO TestCase TEST_WITH_TORCHDYNAMO numpy np numpy testing assert_equal torch _numpy np torch _numpy testing assert_equal parametrize_unary_ufuncs = parametrize ufunc np sin parametrize_casting = parametrize casting no equiv safe same_kind unsafe instantiate_parametrized_tests TestUnaryUfuncs TestCase get_x ufunc np arange dtype= float parametrize_unary_ufuncs test_scalar ufunc check ufunc accepts scalar result convertible scalar x = get_x ufunc float ufunc x skip True reason= XXX unary ufuncs ignore dtype= parameter parametrize_unary_ufuncs test_x_and_dtype ufunc x = get_x ufunc res = ufunc x dtype= float assert res dtype == np dtype float skip True reason= XXX unary ufuncs ignore dtype= parameter parametrize_casting parametrize_unary_ufuncs parametrize dtype float complex float test_x_and_dtype_casting ufunc casting dtype x = get_x ufunc np can_cast x dtype casting=casting assert_raises TypeError ufunc x dtype=dtype casting=casting assert ufunc x dtype=dtype casting=casting dtype == dtype parametrize_casting parametrize_unary_ufuncs parametrize out_dtype float complex float test_x_and_out_casting ufunc casting out_dtype x = get_x ufunc out = np empty_like x dtype=out_dtype np can_cast x out_dtype casting=casting assert_raises TypeError ufunc x out=out casting=casting result = ufunc x out=out casting=casting assert result dtype == out_dtype assert result out parametrize_unary_ufuncs test_x_and_out_broadcast ufunc x = get_x ufunc out = np empty x shape x shape x_b = np broadcast_to x out shape res_out = ufunc x out=out res_bcast = ufunc x_b TODO switching order causes graph break failing test See test dynamo test_misc py -k test_numpy_graph_break assert res_out out assert_equal res_out res_bcast out = np empty x shape x_b = np broadcast_to x out shape res_out = ufunc x out=out res_bcast = ufunc x_b assert res_out out assert_equal res_out res_bcast ufunc_op_iop_numeric = np add operator __add__ operator __iadd__ np subtract operator __sub__ operator __isub__ np multiply operator __mul__ operator __imul__ ufuncs_with_dunders = ufunc ufunc _ _ ufunc_op_iop_numeric numeric_binary_ufuncs = np float_power np power these implemented complex inputs no_complex = np floor_divide np hypot np arctan np copysign np fmax np fmin np fmod np heaviside np logaddexp np logaddexp np maximum np minimum parametrize_binary_ufuncs = parametrize ufunc ufuncs_with_dunders + numeric_binary_ufuncs + no_complex TODO these snowflakes need special handling bitwise_and bitwise_or bitwise_xor equal lcm ldexp left_shift less less_equal gcd greater greater_equal logical_and logical_or logical_xor matmul not_equal instantiate_parametrized_tests TestBinaryUfuncs TestCase get_xy ufunc np arange dtype= float np arange dtype= float parametrize_binary_ufuncs test_scalar ufunc check ufunc accepts scalar result convertible scalar xy = get_xy ufunc x y = xy xy float ufunc x y parametrize_binary_ufuncs test_vector_vs_scalar ufunc x y = get_xy ufunc assert_equal ufunc x y ufunc b b zip x y parametrize_casting parametrize_binary_ufuncs parametrize out_dtype float complex float test_xy_and_out_casting ufunc casting out_dtype x y = get_xy ufunc out = np empty_like x dtype=out_dtype ufunc no_complex np issubdtype out_dtype np complexfloating raise SkipTest f ufunc does accept complex can_cast_x = np can_cast x out_dtype casting=casting can_cast_y = np can_cast y out_dtype casting=casting can_cast_x can_cast_y assert_raises TypeError ufunc x out=out casting=casting result = ufunc x y out=out casting=casting assert result dtype == out_dtype assert result out parametrize_binary_ufuncs test_xy_and_out_broadcast ufunc x y = get_xy ufunc y = y None out = np empty y shape x shape x_b = np broadcast_to x out shape y_b = np broadcast_to y out shape res_out = ufunc x y out=out res_bcast = ufunc x_b y_b TODO switching order causes graph break failing test See test dynamo test_misc py -k test_numpy_graph_break assert res_out out assert_equal res_out res_bcast dtypes_numeric = np int np float np float np complex instantiate_parametrized_tests TestNdarrayDunderVsUfunc TestCase Test ndarray dunders which delegate ufuncs vs ufuncs parametrize ufunc op iop ufunc_op_iop_numeric test_basic ufunc op iop basic op rop iop no dtypes no broadcasting __add__ = np array assert_equal op ufunc assert_equal op tolist ufunc tolist assert_equal op ufunc __radd__ = np array assert_equal op ufunc assert_equal op tolist ufunc tolist __iadd__ = np array = copy iop modifies in-place assert_equal op = np array = copy iop assert_equal op parametrize ufunc op iop ufunc_op_iop_numeric parametrize other_dtype dtypes_numeric test_other_scalar ufunc op iop other_dtype Test op iop rop when other argument scalar different dtype = np array b = other_dtype ufunc no_complex issubclass other_dtype np complexfloating raise SkipTest f ufunc does accept complex __op__ result = op b assert_equal result ufunc b result dtype = np result_type b assert result dtype == np result_type b __rop__ result = op b assert_equal result ufunc b result dtype = np result_type b assert result dtype == np result_type b __iop__ casts result dtype raises cannot can_cast = np can_cast np result_type dtype other_dtype dtype casting= same_kind can_cast = copy result = iop b assert_equal result ufunc b result dtype = np result_type b assert result dtype == np result_type b assert_raises TypeError RuntimeError XXX np UFuncTypeError iop b parametrize ufunc op iop ufunc_op_iop_numeric parametrize other_dtype dtypes_numeric test_other_array ufunc op iop other_dtype Test op iop rop when other argument array different dtype = np array b = np array dtype=other_dtype ufunc no_complex issubclass other_dtype np complexfloating raise SkipTest f ufunc does accept complex __op__ result = op b assert_equal result ufunc b result dtype = np result_type b assert result dtype == np result_type b __rop__ other array result = op b assert_equal result ufunc b result dtype = np result_type b assert result dtype == np result_type b __iop__ can_cast = np can_cast np result_type dtype other_dtype dtype casting= same_kind can_cast = copy result = iop b assert_equal result ufunc b result dtype = np result_type b assert result dtype == np result_type b assert_raises TypeError RuntimeError XXX np UFuncTypeError iop b parametrize ufunc op iop ufunc_op_iop_numeric test_other_array_bcast ufunc op iop Test op rop iop broadcasting __op__ = np array result_op = op None result_ufunc = ufunc None assert result_op shape == result_ufunc shape assert_equal result_op result_ufunc result_op dtype = result_ufunc dtype assert result_op dtype == result_ufunc dtype __rop__ = np array result_op = op None result_ufunc = ufunc None assert result_op shape == result_ufunc shape assert_equal result_op result_ufunc result_op dtype = result_ufunc dtype assert result_op dtype == result_ufunc dtype __iop__ in-place ops ` += other ` etc do broadcast b = None copy assert_raises ValueError RuntimeError XXX ValueError numpy iop b however ` += other ` broadcasts other aa = np broadcast_to copy aa = aa copy result = iop aa result_ufunc = ufunc aa assert result shape == result_ufunc shape assert_equal result result_ufunc result_op dtype = result_ufunc dtype assert result_op dtype == result_ufunc dtype TestUfuncDtypeKwd TestCase test_binary_ufunc_dtype default computation uses float r = np add e- assert r dtype == float assert r - force float dtype loss precision r = np add e- dtype= float assert r dtype == float assert r == now force cast rb = np add e- dtype=bool casting= unsafe assert rb dtype == bool test_binary_ufunc_dtype_and_out all float no precision loss out = np empty dtype=np float r = np add e- out=out assert r = all assert r dtype == np float all float loss precision result float out = np empty dtype=np float r = np add e- dtype=np float out=out assert r == all assert r dtype == np float dtype float so computation float precision loss result then cast float out = np empty dtype=np float r = np add e- dtype=np float out=out assert r == all assert r dtype == np float Internal computations float final cast out dtype truncates precision = precision loss out = np empty dtype=np float r = np add e- dtype=np float out=out assert r == all assert r dtype == np float __name__ == __main__ run_tests