======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_userdict py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests __TestCase = CPythonTestCase redirect statements sys importlib abc redirect_imports = test mapping_tests test typinganndata test test_grammar test test_math test test_iter test typinganndata ann_module RedirectImportFinder importlib abc MetaPathFinder find_spec fullname path target=None Check problematic one fullname redirect_imports try Attempt standalone module name = fullname removeprefix test r = importlib import_module name Redirect module sys modules sys modules fullname = r Return module spec found module importlib util find_spec name except ImportError None None Add custom finder sys meta_path sys meta_path insert RedirectImportFinder ======= END DYNAMO PATCH ======= Check every path through every method UserDict test mapping_tests support unittest collections d = d = one d = one two d = one two three d = one None two None d = one two UserDictTest mapping_tests TestHashMappingProtocol type test = collections UserDict test_all Test constructors u = collections UserDict u = collections UserDict d u = collections UserDict d u = collections UserDict d uu = collections UserDict u uu = collections UserDict u uu = collections UserDict u uu = collections UserDict u keyword arg constructor assertEqual collections UserDict one= two= d item sequence constructor assertEqual collections UserDict one two d assertEqual collections UserDict dict= one two dict one two both together assertEqual collections UserDict one two two= three= d alternate constructor assertEqual collections UserDict fromkeys one two split d assertEqual collections UserDict fromkeys one two split d assertEqual collections UserDict fromkeys one two split d assertEqual collections UserDict fromkeys one two split d assertTrue u fromkeys one two split u assertIsInstance u fromkeys one two split collections UserDict assertIsInstance u fromkeys one two split collections UserDict Test __repr__ assertEqual str u str d assertEqual repr u repr d assertIn repr u one two two one Test rich comparison __len__ all = d d d u u u u uu uu uu uu all b all assertEqual == b len == len b Test __getitem__ assertEqual u one assertRaises KeyError u __getitem__ two Test __setitem__ u = collections UserDict u u two = u three = Test __delitem__ del u three assertRaises KeyError u __delitem__ three Test clear u clear assertEqual u Test copy u = u copy assertEqual u u u b = collections UserDict x= y= u c = u b copy making copy UserDict special cased assertEqual u b u c MyUserDict collections UserDict display print m = MyUserDict u m = m copy assertEqual m m SF bug -- copy UserDict subclass shared data m foo = bar assertNotEqual m m Test keys items values assertEqual sorted u keys sorted d keys assertEqual sorted u items sorted d items assertEqual sorted u values sorted d values Test i u keys assertIn i u assertEqual i u i d assertEqual i u i d Test update t = collections UserDict t update u assertEqual t u Test get i u keys assertEqual u get i u i assertEqual u get i d get i assertEqual u get i d get i Test iteration i range u i = str i ikeys = k u ikeys append k keys = u keys assertEqual set ikeys set keys Test setdefault t = collections UserDict assertEqual t setdefault x assertIn x t assertEqual t setdefault x Test pop t = collections UserDict x= assertEqual t pop x assertRaises KeyError t pop x assertEqual t pop x t x = assertEqual t pop x Test popitem t = collections UserDict x= assertEqual t popitem x assertRaises KeyError t popitem test_init kw other iterable assertEqual list collections UserDict kw items kw assertEqual list collections UserDict dict= items dict assertEqual list collections UserDict dict=None items dict None assertEqual list collections UserDict dict= items dict assertRaises TypeError collections UserDict assertRaises TypeError collections UserDict assertRaises TypeError collections UserDict __init__ test_update kw dict other iterable d = collections UserDict d update kw assertEqual list d items kw assertRaises TypeError collections UserDict update assertRaises TypeError collections UserDict update assertRaises TypeError collections UserDict update test_missing Make sure UserDict doesn t have __missing__ method assertEqual hasattr collections UserDict __missing__ False Test several cases D subclass defines __missing__ method returning value E subclass defines __missing__ method raising RuntimeError F subclass sets __missing__ instance variable no effect G subclass doesn t define __missing__ all D collections UserDict __missing__ key d = D assertEqual d assertEqual d assertNotIn d assertNotIn d keys assertEqual d E collections UserDict __missing__ key raise RuntimeError key e = E try e except RuntimeError err assertEqual err args fail e didn t raise RuntimeError F collections UserDict __init__ An instance variable __missing__ should have no effect __missing__ = lambda key None collections UserDict __init__ f = F try f except KeyError err assertEqual err args fail f didn t raise KeyError G collections UserDict pass g = G try g except KeyError err assertEqual err args fail g didn t raise KeyError Decorate existing test recursion limit because test C structure ` UserDict ` Python structure test_repr_deep = support infinite_recursion mapping_tests TestHashMappingProtocol test_repr_deep __name__ == __main__ run_tests