Owner s module dynamo unittest mock patch torch torch _dynamo test_case torch _dynamo testing torch _dynamo testing unsupported torch _dynamo utils ifdynstaticdefault globalmod = torch nn ReLU indirectly_unsupported b c = + b unsupported c SubGraphTests torch _dynamo test_case TestCase _common fn frame_count op_count torch _dynamo reset v = torch ones v = torch ones - correct = fn v v correct = fn v v cnt = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt r = opt_fn v v r = opt_fn v v assertTrue torch _dynamo testing same r correct assertTrue torch _dynamo testing same r correct assertEqual cnt frame_count frame_count f actual cnt frame_count = expected frame_count assertEqual cnt op_count op_count test_control_flow fn b c = - b c = b - c sum c sum c c _common fn test_control_flow fn b sum b sum _common fn test_control_flow fn b c = - b c = b - m = globalmod c sum c sum m c m c _common fn test_control_flow fn b tmp = sum b sum sum tmp _common fn test_control_flow fn b tmp = sum b sum sum tmp = sum b sum b sum tmp tmp tmp tmp tmp tmp _common fn test_capi_call fn b c = - b c = b - unsupported c c _common fn test_capi_call fn b c = - b c = b - - b - unsupported c c _common fn test_capi_call fn b c = - b c = b - torch _dynamo testing unsupported c c _common fn test_indirect_unsupported fn b c = - b c = b - indirectly_unsupported c c _common fn test_indirect_unsupported fn b local_const = local_const = c = - b c = b - local_const local_const - indirectly_unsupported c c _common fn test_indirect_unsupported fn b args = - b b - indirectly_unsupported args _common fn test_stack_state fn b t = t = c = - b c = b - t t - unsupported c c _common fn test_stack_state fn b t = t = c = - b c = b - t t - indirectly_unsupported c c _common fn test_multigraph fn b x = + b x = x x sum x - x _common fn test_extended_args too_many_adds = + join b source = f lambda b too_many_adds +a sum too_many_adds - b _common eval source test_resume fn b x = + b x = x x = x + x = unsupported x x = x + x = x + x = x + x _common fn test_resume fn b x = + b x = x x = x + x = indirectly_unsupported x x = x + x = x + x = x + x _common fn test_resume fn b x = + b x = x x = x + x = indirectly_unsupported x b=a x = x + x = x + x = x + x _common fn test_resume fn b x = + b x = x x = x + x = indirectly_unsupported a=x b=a x = x + x = x + x = x + x _common fn test_resume fn b x = + b x = x x = x + print x x = x + x = x + x = x + x _common fn test_start fn b print x = + b x = x + x = x + x _common fn test_start fn b x = indirectly_unsupported b x = x + x = x + x = x + x _common fn test_start fn b x = unsupported b x = x + x = x + x = x + x _common fn test_start fn b check check + b + + b - v = torch randn v = torch randn f = torch zeros dtype=torch int t = torch ones dtype=torch int correct = fn v v t correct = fn v v f cnt = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt r = opt_fn v v t r = opt_fn v v f assertTrue torch _dynamo testing same r correct assertTrue torch _dynamo testing same r correct assertEqual cnt frame_count assertEqual cnt op_count test_resume_freevars c = torch randn c = torch randn fn b x = + b + c - c x = unsupported x x x + c - c _common fn test_restore_state fn b len_ = len x = + b x = torch add unsupported x x x + len_ b _common fn test_restore_range fn b x = + b rng = range x = unsupported x x i rng x = x + i x We don t specialize range dynamic shapes which means we fail unroll loop TODO Consider forcing specialization when we iterate over loop _common fn ifdynstaticdefault ifdynstaticdefault test_restore_range_iter fn b x = + b rng = iter range x = unsupported x x x += next rng x list rng _common fn test_pop_after_resume fn b tmp = + b + + b x = x = unsupported x x _ range x += tmp pop - x _common fn patch torch _dynamo config assume_static_by_default False test_dynamic_getitem fn b b size - cnt = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt i range opt_fn torch randn i torch randn i just one graph assertEqual cnt frame_count test_dynamic_kwarg fn b - b torch _dynamo reset cnt_dynamic = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt_dynamic dynamic=True start = end = i range start end opt_fn torch randn i torch randn i assertEqual cnt_dynamic frame_count test_dynamic_duck_size fn b size == b size + b sum + b sum torch _dynamo reset cnt_dynamic = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt_dynamic dynamic=True x = torch randn y = torch randn assertEqual opt_fn x x fn x x assertEqual opt_fn x y fn x y assertEqual cnt_dynamic frame_count test_dynamic_order_dependence fn b sum + b sum torch _dynamo reset cnt_dynamic = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt_dynamic x = torch randn y = torch randn assertEqual opt_fn x y fn x y assertEqual opt_fn x x fn x x NB This COULD validly we don t test disjointedness guards when x y didn t duck size together so we end up generic graph also works when x y happen duck size together assertEqual cnt_dynamic frame_count torch _dynamo reset cnt_dynamic frame_count = assertEqual opt_fn x x fn x x overspecializes assertEqual opt_fn x y fn x y assertEqual cnt_dynamic frame_count test_dynamic_zero_inference fn size = + torch _dynamo reset cnt_dynamic = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt_dynamic dynamic=True x = torch randn y = torch randn assertEqual opt_fn y fn y assertEqual opt_fn x fn x assertEqual cnt_dynamic frame_count patch object torch _dynamo config capture_scalar_outputs True test_no_graph_break_on_item fn b x = + b - x = x sum x item x = x + b x _common fn item gets DCE d patch object torch _dynamo config capture_scalar_outputs False test_graph_break_on_item fn b x = + b - x = x sum x item x = x + b x _common fn test_resume_paths_join fn x c c c x = x + c x = x + x = x + c x = x + x = x + c x = x + x + v = torch randn t = torch Tensor True f = torch Tensor False cnt = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt t f b t f c t f opt_fn v b c checking here we don t create ^n graphs assertEqual cnt frame_count assertEqual cnt op_count test_resume_with_no_grad fn b x = + b torch no_grad x = x + x sum tolist graph break x = x + x = x + x _common fn torch _dynamo reset torch no_grad _common fn test_resume_with_no_grad fn b x = + b torch no_grad x = x + x sum tolist graph break x = x + x sum tolist graph break x = x + x = x + x _common fn test_resume_with_no_grad fn b x = + b torch no_grad torch no_grad x = x + torch enable_grad x sum tolist graph break x = x + x = x + x = x + x _common fn test_resume_tuple_iterator fn b x = + b = iter tuple range x = x + next x = x + next x = x + next x = unsupported x x x = x + next x = x + next x = x + next x = x + next x _common fn test_tuple_iterator_return fn x = iter tuple range x = x + next x = x + next x = unsupported x x x = x + next x = x + next x = unsupported x x x = x + next x = x + next x v = torch randn v = fn v cnt = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt v = opt_fn v v _ = opt_fn v assertEqual v tolist v tolist assertEqual v tolist v tolist assertEqual list list assertEqual cnt frame_count assertEqual cnt op_count test_tuple_iterator_mutate fn x x = x + next x = x + next x = x + next x = x + next x v = torch randn = iter tuple range cnt = torch _dynamo testing CompileCounter opt_fn = torch compile fn backend=cnt assertEqual opt_fn v tolist v + + + tolist assertEqual list test_enumerate_not_break_graph fn b _ x enumerate shape b = b + x i x enumerate b shape b = b + x i b _common fn ifdynstaticdefault __name__ == __main__ torch _dynamo test_case run_tests run_tests