======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_cmath py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests __TestCase = CPythonTestCase redirect statements sys importlib abc redirect_imports = test mapping_tests test typinganndata test test_grammar test test_math test test_iter test typinganndata ann_module RedirectImportFinder importlib abc MetaPathFinder find_spec fullname path target=None Check problematic one fullname redirect_imports try Attempt standalone module name = fullname removeprefix test r = importlib import_module name Redirect module sys modules sys modules fullname = r Return module spec found module importlib util find_spec name except ImportError None None Add custom finder sys meta_path sys meta_path insert RedirectImportFinder ======= END DYNAMO PATCH ======= test support requires_IEEE_ cpython_only import_helper test test_math parse_testfile test_file test test_math test_math unittest cmath math cmath phase polar rect pi platform sys INF = float inf NAN = float nan complex_zeros = complex x y x - y - complex_infinities = complex x y x y INF st quadrant INF INF INF INF INF - INF nd quadrant - INF -INF INF -INF -INF -INF - rd quadrant -INF - -INF -INF - -INF - -INF -INF th quadrant -INF INF -INF INF - INF - complex_nans = complex x y x y NAN -INF NAN - NAN - NAN NAN NAN INF -INF NAN - NAN - NAN NAN NAN INF NAN CMathTests __TestCase list all functions cmath test_functions = getattr cmath fname fname acos acosh asin asinh atan atanh cos cosh exp log log sin sinh sqrt tan tanh test first second arguments independently -argument log test_functions append lambda x cmath log x + j test_functions append lambda x cmath log - j x setUp test_values = open test_file encoding= utf- tearDown test_values close assertFloatIdentical x y Fail unless floats x y identical sense both x y nans both x y infinities same sign both x y zeros same sign x y both finite nonzero x == y msg = floats r r identical math isnan x math isnan y math isnan x math isnan y x == y x = both zero check signs match math copysign x == math copysign y msg += zeros have different signs fail msg format x y assertComplexesAreIdentical x y Fail unless complex numbers x y have equal values signs In particular x y both have real imaginary part zero zeros have different signs test will fail assertFloatIdentical x real y real assertFloatIdentical x imag y imag rAssertAlmostEqual b rel_err = e- abs_err = e- msg=None Fail two floating-point numbers almost equal Determine whether floating-point values b equal within small rounding error The default values rel_err abs_err chosen suitable platforms where float represented IEEE double They allow error between ulps special values testing math isnan math isnan b fail msg r should nan format b math isinf == b fail msg finite result where infinity expected expected r got r format b both b zero check whether they have same sign theory there examples where would legitimate b have opposite signs practice these hardly ever occur b math copysign = math copysign b fail msg zero has wrong sign expected r got r format b a-b overflows b infinite False Again theory there examples where within few ulps max representable float then b could legitimately infinite In practice these examples rare try absolute_error = abs b-a except OverflowError pass test passes either absolute error relative error sufficiently small The defaults amount error between ulps ulps IEEE- compliant machine absolute_error = max abs_err rel_err abs fail msg r r sufficiently close format b test_constants e_expected = pi_expected = assertAlmostEqual cmath pi pi_expected places= msg= cmath pi should format cmath pi pi_expected assertAlmostEqual cmath e e_expected places= msg= cmath e should format cmath e e_expected test_infinity_and_nan_constants assertEqual cmath inf real math inf assertEqual cmath inf imag assertEqual cmath infj real assertEqual cmath infj imag math inf assertTrue math isnan cmath nan real assertEqual cmath nan imag assertEqual cmath nanj real assertTrue math isnan cmath nanj imag Also check sign all these positive assertEqual math copysign cmath nan real assertEqual math copysign cmath nan imag assertEqual math copysign cmath nanj real assertEqual math copysign cmath nanj imag Check consistency reprs assertEqual repr cmath inf inf assertEqual repr cmath infj infj assertEqual repr cmath nan nan assertEqual repr cmath nanj nanj test_user_object Test automatic calling __complex__ __float__ cmath functions some random values use test values we avoid values which any functions cmath undefined i e - j - j would cause overflow cx_arg = + j flt_arg = - variety non-complex numbers used check non-complex values __complex__ give error non_complexes = complex None object NotImplemented Now we introduce variety classes whose instances might end up being passed cmath functions usual case new-style implementing __complex__ torch _dynamo error_on_graph_break False MyComplex __init__ value value = value __complex__ value classes which __complex__ raises exception SomeException Exception pass MyComplexException __complex__ raise SomeException some classes providing __float__ __complex__ NeitherComplexNorFloat object pass Index __int__ __index__ MyInt __int__ other possible combinations __float__ __complex__ should work FloatAndComplex __float__ flt_arg __complex__ cx_arg JustFloat __float__ flt_arg f test_functions usual usage assertEqual f MyComplex cx_arg f cx_arg other combinations __float__ __complex__ assertEqual f FloatAndComplex f cx_arg assertEqual f JustFloat f flt_arg assertEqual f Index f int Index TypeError should raised classes providing either __complex__ __float__ even they provide __int__ __index__ assertRaises TypeError f NeitherComplexNorFloat assertRaises TypeError f MyInt non-complex value __complex__ - TypeError bad_complex non_complexes assertRaises TypeError f MyComplex bad_complex exceptions __complex__ should propagated correctly assertRaises SomeException f MyComplexException test_input_type ints should acceptable inputs all cmath functions virtue providing __float__ method f test_functions arg assertEqual f arg f arg __float__ strings should give TypeError f test_functions arg long_string j assertRaises TypeError f arg test_cmath_matches_math check corresponding cmath math functions equal floats appropriate range test_values test_values = test_values functions defined - unit_interval = test_values + -x x test_values + \ - test_values log log sqrt positive = test_values + + x x test_values nonnegative = + positive test_values functions defined whole real line real_line = + positive + -x x positive test_functions = acos unit_interval asin unit_interval atan real_line cos real_line cosh real_line exp real_line log positive log positive sin real_line sinh real_line sqrt nonnegative tan real_line tanh real_line fn values test_functions items float_fn = getattr math fn complex_fn = getattr cmath fn v values z = complex_fn v rAssertAlmostEqual float_fn v z real assertEqual z imag test two-argument version log various bases base v positive z = cmath log v base rAssertAlmostEqual math log v base z real assertEqual z imag requires_IEEE_ test_specific_values Some tests need skipped ancient OS X versions See issue SKIP_ON_TIGER = tan osx_version = None sys platform == darwin version_txt = platform mac_ver try osx_version = tuple map int version_txt split except ValueError pass rect_complex z Wrapped version rect accepts complex number instead two float arguments cmath rect z real z imag polar_complex z Wrapped version polar returns complex number instead two floats complex polar z id fn ar ai er ei flags parse_testfile test_file arg = complex ar ai expected = complex er ei Skip certain tests OS X osx_version None osx_version id SKIP_ON_TIGER continue fn == rect function = rect_complex fn == polar function = polar_complex function = getattr cmath fn divide-by-zero flags invalid flags try actual = function arg except ValueError continue fail ValueError raised test complex r r format id fn ar ai overflow flags try actual = function arg except OverflowError continue fail OverflowError raised test complex r r format id fn ar ai actual = function arg ignore-real-sign flags actual = complex abs actual real actual imag expected = complex abs expected real expected imag ignore-imag-sign flags actual = complex actual real abs actual imag expected = complex expected real abs expected imag real part log function we allow absolute error up e- fn log log real_abs_err = e- real_abs_err = e- error_message = complex r r \n Expected complex r r \n Received complex r r \n Received value insufficiently close expected value format id fn ar ai expected real expected imag actual real actual imag rAssertAlmostEqual expected real actual real abs_err=real_abs_err msg=error_message rAssertAlmostEqual expected imag actual imag msg=error_message check_polar func check arg expected got = func arg e g zip expected got rAssertAlmostEqual e g check check check - pi check j pi check - j -pi inf = float inf check complex inf inf check complex -inf inf pi check complex inf inf pi check complex -inf inf -pi check complex inf inf inf pi check complex inf -inf inf -pi check complex -inf inf inf pi check complex -inf -inf inf - pi nan = float nan check complex nan nan nan check complex nan nan nan check complex nan nan nan nan check complex inf nan inf nan check complex -inf nan inf nan check complex nan inf inf nan check complex nan -inf inf nan test_polar check_polar polar cpython_only test_polar_errno Issue check previously set C errno doesn t disturb polar _testcapi = import_helper import_module _testcapi polar_with_errno_set z _testcapi set_errno try polar z finally _testcapi set_errno check_polar polar_with_errno_set test_phase assertAlmostEqual phase assertAlmostEqual phase assertAlmostEqual phase - pi assertAlmostEqual phase - + E- j pi assertAlmostEqual phase - - E- j -pi assertAlmostEqual phase j pi assertAlmostEqual phase - j -pi zeros assertEqual phase complex assertEqual phase complex - - assertEqual phase complex - pi assertEqual phase complex - - -pi infinities assertAlmostEqual phase complex -INF - -pi assertAlmostEqual phase complex -INF - -pi assertAlmostEqual phase complex -INF -INF - pi assertAlmostEqual phase complex - -INF -pi assertAlmostEqual phase complex - -INF -pi assertAlmostEqual phase complex -INF -pi assertAlmostEqual phase complex -INF -pi assertAlmostEqual phase complex INF -INF -pi assertEqual phase complex INF - - assertEqual phase complex INF - - assertEqual phase complex INF assertEqual phase complex INF assertAlmostEqual phase complex INF INF pi assertAlmostEqual phase complex INF pi assertAlmostEqual phase complex INF pi assertAlmostEqual phase complex - INF pi assertAlmostEqual phase complex - INF pi assertAlmostEqual phase complex -INF INF pi assertAlmostEqual phase complex -INF pi assertAlmostEqual phase complex -INF pi real imaginary part NaN z complex_nans assertTrue math isnan phase z test_abs zeros z complex_zeros assertEqual abs z infinities z complex_infinities assertEqual abs z INF real imaginary part NaN assertEqual abs complex NAN -INF INF assertTrue math isnan abs complex NAN - assertTrue math isnan abs complex NAN - assertTrue math isnan abs complex NAN assertTrue math isnan abs complex NAN assertEqual abs complex NAN INF INF assertEqual abs complex -INF NAN INF assertTrue math isnan abs complex - NAN assertTrue math isnan abs complex - NAN assertTrue math isnan abs complex NAN assertTrue math isnan abs complex NAN assertEqual abs complex INF NAN INF assertTrue math isnan abs complex NAN NAN requires_IEEE_ test_abs_overflows result overflows assertRaises OverflowError abs complex e e assertCEqual b eps = E- abs real - b eps abs imag - b eps fail b test_rect assertCEqual rect assertCEqual rect assertCEqual rect -pi - assertCEqual rect pi assertCEqual rect -pi - test_isfinite real_vals = float -inf - - float inf float nan x real_vals y real_vals z = complex x y assertEqual cmath isfinite z math isfinite x math isfinite y test_isnan assertFalse cmath isnan assertFalse cmath isnan j assertFalse cmath isnan INF assertTrue cmath isnan NAN assertTrue cmath isnan complex NAN assertTrue cmath isnan complex NAN assertTrue cmath isnan complex NAN NAN assertTrue cmath isnan complex NAN INF assertTrue cmath isnan complex INF NAN test_isinf assertFalse cmath isinf assertFalse cmath isinf j assertFalse cmath isinf NAN assertTrue cmath isinf INF assertTrue cmath isinf complex INF assertTrue cmath isinf complex INF assertTrue cmath isinf complex INF INF assertTrue cmath isinf complex NAN INF assertTrue cmath isinf complex INF NAN requires_IEEE_ testTanhSign z complex_zeros assertComplexesAreIdentical cmath tanh z z The algorithm used atan atanh makes use system log p function If system function doesn t respect sign zero then atan atanh will also have difficulties sign complex zeros requires_IEEE_ testAtanSign z complex_zeros assertComplexesAreIdentical cmath atan z z requires_IEEE_ testAtanhSign z complex_zeros assertComplexesAreIdentical cmath atanh z z IsCloseTests test_math IsCloseTests isclose = cmath isclose test_reject_complex_tolerances assertRaises TypeError isclose j j rel_tol= j assertRaises TypeError isclose j j abs_tol= j assertRaises TypeError isclose j j rel_tol= j abs_tol= j test_complex_values test complex values close within decimal places complex_examples = + j + j + j + j - + j - + j - j - j assertAllClose complex_examples rel_tol= e- assertAllNotClose complex_examples rel_tol= e- test_complex_near_zero test values near zero near within three decimal places near_zero_examples = j + j - + j - j - - j assertAllClose near_zero_examples abs_tol= e- assertAllNotClose near_zero_examples abs_tol= e- assertIsClose - j + j abs_tol= e- assertIsNotClose - j + j abs_tol= e- test_complex_special assertIsNotClose INF INF j assertIsNotClose INF j INF assertIsNotClose INF -INF assertIsNotClose -INF INF assertIsNotClose INF assertIsNotClose INF j __name__ == __main__ run_tests