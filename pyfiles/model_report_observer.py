mypy allow-untyped-defs torch torch ao quantization observer ObserverBase ModelReportObserver ObserverBase r This observer used record additional information regarding keeping track S = average_batch_activation_range epoch_activation_range The purpose information prepare report present users whether Dynamic Static Quantization more appropriate their model given general distributions their data Args ch_axis int optional The channel axis which range outlier stats computed Default comp_percentile float optional The percentile compare against percentile find outliers Should between exclusive Default attr ` num_batches_tracked ` specifies number batches passed through observer attr ` average_batch_activation_range ` defines average across ranges each batch passed through attr ` epoch_activation_min ` defines minimum value passed through observer attr ` epoch_activation_max ` defines maximum value passed through observer attr ` ch_axis ` defines channel being used compute per channel min max stats attr ` min_val ` defines per channel minimum values passed through attr ` max_val ` defines per channel maximum values passed through attr ` comp_percentile ` defines comparison percentile find outliers attr ` average_percentile_ratio ` defines per channel average percentile ratios attr ` percentile_batches_tracked ` defines number percentile batches tracked each channel attr ` constant_channels ` defines number batches aren t constant channels per channel Note tool meant FX Graph Mode Quantization epoch_activation_min torch Tensor epoch_activation_max torch Tensor min_val torch Tensor max_val torch Tensor comp_percentile torch Tensor average_percentile_ratio torch Tensor percentile_batches_tracked torch Tensor constant_channels torch Tensor __init__ ch_axis int = comp_percentile float = super __init__ torch qint num_batches_tracked = keep track min mix range average batch epoch whole average_batch_activation_range torch Tensor = torch tensor float register_buffer epoch_activation_min torch tensor float inf register_buffer epoch_activation_max torch tensor float -inf keep track per channel min max information using given channel ch_axis int = ch_axis register_buffer min_val torch tensor register_buffer max_val torch tensor keep track percentile ratio information per channel register_buffer comp_percentile torch tensor comp_percentile register_buffer average_percentile_ratio torch tensor register_buffer percentile_batches_tracked torch tensor register_buffer constant_channels torch tensor forward x x_copy = x detach avoid keeping autograd tape x_copy = x_copy epoch_activation_min dtype x_copy = _calculate_range_stats x_copy x_copy = _calculate_min_max_stats x_copy x_copy = _calculate_percentile_stats x_copy passed value x _calculate_range_stats x_copy r Calculates stores range stats forward values Args x_copy A copy forward data Returns passed x_copy get min max values data min_val_cur max_val_cur = torch aminmax x_copy calculate new epoch range values epoch_min_val = torch min epoch_activation_min min_val_cur epoch_max_val = torch max epoch_activation_max max_val_cur epoch_activation_min copy_ epoch_min_val epoch_activation_max copy_ epoch_max_val calculate average batch activation range current_batch_range = max_val_cur - min_val_cur new_range = average_batch_activation_range num_batches_tracked + current_batch_range num_batches_tracked + average_batch_activation_range = new_range num_batches_tracked += new batch processed x_copy _calculate_min_max_stats x_copy r Calculates stores per_channel min max stats forward values Does calculation based channel axis ch_axis Args x_copy A copy forward data Returns passed x_copy get current min max vals min_val = min_val max_val = max_val x_dim = x_copy size new_axis_list = i i range len x_dim noqa C new_axis_list ch_axis = new_axis_list = ch_axis y = x_copy permute new_axis_list Need match dtype min max because updates buffers done place types need match comparisons y = y min_val dtype y = torch flatten y start_dim= min_val numel == max_val numel == min_val max_val = torch aminmax y dim= min_val_cur max_val_cur = torch aminmax y dim= min_val = torch min min_val_cur min_val max_val = torch max max_val_cur max_val min_val resize_ min_val shape max_val resize_ max_val shape min_val copy_ min_val max_val copy_ max_val x_copy _calculate_percentile_stats x_copy r Calculates stores per_channel percentile stats forward values Does calculation based channel axis ch_axis Args x_copy A copy forward data Returns passed x_copy get dimension copy x_dim = x_copy size new_axis_list = i i range len x_dim noqa C new_axis_list ch_axis = new_axis_list = ch_axis y = x_copy permute new_axis_list Need match dtype min max because updates buffers done place types need match comparisons y = y min_val dtype y = torch flatten y start_dim= y = y dtype=self min_val dtype device= cpu find percentile values along axis we want both th percentile comp_percentile we also want find th quartile see we have constant channel quantiles_list = comp_percentile quantiles_to_find = torch tensor quantiles_list dtype=self min_val dtype find quantiles desired_quantiles = torch quantile y quantiles_to_find dim=self ch_axis interpolation= lower zero_quantile = desired_quantiles comp_quantile = desired_quantiles hundreth_quartile = desired_quantiles any channels have s we ignore channel calculation any_non_zero_quantile_value torch Tensor = comp_quantile = torch tensor &#124; hundreth_quartile = torch tensor any_non_zero_quantile_value = any_non_zero_quantile_value int transform boolean values int values we also check we have constant channel any_constant_channels torch Tensor = hundreth_quartile - zero_quantile == torch tensor any_constant_channels = any_constant_channels int transform boolean values int values possibilities get nan answer will ignore any these three cases s just deal them now case numerator issue largest all negative rest really negative case denominator possible unless case we just ignore case both outlier channel just kinda useless ignore get ratio get rid nan values quantile_ratios = hundreth_quartile comp_quantile quantile_ratios = torch nan_to_num quantile_ratios update averages remembering only update didn t have zeros ratio_if_not_zero = any_non_zero_quantile_value quantile_ratios num_batches average_ratio initialized we want initialize them percentile_batches_tracked shape == average_percentile_ratio shape == percentile_batches_tracked = torch zeros_like any_non_zero_quantile_value average_percentile_ratio = torch zeros_like ratio_if_not_zero also initialize constant channel var initialized separately constant_channels shape == constant_channels = torch zeros_like any_constant_channels get current num batches average ratio num_batches = percentile_batches_tracked average_ratio = average_percentile_ratio calculate new_number batches new_ratios get rid nans because size batches new_number_of_batches torch Tensor = num_batches + any_non_zero_quantile_value new_ratios torch Tensor = average_ratio num_batches + ratio_if_not_zero new_number_of_batches new_ratios = torch nan_to_num new_ratios update number non-constant channels new_constant_count torch Tensor = constant_channels + any_constant_channels update values locally percentile_batches_tracked copy_ new_number_of_batches average_percentile_ratio copy_ new_ratios constant_channels copy_ new_constant_count x_copy torch jit export get_batch_to_epoch_ratio epoch_activation_range = epoch_activation_max - epoch_activation_min epoch_activation_range == torch tensor float raise ValueError Range Epoch epoch_activation_range == torch tensor float inf raise ValueError No data has been run through observer infinity value present average_batch_activation_range epoch_activation_range torch jit export reset_batch_and_epoch_values set all values back their original defaults new epoch keep device device = max_val device num_batches_tracked = average_batch_activation_range = torch tensor float device=device epoch_activation_min = torch tensor float inf device=device epoch_activation_max = torch tensor float -inf device=device min_val = torch tensor device=device max_val = torch tensor device=device average_percentile_ratio = torch tensor device=device percentile_batches_tracked = torch tensor device=device constant_channels = torch tensor device=device torch jit export calculate_qparams type ignore override raise Exception noqa TRY calculate_qparams should called ModelReportObserver