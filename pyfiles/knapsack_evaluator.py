operator collections deque collections abc Callable networkx nx torch _functorch _activation_checkpointing graph_info_provider GraphInfoProvider KnapsackEvaluator This evaluates theoretical runtime peak memory usage given checkpointing strategy It takes graph list nodes saved recomputed then simulates backward pass calculate peak memory usage __init__ graph_info_provider GraphInfoProvider - None _graph_info_provider = graph_info_provider _get_backward_memory_from_topologically_sorted_graph node_graph nx DiGraph node_memories dict str float saved_nodes_set set str peak_memory_after_forward_pass float - list tuple float str Simulates backward pass keeps track peak memory usage High Level Steps Set Initial Peak Current Memory Allows you set peak memory after forward pass typically sum estimated memory saved nodes Perform reverse topological sort node_graph If full graph defined then will sort full graph only process subset nodes node_graph Iterate through sorted graph nodes If node saved then just drop s memory current memory If node saved then add s memory current memory then traverse s predecessors simulate recomuptation chain Will check new peak memory after all predecessors processed Args node_graph nx DiGraph A directed graph representing recomputable forward nodes saved_nodes_set Set str A set node names saved peak_memory_after_forward_pass float The peak memory usage after forward pass current_memory = peak_memory_after_forward_pass Initial Peak Current Memory already_computed = set sorted_nodes = list reversed list nx topological_sort node_graph dependencies_computed = set node sorted_nodes node saved_nodes_set node already_computed current_memory append current_memory - - node_memories node f Dropping Node already saved node continue already_computed add node current_memory append current_memory - + node_memories node f Recomputing Node node Create queue dependencies required recomputation predecessor_queue = deque dependency dependency v node_graph in_edges node dependency already_computed while predecessor_queue dep = predecessor_queue popleft already_computed add dep dependencies_computed add dep current_memory append current_memory - + node_memories dep f Recomputing Predecessor node dep Add predecessors predecessor queue they haven t been recomputed yet dependency_of_dependency _ node_graph in_edges dep dependency_of_dependency already_computed dependency_of_dependency saved_nodes_set dependency_of_dependency predecessor_queue continue predecessor_queue append dependency_of_dependency dependencies_computed clear current_memory append current_memory - - node_memories node f Dropping Node node current_memory _validate_all_indexes_accounted_for_in_provided_output saved_nodes_idxs list int recomputable_node_idxs list int - None Validate all indexes accounted provided output This function checks union saved nodes recomputable nodes covers all candidate nodes without any overlaps recomputable_node_idxs_set = set recomputable_node_idxs saved_nodes_idxs_set = set saved_nodes_idxs all_candidate_nodes_idxs = set range len _graph_info_provider all_recomputable_banned_nodes Check there no overlaps between saved nodes recomputable nodes assert len recomputable_node_idxs_set intersection saved_nodes_idxs_set == Saved nodes recomputable nodes cannot have any overlaps Check all candidate nodes accounted assert recomputable_node_idxs_set union saved_nodes_idxs_set == all_candidate_nodes_idxs All candidate nodes must accounted provided output evaluate_knapsack_output saved_nodes_idxs list int recomputable_node_idxs list int account_for_backward_pass bool = False - dict str float Evaluate theoretical runtime peak memory usage given checkpointing strategy Args - saved_nodes_idxs List int The indices nodes saved - recomputable_node_idxs List int The indices nodes need recomputed _validate_all_indexes_accounted_for_in_provided_output saved_nodes_idxs recomputable_node_idxs recomputation_runtime = sum _graph_info_provider all_node_runtimes _graph_info_provider all_recomputable_banned_nodes node node recomputable_node_idxs account_for_backward_pass memory_list = _get_backward_memory_from_topologically_sorted_graph node_graph=self _graph_info_provider recomputable_node_only_graph_with_larger_graph_context saved_nodes_set= _graph_info_provider all_recomputable_banned_nodes i i saved_nodes_idxs node_memories=self _graph_info_provider all_node_memories peak_memory_after_forward_pass=sum _graph_info_provider all_node_memories _graph_info_provider all_recomputable_banned_nodes i i saved_nodes_idxs peak_memory = max memory_list key=operator itemgetter peak_memory = sum _graph_info_provider all_node_memories _graph_info_provider all_recomputable_banned_nodes node node saved_nodes_idxs peak_memory peak_memory recomputation_runtime recomputation_runtime non_ac_peak_memory _graph_info_provider get_non_ac_peak_memory theoretical_max_runtime _graph_info_provider get_theoretical_max_runtime percentage_of_theoretical_peak_memory peak_memory _graph_info_provider get_non_ac_peak_memory percentage_of_theoretical_peak_runtime recomputation_runtime _graph_info_provider get_theoretical_max_runtime evaluate_distribution_of_results_for_knapsack_algo knapsack_algo Callable list float list float float tuple float list int list int memory_budget_values list float - list dict str float Evaluates distribution results given knapsack algorithm Args knapsack_algo Callable The knapsack algorithm use evaluation memory_budget_values List float A list memory budgets evaluate results = list memory_budget memory_budget_values _ saved_nodes recomputed_nodes = knapsack_algo _graph_info_provider get_knapsack_memory_input _graph_info_provider get_knapsack_runtime_input memory_budget result = evaluate_knapsack_output saved_nodes_idxs=saved_nodes recomputable_node_idxs=recomputed_nodes result memory_budget = memory_budget results append result results get_knee_point_memory_budget knapsack_algo Callable list float list float float tuple float list int list int max_mem_budget float = min_mem_budget float = iterations int = - float Finds memory budget knee point Pareto frontier The knee point defined point where trade-off between runtime memory usage optimal Args knapsack_algo callable Knapsack algorithm use evaluation max_mem_budget float optional Maximum memory budget Defaults min_mem_budget float optional Minimum memory budget Defaults iterations int optional Number memory budgets evaluate Defaults Returns float Memory budget knee point results = evaluate_distribution_of_results_for_knapsack_algo knapsack_algo=knapsack_algo memory_budget_values= min_mem_budget + i max_mem_budget - min_mem_budget iterations - i range iterations runtime_values = result percentage_of_theoretical_peak_runtime result results memory_values = result percentage_of_theoretical_peak_memory result results runtime_range = max runtime_values - min runtime_values memory_range = max memory_values - min memory_values runtime_range == memory_range == max_mem_budget Normalize values runtime_min = min runtime_values memory_min = min memory_values runtime_norm = value - runtime_min runtime_range value runtime_values memory_norm = value - memory_min memory_range value memory_values Calculate Euclidean distance distances = runtime_norm i + memory_norm i i range len runtime_norm Find knee point shortest distance origin knee_index = distances index min distances results knee_index memory_budget