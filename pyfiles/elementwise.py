itertools operator numpy np scipy special torch benchmark A template elementwise operations A derived will override instance customize its behavior ElementBench benchmark Benchmark List customization variables op_str = None binary_op_pt_func = None binary_op_np_func = None unary_op_pt_func = None unary_op_np_func = None split_input = True __init__ mode device dtype N super __init__ mode device dtype N = N d = rand N device=device dtype=dtype requires_grad=self requires_grad d = rand N device=device dtype=dtype requires_grad=self requires_grad d = rand N device=device dtype=dtype requires_grad=self requires_grad d = rand N device=device dtype=dtype requires_grad=self requires_grad inputs = d d d d deterministic = rand op_str _eval d d d d binary_op unary_op binary_op binary_op x y x + y unary_op unary_op x x split_input d = unary_op d d = unary_op d d = unary_op d d = unary_op d d = unary_op d + d = unary_op d + d = unary_op d + d = unary_op d = binary_op d d b = binary_op d d c = + b c forward d d d d binary_op = __class__ binary_op_pt_func unary_op = __class__ unary_op_pt_func _eval d d d d binary_op unary_op reference binary_op = __class__ binary_op_np_func unary_op = __class__ unary_op_np_func d d d d = numpy d d d d d d _eval d d d d binary_op unary_op config N classmethod module cls element_ + cls op_str memory_workload input_count = len inputs mode == fwd split_input sol_count = input_count + algorithmic_count = input_count + sol_count = + algorithmic_count = + rand op_str sol_count = algorithmic_count = split_input sol_count = input_count + + + input_count algorithmic_count = input_count + + + input_count sol_count = + algorithmic_count = + rand op_str sol_count = algorithmic_count = buffer_size = N sol buffer_size sol_count algorithmic buffer_size algorithmic_count staticmethod default_configs register_element_ops binary_op_list = mul operator mul add operator add sub operator sub div lambda b b + e- pow torch pow np power no fuson triggered max torch max np maximum min torch min np minimum unary_op_list = erf torch erf scipy special erf exp torch exp np exp sin torch sin np sin cos torch cos np cos rand_like torch rand_like lambda x np random rand x shape split_input binary_op itertools product True False binary_op_list Make copy ElementBench len binary_op == op_str op_pt_func = binary_op op_np_func = op_pt_func len binary_op == op_str op_pt_func op_np_func = binary_op split_str = split split_input shared op_str = split_str + _ + op_str bm_cls = type ElementBench_ + op_str ElementBench bm_cls op_str = op_str bm_cls binary_op_pt_func = op_pt_func bm_cls binary_op_np_func = op_np_func bm_cls split_input = split_input benchmark register_benchmark_class bm_cls split_input unary_op itertools product True False unary_op_list Make copy ElementBench len unary_op == op_str op_pt_func = unary_op op_np_func = op_pt_func len unary_op == op_str op_pt_func op_np_func = unary_op split_str = split split_input shared op_str = split_str + _ + op_str bm_cls = type ElementBench_ + op_str ElementBench bm_cls op_str = op_str bm_cls unary_op_pt_func = op_pt_func bm_cls unary_op_np_func = op_np_func bm_cls split_input = split_input benchmark register_benchmark_class bm_cls benchmark register_benchmark_class ElementMulBench register_element_ops SimpleElementBench benchmark Benchmark __init__ mode device dtype N super __init__ mode device dtype N = N data = rand N device=device dtype=dtype requires_grad=self requires_grad inputs = data forward data = data + b = + b reference binary_op = __class__ binary_op_np_func unary_op = __class__ unary_op_np_func d d d d = numpy d d d d d d _eval d d d d binary_op unary_op config N staticmethod input_iterable True classmethod module cls simple_element memory_workload mode == fwd sol_count = algorithmic_count = sol_count = algorithmic_count = buffer_size = N sol buffer_size sol_count algorithmic buffer_size algorithmic_count staticmethod default_configs benchmark register_benchmark_class SimpleElementBench DynamicSimpleElementBench benchmark DynamicShape SimpleElementBench __init__ mode device dtype N benchmark DynamicShape __init__ SimpleElementBench __init__ mode device dtype N classmethod module cls simple_dynamic_element instantiate_input N = rand_shape N data = rand N device=self device dtype=self dtype requires_grad=self requires_grad inputs = data benchmark register_benchmark_class DynamicSimpleElementBench