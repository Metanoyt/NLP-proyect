Owner s oncall jit ruff noqa F inspect os sys types unittest collections defaultdict OrderedDict textwrap dedent typing Any Dict List NamedTuple Optional Tuple torch torch nn nn torch Tensor torch testing FileCheck Make helper files test importable pytorch_test_dir = os path dirname os path dirname os path realpath __file__ sys path append pytorch_test_dir torch testing _internal common_utils raise_on_run_directly skipIfTorchDynamo TEST_CUDA torch testing _internal jit_utils JitTestCase make_global TestList JitTestCase test_list_bool_conversion if_predicate l List int l s = n l s += n s - checkScript if_predicate checkScript if_predicate while_predicate l List int s = while l s += l pop checkScript while_predicate checkScript while_predicate ternary_predicate l List int non-empty l empty checkScript ternary_predicate checkScript ternary_predicate test_in_check int_in x List int - bool x checkScript int_in checkScript int_in float_in x List float - bool x checkScript float_in checkScript float_in str_in x List str - bool hi x checkScript str_in here checkScript str_in hi bye checkScript str_in test_list_literal reassign x = == x = checkScript reassign optimize=False reassign_arity_change x = == x = checkScript reassign_arity_change optimize=False reassign_from_empty_literal x = == x = assertRaisesRegexWithHighlight RuntimeError r previously had type List\ Tensor\ x checkScript reassign_from_empty_literal optimize=False reassign_from_empty_builtin x = torch jit annotate List int == x = y = torch jit annotate List float == y = z = == z = torch randn checkScript reassign_from_empty_builtin optimize=False reassign_bad_type x = == x = assertRaisesRegexWithHighlight RuntimeError previously had type x checkScript reassign_bad_type optimize=False reassign_nested x = torch jit annotate List int == x = == x = assertRaisesRegexWithHighlight RuntimeError previously had type x checkScript reassign_nested optimize=False test_list_variance ` List T ` subtype ` List T ` even ` T ` subtype ` T ` However we have temporary list object list comprehension list literal rhs assignment statement we want ignore inferred type rhs we can prove both lhs rhs lists inner type lhs list subtype inner type rhs list This should pass x List Optional int = None None None This should fail y List None = None None None x List Optional int = y test_listliteral_is_typed_from_annotation x List Optional int = None None None x checkScript test_listliteral_is_typed_from_annotation test_listcomprehension_is_typed_from_annotation x List Optional int = None _ range x checkScript test_listcomprehension_is_typed_from_annotation test_lists_with_different_internal_types_are_invariant x List int = y List Optional int = x x assertRaisesRegex RuntimeError Variable y annotated type r List\ Optional\ int\ \ being assigned value type r List\ int\ torch jit script test_lists_with_different_internal_types_are_invariant test_lists_with_different_internal_types_are_invariant_recursive x List List int = y List List Optional int = x x assertRaisesRegex RuntimeError Variable y annotated type r List\ List\ Optional\ int\ \ \ being assigned value r type List\ List\ int\ \ torch jit script test_lists_with_different_internal_types_are_invariant_recursive test_del inputs fn x List int - List int del x x python_out = fn inputs checkScript reuses same object here s being mutated so do manually cu = torch jit CompilationUnit cu define dedent inspect getsource fn assertEqual cu fn inputs python_out assertEqual torch jit script fn inputs python_out torch jit script fn x List int - List int del x x assertRaisesRegexWithHighlight RuntimeError out range x fn assertRaisesRegexWithHighlight RuntimeError deletion single index x torch jit script fn x List int - List int del x x test_list_keyword foo list noqa C list b noqa C list range list abcdefg checkScript foo foo x List int = list noqa C x append x checkScript foo foo list list abc noqa C checkScript foo FileCheck check_count aten list exactly=True run torch jit script foo graph test_dict_keyword_with_kwargs fn dict foo= bar= baz= checkScript fn test_dict_keyword_with_kwargs_using_container_values fn dict foo= bar= baz= checkScript fn test_dict_keyword_with_iterable fn dict foo bar baz noqa C checkScript fn test_dict_keyword_with_empty_iterable fn dict noqa C checkScript fn test_dict_keyword_with_internal_aggregate_function fn dict zip foo baz bar checkScript fn test_dict_keyword_with_mapping fn foo bar baz checkScript fn test_dict_keyword_with_mapping_and_kwargs fn dict foo bar baz= checkScript fn test_dict_keyword_with_dict_comprehension fn i chr i + i range checkScript fn test_dict_keyword_with_dict_comprehension_and_kwargs fn dict chr + i i i range foo= checkScript fn test_dict_keyword_with_empty_dict_comprehension fn checkScript fn test_dict_keyword_is_correctly_typed fn x Dict str int = dict noqa C x foo = x checkScript fn test_dict_keyword_with_mismatched_annotations err_msg = r Dict type annotation ` Dict\ int str\ ` did match type actual key type ` str ` assertRaisesRegex RuntimeError err_msg torch jit script fn x Dict int str = dict noqa C foo bar baz x test_dict_keyword_with_nested_call fn dict dict foo= bar= baz= checkScript fn test_dict_keyword_with_previously_declared_variable fn d = foo bar dict d checkScript fn test_dict_keyword_with_previously_declared_variable_and_kwargs fn d = foo bar dict d baz= checkScript fn test_min_bool_list jit_min_list List bool b List bool - List bool min b checkScript jit_min_list True False False True test_min_max_list jit_min_list List int b List int - List int min b jit_min_list_float List float b List float - List float min b jit_min_list_bool List bool b List bool - List bool min b run_tests func b t zip b checkScript func t args_left_int = args_right_int = run_tests jit_min_list args_left_int args_right_int args_left_float = args_right_float = run_tests jit_min_list_float args_left_float args_right_float args_left_bool = False True False True True True False False False False False True args_right_bool = False True True False True True False True False False True False False False run_tests jit_min_list_bool args_left_bool args_right_bool jit_max_list List int b List int - List int max b jit_max_list_float List float b List float - List float max b jit_max_list_bool List bool b List bool - List bool max b args_left_int = args_right_int = run_tests jit_max_list args_left_int args_right_int args_left_float = args_right_float = run_tests jit_max_list_float args_left_float args_right_float run_tests jit_max_list_bool args_left_bool args_right_bool test_list_gather index = checkScript index negative_index = - checkScript negative_index bad_index = checkScriptRaisesRegex bad_index Exception list index out range bad_negative_index = - checkScriptRaisesRegex bad_negative_index Exception list index out range test_list_len func = len == checkScript func func = len == checkScript func skipIfTorchDynamo TorchDynamo fails raise checkScriptRaisesRegex because we trace properly now test_list_ops test_equality = b = == b checkScript test_equality optimize=True test_equality_str = foo bar b = foo bar == b checkScript test_equality_str optimize=True test_inequality = b = = b checkScript test_inequality optimize=True test_inequality_str = foo bar b = foo bar food = b checkScript test_inequality_str optimize=True test_non_equality = b = == b checkScript test_non_equality optimize=True test_non_inequality = b = = b checkScript test_non_equality optimize=True test_list_equality_as_cond = b = == b c = c = c checkScript test_list_equality_as_cond optimize=True test_list_add = b = c = + b c == checkScript test_list_add optimize=True test_list_add_empty = b = torch jit annotate List int c = + b c == checkScript test_list_add_empty optimize=True test_tensor_list_equality t = torch ones t = torch ones x = t t y = t t x == y checkScript test_tensor_list_equality optimize=True test_invalid_list_equality t = torch ones t = torch ones x = t t y = t t will throw since tensors have more than one element x == y checkScriptRaisesRegex test_invalid_list_equality RuntimeError Boolean value Tensor test_list_sort template = dedent func li_ = list_create li_ = list_create li_ = list_create li_ sort li_ sort reverse=True li_ = sorted li_ li_ li_ li_ li_ lists = True False True torch tensor torch tensor torch tensor torch tensor torch tensor - torch tensor li lists code = template format list_create=li scope = exec code globals scope cu = torch jit CompilationUnit code t = cu func t = scope func assertEqual t t test_fail x List Tensor - List Tensor x sort x checkScriptRaisesRegex test_fail torch zeros torch zeros Exception Boolean value Tensor more than one value torch jit script test_mutation = sort test_mutation FileCheck check aten sort run test_mutation graph_for test_sorted_copy = torch tensor torch tensor torch tensor b = sorted = torch tensor b checkScript test_sorted_copy test_list_slice test_regular_slice = == checkScript test_regular_slice test_open_ended_slice = == checkScript test_open_ended_slice test_open_ended_slice = == checkScript test_open_ended_slice test_negative_slice = - == checkScript test_negative_slice test_negative_slice = - - == checkScript test_negative_slice test_backward_slice = == torch jit annotate List int checkScript test_backward_slice test_over_slice = == checkScript test_backward_slice test_slice_index = torch tensor test_index_slice x x = x x checkScript test_index_slice test_index_slice x x = x x checkScript test_index_slice test_index_slice x x = x x checkScript test_index_slice test_index_slice_empty_list x empty_list List int = x = x empty_list x checkScript test_index_slice_empty_list test_index_slice_out_of_bounds_index x x = x x assertRaisesRegexWithHighlight RuntimeError index out bounds dimension size x checkScript test_index_slice_out_of_bounds_index test_mutable_list_append test_append = append append == checkScript test_append test_comprehensions_basic comp l List int - List int n = x x l n comp checkScript comp test_comprehensions_basic_float comp l List float - List float n = x x l n checkScript comp test_comprehensions_two_comps torch jit script comp l List int l List int - List int n = x x l n = x + x l n + n assertEqual comp test_comprehension_out_type_not_in_type list_cast - int li = int i i torch tensor torch tensor torch tensor li + li + li checkScript list_cast test_comprehension_iterable test_func fn inputs assertEqual fn inputs torch jit script fn inputs foo names List int results List int - List Tuple int int k + v - k v zip names results test_func foo test_func foo fn x int - List int i i range x noqa C test_func fn test_func fn test_func fn - changes_type = float i i range b = float i i c = float i j i j enumerate b c test_func changes_type test_zero_iter str i i j zip test_func test_zero_iter test_mutable_list_append_ test_append_ = append = append == checkScript test_append_ test_mutable_list_append_if test_append_if = == append == checkScript test_append_if test_mutable_list_append_if_else test_append_if_else = == append append == checkScript test_append_if_else test_mutable_list_append_loop test_append_loop = torch jit annotate List int i range append i == checkScript test_append_loop test_mutable_list_append_loop_if test_append_loop_if = torch jit annotate List int i range i append i append == checkScript test_append_loop_if test_mutable_list_nested_loop test_nested_loop = torch jit annotate List int i range j range append i + j == checkScript test_nested_loop test_mutable_list_function_inline torch jit script bar y List int - None y append torch jit script foo x = bar x x assertEqual foo test_mutable_list_reverse_empty test_reverse_empty = reverse == checkScript test_reverse_empty test_mutable_list_reverse test_reverse = reverse == checkScript test_reverse test_mutable_tensor_list_reverse test_tensor_reverse = torch tensor torch tensor reverse == torch tensor torch tensor checkScript test_tensor_reverse test_mutable_list_pop_empty torch jit script test_pop_empty = torch jit annotate List int pop assertRaisesRegexWithHighlight RuntimeError pop empty list pop test_pop_empty test_mutable_list_pop test_pop = b = pop b == checkScript test_pop test_mutable_list_pop test_pop = b = pop len == checkScript test_pop test_mutable_list_pop_at test_pop_at = b = pop b == checkScript test_pop_at test_mutable_list_pop_at test_pop_at = b = pop len == checkScript test_pop_at test_mutable_list_pop_at_negative test_pop_at_negative = b = pop - b == checkScript test_pop_at_negative test_mutable_list_pop_at_negative test_pop_at_negative = b = pop - len == checkScript test_pop_at_negative test_mutable_list_pop_slice test_pop_slice = b = pop b = b - == b checkScript test_pop_slice test_mutable_list_clear_empty test_clear_empty = torch jit annotate List int clear len == checkScript test_clear_empty test_mutable_list_clear test_clear = clear len == checkScript test_clear test_mutable_list_insert test_list_insert = insert == checkScript test_list_insert test_mutable_list_insert_negative test_list_insert_negative = insert - == checkScript test_list_insert_negative test_mutable_list_insert_neg_out_of_bounds test_list_insert_neg_out_of_bounds = insert - == checkScript test_list_insert_neg_out_of_bounds test_mutable_list_insert_out_of_bounds test_list_insert_out_of_bounds = insert == checkScript test_list_insert_out_of_bounds test_mutable_list_remove_not_existing torch jit script test_list_remove_not_existing = remove assertRaisesRegexWithHighlight RuntimeError x list remove test_list_remove_not_existing test_mutable_list_remove test_list_remove = remove == checkScript test_list_remove test_str_list_remove = foo bar remove foo == bar checkScript test_str_list_remove test_list_index_not_existing torch jit script list_index_not_existing = i = index i assertRaisesRegexWithHighlight RuntimeError list index list_index_not_existing test_list_index list_index = i = index i == checkScript list_index list_str_index = foo bar i = index bar i == checkScript list_str_index test_tensor_list_index tensor_list_index = torch tensor torch tensor torch tensor torch tensor i = index torch tensor i == checkScript tensor_list_index test_tensor_list_index_not_existing torch jit script tensor_list_index_not_existing = torch tensor torch tensor torch tensor torch tensor i = index torch tensor i assertRaisesRegexWithHighlight RuntimeError list index tensor_list_index_not_existing test_list_count list_count = i = count i == checkScript list_count list_str_count = foo bar foo i = count foo i == checkScript list_str_count test_list_count_not_existing list_count_not_existing = i = count i == checkScript list_count_not_existing test_tensor_list_count tensor_list_count = torch tensor torch tensor torch tensor torch tensor i = count torch tensor i == checkScript tensor_list_count test_tensor_list_count_not_existing tensor_list_count_not_existing = torch tensor torch tensor torch tensor torch tensor i = count torch tensor i == checkScript tensor_list_count_not_existing test_mutable_list_remove_tensor test_list_remove_tensor = torch ones torch zeros torch ones remove torch zeros len == checkScript test_list_remove_tensor test_mutable_list_remove test_list_remove = remove len == checkScript test_list_remove test_extend_list_mutable torch jit script extend_list List Tensor b List Tensor - List Tensor extend b l torch rand torch rand torch rand torch rand r torch rand torch rand torch rand torch rand assertEqual extend_list l r l + r test_extend_list_immutable torch jit script extend_list List int b List int - List int extend b l r assertEqual extend_list l r l + r test_copy_list_mutable torch jit script copy_list List Tensor - List Tensor copy l torch rand torch rand torch rand torch rand assertEqual copy_list l l test_copy_list_immutable torch jit script copy_list List int - List int copy l assertEqual copy_list l l test_min_max_single_list min_intlist li List int - int min li max_intlist li List int - int max li min_boollist li List bool - bool min li max_boollist li List bool - bool max li min_floatlist li List float - float min li max_floatlist li List float - float max li int_lists = - - - check_list fn li len li == checkScriptRaisesRegex fn li Exception empty checkScript fn li int_list int_lists check_list min_intlist int_list check_list max_intlist int_list bool_li = bool x x int_list check_list min_boollist bool_li check_list max_boollist bool_li float_li = float x x int_list check_list min_floatlist float_li check_list max_floatlist float_li test_to_list Unit tests Tensor tolist function Boolean dtype unit tests to_list_bool_ D x torch Tensor - bool li = torch jit annotate bool x tolist li to_list_bool_ D x torch Tensor - List bool li = torch jit annotate List bool x tolist li to_list_bool_ D x torch Tensor - List List bool li = torch jit annotate List List bool x tolist li to_list_bool_ D x torch Tensor - List List List bool li = torch jit annotate List List List bool x tolist li checkScript to_list_bool_ D torch tensor False dtype=torch bool bool_input_ D = torch tensor True False True False dtype=torch bool checkScript to_list_bool_ D bool_input_ D bool_input_ D = torch tensor True True False False True False dtype=torch bool checkScript to_list_bool_ D bool_input_ D bool_input_ D = torch tensor True False False True True False False False dtype=torch bool checkScript to_list_bool_ D bool_input_ D bool_input_noncontiguous = torch tensor True False False True True False False False dtype=torch bool transpose checkScript to_list_bool_ D bool_input_noncontiguous Int dtype unit tests to_list_int_ D x torch Tensor - int li = torch jit annotate int x tolist li to_list_int_ D x torch Tensor - List int li = torch jit annotate List int x tolist li to_list_int_ D x torch Tensor - List List int li = torch jit annotate List List int x tolist li to_list_int_ D x torch Tensor - List List List int li = torch jit annotate List List List int x tolist li checkScript to_list_int_ D torch tensor dtype=torch long int_input_ D = torch tensor dtype=torch long checkScript to_list_int_ D int_input_ D int_input_ D = torch tensor dtype=torch long checkScript to_list_int_ D int_input_ D int_input_ D = torch tensor dtype=torch long checkScript to_list_int_ D int_input_ D int_input_noncontiguous = torch tensor dtype=torch long transpose checkScript to_list_int_ D int_input_noncontiguous Float dtype unit tests to_list_float_ D x torch Tensor - float li = torch jit annotate float x tolist li to_list_float_ D x torch Tensor - List float li = torch jit annotate List float x tolist li to_list_float_ D x torch Tensor - List List float li = torch jit annotate List List float x tolist li to_list_float_ D x torch Tensor - List List List float li = torch jit annotate List List List float x tolist li Test torch float dtype Tensors check they converted double automatically checkScript to_list_float_ D torch randn dtype=torch float checkScript to_list_float_ D torch randn dtype=torch float checkScript to_list_float_ D torch randn dtype=torch float checkScript to_list_float_ D torch randn dtype=torch float checkScript to_list_float_ D torch randn dtype=torch float transpose checkScript to_list_float_ D torch randn dtype=torch double checkScript to_list_float_ D torch randn dtype=torch double checkScript to_list_float_ D torch randn dtype=torch double checkScript to_list_float_ D torch randn dtype=torch double checkScript to_list_float_ D torch randn dtype=torch double transpose Complex dtype unit tests to_list_complex_ D x torch Tensor - complex li = torch jit annotate complex x tolist li to_list_complex_ D x torch Tensor - List complex li = torch jit annotate List complex x tolist li to_list_complex_ D x torch Tensor - List List complex li = torch jit annotate List List complex x tolist li to_list_complex_ D x torch Tensor - List List List complex li = torch jit annotate List List List complex x tolist li Test torch complex dtype Tensors check they converted double automatically checkScript to_list_complex_ D torch randn dtype=torch cfloat checkScript to_list_complex_ D torch randn dtype=torch cfloat checkScript to_list_complex_ D torch randn dtype=torch cfloat checkScript to_list_complex_ D torch randn dtype=torch cfloat checkScript to_list_complex_ D torch randn dtype=torch cfloat transpose checkScript to_list_complex_ D torch randn dtype=torch cdouble checkScript to_list_complex_ D torch randn dtype=torch cdouble checkScript to_list_complex_ D torch randn dtype=torch cdouble checkScript to_list_complex_ D torch randn dtype=torch cdouble checkScript to_list_complex_ D torch randn dtype=torch cdouble transpose Non-happy path tests - missing type annotation - mismatch between type annotation input - type annotation unsupported type - type annotation wrong dimension - type annotation scalar type doesn t match input scalar type to_list_missing_type_annotation x torch Tensor - List float li = x tolist li to_list_incorrect_type_annotation x torch Tensor - List float li = torch jit annotate float x tolist li to_list_unsupported_type_annotation x torch Tensor - List float li = torch jit annotate List str x tolist li to_list_type_annotation_wrong_dim x torch Tensor - List List float li = torch jit annotate List List float x tolist li to_list_type_annotation_incorrect_scalar_type x torch Tensor - List float li = torch jit annotate List float x tolist li assertRaisesRegexWithHighlight RuntimeError r Expected type hint result tolist x tolist checkScript to_list_missing_type_annotation torch randn assertRaisesRegexWithHighlight RuntimeError r Return value annotated having type List\ float\ actually type float li checkScript to_list_incorrect_type_annotation torch randn assertRaisesRegex RuntimeError r str one supported element types tolist checkScript to_list_unsupported_type_annotation torch randn assertRaisesRegex RuntimeError r Output annotation list dimension runtime tensor dimension must match checkScript to_list_type_annotation_wrong_dim torch randn dtype=torch double assertRaisesRegex RuntimeError r Output annotation element type runtime tensor element type must match checkScript to_list_type_annotation_incorrect_scalar_type torch ones dtype=torch long unittest skipIf TEST_CUDA CUDA available test_to_list_gpu GPU tests Tensor tolist function to_list_bool_ D x torch Tensor - List bool li = torch jit annotate List bool x tolist li to_list_int_ D x torch Tensor - List int li = torch jit annotate List int x tolist li to_list_float_ D x torch Tensor - List float li = torch jit annotate List float x tolist li checkScript to_list_bool_ D torch tensor True False True False dtype=torch bool cuda checkScript to_list_int_ D torch tensor dtype=torch long cuda checkScript to_list_float_ D torch randn dtype=torch double cuda test_no_element_type_annotation fn_with_comment x torch Tensor - List List = x tolist annotated_fn x torch Tensor - List List = x tolist assertRaisesRegex RuntimeError r Attempted use List without contained type cu = torch jit CompilationUnit cu define dedent inspect getsource fn_with_comment assertRaisesRegex RuntimeError r Attempted use List without contained type cu = torch jit CompilationUnit cu define dedent inspect getsource annotated_fn assertRaisesRegex RuntimeError r Attempted use List without contained type torch jit script fn_with_comment assertRaisesRegex RuntimeError r Attempted use List without contained type torch jit script annotated_fn test_list_none assertRaisesRegex RuntimeError Can create ListType None type x = torch _C ListType None test_list_unification_hint assertRaisesRegex RuntimeError Expected annotation type List torch jit script x b int = b TestDict JitTestCase dict torch ones b torch ones + c torch ones + dict x torch ones + y torch ones + z torch ones + dict_bool True skipIfTorchDynamo TorchDynamo fails test unknown reason test_dict_bool_conversion if_predicate d Dict int int d s t = k v d items s += k t += v s t - - checkScript if_predicate checkScript if_predicate while_predicate d Dict int int while d d clear checkScript while_predicate checkScript while_predicate ternary_predicate d Dict int int non-empty d empty checkScript ternary_predicate checkScript ternary_predicate skipIfTorchDynamo TorchDynamo fails test unknown reason test_del inputs hi bye fn x Dict str int - Dict str int del x hi x python_out = fn inputs checkScript reuses same object here s being mutated so do manually cu = torch jit CompilationUnit cu define dedent inspect getsource fn assertEqual cu fn inputs python_out assertEqual torch jit script fn inputs python_out assertRaisesRegexWithHighlight RuntimeError KeyError x hi checkScript fn skipIfTorchDynamo TorchDynamo fails test unknown reason test_dict_variance ` Dict T _ ` subtype ` Dict T _ ` even ` T ` subtype ` T ` similarly ` Dict _ T ` would subtype ` Dict _ T ` However we have temporary dict object dict comprehension dict literal rhs assignment statement we want ignore inferred type rhs we can prove both lhs rhs dicts same key types TorchScript has restricted set allowed key types so we don t need worry about subtyping relationships here value type dict subtype value type rhs dict test_dictliteral_is_typed_from_annotation x Dict str Optional int = foo None bar None baz None x checkScript test_dictliteral_is_typed_from_annotation test_dictcomprehension_is_typed_from_annotation metasyntactics = foo bar baz x Dict str Optional int = noqa C RUF word None word metasyntactics x checkScript test_dictcomprehension_is_typed_from_annotation test_dicts_with_different_value_types_are_invariant x Dict str int = foo bar baz y Dict str Optional int = x x assertRaisesRegex RuntimeError Variable y annotated type r Dict\ str Optional\ int\ \ being assigned value r type Dict\ str int\ torch jit script test_dicts_with_different_value_types_are_invariant test_dicts_with_different_value_types_are_invariant_recursive x Dict str int = foo bar baz y Dict str Dict str int = foo x bar x baz x z Dict str Dict str Optional int = y x assertRaisesRegex RuntimeError Variable z annotated type r Dict\ str Dict\ str Optional r \ int\ \ \ being assigned r value type Dict\ str r Dict\ str int\ \ torch jit script test_dicts_with_different_value_types_are_invariant_recursive skipIfTorchDynamo TorchDynamo fails test unknown reason test_keys torch jit script keys x Dict str Tensor - List str list x keys assertEqual set keys dict set dict keys torch jit script specialized_list li = keys li append li assertTrue set specialized_list == skipIfTorchDynamo TorchDynamo fails test unknown reason test_values torch jit script values x Dict str Tensor - List Tensor list x values the_dict = dict assertEqual set values the_dict set the_dict values skipIfTorchDynamo TorchDynamo fails test unknown reason test_len length x Dict str Tensor - int len x checkScript length dict skipIfTorchDynamo TorchDynamo fails test unknown reason test_copy func x Dict str Tensor - Dict str Tensor x copy checkScript func dict skipIfTorchDynamo TorchDynamo fails test unknown reason test_items func x Dict str Tensor - List Tuple str Tensor x items The value returned Python arbitrary order so we can t use checkScript scripted_func = torch jit script func eager_out = func dict script_out = scripted_func dict assertEqual len eager_out len script_out item eager_out assertTrue item script_out skipIfTorchDynamo TorchDynamo fails test unknown reason test_pop pop x Dict str Tensor key str - Tuple Tensor Dict str Tensor x pop key x checkScript doesn t copy inputs so we can t use since mutates dict tester fn args eager_out = fn dict args script_out = torch jit script fn dict args assertEqual eager_out script_out tester pop assertRaisesRegexWithHighlight RuntimeError KeyError x pop torch jit script pop dict x default_pop x Dict str Tensor key str default Tensor - Tuple Tensor Dict str Tensor x pop key default x tester default_pop torch randn tester default_pop x torch randn skipIfTorchDynamo TorchDynamo fails test unknown reason test_setdefault setdefault x Dict str Tensor key str default Tensor - Dict str Tensor x setdefault key default x checkScript setdefault dict torch randn checkScript setdefault dict nonexistant torch randn skipIfTorchDynamo TorchDynamo fails test unknown reason test_update update Dict str Tensor b Dict str Tensor - Tuple Dict str Tensor Dict str Tensor update b b checkScript update dict dict checkScript update dict dict skipIfTorchDynamo TorchDynamo fails test unknown reason test_update_existing_key foo - Dict str int Dict str int = i range update i checkScript foo skipIfTorchDynamo TorchDynamo fails test unknown reason test_aug_assign aug_assign_dict_tensor Dict str Tensor - Dict str Tensor += b -= c = c = c = aug_assign_dict_prim Dict str float - Dict str float += b -= c = c = c = checkScript aug_assign_dict_tensor dict checkScript aug_assign_dict_prim b c skipIfTorchDynamo TorchDynamo fails test unknown reason test_popitem torch jit script popitem x Dict str Tensor - Tuple Tuple str Tensor Dict str Tensor item = x popitem item x The value returned Python arbitrary so we can t use checkScript eager_in = dict eager_out = eager_in popitem eager_in script_out = popitem dict Check item removed assertEqual len eager_out len script_out Check item correct types assertTrue isinstance script_out str assertTrue isinstance script_out torch Tensor skipIfTorchDynamo TorchDynamo fails test unknown reason test_clear clear x Dict str Tensor - Dict str Tensor x clear x checkScript clear dict skipIfTorchDynamo TorchDynamo fails test unknown reason test_get get x Dict str Tensor key str - Optional Tensor x get key checkScript get dict checkScript get dict doesn t exist get_default x Dict str Tensor key str - Optional Tensor x get key torch randn checkScript get dict checkScript get dict doesn t exist skipIfTorchDynamo TorchDynamo fails test unknown reason test_get_boolkey get x Dict bool int key bool - Optional int x get key checkScript get dict_bool True checkScript get dict_bool False get_default x Dict bool int key bool - int x get key checkScript get_default dict_bool True checkScript get_default dict_bool False skipIfTorchDynamo TorchDynamo fails test unknown reason test_basic simple x Dict str int - Dict str int x checkScript simple item other_item index x Dict str int - int x item checkScript index item other_item type_default - Dict str Tensor checkScript type_default torch jit script missing_index x Dict str int - int x dne assertRaisesRegexWithHighlight RuntimeError KeyError x dne missing_index item other_item code = dedent literal torch jit annotate Dict int float literal torch jit annotate Dict int float cu = torch jit CompilationUnit code assertEqual cu literal assertEqual cu literal cu = torch jit CompilationUnit dedent literal torch jit annotate Dict int float assertEqual cu literal list_of_dicts - List Dict str Tensor word torch ones + other word torch ones + checkScript list_of_dicts skipIfTorchDynamo TorchDynamo fails test unknown reason test_mutability torch jit script fn - Dict str int = torch jit annotate Dict str int ok = assertEqual fn ok skipIfTorchDynamo TorchDynamo fails test unknown reason test_key_type assertRaisesRegexWithHighlight RuntimeError instead found type None torch jit script fn Dict str int - int None skipIfTorchDynamo TorchDynamo fails test unknown reason test_loop torch jit script fn x int - Dict str int = torch jit annotate Dict str int i range x ok = i assertEqual fn ok skipIfTorchDynamo TorchDynamo fails test unknown reason test_view fn x y l = x x_view = l = x + x x_view add_ y b = x + x == b checkScript fn torch rand torch rand skipIfTorchDynamo TorchDynamo fails test unknown reason test_membership fn x Dict int int y int - int x get y d = checkScript fn d checkScript fn d optional x Dict int int y int - bool res = x get y res None checkScript fn d checkScript fn d assertRaisesRegexWithHighlight RuntimeError actually type Optional x get y torch jit script bad_types x Dict int int y int - int x get y noqa T skipIfTorchDynamo TorchDynamo fails test unknown reason test_dict_to_python torch jit ignore python_lookup my_dict Dict str int keys List str - List int my_dict k k keys fn my_dict Dict str int keys List str - List int python_lookup my_dict keys a_dict = torch ones b torch ones + c torch ones + checkScript fn a_dict c skipIfTorchDynamo TorchDynamo fails test unknown reason test_ordered_dict test_func fn inputs assertEqual fn inputs torch jit script fn inputs repeated_key OrderedDict test_func repeated_key no_args = OrderedDict one = torch tensor two = torch tensor test_func no_args test_dict_constructor = dict noqa C one = torch tensor dict noqa C test_func test_dict_constructor test_dict_initializer_list = torch tensor torch tensor output_order = key output_order append key output_order test_func test_dict_initializer_list test_dict_error = dict noqa C = assertRaisesRegexWithHighlight Exception Arguments call = torch jit script test_dict_error skipIfTorchDynamo TorchDynamo fails test unknown reason test_type_annotation_missing_contained_type Test use Dict type annotation without contained key value types produces error This function uses type comment fn_with_comment input Dict - Any input This function uses Python style type annotations annotated_fn input Dict - Any input assertRaisesRegex RuntimeError r Attempted use Dict without contained types cu = torch jit CompilationUnit cu define dedent inspect getsource fn_with_comment assertRaisesRegex RuntimeError r Attempted use Dict without contained types cu = torch jit CompilationUnit cu define dedent inspect getsource annotated_fn assertRaisesRegex RuntimeError r Attempted use Dict without contained types m = torch jit script fn_with_comment assertRaisesRegex RuntimeError r Attempted use Dict without contained types m = torch jit script annotated_fn skipIfTorchDynamo TorchDynamo fails test unknown reason test_dict_preserves_order dict_ordering Dict int int = i range i = i + checkScript dict_ordering di = torch jit script dict_ordering res = list di items i range key value = res i assertTrue key == i value == i + skipIfTorchDynamo TorchDynamo fails test unknown reason test_optional_dict_construct M torch nn Module use buffer Dict str Optional torch Tensor buffer prev_key forward x prev_key = torch rand next_key = torch rand saved_state Dict str Optional torch Tensor = prev_key prev_key next_key next_key use saved_state checkModule M torch rand TestNamedTuple JitTestCase test_namedtuple FeatureVector NamedTuple float_features float sequence_features List float time_since_first float torch jit script foo x - float fv = FeatureVector rv = fv float_features val fv sequence_features rv += val rv = fv time_since_first rv assertEqual foo torch rand test_namedtuple_constant Tup NamedTuple int b int torch jit script foo Tup assertEqual foo Tup test_return_named_tuple FeatureVector NamedTuple float_features float sequence_features List float time_since_first float torch jit script foo x fv = FeatureVector fv out = foo torch rand out = foo torch rand assertEqual out float_features assertEqual out sequence_features assertEqual out time_since_first test_namedtuple_as_attr Config NamedTuple size int MyMod nn Module configs Dict int Config __init__ configs super __init__ configs = configs forward x config configs values x += config size x s = torch jit script MyMod Config size= test_namedtuple_resolution TheType NamedTuple t int MyModule types ModuleType __init__ - None super __init__ MyModule __getattr__ attr TheType some_module = MyModule fn - some_module Type some_module Type checkScript fn test_namedtuple_slice_unpack MyCoolNamedTuple NamedTuple int b float c List int torch jit script foo int b float c List int tup = MyCoolNamedTuple b c my_a my_b my_c = tup tup my_a my_c assertEqual foo test_namedtuple_lower MyCoolNamedTuple NamedTuple int b float c List int torch jit script foo int tup = MyCoolNamedTuple tup FileCheck check TupleConstruct run foo graph torch _C _jit_pass_lower_all_tuples foo graph FileCheck check_not TupleConstruct run foo graph test_namedtuple_type_annotation global MyCoolNamedTuple see local resolution python MyCoolNamedTuple NamedTuple int b float c List int torch jit script foo x MyCoolNamedTuple - MyCoolNamedTuple x mnt = MyCoolNamedTuple assertEqual foo mnt mnt test_namedtuple_wrong_types MyCoolNamedTuple NamedTuple int b float c List int assertRaisesRegex RuntimeError Expected value type int argument instead found type str torch jit script foo tup = MyCoolNamedTuple foo bar baz tup test_namedtuple_kwarg_construct MyCoolNamedTuple NamedTuple int b float c List int torch jit script foo tup = MyCoolNamedTuple c= b= a= tup tup = foo assertEqual tup assertEqual tup b assertEqual tup c unittest skipIf True broken while these tests CI test_namedtuple_serialization MyCoolNamedTuple NamedTuple int b float c List int MyMod torch jit ScriptModule torch jit script_method forward MyCoolNamedTuple mm = MyMod mm save foo zip torch testing _internal jit_utils clear_class_registry loaded = torch jit load foo zip out = mm out_loaded = loaded name b c assertEqual getattr out_loaded name getattr out name test_namedtuple_inside_forwardref FeatureVector NamedTuple float_features float sequence_features List float time_since_first float torch jit script foo x - float fv = FeatureVector rv = fv float_features val fv sequence_features rv += val rv = fv time_since_first rv assertEqual foo torch rand test_namedtuple_input_forwardref MyNamedTuple NamedTuple int b float c torch Tensor make_global MyNamedTuple nt = MyNamedTuple torch rand fn obj MyNamedTuple obj c + obj b obj sin expected = fn nt fn_s = torch jit script fn actual = fn_s nt assertEqual expected actual see unittest expectedFailure test_namedtuple_resolution_forwardref TheType NamedTuple t int MyModule types ModuleType __init__ - None super __init__ MyModule __getattr__ attr TheType some_module = MyModule fn - some_module Type some_module Type checkScript fn TestScriptDict JitTestCase This contains suite tests torch jit script function returns dictionary-like object has reference semantics across Python TorchScript boundary That can passed TorchScript function mutates those modifications visible scope Python caller said TorchScript function The vast majority tests making sure objects returned torch jit script behave like dictionaries do so they fungible almost all cirumstances regular dictionaries _script_dict_add d torch _C ScriptDict k int v int This helper function inserts pair k v into dictionary d TorchScript It used testing reference semantics torch jit script dict_add d Dict int int k int v int d k = v dict_add d k v _compare_eager_and_script fn input_dict script_input_dict=None This helper function facilitates comparing behaviour between Python dictionaries scripted dictionaries Args fn The function test compare behaviour input_dict The input dictionary use test passed fn script_input_dict The scripted input dictionary use tests If None input_dict scripted torch jit script used instead Create ScriptDict version input_dict needed script_input_dict = script_input_dict torch jit script input_dict Run fn both input_dict scripted_dict eager_raised script_raised = False False try eager_out = fn input_dict except Exception e eager_exception = e eager_raised = True try script_out = fn script_input_dict except Exception e script_exception = e script_raised = True Check both calls raised none them raised assertEqual eager_raised script_raised eager_raised If fn raised exception should same between regular scripted dictionaries assertEqual type eager_exception type script_exception Otherwise make sure outputs match dictionaries match latter may same output assertEqual eager_out script_out assertEqual input_dict script_input_dict test_repr Test __repr__ method _compare_eager_and_script lambda d repr d test_bool Test __bool__ method This should True dictionary non-empty False otherwise _compare_eager_and_script lambda d bool d _compare_eager_and_script lambda d bool d test_iter Test iteration over dictionary s keys sum_keys input_dict s = k input_dict s += k s _compare_eager_and_script sum_keys test_items Test items sum_pair_product input_dict s = k v input_dict items s += k v s _compare_eager_and_script sum_pair_product test_getitem Test accessing dictionary values using operator data = _compare_eager_and_script lambda d d data _compare_eager_and_script lambda d d data _compare_eager_and_script lambda d d data _compare_eager_and_script lambda d d key data test_setitem Test setting dictionary values using operator data = fn input_dict input_dict = input_dict = _compare_eager_and_script fn data Check using improperly typed keys values throws TypeError _compare_eager_and_script cannot used here since following uses __setitem__ valid Python script_data = torch jit script data assertRaises TypeError script_data str = assertRaises TypeError script_data = str test_contains Test membership checks x y x y data = fn input_dict input_dict input_dict input_dict input_dict _compare_eager_and_script fn data Check using improperly typed key throws KeyError script_data = torch jit script data assertRaises KeyError = str script_data test_delitem Test deletion data = del_fn input_dict del input_dict del_fn_raises input_dict del input_dict _compare_eager_and_script del_fn data _compare_eager_and_script del_fn_raises data Check using improperly typed key throws TypeError script_data = torch jit script data assertRaises TypeError del script_data str test_len Test len builtin function _compare_eager_and_script lambda d len d _compare_eager_and_script lambda d len d unittest skip Cannot pass until all dicts returned TorchScript ScriptDicts test_nested Test reference semantics honoured when ScriptDict mutated using TorchScript inside another nested = torch jit script type_hint=Dict int Dict int int one = nested two = nested _script_dict_add one _script_dict_add two The mutation should visible original dictionary nested assertEqual len one assertEqual len two assertEqual len nested assertEqual len nested test_reference_semantics Test reference semantics honoured modifications made ScriptDict TorchScript visible Python data = torch jit script _script_dict_add data The mutation should visible original dictionary assertEqual len data assertTrue data assertEqual data TestScriptList JitTestCase This contains suite tests torch _C ScriptList function returns list-like object has reference semantics across Python TorchScript boundary That can passed TorchScript function mutates those modifications visible scope Python caller said TorchScript function The vast majority tests making sure instances torch _C ScriptList behave like lists do so they fungible almost all cirumstances regular list _script_list_add l torch _C ScriptList e int This helper function inserts element e into list l TorchScript It used testing reference semantics torch jit script list_add l List int e int l append e list_add l e _compare_eager_and_script fn input_list script_input_list=None This helper function facilitates comparing behaviour between Python lists scripted lists Args fn The function test compare behaviour input_list The input list use test passed fn script_input_list The scripted input list use tests If None input_list scripted torch jit script used instead Create ScriptDict version input_list needed script_input_list = script_input_list torch jit script input_list Run fn both input_list scripted_dict eager_raised script_raised = False False try eager_out = fn input_list except Exception e eager_exception = e eager_raised = True try script_out = fn script_input_list except Exception e script_exception = e script_raised = True Check both calls raised none them raised assertEqual eager_raised script_raised eager_raised If fn raised exception should same between regular scripted lists assertEqual type eager_exception type script_exception Otherwise make sure outputs match lists match latter may same output assertEqual eager_out script_out assertEqual input_list script_input_list test_repr Test __repr__ method _compare_eager_and_script lambda l repr l test_bool Test __bool__ method This should True list non-empty False otherwise _compare_eager_and_script lambda l bool l _compare_eager_and_script lambda l bool l test_iter Test iteration over list s elements sum_elements input_list s = k input_list s += k s _compare_eager_and_script sum_elements test_getitem Test accessing list elements using operator data = Test regular indexing _compare_eager_and_script lambda l l data _compare_eager_and_script lambda l l data _compare_eager_and_script lambda l l - data Test slicing _compare_eager_and_script lambda l l data _compare_eager_and_script lambda l l data _compare_eager_and_script lambda l l data _compare_eager_and_script lambda l l data _compare_eager_and_script lambda l l - data _compare_eager_and_script lambda l l - - data Test errors _compare_eager_and_script lambda l l data _compare_eager_and_script lambda l l - data _compare_eager_and_script lambda l l key data test_setitem Test setting list elements using operator data = Test regular assignment setitem input_list input_list = input_list = input_list - = _compare_eager_and_script setitem data copy Test slice assignment TODO Something like input_list = allowed Python pybind stl_bind h does allow Should we setitem_slice input_list input_list = input_list - = _compare_eager_and_script setitem_slice data Test errors out_of_range input_list input_list = out_of_range_negative input_list input_list - = wrong_index_type input_list input_list str = _compare_eager_and_script out_of_range data _compare_eager_and_script out_of_range_negative data _compare_eager_and_script wrong_index_type data Check using value incorrect type throws TypeError _compare_eager_and_script cannot used here since following use __setitem__ valid Python script_data = torch jit script data assertRaises TypeError script_data = str test_contains Test membership checks x y x y data = fn input_list input_list input_list input_list input_list _compare_eager_and_script fn data Check using value incorrect type throws TypeError script_data = torch jit script data assertRaises TypeError = str script_data test_delitem Test deletion data = del_fn input_list del input_list del_fn_out_of_range input_list del input_list del_fn_wrong_type input_list del input_list str _compare_eager_and_script del_fn data copy _compare_eager_and_script del_fn_out_of_range data _compare_eager_and_script del_fn_wrong_type data test_len Test len builtin function _compare_eager_and_script lambda l len l _compare_eager_and_script lambda l len l test_count Test count method _compare_eager_and_script lambda l l count Check using value incorrect type throws TypeError script_data = torch jit script assertRaises TypeError script_data count str test_remove Test remove method _compare_eager_and_script lambda l l remove _compare_eager_and_script lambda l l remove Check using value incorrect type throws TypeError script_data = torch jit script assertRaises TypeError script_data remove str test_append Test append method _compare_eager_and_script lambda l l append Check using value incorrect type throws TypeError script_data = torch jit script assertRaises TypeError script_data append str test_clear Test clear _compare_eager_and_script lambda l l clear test_extend Test extend Iterable __init__ limit int limit = limit value = __iter__ __next__ value == limit noqa F raise StopIteration ret = value value += ret data = extend_list input_list input_list extend extend_dict input_list input_list extend extend_iterable input_list input_list extend Iterable _compare_eager_and_script extend_list data copy _compare_eager_and_script extend_dict data copy _compare_eager_and_script extend_iterable data Check using value incorrect type throws TypeError script_data = torch jit script assertRaises TypeError script_data extend assertRaises TypeError script_data extend test_insert Test insert data = _compare_eager_and_script lambda l l insert data copy _compare_eager_and_script lambda l l insert data copy _compare_eager_and_script lambda l l insert - data Check using value incorrect type throws TypeError script_data = torch jit script assertRaises TypeError script_data insert str test_pop Test pop data = Test normal cases _compare_eager_and_script lambda l l pop data copy _compare_eager_and_script lambda l l pop data copy _compare_eager_and_script lambda l l pop - data copy Test error cases _compare_eager_and_script lambda l l pop data unittest skip Cannot pass until all list returned TorchScript ScriptLists test_nested Test reference semantics honoured when ScriptList mutated using TorchScript inside another nested = torch jit script List List int one = nested two = nested _script_list_add one _script_list_add two The mutation should visible original list nested assertEqual len one assertEqual len two assertEqual one len one - assertEqual two len one - assertEqual len nested assertEqual len nested test_reference_semantics Test reference semantics honoured modifications made ScriptList TorchScript visible Python l = torch jit script _script_list_add l assertEqual len l assertTrue l assertEqual l test_defaultdict get_dict test_dict = defaultdict list test_dict Test torch nn Module segments_groupby_col Dict str List str __init__ - None super __init__ segments_groupby_col = get_dict col = col = b forward col segments_groupby_col keys test = Test test_script = torch jit script test test_script segments_groupby_col Smoketest flakiness Takes around s _ range test = Test test_script = torch jit script test __name__ == __main__ raise_on_run_directly test test_jit py