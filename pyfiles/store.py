usr bin env python mypy allow-untyped-defs Copyright c Facebook Inc its affiliates All rights reserved This source code licensed under BSD-style license found LICENSE file root directory source tree collections abc Callable Iterable contextlib contextmanager datetime timedelta typing Optional torch DistStoreError = torch _C _DistStoreError _NUM_MEMBERS = num_members _LAST_MEMBER_CHECKIN = last_member _TRACE = TRACE _TRACING_GATE = TRACING_GATE _MAX_TRACE_MISSING_RANKS = __all__ = store_timeout get_all synchronize barrier contextmanager store_timeout store timeout float This sets timeout then restores old timeout when context manager exits Args store store set timeout timeout timeout set old_timeout = store timeout store set_timeout timedelta seconds=timeout yield store set_timeout old_timeout get_all store rank int prefix str world_size int r Given store prefix method goes through array keys following format ` ` prefix idx ` ` where idx range size tries retrieve data The Rank process waits end make sure all other processes finished procedure before exiting Usage values = get_all store torchelastic data value = values retrieves data key torchelastic data value = values retrieves data key torchelastic data value = values retrieves data key torchelastic data data_arr = store multi_get f prefix idx idx range world_size barrier_key = _barrier_nonblocking store=store world_size=world_size key_prefix=f prefix finished rank == Rank runs TCPStore daemon result needs exit last Otherwise barrier may timeout rank process finished work before other processes finished ` get_all ` method store wait barrier_key data_arr synchronize store data bytes rank int world_size int key_prefix str timeout float = - list bytes Synchronizes ` ` world_size ` ` agents between each other using underlying c d store The ` ` data ` ` will available each agents Note The data path deleted result there can stale data you use same key_prefix twice Time complexity O N per worker O N^ globally store_timeout store timeout store set f key_prefix rank data agent_data = get_all store rank key_prefix world_size agent_data _try_detecting_missing_ranks store world_size int key_prefix str rank int rank_decoder Callable int str trace_timeout float - Optional Iterable str store set f key_prefix rank _TRACE val_ignored _find_missing_ranks missing_rank_info = set ranks_missing = i range world_size reduce noise assuming general ranks per node It valuable know nodes have timed-out ranks_missing = _MAX_TRACE_MISSING_RANKS break try ranks_missing == store wait f key_prefix i _TRACE timedelta seconds=trace_timeout use shortest timeout some ranks have failed check-in store wait f key_prefix i _TRACE timedelta milliseconds= except DistStoreError ranks_missing += missing_rank_info add rank_decoder i missing_rank_info _checkin try store wait f key_prefix _TRACING_GATE f check rank rank_decoder missing rank info except DistStoreError case rank source timeout original exception will raised None rank == missing_rank_info = _find_missing_ranks store set f key_prefix _TRACING_GATE val_ignored missing_rank_info _checkin _barrier_nonblocking store world_size int key_prefix str - str Does all non-blocking operations barrier returns final key can waited num_members_key = key_prefix + _NUM_MEMBERS last_member_key = key_prefix + _LAST_MEMBER_CHECKIN idx = store add num_members_key idx == world_size store set last_member_key val_ignored last_member_key barrier store world_size int key_prefix str barrier_timeout float = rank Optional int = None rank_tracing_decoder Optional Callable int str = None trace_timeout float = - None A global lock between agents This will pause all workers until least ` ` world_size ` ` workers respond This uses fast incrementing index assign waiting ranks success flag set last worker Time complexity O per worker O N globally Optionally passing rank will enable tracing missing ranks timeouts ` rank_tracing_decoder ` lambda arg can used convert rank data into more meaningful information app level e g hostname Note Since data removed store barrier can used once per unique ` ` key_prefix ` ` rank None assert rank_tracing_decoder None Tracing requires rank information store_timeout store barrier_timeout last_member_key = _barrier_nonblocking store=store world_size=world_size key_prefix=key_prefix try store wait last_member_key except DistStoreError e rank None raise e missing_ranks = _try_detecting_missing_ranks store world_size key_prefix rank rank_tracing_decoder lambda x str x trace_timeout missing_ranks None raise DistStoreError Timed out waiting barrier rank key prefix world_size= missing_ranks= timeout= format rank key_prefix world_size f join missing_ranks barrier_timeout None raise e