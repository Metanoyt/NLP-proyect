contextlib copy hashlib importlib inspect io os pickle tokenize unittest collections abc Callable dataclasses dataclass types FunctionType ModuleType typing Any Generic NoReturn Optional TYPE_CHECKING TypeVar Union typing_extensions deprecated unittest mock torch _utils_internal justknobs_check Types saved loaded configs CONFIG_TYPES = int float bool type None str list set tuple dict Duplicated because mypy needs these types statically T = TypeVar T bound=Union int float bool None str list set tuple dict _UNSET_SENTINEL = object dataclass kw_only=True _Config Generic T Represents config richer behaviour than just default value i e foo = Config justknob= foo bar default=False install_config_module This configs must installed install_config_module used Precedence Order alias If set directly use value alias env_name_force If set environment variable has precedence over everything after If multiple env variables given precedence order left right user_override If user sets value i e foo bar=True has precedence over everything after env_name_default If set environment variable will override everything after If multiple env variables given precedence order left right justknob If pytorch installation supports justknobs will override defaults will override user_override precedence default This value lowest precedence will used nothing set Environment Variables These interpreted either represent true false Arguments justknob name feature JK In OSS unused default value default knob OSS alias The alias config read instead env_name_force The environment variable list read FORCE environment variable I e overrides everything except alias env_name_default The environment variable list read changes default behaviour I e user overrides take preference default Union T object justknob Optional str = None env_name_default Optional list str = None env_name_force Optional list str = None value_type Optional type = None alias Optional str = None __post_init__ - None env_name_default = _Config string_or_list_of_string_to_list env_name_default env_name_force = _Config string_or_list_of_string_to_list env_name_force alias None default _UNSET_SENTINEL justknob None env_name_default None env_name_force None raise AssertionError alias set none default justknob \ env_name_default env_name_force can set staticmethod string_or_list_of_string_to_list val Optional Union str list str - Optional list str val None None isinstance val str val isinstance val list raise AssertionError f val list got type val val In runtime we unbox Config T T typechecker cannot see so order allow dynamic behavior work correctly typechecking we going lie typechecker Config T returns T TYPE_CHECKING Config default Union T object = _UNSET_SENTINEL justknob Optional str = None env_name_default Optional Union str list str = None env_name_force Optional Union str list str = None value_type Optional type = None alias Optional str = None - T Config default Union T object = _UNSET_SENTINEL justknob Optional str = None env_name_default Optional Union str list str = None env_name_force Optional Union str list str = None value_type Optional type = None alias Optional str = None - _Config T _Config default=default justknob=justknob env_name_default=env_name_default env_name_force=env_name_force value_type=value_type alias=alias _read_env_variable name str - Optional Union bool str value = os environ get name value == True value == False value install_config_module module ModuleType - None Converts module-level config into ` ConfigModule ` See _config_typing pyi instructions how get converted module typecheck ConfigModuleInstance ConfigModule __annotations__ written Sphinx autodoc _bypass_keys = set _is_dirty _hash_digest __annotations__ visit source Union ModuleType type dest Union ModuleType SubConfigProxy prefix str - None Walk module structure move everything module _config type_hints = inspect get_annotations source key value list source __dict__ items key startswith __ isinstance value ModuleType FunctionType hasattr value __module__ value __module__ == typing Handle torch utils _config_module Config isinstance value type issubclass value _Config continue name = f prefix key annotated_type = type_hints get key None isinstance value CONFIG_TYPES config name = _ConfigEntry _Config default=value value_type=annotated_type dest module delattr module key isinstance value _Config annotated_type None value value_type None value value_type = annotated_type config name = _ConfigEntry value dest module delattr module key isinstance value type value __module__ = module __name__ raise AssertionError f subconfig value must defined module module __name__ subconfig ` Blah ` syntax proxy = SubConfigProxy module f name visit value proxy f name dest module setattr dest key proxy dest __dict__ key = proxy raise AssertionError f Unhandled config key = value type value config dict str _ConfigEntry = compile_ignored_keys = get_assignments_with_compile_ignored_comments module visit module module module _config = config type ignore attr-defined module _compile_ignored_keys = compile_ignored_keys type ignore attr-defined module __class__ = ConfigModuleInstance module _is_dirty = True type ignore attr-defined module _hash_digest = None type ignore attr-defined COMPILE_IGNORED_MARKER = compile_ignored Gets all keys i e assignments compile_ignored comment get_assignments_with_compile_ignored_comments module ModuleType - set str source_code = inspect getsource module assignments = set Tokenize source code retrieve comments tokens = tokenize tokenize io BytesIO source_code encode utf- readline current_comment = - prev_name = token tokens token type == tokenize COMMENT prev_name = maybe_current = token string strip COMPILE_IGNORED_MARKER maybe_current current_comment = - raise AssertionError f unconsumed COMPILE_IGNORED_MARKER current_comment = maybe_current token start token type == tokenize NAME Only accept first name token handle you have something like foo Bar = prev_name prev_name = token string token type == tokenize OP token string == = Check current assignment follows comment COMPILE_IGNORED_MARKER COMPILE_IGNORED_MARKER current_comment current_comment == token start - assignments add prev_name current_comment = - reset prev_name = current_comment = - raise AssertionError f unconsumed COMPILE_IGNORED_MARKER assignments dataclass _ConfigEntry The default value specified configuration default Any The type configuration value value_type type The value specified user when they overrode configuration _UNSET_SENTINEL indicates value set user_override Any = _UNSET_SENTINEL The justknob check config justknob Optional str = None environment variables read install time env_value_force Any = _UNSET_SENTINEL env_value_default Any = _UNSET_SENTINEL Used work arounds bad assumptions unittest mock patch The code blame https github com python cpython blob e fb f c e acca Lib unittest mock py#L Essentially mock patch requires __dict__ isn t accessible which isn t after delattr called object object must throw when hasattr called Otherwise doesn t call setattr again Technically we ll have intermediate state hiding config while mock patch unpatching itself calls setattr after delete call so final state correct It s just very unintuitive upstream bug - python cpython# hide bool = False alias Optional str = None __init__ config _Config default = config default value_type = config value_type config value_type None type default justknob = config justknob alias = config alias config env_name_default None val config env_name_default env_value = _read_env_variable val None env_value_default = env_value break config env_name_force None val config env_name_force env_value = _read_env_variable val None env_value_force = env_value break Ensure justknobs envvars allowlisted types justknob None default None isinstance default bool raise AssertionError f justknobs only support booleans default boolean value_type None config env_name_default None config env_name_force None value_type bool str Optional bool Optional str raise AssertionError f envvar configs only support optional booleans strings value_type neither ConfigModule ModuleType NOTE This should kept sync _config_typing pyi The actual configuration settings E g torch _dynamo config debug would live debug key torch _inductor config triton cudagraphs maps triton cudagraphs See discussion meaning various sub items _config dict str _ConfigEntry _bypass_keys set str _compile_ignored_keys set str _is_dirty bool _hash_digest Optional bytes __init__ - None raise NotImplementedError f use __name__ install_config_module sys modules __name__ __setattr__ name str value object - None name _bypass_keys super __setattr__ name value name _config raise AttributeError f __name__ name does exist _config name alias None _set_alias_val _config name value _config name user_override = value _is_dirty = True _config name hide = False __getattr__ name str - Any try config = _config name config hide raise AttributeError f __name__ name does exist alias_val = _get_alias_val config alias_val _UNSET_SENTINEL alias_val config env_value_force _UNSET_SENTINEL config env_value_force config user_override _UNSET_SENTINEL config user_override config env_value_default _UNSET_SENTINEL config env_value_default config justknob None JK only supports bools ints justknobs_check name=config justknob default=config default Note reference types can still modified so we copy them user_overrides case user overrides them isinstance config default list set dict config user_override = copy deepcopy config default config user_override config default except KeyError e make hasattr work properly raise AttributeError f __name__ name does exist e __delattr__ name str - None _is_dirty = True must support delete because unittest mock patch deletes then recreate things _config name user_override = _UNSET_SENTINEL _config name hide = True _get_alias_module_and_name entry _ConfigEntry - Optional tuple ModuleType str alias = entry alias alias None None module_name constant_name = alias rsplit try module = importlib import_module module_name except ImportError e raise AttributeError f config alias alias does exist e module constant_name _get_alias_val entry _ConfigEntry - Any data = _get_alias_module_and_name entry data None _UNSET_SENTINEL module constant_name = data constant_value = getattr module constant_name constant_value _set_alias_val entry _ConfigEntry val Any - None data = _get_alias_module_and_name entry data None raise AssertionError alias data should None when setting alias value module constant_name = data setattr module constant_name val _is_default name str - bool Returns true config its default value configs overridden env considered default config_val = _config name The config overridden user env_value_default different default value meaning user has set env change default value not_set_env_default = config_val env_value_default _UNSET_SENTINEL config_val env_value_default == config_val default not_set_env_force = config_val env_value_force _UNSET_SENTINEL config_val env_value_force == config_val default unset = config_val user_override _UNSET_SENTINEL Handle reference types specially avoid spammy warnings isinstance config_val default list set dict unset = unset config_val user_override == config_val default unset not_set_env_default not_set_env_force _get_dict ignored_keys Optional list str = None ignored_prefixes Optional list str = None skip_default bool = False - dict str Any Export dictionary current configuration keys values This function design provide single point which handles accessing config options exporting them into dictionary This used number different user facing export methods which all have slightly different semantics re how what skip If config aliased skips config Arguments ignored_keys keys should exported ignored_prefixes prefixes key matches should exported skip_default does two things One key has been modified skips config dict str Any = key _config ignored_keys key ignored_keys continue ignored_prefixes any key startswith prefix prefix ignored_prefixes continue skip_default _is_default key continue _config key alias None continue config key = copy deepcopy getattr key config get_type config_name str - type _config config_name value_type save_config - bytes Convert config pickled blob ignored_keys = getattr _save_config_ignore pickle dumps _get_dict ignored_keys=ignored_keys protocol= save_config_portable ignore_private_configs bool = True - dict str Any Convert config portable format prefixes = ignore_private_configs prefixes append _ prefixes extend getattr _cache_config_ignore_prefix _get_dict ignored_prefixes=prefixes codegen_config - str Convert config Python statements replicate current config This does NOT include config settings default values additional imports required imports = set get_module_name func Callable add_dot bool - str module_name = func __module__ module_name == builtins module_name = add_dot module_name = module_name += module_name add_import func Callable - None module_name = get_module_name func False module_name imports add module_name list_of_callables_to_string v Union list set - list str f get_module_name item True item __name__ item v importable_callable v Any - bool functools partial has no attributes below callable callable v hasattr v __module__ hasattr v __name__ get_config_line mod k v - str type ignore no-untyped-def Return string version config line Handle v when v callable list dict callables Add statements callables necessary We assume value single config won t mix callables non-callables Example output logging _warnings torch _dynamo config reorderable_logging_functions = _warnings warn logging warn print importable_callable v add_import v f mod k = get_module_name v True v __name__ isinstance v list set all importable_callable item item v item v add_import item v_list = list_of_callables_to_string v isinstance v list f mod k = v_list f mod k = join v_list f mod k = v r lines = mod = __name__ k v _get_dict ignored_keys=getattr _save_config_ignore skip_default=True items lines append get_config_line mod k v import_name imports lines insert f import_name \n join lines get_hash - bytes Hashes configs compile_ignored _is_dirty _hash_digest None dict_to_hash = _get_dict ignored_keys=list _compile_ignored_keys string_to_hash = repr sorted dict_to_hash items _hash_digest = hashlib md string_to_hash encode utf- usedforsecurity=False digest _is_dirty = False _hash_digest deprecated ` config to_dict ` has been deprecated It no longer changes underlying config use ` config get_config_copy ` instead you just want copy config config load_config you need mutable access category=FutureWarning to_dict - dict str Any get_config_copy deprecated ` config shallow_copy_dict ` has been deprecated It no longer changes underlying config use ` config get_config_copy ` instead you just want copy config config load_config you need mutable access category=FutureWarning shallow_copy_dict - dict str Any get_config_copy load_config maybe_pickled_config Union bytes dict str Any - None Restore prior call save_config shallow_copy_dict isinstance maybe_pickled_config dict config = pickle loads maybe_pickled_config config = maybe_pickled_config k v config items k _config setattr k v torch _dynamo utils warn_once warn_once f key k value v understood config get_config_copy - dict str Any _get_dict get_serializable_config_copy - dict str Any _get_dict ignored_keys=getattr _save_config_ignore patch arg Optional Union str dict str Any = None arg Any = None kwargs dict str Any - ContextDecorator Decorator context manager make temporary changes config As decorator config patch name val config patch name =val name =val config patch name val name val foo As context manager config patch name val changes dict str Any arg None arg None isinstance arg str raise AssertionError first argument must string when passing positional args patch patch key True syntax changes = arg arg isinstance arg dict raise AssertionError first argument must dict when passing single positional arg patch patch key True syntax changes = arg kwargs raise AssertionError cannot pass both positional keyword arguments patch patch key=True syntax changes = kwargs arg None raise AssertionError second positional argument only valid when first argument key string isinstance changes dict raise AssertionError f expected ` dict ` got type changes prior dict str Any = config = ConfigPatch ContextDecorator __init__ - None changes = changes __enter__ - None prior raise AssertionError prior should empty when entering ConfigPatch key changes keys KeyError invalid entry prior key = config __getattr__ key k v changes items config __setattr__ k v __exit__ exc_type exc_val exc_tb type ignore no-untyped-def k v prior items config __setattr__ k v prior clear ConfigPatch _make_closure_patcher changes dict str Any - Any A lower-overhead version patch things critical path Usage do off critical path change_fn = config make_closure_patcher foo=True revert = change_fn try finally revert config = _config change - Callable None prior = k config k user_override k changes k v changes items _config k user_override = v revert - None k v prior items _config k user_override = v revert change ContextDecorator contextlib ContextDecorator Same contextlib ContextDecorator support ` unittest TestCase ` __enter__ - None raise NotImplementedError NYI __exit__ exc_type exc_val exc_tb - NoReturn type ignore no-untyped-def raise NotImplementedError NYI __call__ func Callable Any Any - Any isinstance func type issubclass func unittest TestCase _TestCase func type ignore valid-type misc classmethod setUpClass cls - None __enter__ try super setUpClass except Exception __exit__ None None None raise classmethod tearDownClass cls - None try super tearDownClass finally __exit__ None None None _TestCase __name__ = func __name__ _TestCase __qualname__ = func __qualname__ _TestCase __module__ = func __module__ _TestCase super __call__ func SubConfigProxy Shim redirect main config ` config triton cudagraphs ` maps _config triton cudagraphs __init__ config object prefix str ` super __setattr__ ` bypass custom ` __setattr__ ` super __setattr__ _config config super __setattr__ _prefix prefix __setattr__ name str value object - None _config __setattr__ _prefix + name value __getattr__ name str - Any _config __getattr__ _prefix + name __delattr__ name str - None _config __delattr__ _prefix + name patch_object obj object name str value object - object Workaround ` mock patch object ` issue ConfigModule isinstance obj ConfigModule obj patch name value mock patch object obj name value get_tristate_env name str default Any = None - Optional bool value = os environ get name value == True value == False default