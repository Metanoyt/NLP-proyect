mypy allow-untyped-defs Copyright c Meta Platforms Inc its affiliates All rights reserved This source code licensed under BSD-style license found LICENSE file root directory source tree io json os select signal sys threading time collections abc Callable typing Optional TypeVar typing_extensions ParamSpec torch distributed elastic timer api TimerClient TimerRequest torch distributed elastic timer debug_info_logging log_debug_info_for_expired_timers torch distributed elastic utils logging get_logger _P = ParamSpec _P _R = TypeVar _R __all__ = FileTimerClient FileTimerRequest FileTimerServer logger = get_logger __name__ _retry max_retries int sleep_time float - Callable A simple retry wrapper Args max_retries int maximum number retries sleep_time float time sleep between retries wrapper func Callable _P _R - Callable _P _R wrapper args _P args kwargs _P kwargs i range max_retries try func args kwargs except Exception logger exception Error running s Retrying func __name__ i max_retries - time sleep sleep_time raise wrapper wrapper FileTimerRequest TimerRequest Data object representing countdown timer acquisition release used between ` ` FileTimerClient ` ` ` ` FileTimerServer ` ` A negative ` ` expiration_time ` ` should interpreted release request ` ` signal ` ` signal reap worker process server process __slots__ = version worker_pid scope_id expiration_time signal __init__ worker_pid int scope_id str expiration_time float signal int = - None version = worker_pid = worker_pid scope_id = scope_id expiration_time = expiration_time signal = signal __eq__ other - bool isinstance other FileTimerRequest version == other version worker_pid == other worker_pid scope_id == other scope_id expiration_time == other expiration_time signal == other signal False to_json - str json dumps version version pid worker_pid scope_id scope_id expiration_time expiration_time signal signal FileTimerClient TimerClient Client side ` ` FileTimerServer ` ` This client meant used same host ` ` FileTimerServer ` ` running uses pid uniquely identify worker This client uses named_pipe send timer requests ` ` FileTimerServer ` ` This client producer while ` ` FileTimerServer ` ` consumer Multiple clients can work same ` ` FileTimerServer ` ` Args file_path str path FIFO special file ` ` FileTimerServer ` ` must have created calling os mkfifo signal signal signal use kill process Using negative zero signal will kill process __init__ file_path str signal= signal SIGKILL sys platform = win signal CTRL_C_EVENT type ignore attr-defined - None super __init__ _file_path = file_path signal = signal _retry max_retries= sleep_time= _open_non_blocking - Optional io TextIOWrapper The server may have crashed may haven t started yet In such case calling open blocking model blocks client To avoid such issue open non-blocking mode OSError will raised server there fd = os open _file_path os O_WRONLY &#124; os O_NONBLOCK os fdopen fd wt _send_request request FileTimerRequest - None try file = _open_non_blocking except Exception e raise BrokenPipeError Could send FileTimerRequest because FileTimerServer available e file json_request = request to_json Write request no greater than select PIPE_BUF guarantee atomic len json_request select PIPE_BUF raise RuntimeError f FileTimerRequest larger than select PIPE_BUF bytes f supported json_request file write json_request + \n acquire scope_id str expiration_time float - None _send_request request=FileTimerRequest worker_pid=os getpid scope_id=scope_id expiration_time=expiration_time signal=self signal release scope_id str - None _send_request request=FileTimerRequest worker_pid=os getpid scope_id=scope_id expiration_time=- signal= FileTimerServer Server works ` ` FileTimerClient ` ` Clients expected running same host process running server Each host job expected start its own timer server locally each server instance manages timers local workers running processes same host Args file_path str path FIFO special file created max_interval float max interval seconds each watchdog loop daemon bool running watchdog thread daemon mode A daemon thread will block process stop log_event Callable Dict str str None optional callback logging events JSON format __init__ file_path str run_id str max_interval float = daemon bool = True log_event Optional Callable str Optional FileTimerRequest None = None - None _file_path = file_path _run_id = run_id _max_interval = max_interval _daemon = daemon _timers dict tuple int str FileTimerRequest = _stop_signaled = False _watchdog_thread Optional threading Thread = None _is_client_started = False os path exists _file_path os remove _file_path os mkfifo _file_path For test only Count number requests received _request_count = For test only Process all requests stop server _run_once = False _log_event = log_event log_event None lambda name request None _last_progress_time = int time time start - None logger info Starting s max_interval= s daemon= s file_path= s type __name__ _max_interval _daemon _file_path _watchdog_thread = threading Thread target=self _watchdog_loop daemon=self _daemon logger info Starting watchdog thread _watchdog_thread start _log_event watchdog started None stop - None logger info Stopping s type __name__ _stop_signaled = True _watchdog_thread logger info Stopping watchdog thread _watchdog_thread join _max_interval _watchdog_thread = None logger info No watchdog thread running doing nothing os path exists _file_path os remove _file_path _log_event watchdog stopped None run_once - None _run_once = True _watchdog_thread logger info Stopping watchdog thread _watchdog_thread join _watchdog_thread = None logger info No watchdog thread running doing nothing os path exists _file_path os remove _file_path staticmethod is_process_running pid int function check process running try Check process exists we can send signals os kill pid True except OSError False _watchdog_loop - None Open pipe blocking mode blocks server thread This fine following reasons No client case usually does happen We running watchdog loop separate daemon thread which will block process stop try fd = open _file_path except Exception logger exception Could open FileTimerServer pipe raise fd _is_client_started = True while _stop_signaled try run_once = _run_once _run_watchdog fd run_once break _last_progress_time = int time time except Exception logger exception Error running watchdog _run_watchdog fd io TextIOWrapper - None timer_requests = _get_requests fd _max_interval register_timers timer_requests now = time time reaped_worker_pids = set kill_process = False reap_signal = all_expired_timers = get_expired_timers now log_debug_info_for_expired_timers _run_id pid expired_timer to_json expired_timer expired_timers pid expired_timers all_expired_timers items worker_pid expired_timers all_expired_timers items logger info Reaping worker_pid= s Expired timers s worker_pid _get_scopes expired_timers reaped_worker_pids add worker_pid In case we have multiple expired timers we find first timer valid signal expiration time order expired_timers sort key=lambda timer timer expiration_time signal = expired_timer = None timer expired_timers _log_event timer expired timer timer signal signal = timer signal expired_timer = timer break signal = logger info No signal specified worker= s Do reap worker_pid continue _reap_worker worker_pid signal logger info Successfully reaped worker= s signal= s worker_pid signal _log_event kill worker process expired_timer kill_process = True reap_signal = signal logger error Error reaping worker= s Will retry next watchdog worker_pid kill_process reap_signal logger info Terminating server process= s because expired timers os getpid _reap_worker os getpid reap_signal clear_timers reaped_worker_pids _get_scopes timer_requests list FileTimerRequest - list str r scope_id r timer_requests _get_requests fd io TextIOWrapper max_interval float - list FileTimerRequest start = time time requests = while _stop_signaled _run_once For named pipe readline blocking when least one writer opens It returns only when flush called writer side Note flush automatically called inside close After last writer closes readline blocking It will empty string when s end-of-file Since client side always opens pipe writes message closes pipe immediately readline call below blocking long json_request = fd readline len json_request == _run_once break time sleep min max_interval request = json loads json_request pid = request pid scope_id = request scope_id expiration_time = request expiration_time signal = request signal requests append FileTimerRequest worker_pid=pid scope_id=scope_id expiration_time=expiration_time signal=signal now = time time now - start max_interval break requests register_timers timer_requests list FileTimerRequest - None request timer_requests pid = request worker_pid scope_id = request scope_id expiration_time = request expiration_time _request_count += key = pid scope_id negative expiration proxy release call expiration_time key _timers del _timers key _timers key = request clear_timers worker_pids set int - None pid scope_id list _timers keys pid worker_pids FileTimerServer is_process_running pid del _timers pid scope_id get_expired_timers deadline float - dict int list FileTimerRequest pid - timer_requests expired_timers dict int list FileTimerRequest = request _timers values request expiration_time = deadline expired_scopes = expired_timers setdefault request worker_pid expired_scopes append request expired_timers _reap_worker worker_pid int signal int - bool try os kill worker_pid signal True except ProcessLookupError logger info Process pid= s does exist Skipping worker_pid True except Exception logger exception Error terminating pid= s worker_pid False get_last_progress_time - int _last_progress_time _is_client_started int time time