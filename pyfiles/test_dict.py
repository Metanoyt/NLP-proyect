======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_dict py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils run_tests xfailIfTorchDynamo __TestCase = CPythonTestCase redirect statements sys importlib abc redirect_imports = test mapping_tests test typinganndata test test_grammar test test_math test test_iter test typinganndata ann_module RedirectImportFinder importlib abc MetaPathFinder find_spec fullname path target=None Check problematic one fullname redirect_imports try Attempt standalone module name = fullname removeprefix test r = importlib import_module name Redirect module sys modules sys modules fullname = r Return module spec found module importlib util find_spec name except ImportError None None Add custom finder sys meta_path sys meta_path insert RedirectImportFinder ======= END DYNAMO PATCH ======= collections collections abc gc pickle random string sys unittest weakref test support test support import_helper get_c_recursion_limit DictTest __TestCase test_invalid_keyword_arguments torch _dynamo error_on_graph_break False Custom dict pass invalid Custom assertRaises TypeError dict invalid assertRaises TypeError update invalid test_constructor calling built-in types without argument must empty assertEqual dict assertIsNot dict test_literal_constructor check literal constructor different sized dicts exercise BUILD_MAP oparg n items = join random sample string ascii_letters i i range n random shuffle items formatted_items = r d format k v k v items dictliteral = + join formatted_items + assertEqual eval dictliteral dict items test_merge_operator = b = c = copy c &#124; = b assertEqual &#124; b assertEqual c c = b copy c &#124; = assertEqual b &#124; assertEqual c c = copy c &#124; = assertEqual c assertIs __or__ None NotImplemented assertIs __or__ NotImplemented assertIs __or__ BAD NotImplemented assertIs __or__ NotImplemented assertRaises TypeError __ior__ None assertEqual __ior__ assertRaises ValueError __ior__ BAD assertEqual __ior__ test_bool assertIs True assertTrue assertIs bool False assertIs bool True test_keys d = assertEqual set d keys set d = b k = d keys assertEqual set k b assertIn k assertIn b k assertIn d assertIn b d assertRaises TypeError d keys None assertEqual repr dict a= keys dict_keys test_values d = assertEqual set d values set d = assertEqual set d values assertRaises TypeError d values None assertEqual repr dict a= values dict_values test_items d = assertEqual set d items set d = assertEqual set d items assertRaises TypeError d items None assertEqual repr dict a= items dict_items test_views_mapping mappingproxy = type type __dict__ torch _dynamo error_on_graph_break False Dict dict pass cls dict Dict d = cls m = d keys mapping m = d values mapping m = d items mapping m m m m assertIsInstance m mappingproxy assertEqual m d d foo = bar m m m m assertIsInstance m mappingproxy assertEqual m d test_contains d = assertNotIn d assertFalse d assertTrue d d = b assertIn d assertIn b d assertNotIn c d assertRaises TypeError d __contains__ test_len d = assertEqual len d d = b assertEqual len d test_getitem d = b assertEqual d assertEqual d b d c = d = assertEqual d c assertEqual d del d b assertEqual d c assertRaises TypeError d __getitem__ torch _dynamo error_on_graph_break False BadEq object __eq__ other raise Exc __hash__ d = d BadEq = assertRaises KeyError d __getitem__ torch _dynamo error_on_graph_break False Exc Exception pass BadHash object fail = False __hash__ fail raise Exc x = BadHash d x = x fail = True assertRaises Exc d __getitem__ x test_clear d = d clear assertEqual d assertRaises TypeError d clear None test_update d = d update d update d update assertEqual d d update assertEqual d assertRaises TypeError AttributeError d update None torch _dynamo error_on_graph_break False SimpleUserDict __init__ d = keys d keys __getitem__ i d i d clear d update SimpleUserDict assertEqual d torch _dynamo error_on_graph_break False Exc Exception pass d clear torch _dynamo error_on_graph_break False FailingUserDict keys raise Exc assertRaises Exc d update FailingUserDict torch _dynamo error_on_graph_break False FailingUserDict keys BogonIter __init__ i = __iter__ __next__ i i = raise Exc BogonIter __getitem__ key key assertRaises Exc d update FailingUserDict torch _dynamo error_on_graph_break False FailingUserDict keys BogonIter __init__ i = ord __iter__ __next__ i = ord z rtn = chr i i += rtn raise StopIteration BogonIter __getitem__ key raise Exc assertRaises Exc d update FailingUserDict torch _dynamo error_on_graph_break False badseq object __iter__ __next__ raise Exc assertRaises Exc update badseq assertRaises ValueError update unittest skip test hangs test_fromkeys assertEqual dict fromkeys abc None b None c None d = assertIsNot d fromkeys abc d assertEqual d fromkeys abc None b None c None assertEqual d fromkeys assertEqual d fromkeys g yield assertEqual d fromkeys g None assertRaises TypeError fromkeys torch _dynamo error_on_graph_break False dictlike dict pass assertEqual dictlike fromkeys None assertEqual dictlike fromkeys None assertIsInstance dictlike fromkeys dictlike assertIsInstance dictlike fromkeys dictlike torch _dynamo error_on_graph_break False mydict dict __new__ cls collections UserDict ud = mydict fromkeys ab assertEqual ud None b None assertIsInstance ud collections UserDict assertRaises TypeError dict fromkeys torch _dynamo error_on_graph_break False Exc Exception pass baddict dict __init__ raise Exc assertRaises Exc baddict fromkeys torch _dynamo error_on_graph_break False BadSeq object __iter__ __next__ raise Exc assertRaises Exc dict fromkeys BadSeq torch _dynamo error_on_graph_break False baddict dict __setitem__ key value raise Exc assertRaises Exc baddict fromkeys test fast path dictionary inputs res = dict zip range d = dict zip range range assertEqual dict fromkeys d res test fast path set inputs d = set range assertEqual dict fromkeys d res test slow path other iterable inputs d = list range assertEqual dict fromkeys d res test fast path when object s constructor returns large non-empty dict torch _dynamo error_on_graph_break False baddict dict __new__ cls d d = i i i range res = d copy res update a=None b=None c=None assertEqual baddict fromkeys b c res test slow path when object proper subclass dict torch _dynamo error_on_graph_break False baddict dict __init__ dict __init__ d d = i i i range res = d copy res update a=None b=None c=None assertEqual baddict fromkeys b c res test_copy d = assertIsNot d copy d assertEqual d copy d assertEqual d copy copy = d copy d = assertNotEqual copy d assertEqual copy assertRaises TypeError d copy None test_copy_fuzz dict_size dict_size = random randrange dict_size dict_size + dict_size subTest dict_size=dict_size d = i range dict_size d i = i d = d copy assertIsNot d d assertEqual d d d key = value assertNotEqual d d assertEqual len d len d + test_copy_maintains_tracking torch _dynamo error_on_graph_break False A pass key = A d key val d = d copy assertEqual gc is_tracked d gc is_tracked d test_copy_noncompact Dicts don t compact themselves del pop operations Copy will use slow merging strategy produces compacted copy when roughly dict non-used keys-space optimize memory footprint In test we want hit slow compacting branch dict copy make sure works OK d = k k k range k range del d k d = d copy assertEqual d d test_get d = assertIs d get c None assertEqual d get c d = b assertIs d get c None assertEqual d get c assertEqual d get assertEqual d get assertRaises TypeError d get assertRaises TypeError d get None None None test_setdefault dict setdefault d = assertIs d setdefault key None d setdefault key assertIs d setdefault key None d setdefault key append assertEqual d key d setdefault key append assertEqual len d key assertRaises TypeError d setdefault torch _dynamo error_on_graph_break False Exc Exception pass BadHash object fail = False __hash__ fail raise Exc x = BadHash d x = x fail = True assertRaises Exc d setdefault x test_setdefault_atomic Issue setdefault calls __hash__ __eq__ only once torch _dynamo error_on_graph_break False Hashed object __init__ hash_count = eq_count = __hash__ hash_count += __eq__ other eq_count += id == id other hashed = Hashed y = hashed hashed = Hashed y setdefault hashed assertEqual hashed hash_count assertEqual hashed hash_count assertEqual hashed eq_count + hashed eq_count test_setitem_atomic_at_resize torch _dynamo error_on_graph_break False Hashed object __init__ hash_count = eq_count = __hash__ hash_count += __eq__ other eq_count += id == id other hashed = Hashed items y = hashed hashed = Hashed th item forces resize y hashed = assertEqual hashed hash_count assertEqual hashed hash_count assertEqual hashed eq_count + hashed eq_count test_popitem dict popitem copymode - + - b has same structure + b copy log size range size = log size = b = i range size repr i = i copymode b repr i = i copymode b = copy i range size ka va = ta = popitem assertEqual va int ka kb vb = tb = b popitem assertEqual vb int kb assertFalse copymode ta = tb assertFalse assertFalse b d = assertRaises KeyError d popitem test_pop Tests pop specified key d = k v = abc d k = v assertRaises KeyError d pop ghi assertEqual d pop k v assertEqual len d assertRaises KeyError d pop k assertEqual d pop k v v d k = v assertEqual d pop k v assertRaises TypeError d pop torch _dynamo error_on_graph_break False Exc Exception pass BadHash object fail = False __hash__ fail raise Exc x = BadHash d x = x fail = True assertRaises Exc d pop x test_mutating_iteration changing dict size during iteration d = d = assertRaises RuntimeError i d d i+ = test_mutating_iteration_delete change dict content during iteration d = d = assertRaises RuntimeError i d del d d = test_mutating_iteration_delete_over_values change dict content during iteration d = d = assertRaises RuntimeError i d values del d d = test_mutating_iteration_delete_over_items change dict content during iteration d = d = assertRaises RuntimeError i d items del d d = test_mutating_lookup changing dict during lookup issue torch _dynamo error_on_graph_break False NastyKey mutate_dict = None __init__ value value = value __hash__ hash collision __eq__ other NastyKey mutate_dict mydict key = NastyKey mutate_dict NastyKey mutate_dict = None del mydict key value == other value key = NastyKey key = NastyKey d = key NastyKey mutate_dict = d key d key = assertEqual d key test_repr d = assertEqual repr d d = assertEqual repr d d = d = d assertEqual repr d torch _dynamo error_on_graph_break False Exc Exception pass BadRepr object __repr__ raise Exc d = BadRepr assertRaises Exc repr d test_repr_deep d = i range get_c_recursion_limit + d = d assertRaises RecursionError repr d test_eq assertEqual assertEqual torch _dynamo error_on_graph_break False Exc Exception pass BadCmp object __eq__ other raise Exc __hash__ d = BadCmp d = assertRaises Exc d == d test_keys_contained helper_keys_contained lambda x x keys helper_keys_contained lambda x x items helper_keys_contained fn Test rich comparisons against dict key views which should behave same sets empty = fn dict empty = fn dict smaller = fn larger = fn larger = fn larger = fn assertTrue smaller larger assertTrue smaller = larger assertTrue larger smaller assertTrue larger = smaller assertFalse smaller = larger assertFalse smaller larger assertFalse larger = smaller assertFalse larger smaller assertFalse smaller larger assertFalse smaller = larger assertFalse larger smaller assertFalse larger = smaller Inequality strictness assertTrue larger = larger assertTrue larger = larger assertFalse larger larger assertFalse larger larger assertTrue larger == larger assertTrue smaller = larger There optimization zero-element case assertTrue empty == empty assertFalse empty = empty assertFalse empty == smaller assertTrue empty = smaller With same size elementwise compare happens assertTrue larger = larger assertFalse larger == larger test_errors_in_view_containment_check torch _dynamo error_on_graph_break False C __eq__ other raise RuntimeError d = C d = C assertRaises RuntimeError d items == d items assertRaises RuntimeError d items = d items assertRaises RuntimeError d items = d items assertRaises RuntimeError d items = d items d = C C assertRaises RuntimeError d items d items assertRaises RuntimeError d items d items test_dictview_set_operations_on_keys k = keys k = keys k = keys assertEqual k - k set assertEqual k - k assertEqual k - k assertEqual k - k assertEqual k k assertEqual k k set assertEqual k &#124; k assertEqual k ^ k assertEqual k ^ k test_dictview_set_operations_on_items k = items k = items k = items assertEqual k - k set assertEqual k - k assertEqual k - k assertEqual k - k assertEqual k k assertEqual k k set assertEqual k &#124; k assertEqual k ^ k assertEqual k ^ k test_items_symmetric_difference rr = random randrange _ range left = x rr x range rr right = x rr x range rr subTest left=left right=right expected = set left items ^ set right items actual = left items ^ right items assertEqual actual expected test_dictview_mixed_set_operations Just few keys assertTrue keys == assertTrue == keys assertEqual keys &#124; assertEqual &#124; keys And few items assertTrue items == assertTrue == items assertEqual items &#124; assertEqual &#124; items test_missing Make sure dict doesn t have __missing__ method assertFalse hasattr dict __missing__ assertFalse hasattr __missing__ Test several cases D subclass defines __missing__ method returning value E subclass defines __missing__ method raising RuntimeError F subclass sets __missing__ instance variable no effect G subclass doesn t define __missing__ all torch _dynamo error_on_graph_break False D dict __missing__ key d = D assertEqual d assertEqual d assertNotIn d assertNotIn d keys assertEqual d torch _dynamo error_on_graph_break False E dict __missing__ key raise RuntimeError key e = E assertRaises RuntimeError c e assertEqual c exception args torch _dynamo error_on_graph_break False F dict __init__ An instance variable __missing__ should have no effect __missing__ = lambda key None f = F assertRaises KeyError c f assertEqual c exception args torch _dynamo error_on_graph_break False G dict pass g = G assertRaises KeyError c g assertEqual c exception args test_tuple_keyerror SF d = assertRaises KeyError c d assertEqual c exception args test_bad_key Dictionary lookups should fail __eq__ raises exception torch _dynamo error_on_graph_break False CustomException Exception pass BadDictKey __hash__ hash __class__ __eq__ other isinstance other __class__ raise CustomException other d = x = BadDictKey x = BadDictKey d x = stmt d x = z = d x x d d get x d setdefault x d pop x d update x assertRaises CustomException exec stmt locals test_resize Dict resizing bug found Jack Jansen CVS development This version got assert failure debug build infinite loop release build Unfortunately provoking kind stuff requires mix inserts deletes hitting exactly right hash codes exactly right order I can t think randomized approach would likely hit failing case reasonable time d = i range d i = i i range del d i i range i== problem d i = i test_resize Another dict resizing bug SF bug This caused Segmentation faults Illegal instructions torch _dynamo error_on_graph_break False X object __hash__ __eq__ other resizing d clear False d = resizing = False d X = d X = d X = d X = d X = now trigger resize resizing = True d = test_empty_presized_dict_in_freelist Bug empty presized dict size larger than freelist triggered assertion failure assertRaises ZeroDivisionError d = b None c None d None e None f None g None h None d = test_container_iterator Bug tp_traverse implemented dictiter dictview objects torch _dynamo error_on_graph_break False C object pass views = dict items dict values dict keys v views obj = C ref = weakref ref obj container = obj obj v = v container obj x = iter obj v del obj container gc collect assertIs ref None Cycle collected _not_tracked t Nested containers can take several collections untrack gc collect gc collect assertFalse gc is_tracked t t _tracked t assertTrue gc is_tracked t t gc collect gc collect assertTrue gc is_tracked t t test_string_keys_can_track_values Test doesn t leak i range d = j range d str j = j d foo = d support cpython_only test_track_literals Test GC-optimization dict literals x y z w = None _not_tracked _not_tracked x y x z _not_tracked b _not_tracked None True False int _not_tracked object Dicts mutable elements always tracked even those elements tracked right now _tracked _tracked _tracked _tracked set support cpython_only test_track_dynamic Test GC-optimization dynamically-created dicts torch _dynamo error_on_graph_break False MyObject object pass x y z w o = object MyObject d = dict _not_tracked d d = _not_tracked d d y = _not_tracked d d z = _not_tracked d _not_tracked d copy d = w _tracked d _tracked d copy d = None _not_tracked d _not_tracked d copy dd isn t tracked right now may mutate therefore d which contains must tracked d = dict dd = dict d = dd _not_tracked dd _tracked d dd = d _tracked dd d = dict fromkeys x y z _not_tracked d dd = dict dd update d _not_tracked dd d = dict fromkeys x y z o _tracked d dd = dict dd update d _tracked dd d = dict x=x y=y z=z _not_tracked d d = dict x=x y=y z=z w=w _tracked d d = dict d update x=x y=y z=z _not_tracked d d update w=w _tracked d d = dict x y z _not_tracked d d = dict x y z w _tracked d d = dict d update x y z _not_tracked d d update x y z w _tracked d support cpython_only test_track_subtypes Dict subtypes always tracked MyDict dict pass _tracked MyDict make_shared_key_dict n torch _dynamo error_on_graph_break False C pass dicts = i range n = C x y z = dicts append __dict__ dicts support cpython_only test_splittable_setdefault split table must keep correct insertion order when attributes adding using setdefault b = make_shared_key_dict = size_a = sys getsizeof b = b setdefault b size_b = sys getsizeof b b = assertEqual list x y z b assertEqual list b x y z b support cpython_only test_splittable_del split table must combined when del d k b = make_shared_key_dict orig_size = sys getsizeof del y split table combined assertRaises KeyError del y assertEqual list x z assertEqual list b x y z Two dicts have different insertion order y = assertEqual list x z y assertEqual list b x y z support cpython_only test_splittable_pop b = make_shared_key_dict pop y assertRaises KeyError pop y assertEqual list x z assertEqual list b x y z Two dicts have different insertion order y = assertEqual list x z y assertEqual list b x y z support cpython_only test_splittable_pop_pending pop pending key split table should crash b = make_shared_key_dict = assertRaises KeyError b pop support cpython_only test_splittable_popitem split table must combined when d popitem b = make_shared_key_dict orig_size = sys getsizeof item = popitem split table combined assertEqual item z assertRaises KeyError del z assertGreater sys getsizeof orig_size assertEqual list x y assertEqual list b x y z support cpython_only test_splittable_update dict update other must preserve order other torch _dynamo error_on_graph_break False C __init__ order order b c = c b = o = C True o = C False o __dict__ has reversed order assertEqual list o __dict__ c b d = d update o __dict__ assertEqual list d c b support cpython_only test_splittable_to_generic_combinedtable split table must correctly resized converted generic combined table torch _dynamo error_on_graph_break False C pass = C x = d = __dict__ d = split table resized generic combined table assertEqual list d x test_iterator_pickling proto range pickle HIGHEST_PROTOCOL + data = b c = iter data d = pickle dumps proto = pickle loads d assertEqual list list data = pickle loads d try drop = next except StopIteration continue d = pickle dumps proto = pickle loads d del data drop assertEqual list list data test_itemiterator_pickling proto range pickle HIGHEST_PROTOCOL + data = b c dictviews aren t picklable only their iterators itorg = iter data items d = pickle dumps itorg proto = pickle loads d note type unpickled iterator necessarily same original It merely object supporting iterator protocol yielding same objects original one assertEqual type itorg type assertIsInstance collections abc Iterator assertEqual dict data = pickle loads d drop = next d = pickle dumps proto = pickle loads d del data drop assertEqual dict data test_valuesiterator_pickling proto range pickle HIGHEST_PROTOCOL + data = b c data values isn t picklable only its iterator = iter data values d = pickle dumps proto = pickle loads d assertEqual list list data values = pickle loads d drop = next d = pickle dumps proto = pickle loads d values = list + drop assertEqual sorted values sorted list data values test_reverseiterator_pickling proto range pickle HIGHEST_PROTOCOL + data = b c = reversed data d = pickle dumps proto = pickle loads d assertEqual list list reversed data = pickle loads d try drop = next except StopIteration continue d = pickle dumps proto = pickle loads d del data drop assertEqual list list reversed data test_reverseitemiterator_pickling proto range pickle HIGHEST_PROTOCOL + data = b c dictviews aren t picklable only their iterators itorg = reversed data items d = pickle dumps itorg proto = pickle loads d note type unpickled iterator necessarily same original It merely object supporting iterator protocol yielding same objects original one assertEqual type itorg type assertIsInstance collections abc Iterator assertEqual dict data = pickle loads d drop = next d = pickle dumps proto = pickle loads d del data drop assertEqual dict data test_reversevaluesiterator_pickling proto range pickle HIGHEST_PROTOCOL + data = b c data values isn t picklable only its iterator = reversed data values d = pickle dumps proto = pickle loads d assertEqual list list reversed data values = pickle loads d drop = next d = pickle dumps proto = pickle loads d values = list + drop assertEqual sorted values sorted data values test_instance_dict_getattr_str_subclass torch _dynamo error_on_graph_break False Foo __init__ msg msg = msg f = Foo torch _dynamo error_on_graph_break False _str str pass assertEqual f msg getattr f _str msg assertEqual f msg f __dict__ _str msg test_object_set_item_single_instance_non_str_key torch _dynamo error_on_graph_break False Foo pass f = Foo f __dict__ = f = assertEqual f __dict__ check_reentrant_insertion mutate This object will trigger mutation dict when replaced another value Note relies refcounting test won t achieve its purpose fully-GCed Python implementations torch _dynamo error_on_graph_break False Mutating __del__ mutate d d = k Mutating k abcdefghijklmnopqr k list d d k = k test_reentrant_insertion Reentrant insertion shouldn t crash see issue mutate d d b = check_reentrant_insertion mutate mutate d d update __dict__ d clear check_reentrant_insertion mutate mutate d while d d popitem check_reentrant_insertion mutate test_merge_and_mutate torch _dynamo error_on_graph_break False X __hash__ __eq__ o other clear False l = i i range other = dict l other X = d = X assertRaises RuntimeError d update other test_free_after_iterating support check_free_after_iterating iter dict support check_free_after_iterating lambda d iter d keys dict support check_free_after_iterating lambda d iter d values dict support check_free_after_iterating lambda d iter d items dict test_equal_operator_modifying_operand test fix seg fault reported bpo- part torch _dynamo error_on_graph_break False X __del__ dict_b clear __eq__ other dict_a clear True __hash__ dict_a = X dict_b = X X assertTrue dict_a == dict_b test fix seg fault reported bpo- part torch _dynamo error_on_graph_break False Y __eq__ other dict_d clear True dict_c = Y dict_d = set assertTrue dict_c == dict_d test_fromkeys_operator_modifying_dict_operand test fix seg fault reported issue part torch _dynamo error_on_graph_break False X int __hash__ __eq__ other len d d clear False d = required exist so d can constructed d = X X try dict fromkeys d shouldn t crash except RuntimeError implementation defined pass test_fromkeys_operator_modifying_set_operand test fix seg fault reported issue part b torch _dynamo error_on_graph_break False X int __hash__ __eq__ other len d d clear False d = required exist so d can constructed d = X X try dict fromkeys d shouldn t crash except RuntimeError implementation defined pass test_dictitems_contains_use_after_free torch _dynamo error_on_graph_break False X __eq__ other d clear NotImplemented d = set X d items test_dict_contain_use_after_free bpo- torch _dynamo error_on_graph_break False S str __eq__ other d clear NotImplemented __hash__ hash test d = S value assertFalse test d test_init_use_after_free torch _dynamo error_on_graph_break False X __hash__ pair = pair = X dict pair test_oob_indexing_dictiter_iternextitem torch _dynamo error_on_graph_break False X int __del__ d clear d = i X i i range iter_and_mutate result d items result == d = None free d -- X __del__ called assertRaises RuntimeError iter_and_mutate test_reversed d = b foo c d del d foo r = reversed d assertEqual list r list dcba assertRaises StopIteration next r test_reverse_iterator_for_empty_dict bpo- reversed iterator should work properly empty dict directly used reference count test assertEqual list reversed assertEqual list reversed items assertEqual list reversed values assertEqual list reversed keys dict don t trigger same code path assertEqual list reversed dict assertEqual list reversed dict items assertEqual list reversed dict values assertEqual list reversed dict keys test_reverse_iterator_for_shared_shared_dicts torch _dynamo error_on_graph_break False A __init__ x y x x = x y y = y assertEqual list reversed A __dict__ y x assertEqual list reversed A __dict__ x assertEqual list reversed A __dict__ y test_dict_copy_order bpo- od = collections OrderedDict b od move_to_end expected = list od items copy = dict od assertEqual list copy items expected dict subclass doesn t override __iter__ torch _dynamo error_on_graph_break False CustomDict dict pass pairs = b c d = CustomDict pairs assertEqual pairs list dict d items torch _dynamo error_on_graph_break False CustomReversedDict dict keys reversed list dict keys __iter__ = keys items reversed dict items d = CustomReversedDict pairs assertEqual pairs - list dict d items support cpython_only test_dict_items_result_gc bpo- dict items s tuple-reuse speed trick breaks GC s assumptions about what can untracked Make sure we re-track result tuples whenever we reuse them = iter None items gc collect That GC collection probably untracked recycled internal result tuple which initialized None None Make sure s re-tracked when s mutated returned __next__ assertTrue gc is_tracked next support cpython_only test_dict_items_result_gc_reversed Same test_dict_items_result_gc above reversed = reversed None items gc collect assertTrue gc is_tracked next test_store_evilattr torch _dynamo error_on_graph_break False EvilAttr __init__ d d = d __del__ attr d del d attr gc collect Obj pass obj = Obj obj __dict__ = _ range obj attr = EvilAttr obj __dict__ test_str_nonstr cpython uses different lookup function dict only contains ` str ` keys Make sure unoptimized path used when non- ` str ` key appears torch _dynamo error_on_graph_break False StrSub str pass eq_count = This compares equal string key torch _dynamo error_on_graph_break False Key __hash__ hash key __eq__ other nonlocal eq_count isinstance other Key isinstance other str other == key eq_count += True False key _ = StrSub key key _ = Key key _ = Key dicts = Create dicts form ` key key key ` bunch different ways In all cases ` key ` type ` str ` ` key _ ` ` str ` subclass ` key _ ` completely unrelated type key key _ key _ A literal dicts append key key key key inserted via ` dict __setitem__ ` d = key key d key = dicts append d key inserted via ` dict setdefault ` d = key key assertEqual d setdefault key dicts append d key inserted via ` dict update ` d = key key d update key dicts append d key inserted via ` dict __ior__ ` d = key key d &#124; = key dicts append d ` dict iterable ` make_pairs yield key yield key yield key d = dict make_pairs dicts append d ` dict copy ` d = d copy dicts append d dict comprehension d = key + i i key enumerate key key key dicts append d d dicts subTest d=d assertEqual d get key Try make object type ` str ` equal ` key ` least cpython different object noninterned_key = ke noninterned_key += y support check_impl_detail cpython=True suppress SyntaxWarning interned_key = key assertFalse noninterned_key interned_key assertEqual d get noninterned_key assertEqual d get key assertEqual d get key _ assertEqual d get key _ ` key _ ` itself definitely dict key so make sure ` __eq__ ` gets called Note might hold ` key _ ` ` key _ ` because they might same object one dict keys which case implementations allowed skip call ` __eq__ ` eq_count = assertEqual d get key _ assertGreaterEqual eq_count CAPITest __TestCase Test _PyDict_GetItem_KnownHash support cpython_only test_getitem_knownhash _testinternalcapi = import_helper import_module _testinternalcapi dict_getitem_knownhash = _testinternalcapi dict_getitem_knownhash d = x y z assertEqual dict_getitem_knownhash d x hash x assertEqual dict_getitem_knownhash d y hash y assertEqual dict_getitem_knownhash d z hash z dict assertRaises SystemError dict_getitem_knownhash hash key does exist assertRaises KeyError dict_getitem_knownhash hash torch _dynamo error_on_graph_break False Exc Exception pass BadEq __eq__ other raise Exc __hash__ k k = BadEq BadEq d = k assertEqual dict_getitem_knownhash d k hash k assertRaises Exc dict_getitem_knownhash d k hash k test mapping_tests GeneralMappingTests mapping_tests BasicTestMappingProtocol type test = dict Dict dict pass SubclassMappingTests mapping_tests BasicTestMappingProtocol type test = Dict __name__ == __main__ run_tests