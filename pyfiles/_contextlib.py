mypy allow-untyped-defs Extra utilities working context managers should have been standard library functools inspect sys warnings collections abc Callable typing Any cast overload TypeVar typing_extensions Self Used annotating decorator usage _DecoratorContextManager e g no_grad enable_grad See https mypy readthedocs io en latest generics html#declaring-decorators FuncType = Callable Any F = TypeVar F bound=FuncType _wrap_generator ctx_factory func Wrap each generator invocation context manager factory The input should function returns context manager context manager itself handle one-shot context managers functools wraps func generator_context args kwargs gen = func args kwargs Generators suspended unsuspended ` yield ` hence we make sure grad mode properly set every time execution flow returns into wrapped generator restored when returns through our ` yield ` our caller see PR try Issuing ` None ` generator fires up ctx_factory response = gen send None while True try Forward response our caller get its next request request = yield response except GeneratorExit Inform still active generator about its imminent closure ctx_factory gen close raise except BaseException noqa B Propagate exception thrown us caller ctx_factory response = gen throw sys exc_info Pass last request generator get its response ctx_factory response = gen send request We let exceptions raised above generator s ` throw ` ` send ` methods bubble up our caller except StopIteration except StopIteration e The generator informed us done take whatever its returned value any indicate we re done too returning see docs python s return-statement e value generator_context context_decorator ctx func Like contextlib ContextDecorator But following differences Is done wrapping rather than inheritance so works context managers implemented C thus cannot easily inherit Python classes Wraps generators intuitive way c f https bugs python org issue Errors out you try wrap because ambiguous whether you intended wrap only constructor The input argument can either context manager which case must multi-shot context manager can directly invoked multiple times callable produces context manager callable ctx hasattr ctx __enter__ raise AssertionError f Passed ctx both callable also valid context manager has __enter__ making ambiguous which interface use If you intended pass context manager factory rewrite your call context_decorator lambda ctx you intended pass context manager directly rewrite your call context_decorator lambda ctx callable ctx ctx_factory ctx ctx_factory = ctx inspect isclass func raise RuntimeError Cannot decorate classes ambiguous whether only constructor all methods should have context manager applied additionally decorating definition-site will prevent use identifier conventional type To specify which methods decorate decorate each them individually inspect isgeneratorfunction func _wrap_generator ctx_factory func functools wraps func decorate_context args kwargs pyrefly ignore bad-context-manager ctx_factory func args kwargs decorate_context _DecoratorContextManager Allow context manager used decorator __call__ orig_func F - F inspect isclass orig_func warnings warn Decorating classes deprecated will disabled future versions You should only decorate functions methods To preserve current behavior decoration you can directly decorate ` __init__ ` method nothing FutureWarning stacklevel= func = cast F lambda args kwargs orig_func args kwargs func = orig_func cast F context_decorator clone func __enter__ - None raise NotImplementedError __exit__ exc_type Any exc_value Any traceback Any - None raise NotImplementedError clone override method your children takes __init__ parameters __class__ _NoParamDecoratorContextManager _DecoratorContextManager Allow context manager used decorator without parentheses overload __new__ cls orig_func F - F type ignore misc overload __new__ cls orig_func None = None - Self __new__ cls orig_func F &#124; None = None - Self &#124; F type ignore misc orig_func None super __new__ cls cls orig_func