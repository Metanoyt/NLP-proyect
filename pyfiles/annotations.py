mypy allow-untyped-defs ast builtins dis enum inspect re typing warnings textwrap dedent torch torch _C _GeneratorType AnyType AwaitType BoolType ComplexType DeviceObjType DictType EnumType FloatType FutureType InterfaceType IntType ListType NoneType NumberType OptionalType StreamObjType StringType TensorType TupleType UnionType torch _jit_internal type ignore attr-defined _Await _qualified_name Any BroadcastingList BroadcastingList BroadcastingList Dict Future is_await is_dict is_future is_ignored_fn is_list is_optional is_tuple is_union List Optional Tuple Union torch _sources get_source_lines_and_file _state _get_script_class torch distributed rpc is_available torch _C RRefType torch _jit_internal is_rref RRef torch _ops OpOverloadPacket Module __init__ name members name = name members = members __getattr__ name try members name except KeyError raise RuntimeError f Module name has no member called name None EvalEnv env = torch Module torch Tensor torch Tensor Tensor torch Tensor typing Module typing Tuple Tuple Tuple Tuple List List Dict Dict Optional Optional Union Union Future Future Await _Await __init__ rcb rcb = rcb torch distributed rpc is_available pyrefly ignore unsupported-operation env RRef = RRef __getitem__ name name env env name rcb None rcb name getattr builtins name None get_signature fn rcb loc is_method isinstance fn OpOverloadPacket signature = try_real_annotations fn op loc signature = try_real_annotations fn loc signature None is_method If method then signature will include type ` ` type comments do contain ` ` So strip away here so everything consistent ` inspect ismethod ` does work here since ` fn ` unbound point param_types return_type = signature param_types = param_types signature = param_types return_type signature None type_line source = None None try source = dedent join get_source_lines_and_file fn type_line = get_type_line source except TypeError pass This might happen both because we failed get source fn because didn t have any annotations type_line None signature = parse_type_line type_line rcb loc signature is_function_or_method the_callable A stricter version ` inspect isroutine ` does pass built-in functions inspect isfunction the_callable inspect ismethod the_callable is_vararg the_callable is_function_or_method the_callable callable the_callable noqa B If ` the_callable ` de-sugar call so we can still get signature the_callable = the_callable __call__ is_function_or_method the_callable inspect getfullargspec the_callable varargs None False get_param_names fn n_args isinstance fn OpOverloadPacket fn = fn op is_function_or_method fn callable fn is_function_or_method fn __call__ noqa B De-sugar calls classes fn = fn __call__ is_function_or_method fn is_ignored_fn fn fn = inspect unwrap fn inspect getfullargspec fn args The ` fn ` method function maybe __call__ method so use default param name list str i i range n_args check_fn fn loc Make sure function definition instantiation try source = dedent join get_source_lines_and_file fn except OSError TypeError source None py_ast = ast parse source len py_ast body == isinstance py_ast body ast ClassDef raise torch jit frontend FrontendError loc f Cannot instantiate py_ast body name script function len py_ast body = isinstance py_ast body ast FunctionDef raise torch jit frontend FrontendError loc Expected single top-level function _eval_no_call stmt glob loc Evaluate statement long does contain any method function calls bytecode = compile stmt mode= eval insn dis get_instructions bytecode CALL insn opname raise RuntimeError f Type annotation should contain calls stmt does eval bytecode glob loc type ignore arg-type noqa P parse_type_line type_line rcb loc Parse type annotation specified comment Example inputs type Tensor torch Tensor - Tuple Tensor type Tensor Tuple Tensor Tensor - Tensor arg_ann_str ret_ann_str = split_type_line type_line try arg_ann = _eval_no_call arg_ann_str EvalEnv rcb except NameError SyntaxError e raise RuntimeError Failed parse argument list type annotation e isinstance arg_ann tuple arg_ann = arg_ann try ret_ann = _eval_no_call ret_ann_str EvalEnv rcb except NameError SyntaxError e raise RuntimeError Failed parse type type annotation e arg_types = ann_to_type ann loc ann arg_ann arg_types ann_to_type ret_ann loc get_type_line source Try find line containing comment type annotation type_comment = type lines = source split \n lines = list enumerate lines type_lines = list filter lambda line type_comment line lines ` type ignore ` comments may needed JIT ed functions mypy due hack torch _VF py An ignore type comment can following format type ignore type ignore rule-code This ignore statement must end line adding extra backslash before space avoid triggering one checks github workflows lint yml type_pattern = re compile type \\ ignore \\ a-zA-Z- +\\ $ type_lines = list filter lambda line type_pattern search line type_lines len type_lines == Catch common typo patterns like extra spaces typo ignore etc wrong_type_pattern = re compile \t type \t ignore \\ \\ $ wrong_type_lines = list filter lambda line wrong_type_pattern search line lines len wrong_type_lines raise RuntimeError The annotation prefix line + str wrong_type_lines + probably invalid \nIt must type + \nSee PEP https www python org dev peps pep- #suggested-syntax-for-python- - -and-straddling-code noqa B + \nfor examples None len type_lines == Only type line quit now type_lines strip Parse split up argument types according PEP https www python org dev peps pep- #suggested-syntax-for-python- - -and-straddling-code return_line = None parameter_type_lines = line_num line type_lines type - line return_line = line_num line break type_comment line parameter_type_lines append line return_line None raise RuntimeError Return type line type - found multiline type annotation\nfor type lines \n + \n join line line type_lines + \n See PEP https www python org dev peps pep- #suggested-syntax-for-python- - -and-straddling-code get_parameter_type line item_type = line line find type_comment + len type_comment item_type strip types = map get_parameter_type parameter_type_lines parameter_types = join types return_line replace parameter_types split_type_line type_line Split comment type annotation into parts argument types For example input type Tensor torch Tensor - Tuple Tensor Tensor This function will Tensor torch Tensor Tuple Tensor Tensor start_offset = len type try arrow_pos = type_line index - except ValueError raise RuntimeError Syntax error type annotation couldn t find ` - ` None type_line start_offset arrow_pos strip type_line arrow_pos + strip try_real_annotations fn loc Try use Py + annotation syntax get type try Note anything annotated ` Optional T ` will automatically returned ` Union T None ` per https github com python cpython blob main Lib typing py#L sig = inspect signature fn except ValueError None all_annots = sig return_annotation + p annotation p sig parameters values all ann sig empty ann all_annots None arg_types = ann_to_type p annotation loc p sig parameters values return_type = ann_to_type sig return_annotation loc arg_types return_type Finds common type enum values belonging Enum If all values have same type AnyType returned get_enum_value_type e type enum Enum loc enum_values List enum Enum = list e enum_values raise ValueError f No enum values defined e __class__ types = type v value v enum_values ir_types = try_ann_to_type t loc t types If Enum values different types exception will raised here Even though Python supports case we chose implement avoid overcomplicate logic here rare use case Please report feature request you find necessary res = torch _C unify_type_list ir_types res AnyType get res is_tensor ann issubclass ann torch Tensor True issubclass ann torch LongTensor torch DoubleTensor torch FloatTensor torch IntTensor torch ShortTensor torch HalfTensor torch CharTensor torch ByteTensor torch BoolTensor warnings warn TorchScript will treat type annotations Tensor dtype-specific subtypes they normal Tensors dtype constraints enforced compilation either stacklevel= True False _fake_rcb inp None try_ann_to_type ann loc rcb=None ann_args = typing get_args ann always returns tuple ann inspect Signature empty TensorType getInferred ann None NoneType get inspect isclass ann is_tensor ann TensorType get is_tuple ann Special case empty Tuple type annotation ` Tuple ` len ann_args == ann_args == TupleType TupleType try_ann_to_type loc ann_args is_list ann elem_type = try_ann_to_type ann_args loc elem_type ListType elem_type is_dict ann key = try_ann_to_type ann_args loc value = try_ann_to_type ann_args loc Raise error key value None key None raise ValueError f Unknown type annotation ann_args loc highlight value None raise ValueError f Unknown type annotation ann_args loc highlight DictType key value is_optional ann issubclass ann_args type None contained = ann_args contained = ann_args valid_type = try_ann_to_type contained loc msg = Unsupported annotation could resolved because could resolved At\n assert valid_type msg format repr ann repr contained repr loc OptionalType valid_type is_union ann TODO hack recognize NumberType set ann_args == int float complex NumberType get inner List = We need these extra checks because both ` None ` invalid values will ` None ` TODO Determine other cases need fixed well typing get_args ann None inner append NoneType get maybe_type = try_ann_to_type loc msg = Unsupported annotation could resolved because could resolved At\n assert maybe_type msg format repr ann repr maybe_type repr loc inner append maybe_type UnionType inner type ignore arg-type torch distributed rpc is_available is_rref ann RRefType try_ann_to_type ann_args loc is_future ann FutureType try_ann_to_type ann_args loc is_await ann elementType = try_ann_to_type ann_args loc ann_args AnyType get AwaitType elementType ann float FloatType get ann complex ComplexType get ann int ann torch SymInt IntType get ann str StringType get ann bool BoolType get ann Any AnyType get ann type None NoneType get inspect isclass ann hasattr ann __torch_script_interface__ InterfaceType ann __torch_script_interface__ ann torch device DeviceObjType get ann torch Generator _GeneratorType get ann torch Stream StreamObjType get ann torch dtype IntType get dtype yet bound its own type ann torch qscheme IntType get qscheme yet bound its own type inspect isclass ann issubclass ann enum Enum _get_script_class ann None scripted_class = torch jit _script _recursive_compile_class ann loc name = scripted_class qualified_name name = _qualified_name ann EnumType name get_enum_value_type ann loc list ann inspect isclass ann maybe_script_class = _get_script_class ann maybe_script_class None maybe_script_class torch _jit_internal can_compile_class ann torch jit _script _recursive_compile_class ann loc Maybe resolve NamedTuple Tuple Type rcb None rcb = _fake_rcb torch _C _resolve_type_from_object ann loc rcb ann_to_type ann loc rcb=None the_type = try_ann_to_type ann loc rcb the_type None the_type raise ValueError f Unknown type annotation ann loc highlight __all__ = Any List BroadcastingList BroadcastingList BroadcastingList Tuple is_tuple is_list Dict is_dict is_optional is_union TensorType TupleType FloatType ComplexType IntType ListType StringType DictType AnyType Module TODO Consider exporting these during wildcard reserve types idiomatic typing code get_signature check_fn get_param_names parse_type_line get_type_line split_type_line try_real_annotations try_ann_to_type ann_to_type