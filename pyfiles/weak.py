mypy allow-untyped-defs __future__ annotations collections abc _collections_abc weakref collections abc Mapping MutableMapping weakref ref torch Tensor WeakRef = ref __all__ = TensorWeakRef WeakIdRef WeakIdKeyDictionary WeakTensorKeyDictionary TODO make weakref properly thread safe following https github com python cpython pull _IterationGuard This context manager registers itself current iterators weak container such delay all removals until context manager exits This technique should relatively thread-safe since sets __init__ weakcontainer Don t create cycles weakcontainer = ref weakcontainer __enter__ w = weakcontainer w None w _iterating add __exit__ e t b w = weakcontainer w None s = w _iterating s remove s w _commit_removals This file defines variant WeakKeyDictionary overrides hashing behavior key use object identity rather than builtin __eq__ __hash__ functions This useful Tensor weak keys their __eq__ implementation Tensor elementwise equality which means you can t use them directly WeakKeyDictionary standard library Our implementation strategy create wrapper weak key object which we use key stock Python dictionary This similar how weakref implements WeakKeyDictionary instead using weakref ref wrapper we use custom wrapper has different __eq__ __hash__ behavior Note we subsequently store weak key directly ORDINARY dictionary since newly constructed WeakIdKey s only use would dictionary so would have no strong references Ensuring only live WeakIdKeys map handled putting finalizers original key object It simpler implement composition we want directly reuse callback mechanism weakref we need weakref key exactly same object Reusing callback mechanism minimizes divergence between our implementation Lib weakref py NB Prefer using when working weakrefs Tensors e g do WeakIdRef tensor rather than weakref ref tensor handles number easy get wrong cases transparently you WeakIdRef weakref ref __slots__ = _id __init__ key callback=None Unlike stock weakref which preserves hash semantics original object lazily defers hash calls until first time user attempts hash weakref we can eagerly cache id key we know definitely hash method _id = id key super __init__ key callback type ignore call-arg __call__ r = super __call__ Special logic Tensor PyObject resurrection hasattr r _fix_weakref r _fix_weakref type ignore union-attr r __hash__ _id __eq__ other An attractive wrong alternate implementation only test stored _ids match This can lead ABA problem you have = A w = WeakIdRef del = A suppose gets same ID w = WeakIdRef print w == w This should False unrelated dead anyway = b = other None b None b other This same WeakIdRef equality checked using hash rather than id This will equivalent one above except classes where hash their id _WeakHashRef weakref ref __slots__ = _id __init__ key callback=None Unlike stock weakref which preserves hash semantics original object lazily defers hash calls until first time user attempts hash weakref we can eagerly cache id key we know definitely hash method _id = hash key super __init__ key callback type ignore call-arg __call__ r = super __call__ Special logic Tensor PyObject resurrection hasattr r _fix_weakref r _fix_weakref type ignore union-attr r __hash__ _id __eq__ other Use hash equality determine ref equality ScriptObject implements __hash__ wrapped IValue s id so equivalent doing identity comparison = b = other None b None hash == hash b other This directly adapted cpython Lib weakref py WeakIdKeyDictionary MutableMapping __init__ dict=None ref_type=WeakIdRef CHANGED data = ref_type = ref_type CHANGED remove k selfref=ref = selfref None _iterating _pending_removals append k try del data k except KeyError pass _remove = remove A list dead weakrefs keys removed _pending_removals = _iterating = set _dirty_len = False dict None update dict _commit_removals NOTE We don t need call method before mutating dict because dead weakref never compares equal live weakref even they happened refer equal objects However means keys may already have been removed pop = _pending_removals pop d = data while True try key = pop except IndexError try del d key except KeyError pass _scrub_removals d = data _pending_removals = k k _pending_removals k d _dirty_len = False __delitem__ key _dirty_len = True del data ref_type key CHANGED __getitem__ key data ref_type key CHANGED __len__ _dirty_len _pending_removals _pending_removals may still contain keys which explicitly removed we have scrub them see issue _scrub_removals len data - len _pending_removals __repr__ f __class__ __name__ id #x __setitem__ key value data ref_type key _remove = value CHANGED copy new = WeakIdKeyDictionary _IterationGuard key value data items o = key o None new o = value new __copy__ = copy __deepcopy__ memo copy deepcopy new = __class__ _IterationGuard key value data items o = key o None new o = deepcopy value memo new get key default=None data get ref_type key default CHANGED __contains__ key try wr = ref_type key CHANGED except TypeError False wr data items _IterationGuard wr value data items key = wr key None yield key value keys _IterationGuard wr data obj = wr obj None yield obj __iter__ = keys values _IterationGuard wr value data items wr None yield value keyrefs Return list weak references keys The references guaranteed live time they used so result calling references needs checked before being used This can used avoid creating references will cause garbage collector keep keys around longer than needed list data popitem _dirty_len = True while True key value = data popitem o = key o None o value pyrefly ignore bad-override pop key args _dirty_len = True pyrefly ignore not-iterable data pop ref_type key args CHANGED setdefault key default=None data setdefault ref_type key _remove default CHANGED update dict=None kwargs type ignore override d = data dict None hasattr dict items dict = type dict key value dict items d ref_type key _remove = value CHANGED kwargs update kwargs __ior__ other update other __or__ other isinstance other _collections_abc Mapping c = copy c update other c NotImplemented __ror__ other isinstance other _collections_abc Mapping c = __class__ c update other c update c NotImplemented Default Mapping equality will tests keys equality we want test ids equality __eq__ other isinstance other Mapping NotImplemented id k v k v items == id k v k v other items Convenience alias WeakTensorKeyDictionary = WeakIdKeyDictionary TensorWeakRef Wrapper around weak ref Tensor handles _fix_weakref call required when unwrapping Tensor weakref ref WeakRef Tensor __init__ tensor Tensor isinstance tensor Tensor raise AssertionError f expected torch Tensor got type tensor ref = weakref ref tensor __call__ out = ref out None out isinstance out Tensor raise AssertionError f expected torch Tensor got type out TODO add _fix_weakref type binding out _fix_weakref type ignore attr-defined out