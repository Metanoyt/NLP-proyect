JIT C++ strings into executables atexit os re shutil textwrap threading typing Any Optional torch torch utils benchmark utils _stubs CallgrindModuleType TimeitModuleType torch utils benchmark utils common _make_temp_dir torch utils cpp_extension LOCK = threading Lock SOURCE_ROOT = os path split os path abspath __file__ We calculate uuid once time so separate processes will have separate build roots threads will share same build root ` cpp_extension ` uses build root part cache key so per-invocation uuid s e g different build root per _compile_template call would lead cache hit rate spurious recompilation Consider following ` ` ` setup = auto x = torch ones stmt = torch mm x x num_threads print Timer stmt setup num_threads=num_threads language= c++ blocked_autorange ` ` ` ` ` setup ` ` stmt ` do change so we can reuse executable first pass through loop _BUILD_ROOT Optional str = None _get_build_root - str global _BUILD_ROOT _BUILD_ROOT None _BUILD_ROOT = _make_temp_dir prefix= benchmark_utils_jit_build pyrefly ignore missing-argument atexit register shutil rmtree _BUILD_ROOT _BUILD_ROOT BACK_TESTING_NOTE There two workflows where code could used One obvious case where someone simply builds installs PyTorch uses Timer The other entire ` torch utils benchmark ` folder CURRENT PyTorch checkout copy-pasted into much OLDER version PyTorch source code This what we refer here back testing The rationale we might want use current tooling study some aspect earlier version PyTorch e g regression The problem Timer relies several aspects core PyTorch namely some binding functions Valgrind symbols ` torch _C ` ` torch __config__ _cxx_flags ` method If we naively copy code around wouldn t work symbols interest aren t present earlier versions PyTorch In order work around we must add back testing shims These shims will never activate during normal use will allow Timer function outside correct version PyTorch emulating functionality added later These shims temporary Timer becomes more integrated PyTorch cost complexity such shims will increase Once back testing no longer required which say we have done enough historic analysis shims no longer justify their maintenance code complexity costs back testing paths will removed CXX_FLAGS Optional list str hasattr torch __config__ _cxx_flags try CXX_FLAGS = torch __config__ _cxx_flags strip split CXX_FLAGS None -g CXX_FLAGS CXX_FLAGS append -g remove -W flags allow build benchmarks relaxed constraint compiler versions CXX_FLAGS None CXX_FLAGS = list filter lambda x x startswith -W CXX_FLAGS except RuntimeError We FBCode CXX_FLAGS = None FIXME Remove when back testing no longer required CXX_FLAGS = -O -fPIC -g EXTRA_INCLUDE_PATHS list str = os path join SOURCE_ROOT valgrind_wrapper CONDA_PREFIX = os getenv CONDA_PREFIX CONDA_PREFIX None Load will automatically search usr include conda include EXTRA_INCLUDE_PATHS append os path join CONDA_PREFIX include COMPAT_CALLGRIND_BINDINGS Optional CallgrindModuleType = None get_compat_bindings - CallgrindModuleType LOCK global COMPAT_CALLGRIND_BINDINGS COMPAT_CALLGRIND_BINDINGS None COMPAT_CALLGRIND_BINDINGS = cpp_extension load name= callgrind_bindings sources= os path join SOURCE_ROOT valgrind_wrapper compat_bindings cpp extra_cflags=CXX_FLAGS extra_include_paths=EXTRA_INCLUDE_PATHS COMPAT_CALLGRIND_BINDINGS _compile_template stmt str setup str global_setup str src str is_standalone bool - Any before after indentation GLOBAL_SETUP_TEMPLATE_LOCATION global_setup SETUP_TEMPLATE_LOCATION setup STMT_TEMPLATE_LOCATION stmt C++ doesn t care about indentation so code isn t load bearing way Python makes source look nicer human has look src = re sub before textwrap indent after indentation indentation src We want isolate different Timers However ` cpp_extension ` will cache builds which will significantly reduce cost repeated invocations LOCK name = f timer_cpp_ abs hash src build_dir = os path join _get_build_root name os makedirs build_dir exist_ok=True src_path = os path join build_dir timer_src cpp open src_path w f f write src ` cpp_extension ` has its own locking scheme so we don t need our lock cpp_extension load name=name sources= src_path build_directory=build_dir extra_cflags=CXX_FLAGS extra_include_paths=EXTRA_INCLUDE_PATHS is_python_module=not is_standalone is_standalone=is_standalone compile_timeit_template stmt str setup str global_setup str - TimeitModuleType template_path str = os path join SOURCE_ROOT timeit_template cpp open template_path f src str = f read module = _compile_template stmt=stmt setup=setup global_setup=global_setup src=src is_standalone=False isinstance module TimeitModuleType raise AssertionError compiled module TimeitModuleType module compile_callgrind_template stmt str setup str global_setup str - str template_path str = os path join SOURCE_ROOT valgrind_wrapper timer_callgrind_template cpp open template_path f src str = f read target = _compile_template stmt=stmt setup=setup global_setup=global_setup src=src is_standalone=True isinstance target str raise AssertionError compiled target path string target