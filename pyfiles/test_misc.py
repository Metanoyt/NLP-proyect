Owner s oncall package deploy inspect os platform sys io BytesIO pathlib Path textwrap dedent unittest skipIf torch package is_from_package PackageExporter PackageImporter torch package package_exporter PackagingError torch testing _internal common_utils IS_FBCODE IS_SANDCASTLE run_tests skipIfTorchDynamo try common PackageTestCase except ImportError Support case where we run file directly common PackageTestCase TestMisc PackageTestCase Tests one-off random functionality Try add test_file_structure Tests package s Directory structure representation zip file Ensures returned Directory prints what expected filters inputs outputs correctly buffer = BytesIO export_plain = dedent \ \u c\u \u data \u \u c\u \u extern_modules \u \u c\u \u python_version \u \u c\u \u serialization_id \u \u \u \u version \u c\u \u main \u \u \u \u main \u c\u \u obj \u \u \u \u obj pkl \u c\u \u package_a \u \u c\u \u __init__ py \u \u \u \u subpackage py \u c\u \u byteorder \u \u \u module_a py export_include = dedent \ \u c\u \u obj \u \u \u \u obj pkl \u \u \u package_a \u \u \u subpackage py import_exclude = dedent \ \u c\u \u data \u \u c\u \u extern_modules \u \u c\u \u python_version \u \u c\u \u serialization_id \u \u \u \u version \u c\u \u main \u \u \u \u main \u c\u \u obj \u \u \u \u obj pkl \u c\u \u package_a \u \u c\u \u __init__ py \u \u \u \u subpackage py \u c\u \u byteorder \u \u \u module_a py PackageExporter buffer he module_a package_a package_a subpackage obj = package_a subpackage PackageASubpackageObject he intern he save_module module_a __name__ he save_module package_a __name__ he save_pickle obj obj pkl obj he save_text main main my string buffer seek hi = PackageImporter buffer file_structure = hi file_structure remove first line testing because WINDOW iOS Unix treat buffer differently assertEqual dedent \n join str file_structure split \n export_plain file_structure = hi file_structure include= subpackage py pkl assertEqual dedent \n join str file_structure split \n export_include file_structure = hi file_structure exclude= storage assertEqual dedent \n join str file_structure split \n import_exclude test_loaders_that_remap_files_work_ok importlib abc MetaPathFinder importlib machinery SourceFileLoader importlib util spec_from_loader LoaderThatRemapsModuleA SourceFileLoader get_filename name result = super get_filename name name == module_a os path join os path dirname result module_a_remapped_path py result FinderThatRemapsModuleA MetaPathFinder find_spec fullname path target Try find original spec module_a using all remaining meta_path finders fullname = module_a None spec = None finder sys meta_path finder continue hasattr finder find_spec spec = finder find_spec fullname path target=target hasattr finder load_module spec = spec_from_loader fullname finder spec None break assert spec None isinstance spec loader SourceFileLoader spec loader = LoaderThatRemapsModuleA spec loader name spec loader path spec sys meta_path insert FinderThatRemapsModuleA clear sys modules so we use custom finder next time gets imported sys modules pop module_a None try buffer = BytesIO PackageExporter buffer he module_a he intern he save_module module_a __name__ buffer seek hi = PackageImporter buffer assertTrue remapped_path hi get_source module_a finally pop again ensure does mess up other tests sys modules pop module_a None sys meta_path pop test_python_version Tests current python version stored package available via PackageImporter s python_version method buffer = BytesIO PackageExporter buffer he package_a test_module SimpleTest he intern obj = SimpleTest he save_pickle obj obj pkl obj buffer seek hi = PackageImporter buffer assertEqual hi python_version platform python_version skipIf IS_FBCODE IS_SANDCASTLE Tests use temporary files disabled fbcode test_load_python_version_from_package Tests loading package python version embedded importer = PackageImporter f Path __file__ parent package_e test_nn_module pt assertEqual importer python_version test_file_structure_has_file Test Directory s has_file method buffer = BytesIO PackageExporter buffer he package_a subpackage he intern obj = package_a subpackage PackageASubpackageObject he save_pickle obj obj pkl obj buffer seek importer = PackageImporter buffer file_structure = importer file_structure assertTrue file_structure has_file package_a subpackage py assertFalse file_structure has_file package_a subpackage test_exporter_content_lists Test content list API PackageExporter s contained modules PackageExporter BytesIO he package_b he extern package_b subpackage_ he mock package_b subpackage_ he intern he save_pickle obj obj pkl package_b PackageBObject assertEqual he externed_modules package_b subpackage_ assertEqual he mocked_modules package_b subpackage_ assertEqual he interned_modules package_b package_b subpackage_ subsubpackage_ assertEqual he get_rdeps package_b subpackage_ package_b assertRaises PackagingError PackageExporter BytesIO he package_b he deny package_b he save_pickle obj obj pkl package_b PackageBObject assertEqual he denied_modules package_b test_is_from_package is_from_package should work objects modules package_a subpackage buffer = BytesIO obj = package_a subpackage PackageASubpackageObject PackageExporter buffer pe pe intern pe save_pickle obj obj pkl obj buffer seek pi = PackageImporter buffer mod = pi import_module package_a subpackage loaded_obj = pi load_pickle obj obj pkl assertFalse is_from_package package_a subpackage assertTrue is_from_package mod assertFalse is_from_package obj assertTrue is_from_package loaded_obj test_inspect_class Should able retrieve source packaged package_a subpackage buffer = BytesIO obj = package_a subpackage PackageASubpackageObject PackageExporter buffer pe pe intern pe save_pickle obj obj pkl obj buffer seek pi = PackageImporter buffer packaged_class = pi import_module package_a subpackage PackageASubpackageObject regular_class = package_a subpackage PackageASubpackageObject packaged_src = inspect getsourcelines packaged_class regular_src = inspect getsourcelines regular_class assertEqual packaged_src regular_src test_dunder_package_present The attribute __torch_package__ should populated imported modules package_a subpackage buffer = BytesIO obj = package_a subpackage PackageASubpackageObject PackageExporter buffer pe pe intern pe save_pickle obj obj pkl obj buffer seek pi = PackageImporter buffer mod = pi import_module package_a subpackage assertTrue hasattr mod __torch_package__ test_dunder_package_works_from_package The attribute __torch_package__ should accessible within module itself so packaged code can detect whether s being used packaged context package_a use_dunder_package mod buffer = BytesIO PackageExporter buffer pe pe intern pe save_module mod __name__ buffer seek pi = PackageImporter buffer imported_mod = pi import_module mod __name__ assertTrue imported_mod is_from_package assertFalse mod is_from_package skipIfTorchDynamo Not suitable test TorchDynamo test_std_lib_sys_hackery_checks The standard library performs sys module assignment hackery which causes modules who do hackery fail See https github com pytorch pytorch issues more information sys version_info package_a std_sys_module_hacks std_sys_module_hacks package_a std_sys_module_hacks_ _ std_sys_module_hacks buffer = BytesIO mod = std_sys_module_hacks Module PackageExporter buffer pe pe intern pe save_pickle obj obj pkl mod buffer seek pi = PackageImporter buffer mod = pi load_pickle obj obj pkl mod __name__ == __main__ run_tests