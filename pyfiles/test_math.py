======= BEGIN Dynamo patch ======= Owner s module dynamo ruff noqa flake noqa Test copied https raw githubusercontent com python cpython refs tags v Lib test test_math py sys torch torch _dynamo test_case unittest torch _dynamo test_case CPythonTestCase torch testing _internal common_utils slowTest run_tests skipIfTorchDynamo __TestCase = CPythonTestCase redirect statements sys importlib abc redirect_imports = test mapping_tests test typinganndata test test_grammar test test_math test test_iter test typinganndata ann_module RedirectImportFinder importlib abc MetaPathFinder find_spec fullname path target=None Check problematic one fullname redirect_imports try Attempt standalone module name = fullname removeprefix test r = importlib import_module name Redirect module sys modules sys modules fullname = r Return module spec found module importlib util find_spec name except ImportError None None Add custom finder sys meta_path sys meta_path insert RedirectImportFinder ======= END DYNAMO PATCH ======= Python test set -- math module XXXX Should do tests around zero only test support verbose requires_IEEE_ test support unittest fractions itertools decimal math os platform random struct sys eps = E- NAN = float nan INF = float inf NINF = float -inf FLOAT_MAX = sys float_info max FLOAT_MIN = sys float_info min detect evidence double-rounding fsum always correctly rounded machines suffer double rounding x y = e use temporary values defeat peephole optimizer HAVE_DOUBLE_ROUNDING = x + y == e + locate file test values __name__ == __main__ file = sys argv file = __file__ test_dir = os path dirname file os curdir math_testcases = os path join test_dir mathdata math_testcases txt test_file = os path join test_dir mathdata cmath_testcases txt to_ulps x Convert non-NaN float x integer such way adjacent floats converted adjacent integers Then abs ulps x - ulps y gives difference ulps between two floats The results function will only make sense platforms where native doubles represented IEEE binary format Note - converted - respectively n = struct unpack q struct pack d x n n = ~ n+ n Here s pure Python version math factorial algorithm documentation comparison purposes Formula factorial n = factorial_odd_part n n - count_set_bits n where factorial_odd_part n = product_ i = product_ j = n i j odd j The outer product above infinite product once i = n bit_length n i corresponding term product empty So only finitely many terms = i n bit_length contribute anything We iterate downwards i == n bit_length - i == The inner product formula above starts i == n bit_length each i n bit_length we get inner product i i + multiplying all j n i+ j = n i j odd In Python terms set range n i+ + &#124; n i + &#124; count_set_bits n Number bits binary expansion nonnnegative integer + count_set_bits n n - n partial_product start stop Product integers range start stop computed recursively start stop should both odd start = stop numfactors = stop - start numfactors numfactors == start mid = start + numfactors &#124; partial_product start mid partial_product mid stop py_factorial n Factorial nonnegative integer n via Binary Split Factorial Formula described http www luschny de math factorial binarysplitfact html inner = outer = i reversed range n bit_length inner = partial_product n i + + &#124; n i + &#124; outer = inner outer n - count_set_bits n ulp_abs_check expected got ulp_tol abs_tol Given finite floats ` expected ` ` got ` check they re approximately equal within given number ulps given absolute tolerance whichever bigger Returns None success error message failure ulp_error = abs to_ulps expected - to_ulps got abs_error = abs expected - got Succeed either abs_error = abs_tol ulp_error = ulp_tol abs_error = abs_tol ulp_error = ulp_tol None fmt = error = g d ulps permitted error = g d ulps fmt format abs_error ulp_error abs_tol ulp_tol parse_mtestfile fname Parse file test values -- starts comment blank lines lines containing only comment ignored other lines expected have form id fn arg - expected flag open fname encoding= utf- fp line fp strip comments skip blank lines -- line line = line line index -- line strip continue lhs rhs = line split - id fn arg = lhs split rhs_pieces = rhs split exp = rhs_pieces flags = rhs_pieces yield id fn float arg float exp flags parse_testfile fname Parse file test values Empty lines lines starting -- ignored yields id fn arg_real arg_imag exp_real exp_imag open fname encoding= utf- fp line fp skip comment lines blank lines line startswith -- line strip continue lhs rhs = line split - id fn arg_real arg_imag = lhs split rhs_pieces = rhs split exp_real exp_imag = rhs_pieces rhs_pieces flags = rhs_pieces yield id fn float arg_real float arg_imag float exp_real float exp_imag flags result_check expected got ulp_tol= abs_tol= Common logic MathTests ftest test_testcases test_mtestcases Compare arguments expected got floats either float using tolerance expressed multiples ulp expected absolutely given greater As convenience when neither argument float non-finite floats exact equality demanded Also nan==nan far function concerned Returns None success error message failure Check exactly equal applies also strings representing exceptions got == expected got expected math copysign got = math copysign expected f expected expected got got zero has wrong sign None failure = equal Turn mixed float int comparison e g floor all-float isinstance expected float isinstance got int got = float got isinstance got float isinstance expected int expected = float expected isinstance expected float isinstance got float math isnan expected math isnan got Pass since both nan failure = None math isinf expected math isinf got We already know they re equal drop through failure pass Both finite floats now Are they close enough failure = ulp_abs_check expected got ulp_tol abs_tol arguments equal numeric too far apart failure None fail_fmt = expected r got r fail_msg = fail_fmt format expected got fail_msg += format failure fail_msg None FloatLike __init__ value value = value __float__ value IntSubclass int pass Class providing __index__ method MyIndexable object __init__ value value = value __index__ value BadDescr __get__ obj objtype=None raise ValueError MathTests __TestCase ftest name got expected ulp_tol= abs_tol= Compare arguments expected got floats either float using tolerance expressed multiples ulp expected absolutely whichever greater As convenience when neither argument float non-finite floats exact equality demanded Also nan==nan function failure = result_check expected got ulp_tol abs_tol failure None fail format name failure testConstants Ref Abramowitz Stegun Dover ftest pi math pi ftest e math e assertEqual math tau math pi testAcos assertRaises TypeError math acos ftest acos - math acos - math pi ftest acos math acos math pi ftest acos math acos assertRaises ValueError math acos INF assertRaises ValueError math acos NINF assertRaises ValueError math acos + eps assertRaises ValueError math acos - - eps assertTrue math isnan math acos NAN testAcosh assertRaises TypeError math acosh ftest acosh math acosh ftest acosh math acosh assertRaises ValueError math acosh assertRaises ValueError math acosh - assertEqual math acosh INF INF assertRaises ValueError math acosh NINF assertTrue math isnan math acosh NAN testAsin assertRaises TypeError math asin ftest asin - math asin - -math pi ftest asin math asin ftest asin math asin math pi assertRaises ValueError math asin INF assertRaises ValueError math asin NINF assertRaises ValueError math asin + eps assertRaises ValueError math asin - - eps assertTrue math isnan math asin NAN testAsinh assertRaises TypeError math asinh ftest asinh math asinh ftest asinh math asinh ftest asinh - math asinh - - assertEqual math asinh INF INF assertEqual math asinh NINF NINF assertTrue math isnan math asinh NAN testAtan assertRaises TypeError math atan ftest atan - math atan - -math pi ftest atan math atan ftest atan math atan math pi ftest atan inf math atan INF math pi ftest atan -inf math atan NINF -math pi assertTrue math isnan math atan NAN testAtanh assertRaises TypeError math atan ftest atanh math atanh ftest atanh math atanh ftest atanh - math atanh - - assertRaises ValueError math atanh assertRaises ValueError math atanh - assertRaises ValueError math atanh INF assertRaises ValueError math atanh NINF assertTrue math isnan math atanh NAN testAtan assertRaises TypeError math atan ftest atan - math atan - -math pi ftest atan - math atan - -math pi ftest atan math atan ftest atan math atan math pi ftest atan math atan math pi ftest atan - math atan - math pi math atan x ftest atan -inf math atan NINF math pi ftest atan - math atan - math pi ftest atan - math atan - math pi assertEqual math atan assertEqual math atan assertEqual math atan INF assertTrue math isnan math atan NAN math atan - x ftest atan - -inf math atan - NINF -math pi ftest atan - - math atan - - -math pi ftest atan - - math atan - - -math pi assertEqual math atan - - assertEqual math atan - - assertEqual math atan - INF - assertTrue math isnan math atan - NAN math atan INF x ftest atan inf -inf math atan INF NINF math pi ftest atan inf - math atan INF - math pi ftest atan inf - math atan INF - math pi ftest atan inf math atan INF math pi ftest atan inf math atan INF math pi ftest atan inf inf math atan INF INF math pi assertTrue math isnan math atan INF NAN math atan NINF x ftest atan -inf -inf math atan NINF NINF -math pi ftest atan -inf - math atan NINF - -math pi ftest atan -inf - math atan NINF - -math pi ftest atan -inf math atan NINF -math pi ftest atan -inf math atan NINF -math pi ftest atan -inf inf math atan NINF INF -math pi assertTrue math isnan math atan NINF NAN math atan +finite x ftest atan -inf math atan NINF math pi ftest atan - math atan - math pi ftest atan math atan math pi assertEqual math atan INF assertTrue math isnan math atan NAN math atan -finite x ftest atan - -inf math atan - NINF -math pi ftest atan - - math atan - - -math pi ftest atan - math atan - -math pi assertEqual math atan - INF - assertTrue math isnan math atan - NAN math atan NAN x assertTrue math isnan math atan NAN NINF assertTrue math isnan math atan NAN - assertTrue math isnan math atan NAN - assertTrue math isnan math atan NAN assertTrue math isnan math atan NAN assertTrue math isnan math atan NAN INF assertTrue math isnan math atan NAN NAN testCbrt assertRaises TypeError math cbrt ftest cbrt math cbrt ftest cbrt math cbrt ftest cbrt math cbrt ftest cbrt math cbrt ftest cbrt - math cbrt - - ftest cbrt math cbrt ftest cbrt - math cbrt - - ftest cbrt math cbrt ftest cbrt - math cbrt - - ftest cbrt - math cbrt - - assertEqual math cbrt INF INF assertEqual math cbrt NINF NINF assertTrue math isnan math cbrt NAN testCeil assertRaises TypeError math ceil assertEqual int type math ceil assertEqual math ceil assertEqual math ceil assertEqual math ceil assertEqual math ceil - assertEqual math ceil - - assertEqual math ceil - - assertEqual math ceil assertEqual math ceil - #self assertEqual math ceil INF INF #self assertEqual math ceil NINF NINF #self assertTrue math isnan math ceil NAN torch _dynamo error_on_graph_break False TestCeil __ceil__ FloatCeil float __ceil__ TestNoCeil pass TestBadCeil __ceil__ = BadDescr assertEqual math ceil TestCeil assertEqual math ceil FloatCeil assertEqual math ceil FloatLike assertRaises TypeError math ceil TestNoCeil assertRaises ValueError math ceil TestBadCeil t = TestNoCeil t __ceil__ = lambda args args assertRaises TypeError math ceil t assertRaises TypeError math ceil t assertEqual math ceil FloatLike + + assertEqual math ceil FloatLike - - requires_IEEE_ testCopysign assertEqual math copysign assertEqual math copysign assertEqual math copysign - - assertEqual math copysign assertEqual math copysign - - assertRaises TypeError math copysign copysign should let us distinguish signs zeros assertEqual math copysign assertEqual math copysign - - assertEqual math copysign INF INF assertEqual math copysign INF - NINF assertEqual math copysign NINF INF assertEqual math copysign NINF - NINF infinities assertEqual math copysign INF assertEqual math copysign NINF - assertEqual math copysign INF INF INF assertEqual math copysign INF NINF NINF assertEqual math copysign NINF INF INF assertEqual math copysign NINF NINF NINF assertTrue math isnan math copysign NAN assertTrue math isnan math copysign NAN INF assertTrue math isnan math copysign NAN NINF assertTrue math isnan math copysign NAN NAN copysign INF NAN may INF may NINF since we don t know whether sign bit NAN set any given platform assertTrue math isinf math copysign INF NAN similarly copysign NAN could - assertEqual abs math copysign NAN testCos assertRaises TypeError math cos ftest cos -pi math cos -math pi abs_tol=math ulp ftest cos math cos ftest cos pi math cos math pi abs_tol=math ulp ftest cos pi math cos math pi - try assertTrue math isnan math cos INF assertTrue math isnan math cos NINF except ValueError assertRaises ValueError math cos INF assertRaises ValueError math cos NINF assertTrue math isnan math cos NAN unittest skipIf sys platform == win platform machine ARM ARM Windows UCRT off ULP test requires accuracy within ULP testCosh assertRaises TypeError math cosh ftest cosh math cosh ftest cosh - cosh math cosh - math cosh - Thanks Lambert assertEqual math cosh INF INF assertEqual math cosh NINF INF assertTrue math isnan math cosh NAN testDegrees assertRaises TypeError math degrees ftest degrees pi math degrees math pi ftest degrees pi math degrees math pi ftest degrees -pi math degrees -math pi - ftest degrees math degrees testExp assertRaises TypeError math exp ftest exp - math exp - math e ftest exp math exp ftest exp math exp math e assertEqual math exp INF INF assertEqual math exp NINF assertTrue math isnan math exp NAN assertRaises OverflowError math exp testExp assertRaises TypeError math exp ftest exp - math exp - ftest exp math exp ftest exp math exp ftest exp math exp assertEqual math exp INF INF assertEqual math exp NINF assertTrue math isnan math exp NAN assertRaises OverflowError math exp testFabs assertRaises TypeError math fabs ftest fabs - math fabs - ftest fabs math fabs ftest fabs math fabs skipIfTorchDynamo infinite loop testFactorial assertEqual math factorial total = i range total = i assertEqual math factorial i total assertEqual math factorial i py_factorial i assertRaises ValueError math factorial - assertRaises ValueError math factorial - testFactorialNonIntegers assertRaises TypeError math factorial assertRaises TypeError math factorial assertRaises TypeError math factorial - assertRaises TypeError math factorial - e assertRaises TypeError math factorial decimal Decimal assertRaises TypeError math factorial decimal Decimal assertRaises TypeError math factorial Other implementations may place different upper bounds support cpython_only testFactorialHugeInputs Currently raises OverflowError inputs too large fit into C long assertRaises OverflowError math factorial assertRaises TypeError math factorial e testFloor assertRaises TypeError math floor assertEqual int type math floor assertEqual math floor assertEqual math floor assertEqual math floor assertEqual math floor - - assertEqual math floor - - assertEqual math floor - - #self assertEqual math ceil INF INF #self assertEqual math ceil NINF NINF #self assertTrue math isnan math floor NAN torch _dynamo error_on_graph_break False TestFloor __floor__ FloatFloor float __floor__ TestNoFloor pass TestBadFloor __floor__ = BadDescr assertEqual math floor TestFloor assertEqual math floor FloatFloor assertEqual math floor FloatLike assertRaises TypeError math floor TestNoFloor assertRaises ValueError math floor TestBadFloor t = TestNoFloor t __floor__ = lambda args args assertRaises TypeError math floor t assertRaises TypeError math floor t assertEqual math floor FloatLike + + assertEqual math floor FloatLike - - testFmod assertRaises TypeError math fmod ftest fmod math fmod ftest fmod math fmod ftest fmod math fmod ftest fmod - math fmod - - ftest fmod - math fmod - - ftest fmod - math fmod - - assertTrue math isnan math fmod NAN assertTrue math isnan math fmod NAN assertTrue math isnan math fmod NAN NAN assertRaises ValueError math fmod assertRaises ValueError math fmod INF assertRaises ValueError math fmod NINF assertRaises ValueError math fmod INF assertEqual math fmod INF assertEqual math fmod - INF - assertEqual math fmod NINF assertEqual math fmod - NINF - assertEqual math fmod assertEqual math fmod NINF assertRaises ValueError math fmod INF INF testFrexp assertRaises TypeError math frexp testfrexp name result expected mant exp emant eexp = result expected abs mant-emant eps exp = eexp fail s returned r expected r \ name result expected testfrexp frexp - math frexp - - testfrexp frexp math frexp testfrexp frexp math frexp testfrexp frexp math frexp assertEqual math frexp INF INF assertEqual math frexp NINF NINF assertTrue math isnan math frexp NAN requires_IEEE_ unittest skipIf HAVE_DOUBLE_ROUNDING fsum exact machines double rounding testFsum math fsum relies exact rounding correct operation There s known problem IA floating-point causes inexact rounding some situations will cause math fsum tests below fail see issue On non IEEE platforms IEEE platforms exhibit problem described issue we simply skip whole test Python version math fsum comparison Uses different algorithm based frexp ldexp integer arithmetic sys float_info mant_dig = float_info mant_dig etiny = float_info min_exp - mant_dig msum iterable Full precision summation Compute sum iterable without any intermediate accumulation error Based lsum function https code activestate com recipes -binary-floating-point-summation-accurate-to-full-p tmant texp = x iterable mant exp = math frexp x mant exp = int math ldexp mant mant_dig exp - mant_dig texp exp tmant = texp-exp texp = exp mant = exp-texp tmant += mant Round tmant texp float The original recipe used float str tmant texp s little unsafe because str - float conversion can t relied upon do correct rounding all platforms tail = max len bin abs tmant - - mant_dig etiny - texp tail h = tail- tmant = tmant h + bool tmant h tmant h- texp += tail math ldexp tmant texp test_values = e - e e- e - - e e- e - e e- e - - e e- - - - - - + + - + - - - n n range float fromhex x df f f e ap+ - n n n range float fromhex - x af bd p- e e- e - - - - e - - - - exercise code resizing partials array n - n+ + n+ n range - + - float fromhex x p+ Telescoping sum exact differences due Sterbenz terms = i i range test_values append terms i+ - terms i i range + -terms -terms i vals expected enumerate test_values try actual = math fsum vals except OverflowError fail test d failed got OverflowError expected r math fsum r i expected vals except ValueError fail test d failed got ValueError expected r math fsum r i expected vals assertEqual actual expected random random gauss shuffle j range vals = e - - e - e- e- s = i range v = gauss random - s s += v vals append v shuffle vals s = msum vals assertEqual msum vals math fsum vals assertEqual math fsum math inf math inf assertTrue math isnan math fsum math nan assertEqual math fsum e FloatLike - e e- e FloatLike - - e e- assertRaises OverflowError math fsum e+ e+ assertRaises ValueError math fsum math inf -math inf assertRaises TypeError math fsum spam assertRaises TypeError math fsum assertRaises OverflowError math fsum bad_iter yield raise ZeroDivisionError assertRaises ZeroDivisionError math fsum bad_iter testGcd gcd = math gcd assertEqual gcd assertEqual gcd assertEqual gcd - assertEqual gcd assertEqual gcd - assertEqual gcd assertEqual gcd - assertEqual gcd - assertEqual gcd assertEqual gcd - assertEqual gcd x = y = c = x c b = y c assertEqual gcd b c assertEqual gcd b c assertEqual gcd -a b c assertEqual gcd b -a c assertEqual gcd -b c assertEqual gcd -b c assertEqual gcd -a -b c assertEqual gcd -b -a c assertEqual gcd assertEqual gcd assertEqual gcd - assertEqual gcd assertEqual gcd assertRaises TypeError gcd assertRaises TypeError gcd assertRaises TypeError gcd assertRaises TypeError gcd assertEqual gcd MyIndexable MyIndexable testHypot decimal Decimal fractions Fraction hypot = math hypot Test different numbers arguments zero five against straightforward pure python implementation args = math e math pi math sqrt math gamma math sin i range len args + assertAlmostEqual hypot args i math sqrt sum s s args i Test allowable types those __float__ assertEqual hypot assertEqual hypot assertEqual hypot - assertEqual hypot - assertEqual hypot FloatLike - assertEqual hypot FloatLike - assertEqual hypot Decimal Decimal assertEqual hypot Fraction Fraction Fraction assertEqual hypot True False True True True Test corner cases assertEqual hypot Max input zero assertEqual hypot - Negative input assertEqual hypot Negative input assertEqual math copysign hypot - Convert negative zero positive zero assertEqual Handling moving max end hypot hypot Test handling bad arguments assertRaises TypeError Reject keyword args hypot x= assertRaises TypeError Reject values without __float__ hypot string int_too_big_for_float = sys float_info max_ _exp + assertRaises ValueError OverflowError hypot int_too_big_for_float Any infinity gives positive infinity assertEqual hypot INF INF assertEqual hypot INF INF assertEqual hypot INF INF assertEqual hypot - INF INF assertEqual hypot NAN INF INF assertEqual hypot INF NAN INF assertEqual hypot NINF NAN INF assertEqual hypot NAN NINF INF assertEqual hypot -INF INF INF assertEqual hypot -INF -INF INF assertEqual hypot -INF INF If no infinity any NaN gives NaN assertTrue math isnan hypot NAN assertTrue math isnan hypot NAN assertTrue math isnan hypot NAN assertTrue math isnan hypot NAN assertTrue math isnan hypot NAN NAN assertTrue math isnan hypot NAN Verify scaling extremely large values fourthmax = FLOAT_MAX n range assertTrue math isclose hypot fourthmax n fourthmax math sqrt n Verify scaling extremely small values exp range scale = FLOAT_MIN exp assertEqual math hypot scale scale scale assertRaises TypeError math hypot spam requires_IEEE_ unittest skipIf HAVE_DOUBLE_ROUNDING hypot loses accuracy machines double rounding testHypotAccuracy Verify improved accuracy cases known inaccurate The new algorithm s accuracy depends IEEE arithmetic guarantees having usual ROUND HALF EVEN rounding mode system having double rounding due extended precision compiler maintaining specified order operations This test known succeed most our builds If fails some build we either need add another skipIf cause identifiable otherwise we can remove test entirely hypot = math hypot Decimal = decimal Decimal high_precision = decimal Context prec= hx hy Cases ulp error Python compiled Clang x e dca p+ x f b efp+ x eb b p+ x ef cdc f p+ x c e bb p+ x ca b p+ x ae c cp+ x fbe b cp+ x f cd fb ap+ x fe ep+ x b cdd d p+ x b c cp+ x f e f e dp+ x fa bef eec p+ x e edd d fap+ x eb f e p+ x d e d p+ x fea p+ x e bfc p+ x b e b p+ Cases ulp error Python x d fp+ x c ca e p+ x b b p+ x e c e p+ x b e b p+ x dc c e dc p+ x e f bp+ x bd dc f baep+ x b b e cb f p+ x da ab p+ x d cfp+ x d d d ap+ x e b cd p+ x e dff p+ x bbb e p+ x c b fb ap+ x fd p+ x d p+ x e p+ x d af d da p+ Cases ulp error version fff c e b x ee dbd p+ x ab d fc e b p+ x c bfbec c dcp+ x b p+ x dcebba cap+ x ca e c p+ x cdd cf aap+ x cfdc d ep+ x dcf d ep+ x b ep+ x d e b p+ x e cp+ x f f c p+ x eb cd fp+ x d bcb ef p+ x f c cp+ x bdb f f p+ x ba c eed ap+ x d c ea c p+ x d dcfe bc p+ x = float fromhex hx y = float fromhex hy subTest hx=hx hy=hy x=x y=y decimal localcontext high_precision z = float Decimal x + Decimal y sqrt assertEqual hypot x y z testDist decimal Decimal D fractions Fraction F dist = math dist sqrt = math sqrt Simple exact cases assertEqual dist - assertEqual dist - Test different numbers arguments zero nine against straightforward pure python implementation i range j range p = tuple random uniform - k range i q = tuple random uniform - k range i assertAlmostEqual dist p q sqrt sum px - qx px qx zip p q Test non-tuple inputs assertEqual dist - assertEqual dist iter iter - Test allowable types those __float__ assertEqual dist - assertEqual dist - assertEqual dist FloatLike - assertEqual dist FloatLike - - assertEqual dist FloatLike - - assertEqual dist - - assertEqual dist D D D D - D assertEqual dist F F F F - F assertEqual dist True True False False True True True False True False False False Test corner cases assertEqual dist - - Distance zero assertEqual dist Zero-dimensional case assertEqual Convert negative zero positive zero math copysign dist - assertEqual Convert negative zero positive zero math copysign dist - assertEqual Handling moving max end dist dist Verify tuple subclasses allowed torch _dynamo error_on_graph_break False T tuple pass assertEqual dist T - Test handling bad arguments assertRaises TypeError Reject keyword args dist p= q= assertRaises TypeError Too few args dist assertRaises TypeError Too many args dist assertRaises TypeError Scalars allowed dist assertRaises TypeError Reject values without __float__ dist string assertRaises ValueError Check dimension agree dist assertRaises ValueError Check dimension agree dist assertRaises TypeError dist + spam assertRaises TypeError Rejects invalid types dist abc xyz int_too_big_for_float = sys float_info max_ _exp + assertRaises ValueError OverflowError dist int_too_big_for_float assertRaises ValueError OverflowError dist int_too_big_for_float assertRaises TypeError dist assertRaises TypeError dist torch _dynamo error_on_graph_break False BadFloat __float__ = BadDescr assertRaises ValueError dist BadFloat Verify one dimensional case equivalent abs i range p q = random random random random assertEqual dist p q abs p - q Test special values values = NINF - - INF NAN p itertools product values repeat= q itertools product values repeat= diffs = px - qx px qx zip p q any map math isinf diffs Any infinite difference gives positive infinity assertEqual dist p q INF any map math isnan diffs If no infinity any NaN gives NaN assertTrue math isnan dist p q Verify scaling extremely large values fourthmax = FLOAT_MAX n range p = fourthmax n q = n assertTrue math isclose dist p q fourthmax math sqrt n assertTrue math isclose dist q p fourthmax math sqrt n Verify scaling extremely small values exp range scale = FLOAT_MIN exp p = scale scale q = assertEqual math dist p q scale assertEqual math dist q p scale test_math_dist_leak gh- Check error handling does leak memory assertRaises ValueError math dist slowTest testIsqrt Test variety inputs large small test_values = list range + list range - + + e + i e range i range - + value test_values subTest value=value s = math isqrt value assertIs type s int assertLessEqual s s value assertLess value s+ s+ Negative values assertRaises ValueError math isqrt - Integer-like things s = math isqrt True assertIs type s int assertEqual s s = math isqrt False assertIs type s int assertEqual s torch _dynamo error_on_graph_break False IntegerLike object __init__ value value = value __index__ value s = math isqrt IntegerLike assertIs type s int assertEqual s assertRaises ValueError math isqrt IntegerLike - Non-integer-like things bad_values = string decimal Decimal j - value bad_values subTest value=value assertRaises TypeError math isqrt value test_lcm lcm = math lcm assertEqual lcm assertEqual lcm assertEqual lcm - assertEqual lcm assertEqual lcm - assertEqual lcm assertEqual lcm - assertEqual lcm - assertEqual lcm assertEqual lcm - assertEqual lcm x = y = c = x c b = y c d = x y c assertEqual lcm b d assertEqual lcm b d assertEqual lcm -a b d assertEqual lcm b -a d assertEqual lcm -b d assertEqual lcm -b d assertEqual lcm -a -b d assertEqual lcm -b -a d assertEqual lcm assertEqual lcm assertEqual lcm - assertEqual lcm assertEqual lcm assertRaises TypeError lcm assertRaises TypeError lcm assertRaises TypeError lcm assertRaises TypeError lcm assertEqual lcm MyIndexable MyIndexable testLdexp assertRaises TypeError math ldexp assertRaises TypeError math ldexp ftest ldexp math ldexp ftest ldexp math ldexp ftest ldexp - math ldexp - ftest ldexp - math ldexp - - assertRaises OverflowError math ldexp assertRaises OverflowError math ldexp - assertEqual math ldexp - assertEqual math ldexp - - - assertEqual math ldexp INF INF assertEqual math ldexp NINF - NINF assertTrue math isnan math ldexp NAN large second argument n assertEqual math ldexp INF -n INF assertEqual math ldexp NINF -n NINF assertEqual math ldexp -n assertEqual math ldexp - -n - assertEqual math ldexp -n assertEqual math ldexp - -n - assertTrue math isnan math ldexp NAN -n assertRaises OverflowError math ldexp n assertRaises OverflowError math ldexp - n assertEqual math ldexp n assertEqual math ldexp - n - assertEqual math ldexp INF n INF assertEqual math ldexp NINF n NINF assertTrue math isnan math ldexp NAN n testLog assertRaises TypeError math log assertRaises TypeError math log ftest log e math log math e - ftest log math log ftest log e math log math e ftest log math log ftest log math log ftest log math log ftest log math log assertRaises ValueError math log - assertRaises ValueError math log - assertRaises ValueError math log - assertRaises ValueError math log NINF assertEqual math log INF INF assertTrue math isnan math log NAN testLog p assertRaises TypeError math log p n assertAlmostEqual math log p n math log p float n assertRaises ValueError math log p - assertEqual math log p INF INF skipIfTorchDynamo Infinite loop requires_IEEE_ testLog assertRaises TypeError math log Check some integer values assertEqual math log assertEqual math log assertEqual math log Large integer values assertEqual math log assertEqual math log assertEqual math log assertRaises ValueError math log - assertRaises ValueError math log NINF assertTrue math isnan math log NAN skipIfTorchDynamo Infinite loop requires_IEEE_ log accurate enough Mac OS X Tiger support requires_mac_ver testLog Exact Check we get exact equality log powers actual = math log math ldexp n n range - expected = float n n range - assertEqual actual expected testLog assertRaises TypeError math log ftest log math log - ftest log math log ftest log math log ftest log math log assertRaises ValueError math log - assertRaises ValueError math log - assertRaises ValueError math log NINF assertEqual math log INF INF assertTrue math isnan math log NAN testSumProd sumprod = math sumprod Decimal = decimal Decimal Fraction = fractions Fraction Core functionality assertEqual sumprod iter assertEqual sumprod assertEqual sumprod assertEqual sumprod - - assertEqual sumprod - - Type preservation coercion v - Fraction Fraction Decimal Decimal float int Fraction float fraction Fraction int fraction Decimal int decimal p q v v v v - subTest p=p q=q expected = sum p_i q_i p_i q_i zip p q strict=True actual = sumprod p q assertEqual expected actual assertEqual type expected type actual Bad arguments assertRaises TypeError sumprod No args assertRaises TypeError sumprod One arg assertRaises TypeError sumprod Three args assertRaises TypeError sumprod None Non-iterable assertRaises TypeError sumprod None Non-iterable assertRaises TypeError sumprod x Uneven lengths assertRaises ValueError sumprod assertRaises ValueError sumprod Overflows assertEqual sumprod assertEqual sumprod assertEqual sumprod assertEqual sumprod assertRaises OverflowError sumprod assertRaises OverflowError sumprod Error iterator raise_after n i range n yield i raise RuntimeError assertRaises RuntimeError sumprod range raise_after assertRaises RuntimeError sumprod raise_after range test_iter BasicIterClass assertEqual sumprod BasicIterClass assertEqual sumprod BasicIterClass Error multiplication torch _dynamo error_on_graph_break False BadMultiply __mul__ other raise RuntimeError __rmul__ other raise RuntimeError assertRaises RuntimeError sumprod BadMultiply assertRaises RuntimeError sumprod BadMultiply Error addition assertRaises TypeError sumprod abc assertRaises TypeError sumprod abc Special values should give same pure python recipe assertEqual sumprod math inf math inf assertEqual sumprod math inf math inf math inf assertEqual sumprod math inf math inf math inf math inf assertEqual sumprod -math inf -math inf assertTrue math isnan sumprod math inf -math inf math inf assertTrue math isnan sumprod math nan assertTrue math isnan sumprod math inf math nan assertTrue math isnan sumprod math inf math nan Error cases arose during development args = - - assertEqual sumprod args requires_IEEE_ unittest skipIf HAVE_DOUBLE_ROUNDING sumprod accuracy guaranteed machines double rounding support cpython_only Other implementations may choose different algorithm test_sumprod_accuracy sumprod = math sumprod assertEqual sumprod assertEqual sumprod True False assertEqual sumprod True False assertEqual sumprod E - E support requires_resource cpu test_sumprod_stress sumprod = math sumprod product = itertools product Decimal = decimal Decimal Fraction = fractions Fraction torch _dynamo error_on_graph_break False Int int __add__ other Int int + int other __mul__ other Int int int other __radd__ = __add__ __rmul__ = __mul__ __repr__ f Int int Flt float __add__ other Int int + int other __mul__ other Int int int other __radd__ = __add__ __rmul__ = __mul__ __repr__ f Flt int baseline_sumprod p q This defines target behavior including exceptions special values However subject rounding errors so float inputs should exactly representable only few bits total = p_i q_i zip p q strict=True total += p_i q_i total run func args Make comparing functions easier Returns error status type result try result = func args except AssertionError NameError raise except Exception e type e None None None type result repr result pools = - - Int - - - - - - - - - float inf -float inf float NaN + j Flt - Decimal Decimal - Fraction Fraction - + j - Int Decimal Decimal Decimal - Decimal Decimal Inf -Decimal Inf Decimal NaN - - - - - - - - - - - - - - - True False Int pool pools size range args product pool repeat=size args product pool repeat=size args = args args assertEqual run baseline_sumprod args run sumprod args args requires_IEEE_ unittest skipIf HAVE_DOUBLE_ROUNDING sumprod accuracy guaranteed machines double rounding support cpython_only Other implementations may choose different algorithm support requires_resource cpu test_sumprod_extended_precision_accuracy operator fractions Fraction itertools starmap collections namedtuple math log exp fabs random choices uniform shuffle statistics median DotExample = namedtuple DotExample x y target_sumprod condition DotExact x y vec = map Fraction x vec = map Fraction y sum starmap operator mul zip vec vec strict=True Condition x y DotExact map abs x map abs y abs DotExact x y linspace lo hi n width = hi - lo n - lo + width i i range n GenDot n c Algorithm GenDot works follows The condition number dot product xT y proportional degree cancellation In order achieve prescribed cancellation we generate first half vectors x y randomly within large exponent range This range chosen according anticipated condition number The second half x y then constructed choosing xi randomly decreasing exponent calculating yi such some cancellation occurs Finally we permute vectors x y randomly calculate achieved condition number assert n = n = n x = n y = n b = log c First half exponents &#124; _b _ &#124; random ints between e = choices range int b k=n e = int b + e - = x n = uniform - exp p p e y n = uniform - exp p p e Second half e = list map round linspace b n-n i range n n x i = uniform - exp e i - n y i = uniform - exp e i - n - DotExact x y x i Shuffle pairs = list zip x y shuffle pairs x y = zip pairs DotExample x y DotExact x y Condition x y RelativeError res ex x y target_sumprod condition = ex n = DotExact list x + -res list y + fabs n target_sumprod Trial dotfunc c n ex = GenDot c res = dotfunc ex x ex y RelativeError res ex times = Number trials n = Length vectors c = e Target condition number If following test fails means C math library implementation fma compliant C standard inaccurate To solve problem make new build symbol UNRELIABLE_FMA defined That will enable slower accurate code path avoids fma call relative_err = median Trial math sumprod c n i range times assertLess relative_err e- testModf assertRaises TypeError math modf testmodf name result expected v v e e = result expected abs v -e eps abs v -e fail s returned r expected r \ name result expected testmodf modf math modf testmodf modf - math modf - - - assertEqual math modf INF INF assertEqual math modf NINF - NINF modf_nan = math modf NAN assertTrue math isnan modf_nan assertTrue math isnan modf_nan testPow assertRaises TypeError math pow ftest pow math pow ftest pow math pow ftest pow math pow ftest pow - math pow - assertEqual math pow INF INF assertEqual math pow NINF NINF assertEqual math pow INF assertEqual math pow NINF assertTrue math isnan math pow NAN assertTrue math isnan math pow NAN assertTrue math isnan math pow NAN assertEqual math pow NAN assertRaises OverflowError math pow e+ e+ pow x assertEqual math pow INF assertEqual math pow assertEqual math pow assertEqual math pow assertEqual math pow assertEqual math pow - assertRaises ValueError math pow - assertRaises ValueError math pow - assertRaises ValueError math pow - assertEqual math pow NINF INF assertTrue math isnan math pow NAN pow INF x assertEqual math pow INF INF INF assertEqual math pow INF INF assertEqual math pow INF INF assertEqual math pow INF INF assertEqual math pow INF assertEqual math pow INF - assertEqual math pow INF - assertEqual math pow INF - assertEqual math pow INF - assertEqual math pow INF NINF assertTrue math isnan math pow INF NAN pow - x assertEqual math pow - INF assertEqual math pow - - assertEqual math pow - assertEqual math pow - assertEqual math pow - assertEqual math pow - - assertRaises ValueError math pow - - assertRaises ValueError math pow - - assertRaises ValueError math pow - - assertEqual math pow - NINF INF assertTrue math isnan math pow - NAN pow NINF x assertEqual math pow NINF INF INF assertEqual math pow NINF NINF assertEqual math pow NINF INF assertEqual math pow NINF INF assertEqual math pow NINF assertEqual math pow NINF - assertEqual math pow NINF - assertEqual math pow NINF - assertEqual math pow NINF - - assertEqual math pow NINF NINF assertTrue math isnan math pow NINF NAN pow - x assertEqual math pow - INF assertEqual math pow - - assertRaises ValueError math pow - assertEqual math pow - assertEqual math pow - assertEqual math pow - - assertEqual math pow - - assertRaises ValueError math pow - - assertEqual math pow - - - assertEqual math pow - NINF assertTrue math isnan math pow - NAN pow x assertEqual math pow INF assertEqual math pow assertEqual math pow assertEqual math pow assertEqual math pow assertEqual math pow - assertEqual math pow - assertEqual math pow - assertEqual math pow - assertEqual math pow NINF assertEqual math pow NAN pow x should any x assertEqual math pow assertEqual math pow - assertEqual math pow NAN assertEqual math pow - assertEqual math pow - - assertEqual math pow NAN - pow x y invalid x negative y integral assertRaises ValueError math pow - assertRaises ValueError math pow - - pow x NINF assertEqual math pow NINF assertEqual math pow NINF assertEqual math pow NINF INF assertEqual math pow NINF INF assertEqual math pow - NINF INF assertEqual math pow - NINF INF assertEqual math pow - NINF assertEqual math pow - NINF pow x INF assertEqual math pow INF INF assertEqual math pow INF INF assertEqual math pow INF assertEqual math pow INF assertEqual math pow - INF assertEqual math pow - INF assertEqual math pow - INF INF assertEqual math pow - INF INF pow x y should work x negative y integer ftest - math pow - - ftest - math pow - ftest - math pow - - ftest - math pow - ftest - - math pow - - ftest - - math pow - - - ftest - - math pow - - ftest - - math pow - - - assertRaises ValueError math pow - - assertRaises ValueError math pow - following tests have been commented out since they don t really belong here implementation floats independent implementation math pow #self assertEqual NAN #self assertEqual INF #self assertEqual NINF #self assertEqual #self assertEqual NAN #self assertEqual INF #self assertEqual NINF #self assertEqual testRadians assertRaises TypeError math radians ftest radians math radians math pi ftest radians math radians math pi ftest radians - math radians - -math pi ftest radians math radians requires_IEEE_ testRemainder fractions Fraction validate_spec x y r Check r matches remainder x y according IEEE specification Assumes x y r finite y nonzero fx fy fr = Fraction x Fraction y Fraction r r should exceed y absolute value assertLessEqual abs fr abs fy x - r should exact integer multiple y n = fx - fr fy assertEqual n int n abs fr == abs fy If &#124; r &#124; == &#124; y &#124; n should even assertEqual n int n triples x y remainder x y hexadecimal form testcases = Remainders modulo showing ties-to-even behaviour - - - - - - - - - - - - - - - - - - Reductions modulo pi x p+ x fb d p+ x p+ x fb d p+ x fb d p+ x fb d p+ x fb d p+ x fb d p+ x fb d p+ x fb d p+ x fb d p+ x fb d p+ x fb d p+ x fb d p+ - x fb d p+ x fb d p+ x fb d p+ - x p+ x fb d p+ x fb d p+ x p x fb d p+ x fb d p+ x p+ x d c f d p+ x fb d p+ x fb d p+ x d c f d p+ x fb d p+ - x fb d p+ x d c f d p+ x fb d p+ - x fb d p+ x fb d p+ x fb d p+ - x p+ x fb d p+ x fb d p+ x p x fb d p+ x fb d p+ x p+ x f dp+ x fb d p+ x fb d p+ x f ep+ x fb d p+ x fb d p+ x f fp+ x fb d p+ - x fb d p+ x cc eedf p+ x fb d p+ x fb d p+ x cc eedf p+ x fb d p+ - x fb d p+ Symmetry respect signs c - c - - c - - c - c - - c - c - - - c Huge modulus check underlying algorithm doesn t rely modulus being representable x dp+ x p+ x p+ x ep+ x p+ - x ap+ x fp+ x p+ - x p+ case testcases subTest case=case x_hex y_hex expected_hex = case split x = float fromhex x_hex y = float fromhex y_hex expected = float fromhex expected_hex validate_spec x y expected actual = math remainder x y Cheap way checking floats identical we need them assertEqual actual hex expected hex Test tiny subnormal modulus there s potential getting implementation wrong here example assuming modulus exactly representable tiny = float fromhex p- min +ve subnormal n range - n == continue y = n tiny m range x = m tiny actual = math remainder x y validate_spec x y actual actual = math remainder -x y validate_spec -x y actual Special values NaNs should propagate usual value NAN - - NINF INF assertIsNaN math remainder NAN value assertIsNaN math remainder value NAN remainder x inf x non-nan non-infinite x value - - assertEqual math remainder value INF value assertEqual math remainder value NINF value remainder x remainder infinity x non-NaN x invalid operations according IEEE - f should raise value NINF - - INF assertRaises ValueError math remainder INF value assertRaises ValueError math remainder NINF value assertRaises ValueError math remainder value assertRaises ValueError math remainder value - testSin assertRaises TypeError math sin ftest sin math sin ftest sin pi math sin math pi ftest sin -pi math sin -math pi - try assertTrue math isnan math sin INF assertTrue math isnan math sin NINF except ValueError assertRaises ValueError math sin INF assertRaises ValueError math sin NINF assertTrue math isnan math sin NAN testSinh assertRaises TypeError math sinh ftest sinh math sinh ftest sinh -cosh math sinh -math cosh - ftest sinh +sinh - math sinh +math sinh - assertEqual math sinh INF INF assertEqual math sinh NINF NINF assertTrue math isnan math sinh NAN testSqrt assertRaises TypeError math sqrt ftest sqrt math sqrt ftest sqrt math sqrt ftest sqrt math sqrt ftest sqrt math sqrt ftest sqrt math sqrt ftest sqrt math sqrt ftest sqrt math sqrt assertEqual math sqrt INF INF assertRaises ValueError math sqrt - assertRaises ValueError math sqrt NINF assertTrue math isnan math sqrt NAN testTan assertRaises TypeError math tan ftest tan math tan ftest tan pi math tan math pi ftest tan -pi math tan -math pi - try assertTrue math isnan math tan INF assertTrue math isnan math tan NINF except ValueError assertRaises ValueError math tan INF assertRaises ValueError math tan NINF assertTrue math isnan math tan NAN testTanh assertRaises TypeError math tanh ftest tanh math tanh ftest tanh +tanh - math tanh +math tanh - abs_tol=math ulp ftest tanh inf math tanh INF ftest tanh -inf math tanh NINF - assertTrue math isnan math tanh NAN requires_IEEE_ testTanhSign check tanh - == - IEEE systems assertEqual math tanh - - assertEqual math copysign math tanh - math copysign - test_trunc assertEqual math trunc assertEqual math trunc - - assertEqual type math trunc int assertEqual type math trunc int assertEqual math trunc assertEqual math trunc - - assertEqual math trunc assertEqual math trunc - - assertEqual math trunc - - assertEqual math trunc - - torch _dynamo error_on_graph_break False TestTrunc __trunc__ FloatTrunc float __trunc__ TestNoTrunc pass TestBadTrunc __trunc__ = BadDescr assertEqual math trunc TestTrunc assertEqual math trunc FloatTrunc assertRaises TypeError math trunc assertRaises TypeError math trunc assertRaises TypeError math trunc FloatLike assertRaises TypeError math trunc TestNoTrunc assertRaises ValueError math trunc TestBadTrunc testIsfinite assertTrue math isfinite assertTrue math isfinite - assertTrue math isfinite assertTrue math isfinite - assertFalse math isfinite float nan assertFalse math isfinite float inf assertFalse math isfinite float -inf testIsnan assertTrue math isnan float nan assertTrue math isnan float -nan assertTrue math isnan float inf assertFalse math isnan float inf assertFalse math isnan assertFalse math isnan testIsinf assertTrue math isinf float inf assertTrue math isinf float -inf assertTrue math isinf E assertTrue math isinf - E assertFalse math isinf float nan assertFalse math isinf assertFalse math isinf test_nan_constant ` math nan ` must quiet NaN positive sign bit assertTrue math isnan math nan assertEqual math copysign math nan test_inf_constant assertTrue math isinf math inf assertGreater math inf assertEqual math inf float inf assertEqual -math inf float -inf RED_FLAG -Oct- Tim While more consistent about exceptions than previous releases still fails part test some platforms For now we only run test_exceptions verbose mode so isn t normally tested unittest skipUnless verbose requires verbose mode test_exceptions try x = math exp - except mathmodule c failing weed out underflows libm we ve got fp format huge dynamic range fail underflowing exp should have raised exception x = fail underflowing exp should have returned If fails probably using strict IEEE- conforming libm x +Inf afterwards But Python wants overflows detected default try x = math exp except OverflowError pass fail overflowing exp didn t trigger OverflowError If fails could puzzle One odd possibility mathmodule c s macros getting confused while comparing Inf HUGE_VAL NaN artificially setting errno ERANGE result so raising OverflowError instead try x = math sqrt - except ValueError pass fail sqrt - didn t raise ValueError requires_IEEE_ test_testfile Some tests need skipped ancient OS X versions See issue SKIP_ON_TIGER = tan osx_version = None sys platform == darwin version_txt = platform mac_ver try osx_version = tuple map int version_txt split except ValueError pass fail_fmt = r failures = id fn ar ai er ei flags parse_testfile test_file Skip either input result complex ai = ei = continue fn rect polar no real versions rect polar continue Skip certain tests OS X osx_version None osx_version id SKIP_ON_TIGER continue func = getattr math fn invalid flags divide-by-zero flags er = ValueError overflow flags er = OverflowError try result = func ar except ValueError result = ValueError except OverflowError result = OverflowError C + says math h s sqrt If argument +∞ ± returned unmodified On another hand csqrt If z ± + i result + + i Lets correct zero sign er follow first convention id sqrt sqrt sqrt sqrt er = math copysign er ar Default tolerances ulp_tol abs_tol = failure = result_check er result ulp_tol abs_tol failure None continue msg = fail_fmt format id fn ar failure failures append msg failures fail Failures test_testfile \n + \n join failures requires_IEEE_ test_mtestfile fail_fmt = r failures = id fn arg expected flags parse_mtestfile math_testcases func = getattr math fn invalid flags divide-by-zero flags expected = ValueError overflow flags expected = OverflowError try got = func arg except ValueError got = ValueError except OverflowError got = OverflowError Default tolerances ulp_tol abs_tol = Exceptions defaults fn == gamma Experimental results one platform gave accuracy = ulps across entire float domain We weaken require ulp accuracy ulp_tol = fn == lgamma we use weaker accuracy test lgamma lgamma only achieves absolute error few multiples machine accuracy general abs_tol = e- fn == erfc arg = erfc has less-than-ideal accuracy large arguments x ~ so mainly due error involved computing exp -x x Observed between CPython mpmath dp x err = ulp = x err = ulp = x err = ulp = x err = ulp = x ulp arg ulp_tol = arg ulp_tol = ulp_tol = failure = result_check expected got ulp_tol abs_tol failure None continue msg = fail_fmt format id fn arg failure failures append msg failures fail Failures test_mtestfile \n + \n join failures test_prod fractions Fraction F prod = math prod assertEqual prod assertEqual prod start= assertEqual prod list range assertEqual prod iter list range assertEqual prod range start= assertEqual prod assertEqual prod assertEqual prod assertEqual prod assertEqual prod F Error multiplication torch _dynamo error_on_graph_break False BadMultiply __rmul__ other raise RuntimeError assertRaises RuntimeError prod BadMultiply Test overflow fast-path integers assertEqual prod Test overflow fast-path floats assertEqual prod float assertRaises TypeError prod assertRaises TypeError prod assertRaises TypeError prod b c assertRaises TypeError prod b c start= assertRaises TypeError prod b b c start=b values = bytearray b bytearray b b assertRaises TypeError prod values start=bytearray b assertRaises TypeError prod assertRaises TypeError prod assertRaises TypeError prod start= assertRaises TypeError prod start= Some odd cases assertEqual prod start= ab abababababab assertEqual prod start= assertEqual prod start= assertRaises TypeError prod start keyword-only argument assertEqual prod assertEqual prod assertEqual prod _naive_prod iterable start= elem iterable start = elem start Big integers iterable = range assertEqual prod iterable _naive_prod iterable iterable = range - - assertEqual prod iterable _naive_prod iterable iterable = range - assertEqual prod iterable Big floats iterable = float x x range assertEqual prod iterable _naive_prod iterable iterable = float x x range - - assertEqual prod iterable _naive_prod iterable iterable = float x x range - assertIsNaN prod iterable Float tests assertIsNaN prod float nan assertIsNaN prod float nan assertIsNaN prod float nan assertIsNaN prod float inf float nan assertIsNaN prod float -inf float nan assertIsNaN prod float nan float inf assertIsNaN prod float nan float -inf assertEqual prod float inf - float -inf assertEqual prod float -inf - float inf assertIsNaN prod float inf - assertIsNaN prod float -inf - assertIsNaN prod float inf - assertIsNaN prod float -inf - Type preservation assertEqual type prod int assertEqual type prod float assertEqual type prod range int assertEqual type prod range start= float assertEqual type prod decimal Decimal decimal Decimal skipIfTorchDynamo Infinite loop testPerm perm = math perm factorial = math factorial Test factorial definition satisfied n range k range n + n range n range assertEqual perm n k factorial n factorial n - k Test Pascal s identity n range k range n assertEqual perm n k perm n - k - k + perm n - k Test corner cases n range assertEqual perm n assertEqual perm n n assertEqual perm n n factorial n Test one argument form n range assertEqual perm n factorial n assertEqual perm n None factorial n Raises TypeError any argument non-integer argument count assertRaises TypeError perm assertRaises TypeError perm decimal Decimal assertRaises TypeError perm assertRaises TypeError perm assertRaises TypeError perm decimal Decimal assertRaises TypeError perm assertRaises TypeError perm assertRaises TypeError perm assertRaises TypeError perm Raises Value error k n negative numbers assertRaises ValueError perm - assertRaises ValueError perm - assertRaises ValueError perm - assertRaises ValueError perm - Returns zero k greater than n assertEqual perm assertEqual perm n = assertEqual perm n assertEqual perm n n assertEqual perm n n n- support check_impl_detail cpython=True assertRaises OverflowError perm n n n k True True True False False False assertEqual perm n k assertIs type perm n k int assertEqual perm IntSubclass IntSubclass assertEqual perm MyIndexable MyIndexable k range assertIs type perm IntSubclass IntSubclass k int assertIs type perm MyIndexable MyIndexable k int skipIfTorchDynamo infinite loop testComb comb = math comb factorial = math factorial Test factorial definition satisfied n range k range n + n range n range assertEqual comb n k factorial n factorial k factorial n - k Test Pascal s identity n range k range n assertEqual comb n k comb n - k - + comb n - k Test corner cases n range assertEqual comb n assertEqual comb n n n range assertEqual comb n n assertEqual comb n n - n Test Symmetry n range k range n assertEqual comb n k comb n n - k Raises TypeError any argument non-integer argument count assertRaises TypeError comb assertRaises TypeError comb decimal Decimal assertRaises TypeError comb assertRaises TypeError comb assertRaises TypeError comb decimal Decimal assertRaises TypeError comb assertRaises TypeError comb assertRaises TypeError comb assertRaises TypeError comb Raises Value error k n negative numbers assertRaises ValueError comb - assertRaises ValueError comb - assertRaises ValueError comb - assertRaises ValueError comb - Returns zero k greater than n assertEqual comb assertEqual comb n = assertEqual comb n assertEqual comb n n assertEqual comb n n n- assertEqual comb n n assertEqual comb n n- n assertEqual comb n n- n n- support check_impl_detail cpython=True assertRaises OverflowError comb n n n k True True True False False False assertEqual comb n k assertIs type comb n k int assertEqual comb IntSubclass IntSubclass assertEqual comb MyIndexable MyIndexable k range assertIs type comb IntSubclass IntSubclass k int assertIs type comb MyIndexable MyIndexable k int requires_IEEE_ test_nextafter around ^ ^ assertEqual math nextafter -INF assertEqual math nextafter INF assertEqual math nextafter assertEqual math nextafter - - around assertEqual math nextafter -INF float fromhex x fffffffffffffp- assertEqual math nextafter INF float fromhex x p+ assertEqual math nextafter -INF steps= float fromhex x fffffffffffffp- assertEqual math nextafter INF steps= float fromhex x p+ assertEqual math nextafter -INF steps= float fromhex x ffffffffffffdp- assertEqual math nextafter INF steps= float fromhex x p+ x == y y returned steps range assertEqual math nextafter steps=steps assertEqualSign math nextafter - + steps=steps + assertEqualSign math nextafter + - steps=steps - around smallest_subnormal = sys float_info min sys float_info epsilon assertEqual math nextafter + INF smallest_subnormal assertEqual math nextafter - INF smallest_subnormal assertEqual math nextafter + -INF -smallest_subnormal assertEqual math nextafter - -INF -smallest_subnormal assertEqualSign math nextafter smallest_subnormal + + assertEqualSign math nextafter -smallest_subnormal + - assertEqualSign math nextafter smallest_subnormal - + assertEqualSign math nextafter -smallest_subnormal - - around infinity largest_normal = sys float_info max assertEqual math nextafter INF largest_normal assertEqual math nextafter -INF -largest_normal assertEqual math nextafter largest_normal INF INF assertEqual math nextafter -largest_normal -INF -INF NaN assertIsNaN math nextafter NAN assertIsNaN math nextafter NAN assertIsNaN math nextafter NAN NAN assertEqual math nextafter INF steps= assertRaises ValueError math nextafter INF steps=- unittest skip flaky test under torch dynamo works pytest crashes unittest requires_IEEE_ test_ulp assertEqual math ulp sys float_info epsilon use int int rather than float int rely pow accuracy assertEqual math ulp assertEqual math ulp assertEqual math ulp min max assertEqual math ulp sys float_info min sys float_info epsilon assertEqual math ulp FLOAT_MAX FLOAT_MAX - math nextafter FLOAT_MAX -INF special cases assertEqual math ulp INF INF assertIsNaN math ulp math nan negative number ulp -x == ulp x x INF subTest x=x assertEqual math ulp -x math ulp x test_issue A SystemError should raised first arg atan copysign remainder cannot converted float torch _dynamo error_on_graph_break False F __float__ converted = True func math atan math copysign math remainder y = F assertRaises TypeError func number y There should have been any attempt convert second argument float assertFalse getattr y converted False test_input_exceptions assertRaises TypeError math exp spam assertRaises TypeError math erf spam assertRaises TypeError math atan spam assertRaises TypeError math atan spam assertRaises TypeError math atan assertRaises TypeError math atan Custom assertions assertIsNaN value math isnan value fail Expected NaN got r format value assertEqualSign x y Similar assertEqual compare also sign copysign Function useful compare signed zeros assertEqual x y assertEqual math copysign x math copysign y IsCloseTests __TestCase isclose = math isclose subclasses should override assertIsClose b args kwargs assertTrue isclose b args kwargs msg= s s should close b assertIsNotClose b args kwargs assertFalse isclose b args kwargs msg= s s should close b assertAllClose examples args kwargs b examples assertIsClose b args kwargs assertAllNotClose examples args kwargs b examples assertIsNotClose b args kwargs test_negative_tolerances ValueError should raised either tolerance less than zero assertRaises ValueError assertIsClose rel_tol=- e- assertRaises ValueError assertIsClose rel_tol= e- abs_tol=- e test_identical identical values must test close identical_examples = e e e- e- - assertAllClose identical_examples rel_tol= abs_tol= test_eight_decimal_places examples close e- e- eight_decimal_places_examples = e e + - e- - e- assertAllClose eight_decimal_places_examples rel_tol= e- assertAllNotClose eight_decimal_places_examples rel_tol= e- test_near_zero values close zero near_zero_examples = e- - e- - e- these should close any rel_tol assertAllNotClose near_zero_examples rel_tol= these should close abs_tol= e- assertAllClose near_zero_examples abs_tol= e- test_identical_infinite these close regardless tolerance -- i e they equal assertIsClose INF INF assertIsClose INF INF abs_tol= assertIsClose NINF NINF assertIsClose NINF NINF abs_tol= test_inf_ninf_nan these should never close following IEEE rules equality not_close_examples = NAN NAN NAN e- e- NAN INF NAN NAN INF INF NINF INF INF INF e e INF use largest reasonable tolerance assertAllNotClose not_close_examples abs_tol= test_zero_tolerance test zero tolerance zero_tolerance_close_examples = - - - e- - e- assertAllClose zero_tolerance_close_examples rel_tol= zero_tolerance_not_close_examples = e e assertAllNotClose zero_tolerance_not_close_examples rel_tol= test_asymmetry test asymmetry example PEP assertAllClose rel_tol= test_integers test integer values integer_examples = assertAllClose integer_examples rel_tol= e- assertAllNotClose integer_examples rel_tol= e- test_decimals test Decimal values decimal Decimal decimal_examples = Decimal Decimal Decimal e- Decimal e- Decimal e- Decimal e- Decimal e Decimal e assertAllClose decimal_examples rel_tol= e- assertAllNotClose decimal_examples rel_tol= e- test_fractions test Fraction values fractions Fraction fraction_examples = Fraction + Fraction Fraction Fraction Fraction + Fraction assertAllClose fraction_examples rel_tol= e- assertAllNotClose fraction_examples rel_tol= e- FMATests __TestCase Tests math fma test_fma_nan_results Selected representative values values = -math inf - e - - e- - e- e math inf math nan If any input NaN result should NaN too b itertools product values repeat= subTest a=a b=b assertIsNaN math fma math nan b assertIsNaN math fma math nan b assertIsNaN math fma b math nan test_fma_infinities Cases involving infinite inputs results positives = e- e math inf finites = - e - - e- - e- e non_nans = -math inf - - math inf ValueError due inf computation c non_nans infinity math inf -math inf zero - subTest c=c infinity=infinity zero=zero assertRaises ValueError math fma infinity zero c assertRaises ValueError math fma zero infinity c ValueError when b c both infinite opposite signs b positives subTest b=b assertRaises ValueError math fma math inf b -math inf assertRaises ValueError math fma math inf -b math inf assertRaises ValueError math fma -math inf -b -math inf assertRaises ValueError math fma -math inf b math inf assertRaises ValueError math fma b math inf -math inf assertRaises ValueError math fma -b math inf math inf assertRaises ValueError math fma -b -math inf -math inf assertRaises ValueError math fma b -math inf math inf Infinite result when b c both infinite same sign b positives subTest b=b assertEqual math fma math inf b math inf math inf assertEqual math fma math inf -b -math inf -math inf assertEqual math fma -math inf -b math inf math inf assertEqual math fma -math inf b -math inf -math inf assertEqual math fma b math inf math inf math inf assertEqual math fma -b math inf -math inf -math inf assertEqual math fma -b -math inf math inf math inf assertEqual math fma b -math inf -math inf -math inf Infinite result when b finite c infinite b itertools product finites finites subTest b=b assertEqual math fma b math inf math inf assertEqual math fma b -math inf -math inf Infinite result when b infinite c finite b c itertools product positives finites subTest b=b c=c assertEqual math fma math inf b c math inf assertEqual math fma -math inf b c -math inf assertEqual math fma -math inf -b c math inf assertEqual math fma math inf -b c -math inf assertEqual math fma b math inf c math inf assertEqual math fma b -math inf c -math inf assertEqual math fma -b -math inf c math inf assertEqual math fma -b math inf c -math inf gh- On some platforms libc fma doesn t implement IEE - properly doesn t use right sign when result zero unittest skipIf sys platform startswith freebsd wasi netbsd emscripten sys platform == android platform machine == x _ f platform doesn t implement IEE - properly test_fma_zero_result nonnegative_finites = e- e Zero results exact zero inputs b nonnegative_finites subTest b=b assertIsPositiveZero math fma b assertIsPositiveZero math fma b - assertIsNegativeZero math fma -b - assertIsPositiveZero math fma -b assertIsPositiveZero math fma - -b assertIsPositiveZero math fma - -b - assertIsNegativeZero math fma - b - assertIsPositiveZero math fma - b assertIsPositiveZero math fma b assertIsPositiveZero math fma b - assertIsNegativeZero math fma -b - assertIsPositiveZero math fma -b assertIsPositiveZero math fma -b - assertIsPositiveZero math fma -b - - assertIsNegativeZero math fma b - - assertIsPositiveZero math fma b - Exact zero result nonzero inputs assertIsPositiveZero math fma - assertIsPositiveZero math fma - assertIsPositiveZero math fma - - - assertIsPositiveZero math fma - Underflow zero tiny = e- assertIsPositiveZero math fma tiny tiny assertIsNegativeZero math fma tiny -tiny assertIsPositiveZero math fma -tiny -tiny assertIsNegativeZero math fma -tiny tiny assertIsPositiveZero math fma tiny tiny - assertIsNegativeZero math fma tiny -tiny - assertIsPositiveZero math fma -tiny -tiny - assertIsNegativeZero math fma -tiny tiny - Corner case where rounding multiplication would give wrong result x = float fromhex x p- y = float fromhex x p- z = float fromhex x p- assertIsNegativeZero math fma x-y x+y -z assertIsPositiveZero math fma y-x x+y z assertIsNegativeZero math fma y-x - x+y -z assertIsPositiveZero math fma x-y - x+y z test_fma_overflow = b = float fromhex x p c = float fromhex x p Overflow multiplication assertRaises OverflowError math fma b assertEqual math fma b c Overflow addition assertRaises OverflowError math fma b c No overflow even though b overflows float assertEqual math fma b -c c Extreme case b exactly overflow boundary so tiniest offset makes difference between overflow finite result = float fromhex x ffffffc p+ b = float fromhex x p+ c = float fromhex x p- assertRaises OverflowError math fma b assertRaises OverflowError math fma b c assertEqual math fma b -c float fromhex x fffffffffffffp+ Another extreme case here b about large possible subject math fma b c being finite = float fromhex x ae f p+ b = float fromhex x de db p+ c = float fromhex x fffffffffffffp+ assertEqual math fma b -c c test_fma_single_round = float fromhex x p- assertEqual math fma - + test_random A collection randomly generated inputs which naive FMA two rounds gives different result singly-rounded FMA tuples b c expected test_values = x adde b p- x b d caed p- x f e b deab p- x f da c adp- x ccc ad p- x ce bf p- x e bf bf e p- x af d aa p- x e abd d p- x e b e p- x ce p- x d cc c fbbp+ x f e efd p- x c cebp- x f fb ccd p- x ccdcee ff p- x bd f eedc p- x eee ca c p- x c eb p- x cdcfb fdb p+ x fbccdp- x b f p- x e da c b cbp- x c e c e p+ x f b bp- x ec bff p- x f f ccc bp- x ad f c bp- x d e cp- x cd abd p- x ab bbe p- x f b p+ x cb b b p- x fd d d p- x d ea f p- x b fd p- x aa e b p- x d dff p- x b ebdfp- x bf b cc p+ x e f e fp- x bcc fdcd fep- x fd f p- x b afbc p+ x d e fe p- x dd c afp- x e fc p- x df eb p- x cf c ee fbap- x b decdc p- x d fe ac p- x d ea c abbp+ x ae f p- x d ec f p- x b b fbp- x ef c p- x c d bf ec p- x bc e p- x ce b dc dp- x cf f bp+ x d ac p- x e cp- x f b fd p- x b cee caa p- a_hex b_hex c_hex expected_hex test_values subTest a_hex=a_hex b_hex=b_hex c_hex=c_hex expected_hex=expected_hex = float fromhex a_hex b = float fromhex b_hex c = float fromhex c_hex expected = float fromhex expected_hex assertEqual math fma b c expected assertEqual math fma b c expected Custom assertions assertIsNaN value assertTrue math isnan value msg= Expected NaN got r format value assertIsPositiveZero value assertTrue value == math copysign value msg= Expected positive zero got r format value assertIsNegativeZero value assertTrue value == math copysign value msg= Expected negative zero got r format value __name__ == __main__ run_tests