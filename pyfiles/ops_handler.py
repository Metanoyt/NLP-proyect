mypy allow-untyped-defs __future__ annotations inspect itertools re warnings io StringIO typing Any Callable Generic Literal NamedTuple Optional TypeVar Union unittest mock patch sympy torch torch utils _pytree pytree utils _ordered_set OrderedSet utils IndentedBuffer reduction_num_outputs sympy_index_symbol sympy_str T = TypeVar T StoreMode = Optional Literal atomic_add tma ReductionType = Literal argmax argmin welford_reduce welford_combine any max min prod sum dot xor_sum online_softmax_reduce _arg_str object - str isinstance sympy Expr sympy_str str See OpDecompositions superclass desugars operations like reciprocal square OpsHandler Generic T Protocol describing set valid operations ` ` torch _inductor virtualized ops ` ` well contract op handlers The type T signifies domain abstract analysis AKA what all functions take arguments anywhere compute occurs While these operators typically dtype polymorphic e g you can use mul both integers floats they do NOT do promotion usually same dtype input You expected have handled type promotion during ATen decompositions Most operators correspond exactly pointwise operations defined torch so when doubt about semantics check corresponding torch documentation These all scalar operations so they defined operate single element time For convenience many operators take src_dtype which indicates what dtype input argument Although principle can derived analysis providing ops where useful helps avoid having repeatedly recompute dtype code generation Note often describes static methods stateless ops handlers Handlers often defined using metaprogramming e g _initialize_pointwise_overrides which means you will get type errors those methods We have tests test inductor test_op_completeness py which check all operators implemented after all metaprogramming has run constant value Union bool float int dtype torch dtype - T Produces scalar constant type dtype raise NotImplementedError load_seed name str offset T - T Computes inductor_prims lookup_seed raise NotImplementedError rand seed T offset T - T Computes inductor_prims random mode= rand offset has dtype int raise NotImplementedError randn seed T offset T - T Computes inductor_prims random mode= randn offset has dtype int raise NotImplementedError randint seed T offset T low T high T - T Computes inductor_prims randint offset has dtype int raise NotImplementedError masked mask T body Callable T other T - T Computes body only perform loads stores boolean mask evaluates true For example you would use you needed perform indirect load may valid some elements without masking invalid accesses can cause IMAs When mask true result result body otherwise other Here ` other ` needs constant Contrast ops where which can multiplex between two values have been unconditionally computed raise NotImplementedError where condition T input T other T - T Computes torch where when condition true input otherwise other raise NotImplementedError index_expr expr sympy Expr dtype torch dtype - T Converts sympy expression into scalar type dtype expr typically indexing expression thus name however can also used non-indexing situations raise NotImplementedError to_dtype x T dtype torch dtype src_dtype Optional torch dtype = None use_compute_types bool = True - T Convert x dtype src_dtype can optionally set specify what original dtype x which can improve code generation used torch dtype=dtype raise NotImplementedError trunc_to_int x T dtype torch dtype - T Convert x dtype truncation semantics similar how int constructor works Python In Inductor codegen just decays trunc then to_dtype composite operation helps roundtrips Sympy evaluation dtype taken explicit parameter because desired output dtype typically index dtype which may vary between int int depending we ve shown all indexing operations can done int raise NotImplementedError ceil_to_int x T dtype torch dtype - T Convert x dtype ceiling semantics See also trunc_to_int raise NotImplementedError floor_to_int x T dtype torch dtype - T Convert x dtype ceiling semantics See also trunc_to_int raise NotImplementedError round_to_int x T dtype torch dtype - T Convert x dtype round-to-even semantics See also trunc_to_int raise NotImplementedError to_dtype_bitcast x T dtype torch dtype src_dtype torch dtype - T Reinterpret cast x dtype reinterpreting bits memory another dtype src_dtype must original type x raise NotImplementedError identity x T - T Returns x This used trigger CSE raise NotImplementedError ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ These operations only available kernel context Check torch _inductor codegen common CSEProxy their typical implementation op handler routing their respective implementations kernel handler Importantly inside kernel indexing mask variables available scope which typically used sympy Expr indexing indirect_indexing x T size sympy Expr check bool = True wrap_neg=True - sympy Expr Convert integral x into sympy Expr can subsequently used indexing computation size represents upper bound what valid indexes can when check True we check x bounds NB This typically mandatory implement any analysis because you MUST valid sympy Expr some sort even s meaningless symbol raise NotImplementedError load name str index sympy Expr - T Load memory location name offset some indexing expression index raise NotImplementedError store name str index sympy Expr value T mode StoreMode = None - None Store value memory location name offset expr If specified mode can require store atomic addition raise NotImplementedError TODO Better explain how collective semantics these ops remember input value scalar you can t reduce traditional sense reduction dtype torch dtype src_dtype torch dtype reduction_type ReductionType value T - Union T tuple T Perform reduction_type reduction value dtype src_dtype using dtype accumulation dtype reduction The result intermediate computation which should stored final location using ops store_reduction Valid reduction types For Welford reduction types function returns multiple outputs consult reduction_num_outputs determine amount metaprogramming applications raise NotImplementedError TODO practice seems actually None returning T makes common __getattr__ idioms type correctly Figure out should returning something store_reduction name str index sympy Expr value T - None Store fully accumulated result reduction memory location name offset expr raise NotImplementedError scan dtypes tuple torch dtype combine_fn Callable tuple T tuple T tuple T values tuple T - tuple T Perform associative scan value TODO Improve description some pseudocode raise NotImplementedError sort dtypes tuple torch dtype values tuple T stable bool descending bool - tuple T Sort values along reduction dimension raise NotImplementedError bucketize values T boundaries tuple str sympy Expr sympy Expr sympy Expr boundary_indices T indexing_dtype torch dtype right bool sorter Optional tuple str sympy Expr = None sorter_indices Optional T = None - T See Note Inductor bucketize op raise NotImplementedError partial_accumulate name str reduction_type ReductionType value T extra_meta dict str Any - None raise NotImplementedError ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ The following ops have semantics correspond exactly torch operation same corresponding name abs x T - T raise NotImplementedError exp x T - T raise NotImplementedError exp x T - T raise NotImplementedError expm x T - T raise NotImplementedError sqrt x T - T raise NotImplementedError relu x T - T raise NotImplementedError minimum x T x T - T raise NotImplementedError maximum x T x T - T raise NotImplementedError cos x T - T raise NotImplementedError sin x T - T raise NotImplementedError lgamma x T - T raise NotImplementedError erf x T - T raise NotImplementedError cosh x T - T raise NotImplementedError sinh x T - T raise NotImplementedError acos x T - T raise NotImplementedError acosh x T - T raise NotImplementedError asin x T - T raise NotImplementedError asinh x T - T raise NotImplementedError atan x T x T - T raise NotImplementedError atan x T - T raise NotImplementedError atanh x T - T raise NotImplementedError copysign x T x T - T raise NotImplementedError erfc x T - T raise NotImplementedError erfinv x T - T raise NotImplementedError frexp x T raise NotImplementedError hypot x T x T - T raise NotImplementedError log x T - T raise NotImplementedError log x T - T raise NotImplementedError nextafter x T x T - T raise NotImplementedError logical_and x T x T - T raise NotImplementedError logical_not x T - T raise NotImplementedError logical_or x T x T - T raise NotImplementedError logical_xor x T x T - T raise NotImplementedError bitwise_and x T x T - T raise NotImplementedError bitwise_not x T - T raise NotImplementedError bitwise_or x T x T - T raise NotImplementedError bitwise_xor x T x T - T raise NotImplementedError bitwise_left_shift x T x T - T raise NotImplementedError bitwise_right_shift x T x T - T raise NotImplementedError rsqrt x T - T raise NotImplementedError log p x T - T raise NotImplementedError tan x T - T raise NotImplementedError tanh x T - T raise NotImplementedError sigmoid x T - T raise NotImplementedError signbit x T - T raise NotImplementedError fmod x T x T - T raise NotImplementedError log x T - T raise NotImplementedError isinf x T - T raise NotImplementedError isnan x T - T raise NotImplementedError NB returns float like torch operation This rounds half even break ties round x T - T raise NotImplementedError NB returns float like torch operation floor x T - T raise NotImplementedError sign x T - T raise NotImplementedError NB returns float like torch operation trunc x T - T raise NotImplementedError NB returns float like torch operation ceil x T - T raise NotImplementedError neg x T - T raise NotImplementedError reciprocal x T - T raise NotImplementedError eq x T x T - T raise NotImplementedError ne x T x T - T raise NotImplementedError lt x T x T - T raise NotImplementedError gt x T x T - T raise NotImplementedError le x T x T - T raise NotImplementedError ge x T x T - T raise NotImplementedError add x T x T - T raise NotImplementedError sub x T x T - T raise NotImplementedError mul x T x T - T raise NotImplementedError NB returns float like torch operation pow x T x T - T raise NotImplementedError and_ x T x T - T raise NotImplementedError or_ x T x T - T raise NotImplementedError xor x T x T - T raise NotImplementedError These metaprogrammed MockHandler _init_cls lshift x T x T - T raise NotImplementedError rshift x T x T - T raise NotImplementedError ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ These special operators These only exist target language actually supports operator Keep sync pointwise_overrides_data airy_ai x T - T raise NotImplementedError bessel_j x T - T raise NotImplementedError bessel_j x T - T raise NotImplementedError bessel_y x T - T raise NotImplementedError bessel_y x T - T raise NotImplementedError digamma x T - T raise NotImplementedError erfcx x T - T raise NotImplementedError fma x T y T z T - T raise NotImplementedError igamma x T y T - T raise NotImplementedError igammac x T y T - T raise NotImplementedError gammainc x T y T - T raise NotImplementedError gammaincc x T y T - T raise NotImplementedError i x T - T raise NotImplementedError i e x T - T raise NotImplementedError i x T - T raise NotImplementedError i e x T - T raise NotImplementedError log_ndtr x T - T raise NotImplementedError modified_bessel_i x T - T raise NotImplementedError modified_bessel_i x T - T raise NotImplementedError modified_bessel_k x T - T raise NotImplementedError modified_bessel_k x T - T raise NotImplementedError ndtr x T - T raise NotImplementedError ndtri x T - T raise NotImplementedError polygamma x T y T - T raise NotImplementedError scaled_modified_bessel_k x T - T raise NotImplementedError scaled_modified_bessel_k x T - T raise NotImplementedError spherical_bessel_j x T - T raise NotImplementedError zeta x T y T - T raise NotImplementedError chebyshev_polynomial_t x T y T - T raise NotImplementedError chebyshev_polynomial_u x T y T - T raise NotImplementedError chebyshev_polynomial_v x T y T - T raise NotImplementedError chebyshev_polynomial_w x T y T - T raise NotImplementedError legendre_polynomial_p x T y T - T raise NotImplementedError shifted_chebyshev_polynomial_t x T y T - T raise NotImplementedError shifted_chebyshev_polynomial_u x T y T - T raise NotImplementedError shifted_chebyshev_polynomial_v x T y T - T raise NotImplementedError shifted_chebyshev_polynomial_w x T y T - T raise NotImplementedError hermite_polynomial_h x T y T - T raise NotImplementedError hermite_polynomial_he x T y T - T raise NotImplementedError laguerre_polynomial_l x T y T - T raise NotImplementedError ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ These operators bit special because they conventionally natively supported both Python C semantics differ so care must taken truncdiv x T x T - T C-style trunc division between integers only Computes true division two numbers rounds result zero raise NotImplementedError floordiv x T x T - T Python-style floor division between integers only Computes true division two numbers floors result If you want floor division floats do regular truediv floor result raise NotImplementedError truediv x T x T - T True division between floats Integer inputs NOT valid To do Python-style int int - float division use int_truediv raise NotImplementedError int_truediv x T x T - T True division between integers This NOT same promoting float doing integer division there bespoke algorithm doing division higher precision than above raise NotImplementedError mod x T x T - T C-style modulus take sign LHS x raise NotImplementedError remainder x T x T - T Python-style modulus take sign RHS x raise NotImplementedError square x T - T raise NotImplementedError check_bounds expr sympy Expr size sympy Expr lower bool upper bool - None raise NotImplementedError halide-only halide_clamp value T size sympy Expr check bool - T raise NotImplementedError triton-only dot x T y T - T raise NotImplementedError triton-only inline_asm_elementwise inputs T asm str constraints Optional str = None dtype torch dtype = torch float is_pure bool = True pack int = - T raise NotImplementedError output args T - None This fake op used analysis codegen raise NotImplementedError placeholder index int - T This fake op used analysis codegen raise NotImplementedError device_assert_async cond T msg str - T raise NotImplementedError _ignore_op_re = re compile r _ &#124; paren fullmatch list_ops cls type Any OrderedSet x x dir cls _ignore_op_re x OP_NAMES = list_ops OpsHandler DefaultHandler OpsHandler Any _default name str args tuple Any kwargs dict str Any - Any Default implementation all ops Override subclass provide generic op behavior Args name name op see OpHandler name args positional args passed op kwargs keyword args passed op Returns value op raise NotImplementedError __getattr__ name str - Any fallback args Any kwargs Any - Any _default name args kwargs would like remove function entirely s used MTIA backend warnings warn f undefined OpHandler name please add missing op schema fallback staticmethod _call_default target str call_default args kwargs _default target args kwargs call_default __name__ = target call_default classmethod _init_cls cls Here we codegen many functions form add b _default add b install them cls This same _call_default above about x faster since CPython varargs parsing slow code = StringIO target OP_NAMES sig = inspect signature getattr OpsHandler target all p kind == inspect Parameter POSITIONAL_OR_KEYWORD p default inspect Parameter empty p sig parameters values self_arg args = sig parameters keys assert self_arg == code write f target join args _default target r join args strip code write \n\n slower fallback ops default variadic arguments setattr cls target cls _call_default target ctx dict str Any = exec code getvalue ctx target impl ctx items target OP_NAMES setattr cls target impl DefaultHandler _init_cls NoopHandler DefaultHandler name = NoopHandler _default name str args tuple Any kwargs dict str Any - Any None staticmethod masked mask body other - None None staticmethod frexp x - tuple None None None None staticmethod scan dtypes combine_fn values - tuple None None len values staticmethod sort dtypes values stable descending - tuple None None len values staticmethod indirect_indexing index_var size check=True wrap_neg=True - sympy Symbol sympy S Zero BasicMathOpsMixin staticmethod add b f + b staticmethod sub b f - b staticmethod mul b f b staticmethod floordiv b f b staticmethod truediv b f b staticmethod mod b careful depending target semantics varies f b staticmethod pow b f b staticmethod lshift b f b staticmethod rshift b f b staticmethod and_ b f b staticmethod or_ b f &#124; b staticmethod xor b f ^ b staticmethod eq b f == b staticmethod ne b f = b staticmethod lt b f b staticmethod gt b f b staticmethod le b f = b staticmethod ge b f = b staticmethod neg f - MockHandler BasicMathOpsMixin DefaultHandler name = MockHandler _default name str args tuple Any kwargs dict str Any - Any fargs = map _arg_str args k v kwargs items fargs append f k = _arg_str v f ops name join fargs staticmethod masked mask body other - str f ops masked mask body other staticmethod frexp x f ops frexp x f ops frexp x staticmethod scan dtypes combine_fn values tuple f ops scan dtypes combine_fn values i i range len values staticmethod sort dtypes values stable descending tuple f ops sort dtypes values stable= stable descending= descending i i range len values staticmethod indirect_indexing index_var size check=True wrap_neg=True - sympy Symbol sympy_index_symbol str index_var KernelFormatterHandler DefaultHandler __init__ parent_handler OpsHandler Any parent_handler = parent_handler _output = IndentedBuffer var_counter = itertools count staticmethod ir_to_string ir_fn index rindex=None - str ir FlexibleLayout virtualized V args = index rindex rindex None index names = index rindex rindex None index formatter = KernelFormatterHandler MockHandler formatter _output indent - formatter _output writeline f inner_fn join names name arg zip names args arg lhs = join str _ isinstance v int sympy Integer v v arg formatter _output writeline f lhs = name V set_ops_handler formatter patch object FlexibleLayout allow_indexing True result = ir_fn args formatter getvalue result indirect_indexing args kwargs - sympy Symbol parent_handler indirect_indexing args kwargs _write line replace line new variable name varname = f tmp next var_counter _output writeline f varname = line varname _default name str args tuple Any kwargs dict str Any - Any pytree tree_map _write getattr parent_handler name args kwargs reduction dtype torch dtype src_dtype torch dtype reduction_type ReductionType value Union str tuple str - Union str tuple str line = parent_handler reduction dtype src_dtype reduction_type value num_values = reduction_num_outputs reduction_type varnames = f tmp next var_counter _ range num_values _output writeline f join varnames = line tuple varnames num_values varnames getvalue result _output writeline f result _output getvalue WrapperHandler DefaultHandler __init__ inner OpsHandler Any _inner = inner _default name str args tuple Any kwargs dict str Any - Any getattr _inner name args kwargs AddParenHandler WrapperHandler _default name str args tuple Any kwargs dict str Any - Any val = getattr _inner name args kwargs val isinstance val sympy Expr tuple list val f val OpCountResult NamedTuple num_ops int used_ops OrderedSet str read_buffers list str nontrivial_read_count int OpCounterCSE DefaultHandler Shim count how many ops used __init__ inner OpsHandler Any super __init__ parent_handler = inner op_count = var_names dict str str = _used_ops OrderedSet str = OrderedSet _read_names list str = _nontrivial_read_count = _default name str args tuple Any kwargs dict str Any - Any _used_ops add name pytree tree_map _update_count getattr parent_handler name args kwargs _update_count val varname = var_names get val varname varname = f tmp op_count op_count += var_names val = varname varname indirect_indexing args kwargs _used_ops add indirect_indexing parent_handler indirect_indexing args kwargs load name str index sympy Expr - str val = parent_handler load name index val var_names _used_ops add load _read_names append name isinstance index sympy Integer int _nontrivial_read_count += _update_count val load_seed name str offset T val = parent_handler load_seed name offset val var_names _used_ops add load_seed _read_names append name _update_count val bucketize values T boundaries tuple str sympy Expr sympy Expr sympy Expr boundary_indices T indexing_dtype torch dtype right bool sorter Optional tuple str sympy Expr = None sorter_indices Optional T = None - T See Note Inductor bucketize op val = parent_handler bucketize values boundaries boundary_indices indexing_dtype right sorter sorter_indices val var_names _used_ops add bucketize _read_names append boundaries sorter None _read_names append sorter _update_count val getvalue OpCountResult op_count _used_ops _read_names _nontrivial_read_count ExtractConstantsHandler NoopHandler __init__ device Optional torch device device = device constant value Any dtype torch dtype - torch _inductor ir Constant torch _inductor ir ir Constant value=value dtype=dtype device=self device torch get_default_device SimpleCSEHandler WrapperHandler Wraps underlying handler CSE pass NOTE Compared codegen level CSE simplified doesn t support stores which require load cache invalidation __init__ inner Any super __init__ inner cse_cache dict str Union Any tuple Any = mock = MockHandler indirect_indexing args kwargs - sympy Expr super indirect_indexing args kwargs type ignore misc store args kwargs - None raise NotImplementedError store implemented store_reduction args kwargs - None raise NotImplementedError store implemented _default name str args tuple Any kwargs dict str Any - Any key = getattr mock name args kwargs val = cse_cache get key val None val val = getattr _inner name args kwargs cse_cache key = val val device_assert_async args kwargs - None raise NotImplementedError f type __name__ device_assert_async should handled CSEProxy