mypy allow-untyped-defs copy logging traceback contextlib contextmanager enum Enum typing Any Optional Union torch _utils_internal signpost_event _compatibility compatibility graph Graph graph_module GraphModule node Node log = logging getLogger __name__ __all__ = annotate annotate_fn preserve_node_meta has_preserved_node_meta set_stack_trace set_grad_fn_seq_nr reset_grad_fn_seq_nr format_stack set_current_meta get_current_meta NodeSource NodeSourceAction get_graph_provenance_json set_current_replay_node get_current_replay_node current_meta dict str Any = current_replay_node Optional Node = None should_preserve_node_meta = False compatibility is_backward_compatible=False NodeSourceAction Enum CREATE = create REPLACE = replace compatibility is_backward_compatible=False NodeSource NodeSource data structure contains provenance information node If node ` ` created node ` b ` then ` meta from_node ` may contain NodeSource b NodeInfo __init__ name str target str graph_id int name = name target = target graph_id = graph_id pass_name str action list NodeSourceAction from_node list NodeSource node_info Optional NodeInfo _dict Optional dict str Any _action_string Optional str __init__ node Optional Node pass_name str = action Optional Union NodeSourceAction list NodeSourceAction = None pass_name = pass_name action None action = isinstance action list action = action action assert isinstance NodeSourceAction action = action node node_info = NodeInfo name=node name target=str node target graph_id=id node graph from_node = copy deepcopy node meta from_node from_node node meta node_info = None from_node = cache action string dict representation performance _action_string Optional str = None _dict Optional dict str Any = None property name - str node_info name node_info property target - str node_info target node_info property graph_id - int node_info graph_id node_info - __repr__ print_readable _get_action_string _action_string None _action_string = + join name lower action _action_string print_readable indent= indent result = action_string = _get_action_string result += indent + f name= name pass_name= pass_name action= action_string graph_id= graph_id \n item from_node result += item print_readable indent + result to_dict - dict _dict None Convert object dictionary action_string = _get_action_string _dict = name name target target graph_id graph_id pass_name pass_name action action_string from_node node to_dict node from_node assert _dict None _dict __eq__ other object isinstance other NodeSource False to_dict == other to_dict __hash__ Create hash based dictionary representation We need convert dict hashable form _make_hashable obj isinstance obj dict tuple sorted k _make_hashable v k v obj items isinstance obj list tuple _make_hashable item item obj obj hash _make_hashable to_dict classmethod _from_dict cls d Optional dict - Optional NodeSource Recursively deserialize from_node metadata dictionary data It used deserialize from_node field serialized metadata Please use constructor NodeSource node create NodeSource object d None None assert isinstance d dict f Expected dict got type d Create NodeSource object directly without going through constructor avoid issues graph ID node creation node_source = NodeSource __new__ NodeSource Reset cached properties node_source _action_string = None node_source _dict = None Set basic attributes node_source pass_name = d get pass_name Parse action string back NodeSourceAction enum list action_str = d get action actions = action_str action_name action_str split + action_name upper == CREATE actions append NodeSourceAction CREATE action_name upper == REPLACE actions append NodeSourceAction REPLACE node_source action = actions Create NodeInfo object directly name d target d graph_id d node_info = NodeSource NodeInfo d get name d get target d get graph_id - node_source node_info = node_info node_source node_info = None Recursively deserialize nested from_node d get from_node None None node_source from_node = result fn d get from_node result = cls _from_dict fn None node_source from_node = node_source compatibility is_backward_compatible=False contextmanager preserve_node_meta enable=True global should_preserve_node_meta global current_meta saved_should_preserve_node_meta = should_preserve_node_meta Shallow copy OK since fields current_meta mutated saved_current_meta = current_meta copy try should_preserve_node_meta = enable yield finally should_preserve_node_meta = saved_should_preserve_node_meta current_meta = saved_current_meta compatibility is_backward_compatible=False set_stack_trace stack list str global current_meta should_preserve_node_meta stack current_meta stack_trace = join stack compatibility is_backward_compatible=False contextmanager annotate annotation_dict dict Temporarily adds custom annotations current tracing context The fx_node produced tracing context will have custom annotations node metadata custom field This context manager allows you insert arbitrary metadata into PT tracing system updating global ` current_meta custom ` dictionary The annotations automatically reverted after context exits This intended advanced users who need attach additional metadata fx nodes e g debugging analysis external tooling during export tracing Note This API backward compatible may evolve future releases Note This API compatible fx symbolic_trace jit trace It s intended used PT family tracers e g torch export dynamo Args annotation_dict dict A dictionary custom key-value pairs inject into FX trace metadata Example After exiting context custom annotations removed annotate source custom_pass tag pass Your computation here global current_meta has_custom = custom current_meta old_custom = copy copy current_meta get custom try has_custom current_meta custom = Update all key-value pairs input dict current_meta custom update annotation_dict yield finally has_custom Restore original custom dict current_meta custom = old_custom del current_meta custom compatibility is_backward_compatible=False annotate_fn annotation_dict dict A decorator wraps function annotate context manager Use when you want annotate entire function instead specific code block Note This API backward compatible may evolve future releases Note This API compatible fx symbolic_trace jit trace It s intended used PT family tracers e g torch export dynamo Args annotation_dict dict A dictionary custom key-value pairs inject into FX trace metadata all operations function Example All operations my_function will have pp_stage their metadata annotate_fn pp_stage my_function x x + functools wraps decorator func wraps func wrapper args kwargs annotate annotation_dict func args kwargs wrapper decorator compatibility is_backward_compatible=False set_grad_fn_seq_nr seq_nr global current_meta should_preserve_node_meta The seq_nr captured eager mode grad_fn during forward current_meta grad_fn_seq_nr = current_meta get grad_fn_seq_nr + seq_nr current_meta in_grad_fn = current_meta get in_grad_fn + compatibility is_backward_compatible=False reset_grad_fn_seq_nr NB reset state properly would helpful towards supporting reentrant autograd we actually wanted do global current_meta should_preserve_node_meta current_level = current_meta get in_grad_fn assert current_level current_level == del current_meta in_grad_fn del current_meta grad_fn_seq_nr current_meta in_grad_fn = current_level - current_meta grad_fn_seq_nr = current_meta grad_fn_seq_nr - compatibility is_backward_compatible=False format_stack - list str should_preserve_node_meta current_meta get stack_trace fallback traceback format_stack traceback format_list traceback extract_stack - compatibility is_backward_compatible=False has_preserved_node_meta - bool should_preserve_node_meta compatibility is_backward_compatible=False contextmanager set_current_meta node pass_name= global current_meta should_preserve_node_meta node meta saved_meta = current_meta try current_meta = node meta copy Update from_node field current_meta provenance tracking Instead appending overwrite from_node field because current_meta will assigned new node The new NodeSource node will include information previous current_meta from_node current_meta from_node = NodeSource node pass_name NodeSourceAction CREATE yield finally current_meta = saved_meta yield compatibility is_backward_compatible=False get_current_meta - dict str Any current_meta compatibility is_backward_compatible=False contextmanager set_current_replay_node node Set currently replay node If ` current_replay_node ` None then we re re-generating ` current_replay_node ` FunctionalTensorMode See Note annotation more details global current_replay_node saved_current_replay_node = current_replay_node try current_replay_node = node yield finally current_replay_node = saved_current_replay_node compatibility is_backward_compatible=False get_current_replay_node Get currently replay node current_replay_node compatibility is_backward_compatible=False get_graph_provenance_json graph Graph - dict str Any Given fx Graph json contains provenance information each node try provenance_tracking_json = node graph nodes node op == call_function provenance_tracking_json node name = source to_dict source node meta from_node from_node node meta provenance_tracking_json except Exception e Since just debugging should never interfere regular program execution so we use try-except guard against any error signpost_event inductor provenance_tracking_error function get_graph_provenance_json error_msg str e stack_trace traceback format_exc _get_custom_metadata gm GraphModule - str assert isinstance gm GraphModule helper gm GraphModule custom_metadata = node gm graph nodes hasattr node meta node meta get custom None custom_metadata append node op node name node meta custom node op == get_attr isinstance getattr gm node target GraphModule custom_metadata append helper getattr gm node target custom_metadata \n join str x x helper gm