mypy allow-untyped-defs abc cmath collections abc contextlib collections abc Callable Collection Sequence typing Any NoReturn Optional Union typing_extensions deprecated torch try numpy np HAS_NUMPY = True except ModuleNotFoundError HAS_NUMPY = False np = None type ignore assignment ErrorMeta Exception Internal testing exception makes carries error metadata __init__ type type Exception msg str id tuple Any = - None super __init__ If you user see message during normal operation please file issue https github com pytorch pytorch issues If you developer working comparison functions please ` raise ErrorMeta to_error ` user facing errors type = type msg = msg id = id to_error msg Optional Union str Callable str str = None - Exception isinstance msg str generated_msg = msg id generated_msg += f \n\nThe failure occurred item join str item item id msg = msg generated_msg callable msg generated_msg type msg Some analysis tolerance logging tests test_torch py can found https github com pytorch pytorch pull dtype rtol atol _DTYPE_PRECISIONS = torch float e- torch bfloat e- torch float e- e- torch float e- e- torch complex e- torch complex e- e- torch complex e- e- The default tolerances torch float used quantized dtypes because quantized tensors compared their dequantized floating point representation For more details see ` TensorLikePair _compare_quantized_values ` _DTYPE_PRECISIONS update dict fromkeys torch quint torch quint x torch quint x torch qint torch qint _DTYPE_PRECISIONS torch float default_tolerances inputs Union torch Tensor torch dtype dtype_precisions Optional dict torch dtype tuple float float = None - tuple float float Returns default absolute relative testing tolerances set inputs based dtype See func ` assert_close ` table default tolerance each dtype Returns Tuple float float Loosest tolerances all input dtypes dtypes = input inputs isinstance input torch Tensor dtypes append input dtype isinstance input torch dtype dtypes append input raise TypeError f Expected torch Tensor torch dtype got type input instead dtype_precisions = dtype_precisions _DTYPE_PRECISIONS rtols atols = zip dtype_precisions get dtype dtype dtypes strict=True max rtols max atols get_tolerances inputs Union torch Tensor torch dtype rtol Optional float atol Optional float id tuple Any = - tuple float float Gets absolute relative used numeric comparisons If both ` ` rtol ` ` ` ` atol ` ` specified no-op If both specified value func ` default_tolerances ` used Raises ErrorMeta With ` ValueError ` only ` ` rtol ` ` ` ` atol ` ` specified Returns Tuple float float Valid absolute relative tolerances rtol None ^ atol None We require both tolerance omitted specified because specifying only one might lead surprising results Imagine setting atol= tensors still match because rtol raise ErrorMeta ValueError f Both rtol atol must either specified omitted f got no rtol rtol None atol id=id rtol None atol None rtol atol default_tolerances inputs _make_bitwise_mismatch_msg default_identifier str identifier Optional Union str Callable str str = None extra Optional str = None first_mismatch_idx Optional tuple int = None Makes mismatch error message bitwise values Args default_identifier str Default description compared values e g Tensor-likes identifier Optional Union str Callable str str Optional identifier overrides ` ` default_identifier ` ` Can passed callable which case will called ` ` default_identifier ` ` create description runtime extra Optional str Extra information placed after message header mismatch statistics first_mismatch_idx Optional tuple int index first mismatch each dimension identifier None identifier = default_identifier callable identifier identifier = identifier default_identifier msg = f identifier equal \n\n extra msg += f extra strip \n first_mismatch_idx None msg += f The first mismatched element index first_mismatch_idx \n msg strip _make_mismatch_msg default_identifier str identifier Optional Union str Callable str str = None extra Optional str = None abs_diff float abs_diff_idx Optional Union int tuple int = None atol float rel_diff float rel_diff_idx Optional Union int tuple int = None rtol float - str Makes mismatch error message numeric values Args default_identifier str Default description compared values e g Tensor-likes identifier Optional Union str Callable str str Optional identifier overrides ` ` default_identifier ` ` Can passed callable which case will called ` ` default_identifier ` ` create description runtime extra Optional str Extra information placed after message header mismatch statistics abs_diff float Absolute difference abs_diff_idx Optional Union int Tuple int Optional index absolute difference atol float Allowed absolute tolerance Will only added mismatch statistics ` ` rtol ` ` ` ` ` ` rel_diff float Relative difference rel_diff_idx Optional Union int Tuple int Optional index relative difference rtol float Allowed relative tolerance Will only added mismatch statistics ` ` atol ` ` ` ` ` ` equality = rtol == atol == make_diff_msg type str diff float idx Optional Union int tuple int tol float - str idx None msg = f type title difference diff msg = f Greatest type difference diff index idx equality msg += f up tol allowed msg + \n identifier None identifier = default_identifier callable identifier identifier = identifier default_identifier msg = f identifier equal equality close \n\n extra msg += f extra strip \n msg += make_diff_msg type= absolute diff=abs_diff idx=abs_diff_idx tol=atol msg += make_diff_msg type= relative diff=rel_diff idx=rel_diff_idx tol=rtol msg strip make_scalar_mismatch_msg actual Union bool int float complex expected Union bool int float complex rtol float atol float identifier Optional Union str Callable str str = None - str Makes mismatch error message scalars Args actual Union bool int float complex Actual scalar expected Union bool int float complex Expected scalar rtol float Relative tolerance atol float Absolute tolerance identifier Optional Union str Callable str str Optional description scalars Can passed callable which case will called default value create description runtime Defaults Scalars abs_diff = abs actual - expected pyrefly ignore bad-argument-type rel_diff = float inf expected == abs_diff abs expected _make_mismatch_msg default_identifier= Scalars identifier=identifier extra=f Expected expected got actual abs_diff=abs_diff atol=atol rel_diff=rel_diff rtol=rtol make_tensor_mismatch_msg actual torch Tensor expected torch Tensor matches torch Tensor rtol float atol float identifier Optional Union str Callable str str = None Makes mismatch error message tensors Args actual torch Tensor Actual tensor expected torch Tensor Expected tensor matches torch Tensor Boolean mask same shape ` ` actual ` ` ` ` expected ` ` indicates location matches rtol float Relative tolerance atol float Absolute tolerance identifier Optional Union str Callable str str Optional description tensors Can passed callable which case will called default value create description runtime Defaults Tensor-likes unravel_flat_index flat_index int - tuple int matches shape inverse_index = size matches shape - div mod = divmod flat_index size flat_index = div inverse_index append mod tuple inverse_index - number_of_elements = matches numel total_mismatches = number_of_elements - int torch sum matches extra = f Mismatched elements total_mismatches number_of_elements f total_mismatches number_of_elements actual dtype is_floating_point actual dtype itemsize == skip checking max_abs_diff max_rel_diff float -like values first_mismatch_idx = tuple torch nonzero ~matches as_tuple=False tolist _make_bitwise_mismatch_msg default_identifier= Tensor-likes identifier=identifier extra=extra first_mismatch_idx=first_mismatch_idx actual_flat = actual flatten expected_flat = expected flatten matches_flat = matches flatten actual dtype is_floating_point actual dtype is_complex TODO Instead always upcasting int would sufficient cast next higher dtype avoid overflow actual_flat = actual_flat torch int expected_flat = expected_flat torch int abs_diff = torch abs actual_flat - expected_flat Ensure only mismatches used max_abs_diff computation abs_diff matches_flat = max_abs_diff max_abs_diff_flat_idx = torch max abs_diff rel_diff = abs_diff torch abs expected_flat Ensure only mismatches used max_rel_diff computation rel_diff matches_flat = max_rel_diff max_rel_diff_flat_idx = torch max rel_diff _make_mismatch_msg default_identifier= Tensor-likes identifier=identifier extra=extra abs_diff=max_abs_diff item abs_diff_idx=unravel_flat_index int max_abs_diff_flat_idx atol=atol rel_diff=max_rel_diff item rel_diff_idx=unravel_flat_index int max_rel_diff_flat_idx rtol=rtol UnsupportedInputs Exception noqa B Exception raised during construction ` Pair ` case doesn t support inputs Pair abc ABC ABC all comparison pairs used conjunction func ` assert_equal ` Each subclass needs overwrite meth ` Pair compare ` performs actual comparison Each pair receives all options so select ones applicable subclass forward rest super Raising ` UnsupportedInputs ` during constructions indicates pair able handle inputs next pair type will tried All other errors should raised ` ErrorMeta ` After instantiation meth ` Pair _make_error_meta ` can used automatically handle overwriting message user supplied one id handling __init__ actual Any expected Any id tuple Any = unknown_parameters Any - None actual = actual expected = expected id = id _unknown_parameters = unknown_parameters staticmethod _inputs_not_supported - NoReturn raise UnsupportedInputs staticmethod _check_inputs_isinstance inputs Any cls Union type tuple type Checks all inputs instances given raise ` UnsupportedInputs ` otherwise all isinstance input cls input inputs Pair _inputs_not_supported _fail type type Exception msg str id tuple Any = - NoReturn Raises ` ErrorMeta ` given exception type message stored id warning If you use before ` ` super __init__ ` ` call constructor you have pass ` ` id ` ` explicitly raise ErrorMeta type msg id=self id id hasattr id id abc abstractmethod compare - None Compares inputs raises ` ErrorMeta ` case they mismatch extra_repr - Sequence Union str tuple str Any Returns extra information will included representation Should overwritten all subclasses use additional options The representation object will only surfaced case we encounter unexpected error thus should help debug issue Can sequence key-value-pairs attribute names __repr__ - str head = f type __name__ tail = body = f name = value s name value id id actual actual expected expected extra getattr extra isinstance extra str extra extra extra_repr \n join head body tail ObjectPair Pair Pair any type inputs will compared ` == ` operator note Since will instantiate any kind inputs should only used fallback after all other pairs couldn t handle inputs compare - None try equal = actual == expected except Exception error We using ` _raise_error_meta ` here since we need exception chaining raise ErrorMeta ValueError f actual == expected failed \n error id=self id error equal _fail AssertionError f actual = expected NonePair Pair Pair ` ` None ` ` inputs __init__ actual Any expected Any other_parameters Any - None actual None expected None _inputs_not_supported super __init__ actual expected other_parameters compare - None actual None expected None _fail AssertionError f None mismatch actual expected BooleanPair Pair Pair ` bool ` inputs note If ` ` numpy ` ` available also handles ` numpy bool_ ` inputs __init__ actual Any expected Any id tuple Any other_parameters Any - None actual expected = _process_inputs actual expected id=id super __init__ actual expected other_parameters property _supported_types - tuple type cls list type = bool HAS_NUMPY pyrefly ignore missing-attribute cls append np bool_ tuple cls _process_inputs actual Any expected Any id tuple Any - tuple bool bool _check_inputs_isinstance actual expected cls=self _supported_types actual expected = _to_bool bool_like id=id bool_like actual expected actual expected _to_bool bool_like Any id tuple Any - bool isinstance bool_like bool bool_like pyrefly ignore missing-attribute isinstance bool_like np bool_ bool_like item raise ErrorMeta TypeError f Unknown boolean type type bool_like id=id compare - None actual expected _fail AssertionError f Booleans mismatch actual expected NumberPair Pair Pair Python number ` int ` ` float ` ` complex ` inputs note If ` ` numpy ` ` available also handles ` numpy number ` inputs Kwargs rtol Optional float Relative tolerance If specified ` ` atol ` ` must also specified If omitted default values based type selected below table atol Optional float Absolute tolerance If specified ` ` rtol ` ` must also specified If omitted default values based type selected below table equal_nan bool If ` ` True ` ` two ` ` NaN ` ` values considered equal Defaults ` ` False ` ` check_dtype bool If ` ` True ` ` type inputs will checked equality Defaults ` ` False ` ` The following table displays correspondence between Python number type ` ` torch dtype ` ` s See func ` assert_close ` corresponding tolerances + ------------------ + ------------------------------- + &#124; ` ` type ` ` &#124; corresponding ` ` torch dtype ` ` &#124; +==================+===============================+ &#124; ` int ` &#124; attr ` ~torch int ` &#124; + ------------------ + ------------------------------- + &#124; ` float ` &#124; attr ` ~torch float ` &#124; + ------------------ + ------------------------------- + &#124; ` complex ` &#124; attr ` ~torch complex ` &#124; + ------------------ + ------------------------------- + _TYPE_TO_DTYPE = int torch int float torch float complex torch complex _NUMBER_TYPES = tuple _TYPE_TO_DTYPE keys __init__ actual Any expected Any id tuple Any = rtol Optional float = None atol Optional float = None equal_nan bool = False check_dtype bool = False other_parameters Any - None actual expected = _process_inputs actual expected id=id super __init__ actual expected id=id other_parameters rtol atol = get_tolerances _TYPE_TO_DTYPE type input input actual expected rtol=rtol atol=atol id=id equal_nan = equal_nan check_dtype = check_dtype property _supported_types - tuple type cls = list _NUMBER_TYPES HAS_NUMPY pyrefly ignore missing-attribute cls append np number tuple cls _process_inputs actual Any expected Any id tuple Any - tuple Union int float complex Union int float complex _check_inputs_isinstance actual expected cls=self _supported_types actual expected = _to_number number_like id=id number_like actual expected actual expected _to_number number_like Any id tuple Any - Union int float complex pyrefly ignore missing-attribute HAS_NUMPY isinstance number_like np number number_like item isinstance number_like _NUMBER_TYPES number_like type ignore return-value raise ErrorMeta TypeError f Unknown number type type number_like id=id compare - None check_dtype type actual type expected _fail AssertionError f The d types do match type actual = type expected actual == expected equal_nan cmath isnan actual cmath isnan expected abs_diff = abs actual - expected tolerance = atol + rtol abs expected cmath isfinite abs_diff abs_diff = tolerance _fail AssertionError make_scalar_mismatch_msg actual expected rtol=self rtol atol=self atol extra_repr - Sequence str rtol atol equal_nan check_dtype TensorLikePair Pair Pair ` torch Tensor ` -like inputs Kwargs allow_subclasses bool rtol Optional float Relative tolerance If specified ` ` atol ` ` must also specified If omitted default values based type selected See func assert_close details atol Optional float Absolute tolerance If specified ` ` rtol ` ` must also specified If omitted default values based type selected See func assert_close details equal_nan bool If ` ` True ` ` two ` ` NaN ` ` values considered equal Defaults ` ` False ` ` check_device bool If ` ` True ` ` default asserts corresponding tensors same attr ` ~torch Tensor device ` If check disabled tensors different attr ` ~torch Tensor device ` s moved CPU before being compared check_dtype bool If ` ` True ` ` default asserts corresponding tensors have same ` ` dtype ` ` If check disabled tensors different ` ` dtype ` ` s promoted common ` ` dtype ` ` according func ` torch promote_types ` before being compared check_layout bool If ` ` True ` ` default asserts corresponding tensors have same ` ` layout ` ` If check disabled tensors different ` ` layout ` ` s converted strided tensors before being compared check_stride bool If ` ` True ` ` corresponding tensors strided asserts they have same stride __init__ actual Any expected Any id tuple Any = allow_subclasses bool = True rtol Optional float = None atol Optional float = None equal_nan bool = False check_device bool = True check_dtype bool = True check_layout bool = True check_stride bool = False other_parameters Any actual expected = _process_inputs actual expected id=id allow_subclasses=allow_subclasses super __init__ actual expected id=id other_parameters rtol atol = get_tolerances actual expected rtol=rtol atol=atol id=self id equal_nan = equal_nan check_device = check_device check_dtype = check_dtype check_layout = check_layout check_stride = check_stride _process_inputs actual Any expected Any id tuple Any allow_subclasses bool - tuple torch Tensor torch Tensor directly_related = isinstance actual type expected isinstance expected type actual directly_related _inputs_not_supported allow_subclasses type actual type expected _inputs_not_supported actual expected = _to_tensor input input actual expected tensor actual expected _check_supported tensor id=id actual expected _to_tensor tensor_like Any - torch Tensor isinstance tensor_like torch Tensor tensor_like try torch as_tensor tensor_like except Exception _inputs_not_supported _check_supported tensor torch Tensor id tuple Any - None tensor layout torch strided torch jagged torch sparse_coo torch sparse_csr torch sparse_csc torch sparse_bsr torch sparse_bsc raise ErrorMeta ValueError f Unsupported tensor layout tensor layout id=id compare - None actual expected = actual expected _compare_attributes actual expected any input device type == meta input actual expected actual expected = _equalize_attributes actual expected _compare_values actual expected _compare_attributes actual torch Tensor expected torch Tensor - None Checks attributes two tensors match Always checks - attr ` ~torch Tensor shape ` - whether both inputs quantized - they use same quantization scheme Checks - attr ` ~torch Tensor layout ` - meth ` ~torch Tensor stride ` - attr ` ~torch Tensor device ` - attr ` ~torch Tensor dtype ` optional can disabled through corresponding ` ` check_ ` ` flag during construction pair raise_mismatch_error attribute_name str actual_value Any expected_value Any - NoReturn _fail AssertionError f The values attribute attribute_name do match actual_value = expected_value actual shape = expected shape raise_mismatch_error shape actual shape expected shape actual is_quantized = expected is_quantized raise_mismatch_error is_quantized actual is_quantized expected is_quantized actual is_quantized actual qscheme = expected qscheme raise_mismatch_error qscheme actual qscheme expected qscheme actual layout = expected layout check_layout raise_mismatch_error layout actual layout expected layout actual layout == torch strided check_stride actual stride = expected stride raise_mismatch_error stride actual stride expected stride check_device actual device = expected device raise_mismatch_error device actual device expected device check_dtype actual dtype = expected dtype raise_mismatch_error dtype actual dtype expected dtype _equalize_attributes actual torch Tensor expected torch Tensor - tuple torch Tensor torch Tensor Equalizes some attributes two tensors value comparison If ` ` actual ` ` ` ` expected ` ` - same attr ` ~torch Tensor device ` they moved CPU memory - same ` ` dtype ` ` they promoted common ` ` dtype ` ` according func ` torch promote_types ` - same ` ` layout ` ` they converted strided tensors Args actual Tensor Actual tensor expected Tensor Expected tensor Returns Tuple Tensor Tensor Equalized tensors The comparison logic uses operators currently supported MPS backends See https github com pytorch pytorch issues details TODO Remove conversion soon all operations supported natively MPS backend actual is_mps expected is_mps type ignore attr-defined actual = actual cpu expected = expected cpu actual device = expected device actual = actual cpu expected = expected cpu actual dtype = expected dtype actual_dtype = actual dtype expected_dtype = expected dtype For uint sound general which why promote_types doesn t allow easy testing we re unlikely get confused large uint overflowing into negative int actual_dtype torch uint torch uint torch uint actual_dtype = torch int expected_dtype torch uint torch uint torch uint expected_dtype = torch int dtype = torch promote_types actual_dtype expected_dtype actual = actual dtype expected = expected dtype actual layout = expected layout These checks needed since Tensor to_dense fails tensors already strided actual = actual to_dense actual layout = torch strided actual expected = expected to_dense expected layout = torch strided expected actual expected _compare_values actual torch Tensor expected torch Tensor - None actual is_quantized compare_fn = _compare_quantized_values actual is_sparse compare_fn = _compare_sparse_coo_values actual layout torch sparse_csr torch sparse_csc torch sparse_bsr torch sparse_bsc compare_fn = _compare_sparse_compressed_values actual layout == torch jagged actual expected = actual values expected values compare_fn = _compare_regular_values_close actual dtype is_floating_point actual dtype itemsize == bitwise_comp actual torch Tensor expected torch Tensor rtol float atol float equal_nan bool identifier Optional Union str Callable str str = None - None rtol = atol = raise ErrorMeta AssertionError f Rtol= rtol atol= atol supported bitwise comparison low dimensional floats Please use rtol= atol= _compare_regular_values_close actual expected rtol=rtol atol=atol equal_nan=equal_nan identifier=identifier compare_fn = bitwise_comp compare_fn = _compare_regular_values_close compare_fn actual expected rtol=self rtol atol=self atol equal_nan=self equal_nan _compare_quantized_values actual torch Tensor expected torch Tensor rtol float atol float equal_nan bool - None Compares quantized tensors comparing meth ` ~torch Tensor dequantize ` d variants closeness note A detailed discussion about why only dequantized variant checked closeness rather than checking individual quantization parameters closeness integer representation equality can found https github com pytorch pytorch issues _compare_regular_values_close actual dequantize expected dequantize rtol=rtol atol=atol equal_nan=equal_nan identifier=lambda default_identifier f Quantized default_identifier lower _compare_sparse_coo_values actual torch Tensor expected torch Tensor rtol float atol float equal_nan bool - None Compares sparse COO tensors comparing - number sparse dimensions - number non-zero elements nnz equality - indices equality - values closeness actual sparse_dim = expected sparse_dim _fail AssertionError f The number sparse dimensions sparse COO tensors does match f actual sparse_dim = expected sparse_dim actual _nnz = expected _nnz _fail AssertionError f The number specified values sparse COO tensors does match f actual _nnz = expected _nnz _compare_regular_values_equal actual _indices expected _indices identifier= Sparse COO indices _compare_regular_values_close actual _values expected _values rtol=rtol atol=atol equal_nan=equal_nan identifier= Sparse COO values _compare_sparse_compressed_values actual torch Tensor expected torch Tensor rtol float atol float equal_nan bool - None Compares sparse compressed tensors comparing - number non-zero elements nnz equality - plain indices equality - compressed indices equality - values closeness format_name compressed_indices_method plain_indices_method = torch sparse_csr CSR torch Tensor crow_indices torch Tensor col_indices torch sparse_csc CSC torch Tensor ccol_indices torch Tensor row_indices torch sparse_bsr BSR torch Tensor crow_indices torch Tensor col_indices torch sparse_bsc BSC torch Tensor ccol_indices torch Tensor row_indices actual layout actual _nnz = expected _nnz _fail AssertionError f The number specified values sparse format_name tensors does match f actual _nnz = expected _nnz Compressed plain indices CSR CSC BSR BSC sparse formats can ` torch int ` _or_ ` torch int ` While same dtype enforced compressed plain indices single tensor can different between two tensors Thus we need convert them same dtype comparison will fail actual_compressed_indices = compressed_indices_method actual expected_compressed_indices = compressed_indices_method expected indices_dtype = torch promote_types actual_compressed_indices dtype expected_compressed_indices dtype _compare_regular_values_equal actual_compressed_indices indices_dtype expected_compressed_indices indices_dtype identifier=f Sparse format_name compressed_indices_method __name__ _compare_regular_values_equal plain_indices_method actual indices_dtype plain_indices_method expected indices_dtype identifier=f Sparse format_name plain_indices_method __name__ _compare_regular_values_close actual values expected values rtol=rtol atol=atol equal_nan=equal_nan identifier=f Sparse format_name values _compare_regular_values_equal actual torch Tensor expected torch Tensor equal_nan bool = False identifier Optional Union str Callable str str = None - None Checks values two tensors equal _compare_regular_values_close actual expected rtol= atol= equal_nan=equal_nan identifier=identifier _compare_regular_values_close actual torch Tensor expected torch Tensor rtol float atol float equal_nan bool identifier Optional Union str Callable str str = None - None Checks values two tensors close up desired tolerance matches = torch isclose actual expected rtol=rtol atol=atol equal_nan=equal_nan torch all matches actual shape == torch Size msg = make_scalar_mismatch_msg actual item expected item rtol=rtol atol=atol identifier=identifier msg = make_tensor_mismatch_msg actual expected matches rtol=rtol atol=atol identifier=identifier _fail AssertionError msg extra_repr - Sequence str rtol atol equal_nan check_device check_dtype check_layout check_stride originate_pairs actual Any expected Any pair_types Sequence type Pair sequence_types tuple type = collections abc Sequence mapping_types tuple type = collections abc Mapping id tuple Any = options Any pyrefly ignore bad-return - list Pair Originates pairs individual inputs ` ` actual ` ` ` ` expected ` ` can possibly nested ` ~collections abc Sequence ` s ` ~collections abc Mapping ` s In case pairs originated recursing through them Args actual Any Actual input expected Any Expected input pair_types Sequence Type Pair Sequence pair types will tried construct inputs First successful pair will used sequence_types Tuple Type Optional types treated sequences will checked elementwise mapping_types Tuple Type Optional types treated mappings will checked elementwise id Tuple Any Optional id pair will included error message options Any Options passed each pair during construction Raises ErrorMeta With ` AssertionError ` inputs ` ~collections abc Sequence ` s their length does match ErrorMeta With ` AssertionError ` inputs ` ~collections abc Mapping ` s their set keys do match ErrorMeta With ` TypeError ` no pair able handle inputs ErrorMeta With any expected exception happens during construction pair Returns List Pair Originated pairs We explicitly exclude str s here since they self-referential would cause infinite recursion loop == isinstance actual sequence_types isinstance actual str isinstance expected sequence_types isinstance expected str actual_len = len actual type ignore arg-type expected_len = len expected type ignore arg-type actual_len = expected_len raise ErrorMeta AssertionError f The length sequences mismatch actual_len = expected_len id=id pairs = idx range actual_len pairs extend originate_pairs actual idx type ignore index expected idx type ignore index pair_types=pair_types sequence_types=sequence_types mapping_types=mapping_types id= id idx options pairs isinstance actual mapping_types isinstance expected mapping_types actual_keys = set actual keys type ignore attr-defined expected_keys = set expected keys type ignore attr-defined actual_keys = expected_keys missing_keys = expected_keys - actual_keys additional_keys = actual_keys - expected_keys raise ErrorMeta AssertionError f The keys mappings do match \n f Missing keys actual mapping sorted missing_keys \n f Additional keys actual mapping sorted additional_keys id=id keys Collection = actual_keys Since origination aborts after first failure we try deterministic contextlib suppress Exception keys = sorted keys pairs = key keys pairs extend originate_pairs actual key type ignore index expected key type ignore index pair_types=pair_types sequence_types=sequence_types mapping_types=mapping_types id= id key options pairs pair_type pair_types try pyrefly ignore bad-instantiation pair_type actual expected id=id options Raising ` UnsupportedInputs ` during origination indicates pair type able handle inputs Thus we try next pair type except UnsupportedInputs continue Raising ` ErrorMeta ` during origination orderly way abort so we simply re-raise This only separate branch because one below would also except except ErrorMeta raise Raising any other exception during origination unexpected will give some extra information about what happened If applicable exception should expected future except Exception error raise RuntimeError f Originating pair_type __name__ item join str item item id with\n\n f type actual __name__ actual \n\n f and\n\n f type expected __name__ expected \n\n f resulted unexpected exception above f If you user see message during normal operation please file issue https github com pytorch pytorch issues If you developer working comparison functions please except previous error raise expressive ` ErrorMeta ` instead error raise ErrorMeta TypeError f No comparison pair able handle inputs type type actual type expected id=id not_close_error_metas actual Any expected Any pair_types Sequence type Pair = ObjectPair sequence_types tuple type = collections abc Sequence mapping_types tuple type = collections abc Mapping options Any - list ErrorMeta Asserts inputs equal ` ` actual ` ` ` ` expected ` ` can possibly nested ` ~collections abc Sequence ` s ` ~collections abc Mapping ` s In case comparison happens elementwise recursing through them Args actual Any Actual input expected Any Expected input pair_types Sequence Type Pair Sequence ` Pair ` types will tried construct inputs First successful pair will used Defaults only using ` ObjectPair ` sequence_types Tuple Type Optional types treated sequences will checked elementwise mapping_types Tuple Type Optional types treated mappings will checked elementwise options Any Options passed each pair during construction Hide function ` pytest ` s traceback __tracebackhide__ = True try pairs = originate_pairs actual expected pair_types=pair_types sequence_types=sequence_types mapping_types=mapping_types options except ErrorMeta error_meta Explicitly raising None hide internal traceback raise error_meta to_error None noqa RSE error_metas list ErrorMeta = pair pairs try pair compare except ErrorMeta error_meta error_metas append error_meta Raising any exception besides ` ErrorMeta ` while comparing unexpected will give some extra information about what happened If applicable exception should expected future except Exception error raise RuntimeError f Comparing\n\n f pair \n\n f resulted unexpected exception above f If you user see message during normal operation please file issue https github com pytorch pytorch issues If you developer working comparison functions please except previous error raise expressive ` ErrorMeta ` instead error ErrorMeta Cycles ErrorMeta objects list capture tracebacks refer frame function The local variable ` error_metas ` refers error meta objects creating reference cycle Frames traceback would get freed until cycle collection leaking cuda memory tests We break cycle removing reference error_meta objects frame returns pyrefly ignore bad-assignment error_metas = error_metas pyrefly ignore bad-return error_metas pop assert_close actual Any expected Any allow_subclasses bool = True rtol Optional float = None atol Optional float = None equal_nan bool = False check_device bool = True check_dtype bool = True check_layout bool = True check_stride bool = False msg Optional Union str Callable str str = None r Asserts ` ` actual ` ` ` ` expected ` ` close If ` ` actual ` ` ` ` expected ` ` strided non-quantized real-valued finite they considered close math \lvert \text actual - \text expected \rvert \le \texttt atol + \texttt rtol \cdot \lvert \text expected \rvert Non-finite values ` ` -inf ` ` ` ` inf ` ` only considered close only they equal ` ` NaN ` ` s only considered equal each other ` ` equal_nan ` ` ` ` True ` ` In addition they only considered close they have same - attr ` ~torch Tensor device ` ` ` check_device ` ` ` ` True ` ` - ` ` dtype ` ` ` ` check_dtype ` ` ` ` True ` ` - ` ` layout ` ` ` ` check_layout ` ` ` ` True ` ` - stride ` ` check_stride ` ` ` ` True ` ` If either ` ` actual ` ` ` ` expected ` ` meta tensor only attribute checks will performed If ` ` actual ` ` ` ` expected ` ` sparse either having COO CSR CSC BSR BSC layout their strided members checked individually Indices namely ` ` indices ` ` COO ` ` crow_indices ` ` ` ` col_indices ` ` CSR BSR ` ` ccol_indices ` ` ` ` row_indices ` ` CSC BSC layouts respectively always checked equality whereas values checked closeness according definition above If ` ` actual ` ` ` ` expected ` ` quantized they considered close they have same meth ` ~torch Tensor qscheme ` result meth ` ~torch Tensor dequantize ` close according definition above ` ` actual ` ` ` ` expected ` ` can ` ~torch Tensor ` s any tensor-or-scalar-likes which ` torch Tensor ` s can constructed func ` torch as_tensor ` Except Python scalars input types have directly related In addition ` ` actual ` ` ` ` expected ` ` can ` ~collections abc Sequence ` s ` ~collections abc Mapping ` s which case they considered close their structure matches all their elements considered close according above definition note Python scalars exception type relation requirement because their func ` type ` i e ` int ` ` float ` ` complex ` equivalent ` ` dtype ` ` tensor-like Thus Python scalars different types can checked require ` ` check_dtype=False ` ` Args actual Any Actual input expected Any Expected input allow_subclasses bool If ` ` True ` ` default except Python scalars inputs directly related types allowed Otherwise type equality required rtol Optional float Relative tolerance If specified ` ` atol ` ` must also specified If omitted default values based attr ` ~torch Tensor dtype ` selected below table atol Optional float Absolute tolerance If specified ` ` rtol ` ` must also specified If omitted default values based attr ` ~torch Tensor dtype ` selected below table equal_nan Union bool str If ` ` True ` ` two ` ` NaN ` ` values will considered equal check_device bool If ` ` True ` ` default asserts corresponding tensors same attr ` ~torch Tensor device ` If check disabled tensors different attr ` ~torch Tensor device ` s moved CPU before being compared check_dtype bool If ` ` True ` ` default asserts corresponding tensors have same ` ` dtype ` ` If check disabled tensors different ` ` dtype ` ` s promoted common ` ` dtype ` ` according func ` torch promote_types ` before being compared check_layout bool If ` ` True ` ` default asserts corresponding tensors have same ` ` layout ` ` If check disabled tensors different ` ` layout ` ` s converted strided tensors before being compared check_stride bool If ` ` True ` ` corresponding tensors strided asserts they have same stride msg Optional Union str Callable str str Optional error message use case failure occurs during comparison Can also passed callable which case will called generated message should new message Raises ValueError If no ` torch Tensor ` can constructed input ValueError If only ` ` rtol ` ` ` ` atol ` ` specified AssertionError If corresponding inputs Python scalars directly related AssertionError If ` ` allow_subclasses ` ` ` ` False ` ` corresponding inputs Python scalars have different types AssertionError If inputs ` ~collections abc Sequence ` s their length does match AssertionError If inputs ` ~collections abc Mapping ` s their set keys do match AssertionError If corresponding tensors do have same attr ` ~torch Tensor shape ` AssertionError If ` ` check_layout ` ` ` ` True ` ` corresponding tensors do have same attr ` ~torch Tensor layout ` AssertionError If only one corresponding tensors quantized AssertionError If corresponding tensors quantized have different meth ` ~torch Tensor qscheme ` s AssertionError If ` ` check_device ` ` ` ` True ` ` corresponding tensors same attr ` ~torch Tensor device ` AssertionError If ` ` check_dtype ` ` ` ` True ` ` corresponding tensors do have same ` ` dtype ` ` AssertionError If ` ` check_stride ` ` ` ` True ` ` corresponding strided tensors do have same stride AssertionError If values corresponding tensors close according definition above The following table displays default ` ` rtol ` ` ` ` atol ` ` different ` ` dtype ` ` s In case mismatching ` ` dtype ` ` s maximum both tolerances used + --------------------------- + ------------ + ---------- + &#124; ` ` dtype ` ` &#124; ` ` rtol ` ` &#124; ` ` atol ` ` &#124; +===========================+============+==========+ &#124; attr ` ~torch float ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch bfloat ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch float ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch float ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch complex ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch complex ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch complex ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch quint ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch quint x ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch quint x ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch qint ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; attr ` ~torch qint ` &#124; ` ` e- ` ` &#124; ` ` e- ` ` &#124; + --------------------------- + ------------ + ---------- + &#124; other &#124; ` ` ` ` &#124; ` ` ` ` &#124; + --------------------------- + ------------ + ---------- + note func ` ~torch testing assert_close ` highly configurable strict default settings Users encouraged func ` ~functools partial ` fit their use case For example equality check needed one might define ` ` assert_equal ` ` uses zero tolerances every ` ` dtype ` ` default functools assert_equal = functools partial torch testing assert_close rtol= atol= assert_equal e- e- Traceback most recent call last AssertionError Scalars equal BLANKLINE Expected e- got e- Absolute difference e- Relative difference Examples tensor tensor comparison expected = torch tensor e e- e- actual = torch acos torch cos expected torch testing assert_close actual expected scalar scalar comparison math expected = math sqrt actual = math sqrt torch testing assert_close actual expected numpy array numpy array comparison numpy np expected = np array e e- e- actual = np arccos np cos expected torch testing assert_close actual expected sequence sequence comparison numpy np The types sequences do have match They only have have same length their elements have match expected = torch tensor np array actual = tuple expected torch testing assert_close actual expected mapping mapping comparison collections OrderedDict numpy np foo = torch tensor bar = baz = np array The types possible ordering mappings do have match They only have have same set keys their elements have match expected = OrderedDict foo foo bar bar baz baz actual = baz baz bar bar foo foo torch testing assert_close actual expected expected = torch tensor actual = expected clone By default directly related instances can compared torch testing assert_close torch nn Parameter actual expected This check can made more strict allow_subclasses=False torch testing assert_close torch nn Parameter actual expected allow_subclasses=False Traceback most recent call last TypeError No comparison pair able handle inputs type torch nn parameter Parameter torch Tensor If inputs directly related they never considered close torch testing assert_close actual numpy expected Traceback most recent call last TypeError No comparison pair able handle inputs type numpy ndarray torch Tensor Exceptions these rules Python scalars They can checked regardless their type check_dtype=False torch testing assert_close check_dtype=False NaN = NaN default expected = torch tensor float Nan actual = expected clone torch testing assert_close actual expected Traceback most recent call last AssertionError Scalars close BLANKLINE Expected nan got nan Absolute difference nan up e- allowed Relative difference nan up e- allowed torch testing assert_close actual expected equal_nan=True expected = torch tensor actual = torch tensor The default error message can overwritten torch testing assert_close actual expected msg= Argh tensors close Traceback most recent call last AssertionError Argh tensors close If msg callable can used augment generated message extra information torch testing assert_close actual expected msg=lambda msg f Header\n\n msg \n\nFooter Traceback most recent call last AssertionError Header BLANKLINE Tensor-likes close BLANKLINE Mismatched elements Greatest absolute difference index up e- allowed Greatest relative difference index up e- allowed BLANKLINE Footer Hide function ` pytest ` s traceback __tracebackhide__ = True error_metas = not_close_error_metas actual expected pair_types= NonePair BooleanPair NumberPair TensorLikePair allow_subclasses=allow_subclasses rtol=rtol atol=atol equal_nan=equal_nan check_device=check_device check_dtype=check_dtype check_layout=check_layout check_stride=check_stride msg=msg error_metas TODO compose all metas into one AssertionError raise error_metas to_error msg deprecated ` torch testing assert_allclose ` deprecated since will removed future release Please use ` torch testing assert_close ` instead You can find detailed upgrade instructions https github com pytorch pytorch issues category=FutureWarning assert_allclose actual Any expected Any rtol Optional float = None atol Optional float = None equal_nan bool = True msg str = - None warning func ` torch testing assert_allclose ` deprecated since ` ` ` ` will removed future release Please use func ` torch testing assert_close ` instead You can find detailed upgrade instructions ` here https github com pytorch pytorch issues ` _ isinstance actual torch Tensor actual = torch tensor actual isinstance expected torch Tensor expected = torch tensor expected dtype=actual dtype rtol None atol None rtol atol = default_tolerances actual expected dtype_precisions= torch float e- e- torch float e- e- torch float e- e- torch testing assert_close actual expected rtol=rtol atol=atol equal_nan=equal_nan check_device=True check_dtype=False check_stride=False msg=msg None