mypy allow-untyped-defs dataclasses functools os platform re subprocess sys warnings typing Any Callable Union torch torch _inductor config torch _inductor utils python_subprocess_env _IS_WINDOWS = sys platform == win _get_isa_dry_compile_fingerprint isa_flags str - str ISA dry compile will cost about sec time each startup time Please check issue https github com pytorch pytorch issues Actually dry compile checking compile capability ISA We just record compiler version isa options pytorch version info generated them output binary hash path It would optimize skip compile existing binary torch _inductor cpp_builder get_compiler_version_info get_cpp_compiler compiler_info = get_compiler_version_info get_cpp_compiler torch_version = torch __version__ fingerprint = f compiler_info = isa_flags = torch_version fingerprint VecISA _bit_width int _macro list str _arch_flags str _dtype_nelements dict torch dtype int Note Checking Vectorized Support Inductor TorchInductor CPU vectorization reuses PyTorch vectorization utility functions Hence TorchInductor would depend Sleef accelerate mathematical functions like exp pow sin cos etc But PyTorch TorchInductor might use different compilers build code If PyTorch uses gcc- g++- build release package libtorch_cpu so will expose Sleef AVX symbols since gcc- g++- cannot pass avx check CMake - FindAVX cmake But TorchInductor install latest gcc g++ compiler default while could support AVX compilation Therefore there would conflict sleef version between PyTorch TorchInductor Hence we dry-compile following code check whether current HW platform PyTorch both could support AVX AVX And suppose ARM also needs logic In fbcode however we using same compiler pytorch inductor codegen making runtime check unnecessary _avx_code = #if defined CPU_CAPABILITY_AVX &#124; &#124; defined CPU_CAPABILITY_AVX &#124; &#124; defined CPU_CAPABILITY_ZVECTOR &#124; &#124; defined CPU_CAPABILITY_NEON &#124; &#124; defined CPU_CAPABILITY_VSX &#124; &#124; defined CPU_CAPABILITY_SVE #include ATen cpu vec functional h #include ATen cpu vec vec h #endif alignas float in_out_ptr = extern C void __avx_chk_kernel auto tmp = vec Vectorized float auto tmp = tmp exp tmp store in_out_ptr noqa B _avx_py_load = torch ctypes cdll cdll LoadLibrary __lib_path__ bit_width - int _bit_width nelements dtype torch dtype = torch float - int _dtype_nelements dtype build_macro - list str _macro build_arch_flags - str _arch_flags __hash__ - int hash str check_build code str - bool torch _inductor codecache get_lock_dir LOCK_TIMEOUT write torch _inductor cpp_builder CppBuilder CppTorchOptions normalize_path_separator key input_path = write code cpp extra=_get_isa_dry_compile_fingerprint _arch_flags torch utils _filelock FileLock lock_dir = get_lock_dir lock = FileLock os path join lock_dir key + lock timeout=LOCK_TIMEOUT lock output_dir = os path dirname input_path buid_options = CppTorchOptions vec_isa=self warning_all=False x _isa_help_builder = CppBuilder key input_path buid_options output_dir try Check output file exist compile when output_path = normalize_path_separator x _isa_help_builder get_target_file_path os path isfile output_path x _isa_help_builder build Check build result subprocess check_call sys executable -c VecISA _avx_py_load replace __lib_path__ output_path cwd=output_dir stderr=subprocess DEVNULL env=python_subprocess_env except Exception False True __bool__ - bool __bool__impl config cpp vec_isa_ok functools cache noqa B __bool__impl vec_isa_ok - bool vec_isa_ok None vec_isa_ok config is_fbcode True check_build VecISA _avx_code dataclasses dataclass VecNEON VecISA _bit_width = This required leverage compute implemented aten src ATen cpu vec vec vec _float_neon h _macro = CPU_CAPABILITY_NEON AT_BUILD_ARM_VEC _WITH_SLEEF _arch_flags = Unused _dtype_nelements = torch float torch bfloat torch float __str__ - str config is_fbcode neon asimd detects presence advanced SIMD armv -a kernels __hash__ Callable VecISA Any = VecISA __hash__ type ignore assignment dataclasses dataclass VecSVE VecISA function can repurposed SVE variable vec length _bit_width = _macro = CPU_CAPABILITY_SVE CPU_CAPABILITY_SVE AT_BUILD_ARM_VEC _WITH_SLEEF __ARM_FEATURE_BF _arch_flags = -march=armv -a+sve+bf -msve-vector-bits= _dtype_nelements = torch float torch bfloat torch float __str__ - str config is_fbcode neon asimd __hash__ Callable VecISA Any = VecISA __hash__ type ignore assignment dataclasses dataclass VecAVX VecISA _bit_width = _macro = CPU_CAPABILITY_AVX _arch_flags = -mavx f -mavx dq -mavx vl -mavx bw -mfma _IS_WINDOWS arch AVX TODO use cflags _dtype_nelements = torch float torch bfloat torch float _is_avx _bf _supported = False __str__ - str avx __hash__ Callable VecISA Any = VecISA __hash__ type ignore assignment _avx _bf _code = #include cstdint #include immintrin h extern C __m bh __avx _bf _chk_kernel __m __m b _mm _cvtne ps_pbh b functools cache noqa B pyrefly ignore bad-override __bool__ - bool super __bool__ config is_fbcode False check avx _bf torch cpu _is_avx _bf _supported _IS_WINDOWS save _arch_flags base_flags = _arch_flags temporarily change _arch_flags avx _bf check_build _arch_flags += -mavx bf check_build VecAMX _avx _bf _code _is_avx _bf _supported = True restore _arch_flags _arch_flags = base_flags True False functools lru_cache None noqa B is_avx _bf _supported - bool _is_avx _bf _supported build_arch_flags - str _is_avx _bf _supported _arch_flags + -mavx bf _arch_flags dataclasses dataclass VecAMX VecAVX _arch_flags = VecAVX _arch_flags + -mamx-tile -mamx-bf -mamx-int check amx_fp separately since always supported when amx supported amx_fp intrinsic compilation need gcc = platforms which support amx_fp _is_amx_fp _supported = False __str__ - str super __str__ + amx_tile __hash__ Callable VecISA Any = VecISA __hash__ _amx_code = #include cstdint #include immintrin h struct amx_tilecfg uint _t palette_id uint _t start_row uint _t reserved_ uint _t colsb uint _t rows extern C void __amx_chk_kernel amx_tilecfg cfg = _tile_loadconfig cfg _tile_zero _tile_dpbf ps _tile_dpbusd _amx_fp _code = _amx_code replace _tile_dpbf ps _tile_dpfp ps functools cache noqa B __bool__ - bool super __bool__ config is_fbcode False check_build VecAMX _amx_code torch cpu _init_amx check amx-fp well when check amx torch cpu _is_amx_fp _supported save _arch_flags base_flags = _arch_flags temporarily change _arch_flags amx-fp check_build _arch_flags += -mamx-fp check_build VecAMX _amx_fp _code _is_amx_fp _supported = True restore _arch_flags _arch_flags = base_flags True False functools lru_cache None noqa B is_amx_fp _supported - bool _is_amx_fp _supported build_arch_flags - str extra_flags = _is_avx _bf _supported avx _bf among base flags so we need check add here And we need flag WOQ case dequantization extra_flags += -mavx bf _is_amx_fp _supported extra_flags += -mamx-fp _arch_flags + extra_flags dataclasses dataclass VecAVX VecISA _bit_width = _macro = CPU_CAPABILITY_AVX _arch_flags = -mavx -mfma -mf c _IS_WINDOWS arch AVX TODO use cflags _dtype_nelements = torch float torch bfloat torch float __str__ - str avx __hash__ Callable VecISA Any = VecISA __hash__ type ignore assignment dataclasses dataclass VecZVECTOR VecISA _bit_width = _macro = CPU_CAPABILITY_ZVECTOR CPU_CAPABILITY=ZVECTOR HAVE_ZVECTOR_CPU_DEFINITION _arch_flags = -mvx -mzvector _dtype_nelements = torch float torch bfloat torch float __str__ - str zvector __hash__ Callable VecISA Any = VecISA __hash__ type ignore assignment dataclasses dataclass VecVSX VecISA _bit_width = VSX simd supports bit_width aten emulating _macro = CPU_CAPABILITY_VSX _arch_flags = -mvsx _dtype_nelements = torch float torch bfloat torch float __str__ - str vsx __hash__ Callable VecISA Any = VecISA __hash__ type ignore assignment InvalidVecISA VecISA _bit_width = _macro = _arch_flags = _dtype_nelements = __str__ - str INVALID_VEC_ISA __bool__ - bool type ignore override False __hash__ Callable VecISA Any = VecISA __hash__ type ignore assignment x _isa_checker - list str supported_isa list str = _check_and_append_supported_isa dest list str isa_supported bool isa_name str - None isa_supported dest append isa_name Arch = platform machine Arch value x _ Linux value AMD Windows Arch = x _ Arch = AMD supported_isa avx = torch cpu _is_avx _supported avx = torch cpu _is_avx _supported amx_tile = torch cpu _is_amx_tile_supported _check_and_append_supported_isa supported_isa avx avx _check_and_append_supported_isa supported_isa avx avx _check_and_append_supported_isa supported_isa amx_tile amx_tile supported_isa invalid_vec_isa = InvalidVecISA supported_vec_isa_list = VecAMX VecAVX VecAVX VecNEON VecSVE get_isa_from_cpu_capability capability Union str None vec_isa_list list VecISA invalid_vec_isa InvalidVecISA AMX setting supported eager VecAMX will prioritized selection when setting ATEN_CPU_CAPABILITY avx TODO add sve support capability_to_isa_str = default INVALID_VEC_ISA zvector zvector vsx vsx avx avx avx avx capability capability_to_isa_str keys pyrefly ignore index-error isa_str = capability_to_isa_str capability isa_str == INVALID_VEC_ISA invalid_vec_isa vec_isa vec_isa_list isa_str str vec_isa vec_isa capability warnings warn f ignoring invalid value ATEN_CPU_CAPABILITY capability vec_isa_list Cache cpuinfo avoid I O overhead Meanwhile cpuinfo content might have too much redundant content useless ISA check Hence we only cache some key isa information functools cache valid_vec_isa_list - list VecISA isa_list list VecISA = sys platform == darwin platform processor == arm isa_list append VecNEON sys platform linux win isa_list arch = platform machine arch == s x open proc cpuinfo _cpu_info while True line = _cpu_info readline line break process line featuresmatch = re match r ^features\s \s $ line featuresmatch group featuresmatch groups re search r \^ +vxe \$ + group isa_list append VecZVECTOR break arch == ppc le isa_list append VecVSX arch == aarch torch backends cpu get_cpu_capability == SVE isa_list append VecSVE isa_list append VecNEON arch x _ AMD arch value x _ Linux value AMD Windows _cpu_supported_x _isa = x _isa_checker isa_list extend isa isa supported_vec_isa_list all flag _cpu_supported_x _isa flag str isa split isa isa_list pick_vec_isa - VecISA config is_fbcode platform machine x _ AMD VecAVX _valid_vec_isa_list list VecISA = valid_vec_isa_list _valid_vec_isa_list invalid_vec_isa If simdlen None set simdlen based environment ATEN_CPU_CAPABILITY control CPU vec ISA config cpp simdlen None get_isa_from_cpu_capability os getenv ATEN_CPU_CAPABILITY _valid_vec_isa_list invalid_vec_isa isa _valid_vec_isa_list config cpp simdlen == isa bit_width isa invalid_vec_isa