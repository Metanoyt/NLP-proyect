mypy allow-untyped-defs inspect typing Any Optional torch torch fx torch _jit_internal boolean_dispatched torch fx Transformer torch fx node Argument Target torch fx operator_schemas _torchscript_type_to_python_type AnnotateTypesWithSchema Transformer Use Python function signatures annotate types ` Nodes ` within FX graph This pulls out Python function signatures Standard ` torch nn ` Module calls ` torch nn functional ` calls Attribute fetches via ` get_attr ` Example usage m = torchvision models resnet traced = torch fx symbolic_trace m traced = AnnotateTypesWithSchema traced transform __init__ module torch nn Module annotate_functionals bool = True annotate_modules bool = True annotate_get_attrs bool = True super __init__ module annotate_functionals = annotate_functionals annotate_modules = annotate_modules annotate_get_attrs = annotate_get_attrs call_function target Target args tuple Argument kwargs dict str Any python_ret_type = None annotate_functionals target __module__ == torch nn functional target_for_analysis = target target boolean_dispatched HACK ` boolean_dispatch ` used ` torch nn functional ` makes so we have -way dispatch based boolean value Here we check ` true ` ` false ` branches dispatch have exactly same signature If they do use ` true ` branch signature analysis Otherwise leave un-normalized assert isinstance target str dispatched = boolean_dispatched target if_true if_false = dispatched if_true dispatched if_false TODO can we emit union these What implications TorchScript compilation inspect signature if_true return_annotation = inspect signature if_false return_annotation super call_function target args kwargs target_for_analysis = if_true python_ret_type = _extract_python_return_type target_for_analysis return_proxy = super call_function target args kwargs return_proxy node type = return_proxy node type return_proxy node type python_ret_type return_proxy call_module target Target args tuple Argument kwargs dict str Any python_ret_type = None assert isinstance target str submod = fetch_attr target annotate_modules hasattr submod __class__ __name__ classname = submod __class__ __name__ getattr torch nn classname None == submod __class__ python_ret_type = _extract_python_return_type submod forward return_proxy = super call_module target args kwargs return_proxy node type = return_proxy node type return_proxy node type python_ret_type return_proxy get_attr target torch fx node Target args tuple Argument kwargs dict str Any attr_proxy = super get_attr target args kwargs annotate_get_attrs module_itr = module assert isinstance target str atoms = target split i atom enumerate atoms hasattr module_itr atom raise RuntimeError f Node referenced nonextent target join atoms i module_itr = getattr module_itr atom maybe_inferred_ts_type = torch _C _jit_try_infer_type module_itr maybe_inferred_ts_type success python_type = _torchscript_type_to_python_type maybe_inferred_ts_type type attr_proxy node type = python_type attr_proxy node type attr_proxy node type attr_proxy _extract_python_return_type target Target - Optional Any Given Python call target try extract Python annotation available otherwise None Args target Callable Python callable get annotation Returns Optional Any Return annotation ` target ` None available assert callable target try sig = inspect signature target except ValueError TypeError None sig return_annotation sig return_annotation inspect Signature empty None