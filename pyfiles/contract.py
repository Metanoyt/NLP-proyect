mypy allow-untyped-defs uuid collections OrderedDict collections abc Callable functools wraps typing Concatenate Generic Optional Protocol typing_extensions ParamSpec TypeVar torch torch nn nn torch distributed _composable_state _State torch distributed utils _get_root_modules _T = TypeVar _T covariant=True _P = ParamSpec _P generate_state_key string= __composable_api_state_key f string _ str uuid uuid STATE_KEY = generate_state_key REGISTRY_KEY = generate_state_key TODO we can add additional info RegistryItem share across APIs E g we can add args kwargs here then we can detect whether fully_shard combined reentrant activation checkpointing error out clear message RegistryItem pass _TState = TypeVar _TState bound= _State covariant=True _M = TypeVar _M nn Module list nn Module _ContractFn Protocol Generic _P _T _TState __call__ args _P args kwargs _P kwargs - _T state module nn Module - _TState contract state_cls type _TState = _State type ignore assignment - Callable Callable Concatenate _M _P _M _ContractFn Concatenate _M _P _M _TState r Decorate function composable distributed API where first argument function must ` nn Module ` instance sequence ` nn Module ` instances The decorator verifies decorated function does modify fully-qualified names FQNs parameters buffers modules The decorated function can different module instances than input modules FQN invariant will enforced following input order When function ` ` func ` ` decorated ` ` contract ` ` ` ` state module nn Module ` ` method will installed decorated function Then you can retrieve modify state module calling ` ` func state module ` ` Example xdoctest +SKIP torch nn nn MyModel nn Module __init__ - None super __init__ l = nn Linear l = nn Linear forward x l l x contract my_feature module nn Module - nn Module my_feature state module some_state = any value module model = MyModel my_feature model l assert my_feature state model l some_state == any value my_feature model l model torch randn sum backward wraps will make functions decorated contract pickleable - needed integration torch package wraps state_cls type ignore arg-type inner func Callable Concatenate _M _P _M - _ContractFn Concatenate _M _P _M _TState wraps func wrapper module _M args _P args kwargs _P kwargs - _M inp_module = module modules list nn Module isinstance module nn Module modules = module If user passes sequence modules then we assume we only need insert state object root modules i e those without parent among passed-in modules pyrefly ignore no-matching-overload modules = _get_root_modules list module state = state_cls shared across all modules registry_item = RegistryItem shared across all modules ` func ` allowed different module instances than input modules long FQNs preserved following input module order all_orig_named_params list dict str nn Parameter = all_orig_named_buffers list dict str torch Tensor = all_orig_named_modules list dict str nn Module = pyrefly ignore bad-assignment module modules default_all_state dict Callable _State = OrderedDict default_registry dict str RegistryItem = OrderedDict all_state dict Callable _State = module __dict__ setdefault type ignore call-overload STATE_KEY default_all_state isinstance all_state dict raise AssertionError f Distributed composable API states corrupted all_state registry dict str RegistryItem = module __dict__ setdefault type ignore call-overload REGISTRY_KEY default_registry isinstance registry dict raise AssertionError f Distributed composable API registry corrupted registry func all_state func __name__ registry raise AssertionError Each distinct composable distributed API can only applied f module once func __name__ has already been applied f following module \n module all_state setdefault func state registry setdefault func __name__ registry_item pyrefly ignore missing-attribute all_orig_named_params append OrderedDict module named_parameters pyrefly ignore missing-attribute all_orig_named_buffers append OrderedDict module named_buffers pyrefly ignore missing-attribute all_orig_named_modules append OrderedDict module named_modules updated = func inp_module args kwargs updated None updated = inp_module type ignore assignment updated_modules list nn Module isinstance updated nn Module updated_modules = updated updated_modules = _get_root_modules list inp_module type ignore arg-type call-overload all_new_named_params list dict str nn Parameter = all_new_named_buffers list dict str torch Tensor = all_new_named_modules list dict str nn Module = pyrefly ignore bad-assignment module updated_modules pyrefly ignore missing-attribute all_new_named_params append OrderedDict module named_parameters pyrefly ignore missing-attribute all_new_named_buffers append OrderedDict module named_buffers pyrefly ignore missing-attribute all_new_named_modules append OrderedDict module named_modules num_orig_modules = len all_orig_named_modules num_new_modules = len all_new_named_modules num_orig_modules = num_new_modules raise AssertionError f func __name__ should same number modules input modules f Inputs num_orig_modules modules\n f Outputs num_new_modules modules check_fqn orig_fqns list str new_fqns list str check_key str orig_fqns == new_fqns orig_fqn_set new_fqn_set = set orig_fqns set new_fqns orig_only = orig_fqn_set - new_fqn_set new_only = new_fqn_set - orig_fqn_set len orig_only len new_only raise RuntimeError f check_key Composable distributed API implementations cannot modify FQNs \n f FQNs only original orig_only \n f FQNs only new new_only raise RuntimeError f check_key Composable distributed API implementations cannot modify order FQNs \n f Original FQNs orig_only \n f New FQNs new_only orig_named_params new_named_params zip all_orig_named_params all_new_named_params check_fqn list orig_named_params keys list new_named_params keys Checking parameters orig_named_buffers new_named_buffers zip all_orig_named_buffers all_new_named_buffers check_fqn list orig_named_buffers keys list new_named_buffers keys Checking buffers orig_named_modules new_named_modules zip all_orig_named_modules all_new_named_modules check_fqn list orig_named_modules keys list new_named_modules keys Checking modules TODO verify installed distributed paradigms compatible each other pyrefly ignore bad-return updated get_state module nn Module - _State module __dict__ setdefault type ignore call-overload STATE_KEY TODO yhcharles temporary fix need better way get func type ignore call-overload wrapper state = get_state type ignore attr-defined wrapper type ignore return-value inner type ignore return-value _get_registry module nn Module - Optional dict str RegistryItem r Get ` ` OrderedDict ` ` composable APIs have been applied ` ` module ` ` indexed API name If no API has been applied then returns ` ` None ` ` getattr module REGISTRY_KEY None