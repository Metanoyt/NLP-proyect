File invoked through subprocess actually carry out measurements ` worker main py ` deliberately isolated rest benchmark infrastructure Other parts benchmark rely file ` worker ` has only one Python file does ANYTHING rest benchmark suite The reason important we can t rely paths access other files namely ` core api ` since source command might change CWD It also helps keep startup time down limiting spurious definition work The life worker very simple It receives file containing ` WorkerTimerArgs ` telling what run writes ` WorkerOutput ` result back same file Because file only expects run child context error handling means plumbing failures up caller raising process argparse dataclasses io os pickle sys timeit traceback typing Any TYPE_CHECKING Union TYPE_CHECKING Benchmark utils only partially strict compliant so MyPy won t follow imports using public namespace Due exclusion rule mypy-strict ini torch utils benchmark utils timer Language Timer torch utils benchmark utils valgrind_wrapper timer_interface CallgrindStats torch utils benchmark CallgrindStats Language Timer WORKER_PATH = os path abspath __file__ ============================================================================= == Interface ================================================================ ============================================================================= While point mainly collect instruction counts we re going have compile C++ timers anyway they re used check before calling Valgrind so we may well grab wall times reference They comparatively inexpensive MIN_RUN_TIME = Repeats inexpensive long they all run same process This also lets us filter outliers e g malloc arena reorganization so we don t need high CALLGRIND_NUMBER get good data CALLGRIND_NUMBER = CALLGRIND_REPEATS = dataclasses dataclass frozen=True WorkerTimerArgs Container Timer constructor arguments This dataclass serves two roles First simple interface defining benchmarks See core api GroupedStmts core api GroupedModules advanced interfaces Second provides serialization controlling workers ` Timer ` pickleable so instead main process will pass ` WorkerTimerArgs ` instances workers processing stmt str setup str = pass global_setup str = num_threads int = language Language = Language PYTHON dataclasses dataclass frozen=True WorkerOutput Only values reduce communication between main process workers wall_times tuple float instructions tuple int dataclasses dataclass frozen=True WorkerFailure If worker fails we attach string contents Exception rather than Exception object itself This done two reasons Depending type thrown ` e ` may may pickleable If we re-throw main process we lose true stack trace failure_trace str WorkerUnpickler pickle Unpickler find_class module str name str - Any Resolve pickle When main runner uses symbol ` foo ` file sees ` worker main foo ` However worker called standalone file sees same symbol ` __main__ foo ` We have help pickle understand they refer same symbols symbol_map = Only blessed interface Enums dataclasses need mapped WorkerTimerArgs WorkerTimerArgs WorkerOutput WorkerOutput WorkerFailure WorkerFailure name symbol_map symbol_map name super find_class module name load_input - WorkerTimerArgs result = load assert isinstance result WorkerTimerArgs result load_output - Union WorkerTimerArgs WorkerOutput WorkerFailure Convenience method type safe loading result = load assert isinstance result WorkerTimerArgs WorkerOutput WorkerFailure result ============================================================================= == Execution ================================================================ ============================================================================= _run timer_args WorkerTimerArgs - WorkerOutput timer = Timer stmt=timer_args stmt setup=timer_args setup pass global_setup=timer_args global_setup Prevent NotImplementedError GPU builds C++ snippets timer=timeit default_timer num_threads=timer_args num_threads language=timer_args language m = timer blocked_autorange min_run_time=MIN_RUN_TIME stats tuple CallgrindStats = timer collect_callgrind number=CALLGRIND_NUMBER collect_baseline=False repeats=CALLGRIND_REPEATS retain_out_file=False WorkerOutput wall_times=tuple m times instructions=tuple s counts denoise=True s stats main communication_file str - None result Union WorkerOutput WorkerFailure try open communication_file rb f timer_args WorkerTimerArgs = WorkerUnpickler f load_input assert isinstance timer_args WorkerTimerArgs result = _run timer_args except KeyboardInterrupt Runner process sent SIGINT sys exit except BaseException noqa B trace_f = io StringIO traceback print_exc file=trace_f result = WorkerFailure failure_trace=trace_f getvalue os path exists os path split communication_file This worker orphan parent has already cleaned up working directory In case we can simply exit print f Orphaned worker os getpid exiting open communication_file wb f pickle dump result f __name__ == __main__ parser = argparse ArgumentParser parser add_argument -- communication-file -- communication_file type=str communication_file = parser parse_args communication_file main communication_file