importlib itertools logging pickle random signal string traceback collections abc KeysView Sequence enum Enum functools partial wraps types FrameType typing Any Callable get_args get_origin Literal Optional TypeVar Union torch functorch compile min_cut_rematerialization_partition torch _inductor custom_graph_pass CustomGraphPass CustomPartitionerFn torch _inductor scheduler BaseSchedulerNode torch utils _config_module _ConfigEntry ConfigModule torch utils _ordered_set OrderedSet log = logging getLogger __name__ is_type type_hint comp_type - bool type ignore no-untyped-def Determines type_hint comp_type There some type annotations doesn t work I think s because some Type annotations Type Objects some Special Forms sure There s definite room improvement make more general someone who deeply understands Python types type_hint comp_type get_origin type_hint comp_type is_optional_type type_hint - bool type ignore no-untyped-def Special case is_type origin = get_origin type_hint origin Union args = get_args type_hint type None args False is_callable_type type_hint - bool type ignore no-untyped-def Special Case is_type type_hint __name__ == Callable DummyPass CustomGraphPass A Dummy pass used ConfigFuzzer __call__ graph torch fx graph Graph - None None uuid - Optional Any None DummyPartitionerFn CustomPartitionerFn A Dummy partitioner function used ConfigFuzzer __call__ gm torch fx GraphModule joint_inputs Sequence object kwargs Any - tuple torch fx GraphModule torch fx GraphModule min_cut_rematerialization_partition gm joint_inputs kwargs uuid - Optional Any None T = TypeVar T TypeExemplars This returns examples Type given its name TYPE_EXEMPLARS dict str Any = CustomGraphPass __name__ DummyPass CustomPartitionerFn __name__ DummyPartitionerFn torch fx graph Graph __name__ torch fx graph Graph BaseSchedulerNode __name__ BaseSchedulerNode None type ignore arg-type staticmethod example t type T - Optional T Return example pyrefly ignore bad-argument-type bad-argument-count TypeExemplars TYPE_EXEMPLARS get t __name__ None staticmethod contains t type T - bool pyrefly ignore bad-argument-type bad-argument-count t __name__ TypeExemplars TYPE_EXEMPLARS check_halide_import - bool checks we have halide available try importlib import_module halide True except ModuleNotFoundError False check_halide_import CUDA_BACKEND = triton halide CUDA_BACKEND = triton Status Enum The Status value enum Config Fuzzer ConfigFuzzer skipped test SKIPPED = skipped ConfigFuzzer compiled ran test function passed PASSED = passed ConfigFuzzer failed compile test function FAILED_COMPILE = failed_compile ConfigFuzzer compiled test function running raised exception FAILED_RUN_COMPILE_EXCEPTION = failed_run_compile_exception ConfigFuzzer ran eager raised exception FAILED_RUN_EAGER_EXCEPTION = failed_run_eager_exception ConfigFuzzer compiled test function value indicated compiled value didn t match value eager however you set up comparison test function FAILED_RUN_RETURN = failed_run_return failing - bool Convenience method check whether these status represent failure == Status FAILED_COMPILE == Status FAILED_RUN_EAGER_EXCEPTION == Status FAILED_RUN_COMPILE_EXCEPTION == Status FAILED_RUN_RETURN Sometime types configs aren t expressive enough captured python type system so options can manually specified here TODO needs indexed module like inductor dynamo name collisions TYPE_OVERRIDES dict str list Any = cuda_backend CUDA_BACKEND post_grad_fusion_options batch_linear_post_grad shape_broadcast_batch_linear True fuse_nodes_with_same_users True batch_aten_mul fuse_nodes_with_same_parent False batch_aten_sigmoid fuse_nodes_with_same_parent True batch_aten_add fuse_nodes_with_same_parent True normalization_aten_pass unbind_stack_aten_pass batch_aten_add batch_aten_mul batch_aten_sub batch_aten_div group_linear require_fbgemm True autoheuristic_collect pad_mm mixed_mm autoheuristic_use pad_mm mixed_mm traceable_tensor_subclasses OrderedSet nontraceable_tensor_subclasses OrderedSet SamplingType = Callable str type Any Any Any SamplingMethod Enum This handles process assigning concrete values type annotations So type annotation ` ` ` python foo Optional int = None ` ` ` Will assigned int dispatch function gets TOGGLE split between int None gets RANDOM TOGGLE = TOGGLE toggle opposite value RANDOM = RANDOM randomly choose option staticmethod _generate_value_for_type random_sample bool field_name str type_hint type Any default Any - Any Generates value type based setting look name type overrides field_name TYPE_OVERRIDES random choice TYPE_OVERRIDES field_name type_hint bool random choice True False random_sample default type_hint int NOTE initially tried use negation value doesn t work because most types ints when they should natural numbers + zero Python types cover these values aren t super convenient random randint type_hint float random uniform type_hint str characters = string ascii_letters + string digits + string punctuation join random choice characters _ range random randint is_type type_hint list elem_type = getattr type_hint __args__ type default default len default type None new_default = default default len default None SamplingMethod _generate_value_for_type random_sample field_name elem_type new_default _ range random randint is_type type_hint set noqa set_linter indexable = list default elem_type = getattr type_hint __args__ type indexable default len default type None new_default = indexable default len default None noqa set_linter SamplingMethod _generate_value_for_type random_sample field_name elem_type new_default _ range random randint is_type type_hint OrderedSet indexable = list default elem_type = getattr type_hint __args__ type indexable default len default type None new_default = indexable default len default None OrderedSet SamplingMethod _generate_value_for_type random_sample field_name elem_type new_default _ range random randint is_type type_hint dict key_type value_type = getattr type_hint __args__ map type next iter default items default None len default type None type None default None len default items default_key default_val = next iter default items default_key default_val = None None SamplingMethod _generate_value_for_type random_sample field_name key_type default_key SamplingMethod _generate_value_for_type random_sample field_name value_type default_val _ range random randint is_type type_hint Union do whatever type default try assert len type_hint __args__ except AttributeError err raise ValueError Union type no args err random_sample new_type = random choice type_hint __args__ new_type = random choice t t type_hint __args__ t type default try new_default = new_type except Exception default constructor doesn t work try None new_default = None SamplingMethod _generate_value_for_type random_sample field_name new_type new_default is_type type_hint tuple args = getattr type_hint __args__ tuple map type default zipped = zip args default tuple map noqa C lambda x SamplingMethod _generate_value_for_type random_sample field_name x x zipped is_type type_hint Literal try random_sample random choice type_hint __args__ choices = t t type_hint __args__ t = default choices random choice choices default except AttributeError err raise ValueError Literal type no args err is_optional_type type_hint try elem_type = type_hint __args__ except AttributeError err raise ValueError Optional type no args err random_sample random choice None SamplingMethod _generate_value_for_type random_sample field_name elem_type default default None SamplingMethod _generate_value_for_type random_sample field_name elem_type None None type_hint type None None is_callable_type type_hint try return_type = list type_hint __args__ - except AttributeError err raise ValueError Callable type no args err wraps lambda args kwargs None dummy_function args kwargs type ignore no-untyped-def SamplingMethod _generate_value_for_type random_sample field_name return_type None dummy_function type_hint == torch _ops OpOverload torch ops aten add default TypeExemplars contains type_hint TypeExemplars example type_hint type_hint == Any default = raise ValueError f Unable process type type_hint PRs welcome staticmethod dispatch sm SamplingMethod - SamplingType Returns function will generate values type based SamplingMethod passed sm == SamplingMethod RANDOM partial SamplingMethod _generate_value_for_type True sm == SamplingMethod TOGGLE partial SamplingMethod _generate_value_for_type False raise ValueError f malformed sampling method sm Default Singleton default object will cause ConfigFuzzer always use default value set config DEFAULT = Default The combination config settings being set based their strings ComboType = tuple str ResultType The mapping combo strings result status after running config fuzzer _vals dict ComboType Status __repr__ - str f ResultType _vals __init__ - None _vals = __len__ - int len _vals num_ran - int Returns how many combos actually ran weren t skipped ret = len _vals status _vals values status == Status SKIPPED ret -= ret set combo ComboType status Status - None combo = tuple sorted combo _vals combo = status lookup combo ComboType - Optional Status combo = tuple sorted combo _vals get combo None keys - KeysView ComboType _vals keys Type maps config strings their default value ConfigType = dict str Any Callable returns bool FactoryOutputType = Callable bool input function factory FactoryType = Callable FactoryOutputType Why some configs disabled default Because we don t fuzzer produces uninteresting results It will always hone-in these failures even most basic model making useless debugging more complex models More explicit explanations below Out Scope We can t fuzz say cuda version because comes environment will produce failure aligned env Known Failure Disabled due known failure Hopefully re-enable Known failures listed docstring file Required Required fuzzer operate removing caching etc FSDP Flag meant FSDP fails non FSDP envs Re-enable these you re testing FSDP Typing disabled because type annotation config isn t constrained enough produce meaningful fuzz values These could improved Timing These take too long compile feel free enable MODULE_DEFAULTS dict str ConfigType = torch _inductor config force_disable_caches True Required cpp cxx DEFAULT Out Scope TYPE_CHECKING DEFAULT Not config max_autotune_pointwise DEFAULT Timing max_autotune_gemm DEFAULT Timing re-enable when autotune speed improvements merged max_autotune_gemm_backends DEFAULT Timing max_autotune_conv_backends DEFAULT Timing max_autotune_gemm_search_space DEFAULT Timing max_autotune_subproc_result_timeout_seconds DEFAULT Timing max_autotune_subproc_graceful_timeout_seconds DEFAULT Timing max_autotune_subproc_terminate_timeout_seconds DEFAULT Timing aot_inductor presets DEFAULT Typing cuda arch DEFAULT Out Scope cuda version DEFAULT Out Scope cuda cutlass_dir DEFAULT Out Scope cuda cuda_cxx DEFAULT Out Scope rocm arch DEFAULT Out Scope rocm ck_supported_arch DEFAULT Out Scope rocm ck_dir DEFAULT Out Scope rocm rocm_home DEFAULT Out Scope check_stack_no_cycles_TESTING_ONLY DEFAULT Testing sleep_sec_TESTING_ONLY DEFAULT Testing triton inject_relu_bug_TESTING_ONLY DEFAULT Testing reorder_for_compute_comm_overlap DEFAULT FSDP enabled_metric_tables DEFAULT Typing triton debug_sync_graph DEFAULT Known Failure triton debug_sync_kernel DEFAULT Known Failure profile_bandwidth_regex DEFAULT Known Failure disable_cpp_codegen DEFAULT Known Failure trace save_real_tensors DEFAULT Known Failure pre_grad_fusion_options DEFAULT Typing external_matmul DEFAULT Typing need add type overrides type exemplars test_configs autotune_choice_name_regex DEFAULT Typing test_configs autotune_choice_desc_regex DEFAULT Typing cpp enable_floating_point_contract_flag DEFAULT Typing post_grad_custom_pre_pass DEFAULT Typing post_grad_custom_post_pass DEFAULT Typing reorder_for_compute_comm_overlap_passes DEFAULT Typing joint_custom_post_pass DEFAULT Typing joint_custom_pre_pass DEFAULT Typing pre_grad_custom_pass DEFAULT Typing custom_partitioner_fn DEFAULT Typing inductor_choices_class DEFAULT Typing torch _dynamo config traceable_tensor_subclasses DEFAULT Typing nontraceable_tensor_subclasses DEFAULT Typing compiled_autograd_kwargs_override DEFAULT Typing fail_on_recompile_limit_hit DEFAULT fails combo suppress_errors suppress_errors DEFAULT caching_precompile False Required ConfigFuzzer This tool makes easy search through config state-space minimal reproduction test either debugging just bug hunting It has two entry points - bisect which randomly flips configs tries find minimal reproduction upon failure - fuzz_n_tuple which tries every combination n configs This grows quickly function n so beware bisect recommended fuzz_n_tuple can give you peace mind new config will compose every other config The main interface function factory will Callables torch compiled This function factory should test function when s called Said test function returns boolean which determines whether ConfigFuzzer considers successful run Throwing exception within function will considered failure well Example usage ` ` ` python torch _inductor config cfg create_simple_test_model_gpu - FactoryOutputType batch_size = seq_length = hidden_size = test_fn - bool inp = torch randn batch_size seq_length hidden_size device= cuda weight = torch randn hidden_size hidden_size device= cuda matmul_output = inp weight final_output = torch nn LayerNorm hidden_size device= cuda matmul_output True test_fn fuzzer = ConfigFuzzer cfg create_simple_test_model_gpu seed= Test every pair configs results = fuzzer fuzz_n_tuple n max_combinations= visualize_results n results Test random configs bisection ret = fuzzer bisect num_attempts= reproduce failing config fuzzer reproduce triton autotune_pointwise coordinate_descent_tuning ` ` ` The list known failures inductor config cpp_wrapper triton_debug_sync_graph cpp_wrapper triton_debug_sync_kernel cpp_wrapper disable_cpp_codegen combo_kernels benchmark_combo_kernel profile_bandwidth profile_bandwidth_regex trace enabled trace save_real_tensors sample SamplingType default ConfigType __init__ config_module ConfigModule test_model_fn_factory FactoryType seed int default Optional ConfigType = None sm SamplingMethod = SamplingMethod TOGGLE test_timeout int = Args config_module The module containing configs fuzz test_model_fn_factory Function returns test model which runs returns True successful outputs they should compared eager seed Randomness seed default Default values config Inductor has preset based know failures sm How type value samples generated default TOGGLE test_timeout max time test can take seed = seed test_timeout = test_timeout detailed_results dict ComboType dict str Any = config_module = config_module test_model_fn_factory = test_model_fn_factory fields dict str _ConfigEntry = config_module _config sample = SamplingMethod dispatch sm default None config_module __name__ MODULE_DEFAULTS default = MODULE_DEFAULTS config_module __name__ raise ValueError No default passed ConfigFuzzer default = default __repr__ - str f ConfigFuzzer config_module= config_module f test_model_fn_factor= test_model_fn_factory seed= seed default= default _set_config field_name str value Any - None Set config value module setattr config_module field_name value _reset_configs - None Reset all configs their default values field_name field_obj fields items _set_config field_name field_obj default new_config - ConfigType creates new config default ret = name val val = DEFAULT fields name default name val default items ret reproduce configs Sequence ConfigType - ResultType entrypoint reproduce any failure results = ResultType conf configs _reproduce_single_helper conf results results _reproduce_single_helper conf ConfigType results ResultType - None print f Starting repro conf new_config = new_config new_config update conf test_config results new_config print f Status conf \n results lookup tuple conf keys reproduce_single config ConfigType - ResultType results = ResultType _reproduce_single_helper config results results _fuzz_helper results ResultType combo ComboType - Status print combo st = results lookup combo we already processed config st config = new_config skip = False field_name combo field_name config don t break here because we need build config dict skip = True field_name startswith _ skip = True field = fields field_name value = sample field_name field value_type field default config field_name = value skip results set combo Status SKIPPED Status SKIPPED test_config results config fuzz_n_tuple n int max_combinations int = - ResultType Test every combination n configs returns dict shape config- config- config-n status results = ResultType print f Starting n -tuple testing seed seed random seed seed combo itertools combinations fields n st = _fuzz_helper results combo st = Status SKIPPED max_combinations -= max_combinations = print Reached maximum combinations limit break results save_state filename str = fuzzer_state pkl - None Save current fuzzer state file open filename wb f pickle dump results results detailed_results detailed_results f load_state filename str = fuzzer_state pkl - None Load fuzzer state file open filename rb f state = pickle load f results = state results detailed_results = state get detailed_results timeout_handler signum int frame Optional FrameType - None raise TimeoutError Test execution timed out test_config results ResultType config ConfigType - Status Tests config calling function produced factory function original_handler = signal signal signal SIGALRM timeout_handler signal alarm test_timeout print f Testing config config config_tuple = tuple config keys ret = results lookup config_tuple signal signal signal SIGALRM original_handler ret print_config - None field value config items print f field = value get_error_info exc Exception - dict str Any exception str exc traceback traceback format_exc config config copy handle_return message str return_status Status print_traceback bool exc Optional Exception - Status signal signal signal SIGALRM original_handler print f message config combination print_config exc detailed_results config_tuple = get_error_info exc print_traceback traceback print_exc results set config_tuple return_status return_status reset config torch _dynamo reset _reset_configs name value config items _set_config name value try running eager test_model_fn = test_model_fn_factory try test_model_fn except Exception exc handle_return Eager exception Status FAILED_RUN_EAGER_EXCEPTION True exc try compilation try test_model_fn = test_model_fn_factory comp = torch compile test_model_fn backend= inductor except Exception exc handle_return Exception compiling Status FAILED_COMPILE True exc try running compiled try compile_result = comp except Exception exc handle_return Exception running compiled Status FAILED_RUN_COMPILE_EXCEPTION True exc bool value means don t compare eager compile_result handle_return Function returned False Status FAILED_RUN_RETURN False None handle_return Function succeeded Status PASSED False None bisect num_attempts int = p float = - list ConfigType Test configs bisect minimal failing configuration print f Starting random testing bisection seed seed p p random seed seed _reset_configs results = ResultType ret list ConfigType = attempt range num_attempts print f Random attempt attempt + num_attempts config = new_config field_name config_entry fields items field_name config field_name startswith _ TESTING_ONLY field_name random random p value = sample field_name config_entry value_type config_entry default config field_name = value status = test_config results config status OrderedSet Status PASSED Status SKIPPED minimal_failing_config = _bisect_failing_config results config print f Minimum failing config minimal_failing_config ret append minimal_failing_config ret _bisect_failing_config results ResultType failing_config ConfigType - Optional ConfigType _bisect_failing_config_helper results list failing_config items _bisect_failing_config_helper results ResultType failing_config list tuple str Any - Optional ConfigType Bisect failing configuration find minimal set configs cause failure Splits into halves then fourths then tries dropping configs one-by-one print f bisecting config failing_config failing_config None test x list tuple str Any - Status d = dict x result = test_config results d result len failing_config = dict failing_config test failing_config failing None random shuffle failing_config mid = len failing_config first_half = failing_config mid second_half = failing_config mid test first_half failing _bisect_failing_config_helper results first_half test second_half failing _bisect_failing_config_helper results second_half len failing_config = low = len failing_config high = mid + low quart = failing_config low test quart failing _bisect_failing_config_helper results quart quart = failing_config low + second_half test quart failing _bisect_failing_config_helper results quart quart = first_half + failing_config high test quart failing _bisect_failing_config_helper results quart quart = failing_config high test quart failing _bisect_failing_config_helper results quart try dropping one value time i range len failing_config new_list = x j x enumerate failing_config j = i test new_list failing _bisect_failing_config_helper results new_list we have minimal set dict failing_config visualize_results n int results ResultType filename str = results html - None Creates HTML document representing results running fuzzer fuzz_n_tuple n = TODO support more dimensions assert n == assert len results input_set OrderedSet str = OrderedSet key results keys input_set add key input_set add key input_list = sorted input_set Start HTML content html_content = DOCTYPE html html lang= en head meta charset= UTF- meta name= viewport content= width=device-width initial-scale= title Fuzzer Visualization title style table border-collapse collapse width margin px auto th td border px solid #ddd padding px text-align center th background-color #f f f skipped background-color yellow passed background-color green color white failed background-color red color white style head body h style= text-align center Fuzzer Visualization h table thead html_content += tr th \\ th col_name input_list col = br join col_name html_content += f th col th html_content += tr thead tbody Add table rows row_name input_list html_content += f tr th row_name th col_name input_list Determine status cell status_enum = results lookup row_name col_name status_class = status_val = status_enum == Status SKIPPED status_class = skipped status_val = - status_enum == Status PASSED status_class = passed status_val = O status_enum == Status FAILED_RUN_EAGER_EXCEPTION status_class = failed status_val = e status_enum == Status FAILED_RUN_COMPILE_EXCEPTION status_class = failed status_val = E status_enum == Status FAILED_RUN_RETURN status_class = failed status_val = R status_enum == Status FAILED_COMPILE status_class = failed status_val = C status_class = skipped status_val = - html_content += f td class= status_class status_val td html_content += tr html_content += tbody table body html open filename w file file write html_content