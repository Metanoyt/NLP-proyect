mypy allow-untyped-defs collections OrderedDict OrderedDict OrdDict typing Any torch try tablate got_tabulate = True try tabulate tabulate except ImportError got_tabulate = False var see we could matplotlib got_matplotlib = True try matplotlib pyplot plt except ImportError got_matplotlib = False ModelReportVisualizer r The ModelReportVisualizer aims provide users way visualize some statistics generated ModelReport API However higher level aims provide some level visualization statistics PyTorch order make easier parse data diagnose any potential issues data specific model With respect visualizations ModelReportVisualizer currently supports several methods visualizing data Supported Visualization Methods Include - Table format - Plot format line graph - Histogram format For all existing visualization methods there option filter data based - A module fqn prefix - Feature required plot histogram attr ` generated_reports ` The reports generated ModelReport structure below Ensure sure features same across different report contain same name Ensure objects representing same features same type dimension where applicable Note Currently ModelReportVisualizer supports visualization data generated ModelReport However structure extensible should allow visualization other information long information structured following general format Report Structure -- module_fqn module attached detectors &#124; -- feature keys every detector extracts same information same collected info has same keys unless can specific detector The goal behind generated visualizations can used conjunction generated report people get better understanding issues what fix might It also just provide good visualization platform since might hard parse through ModelReport returned dictionary grows size General Use Flow Expected Initialize ModelReport object reports interest passing initialized detector objects Prepare your model prepare_fx Call model_report prepare_detailed_calibration your model add relevant observers Calibrate your model data Call model_report generate_report your model generate report optionally remove added observers Use output model_report generate_report initialize ModelReportVisualizer instance Use instance view different views data desired applying filters needed Either see super detailed information just actual printed shown table plot histogram keys table dict TABLE_TENSOR_KEY = tensor_level_info TABLE_CHANNEL_KEY = channel_level_info Constants header vals NUM_NON_FEATURE_TENSOR_HEADERS = NUM_NON_FEATURE_CHANNEL_HEADERS = Constants row index header CHANNEL_NUM_INDEX = __init__ generated_reports OrderedDict str Any r Initializes ModelReportVisualizer instance necessary reports Args generated_reports Dict str Any The reports generated ModelReport can also dictionary generated another manner long format same generated_reports = generated_reports get_all_unique_module_fqns - set str r The purpose method provide user set all module_fqns so they wish use some filtering capabilities ModelReportVisualizer they don t need manually parse generated_reports dictionary get information Returns all unique module fqns present reports ModelReportVisualizer instance initialized returns keys ordered dict set generated_reports keys get_all_unique_feature_names plottable_features_only bool = True - set str r The purpose method provide user set all feature names so they wish use filtering capabilities generate_table_view use either generate_plot_view generate_histogram_view they don t need manually parse generated_reports dictionary get information Args plottable_features_only bool True user only looking plottable features False otherwise plottable features those tensor values Default True only those feature names plottable Returns all unique module fqns present reports ModelReportVisualizer instance initialized unique_feature_names = set module_fqn generated_reports get dict features feature_dict dict str Any = generated_reports module_fqn loop through features feature_name feature_dict we need plottable ensure type val tensor plottable_features_only type feature_dict feature_name torch Tensor unique_feature_names add feature_name our compiled set unique feature names unique_feature_names _get_filtered_data feature_filter str module_fqn_filter str - OrderedDict str Any r Filters data returns same ordered dictionary format so relevant views can displayed Args feature_filter str The feature filter we want filter set data only include certain set features include feature_filter If feature = then we do filter based any features module_fqn_filter str The filter prefix module fqn All modules have fqn prefix will included If module_fqn_filter = we do filter based module fqn include all modules First data filtered based module_fqn then filtered based feature Returns OrderedDict sorted order model mapping module_fqns - feature_names - values create dict filtered_dict OrderedDict str Any = OrdDict module_fqn generated_reports first filter based module module_fqn_filter == module_fqn_filter module_fqn create entry module loop through features filtered_dict module_fqn = module_reports = generated_reports module_fqn feature_name module_reports check filtering features do so desired feature_filter == feature_filter feature_name filtered_dict module_fqn feature_name = module_reports feature_name we have populated filtered dict must filtered_dict _generate_tensor_table filtered_data OrderedDict str dict str Any tensor_features list str - tuple list list r Takes filtered data features list generates tensor headers table Currently meant generate headers table both tensor information Args filtered_data OrderedDict str Dict str Any An OrderedDict sorted order model mapping module_fqns - feature_names - values tensor_features List str A list tensor level features Returns tuple A list headers tensor table A list lists containing table information row row The th index row will contain headers columns The rest rows will contain data now we compose tensor information table tensor_table list list Any = tensor_headers list str = append table row table only we have features len tensor_features now we add all data index module_fqn enumerate filtered_data we make new row tensor table tensor_table_row = index module_fqn feature tensor_features we iterate same order added features feature filtered_data module_fqn add value applicable module feature_val = filtered_data module_fqn feature add applicable feature_val = Not Applicable s tensor we want extract val isinstance feature_val torch Tensor feature_val = feature_val item we add our list values pyrefly ignore bad-argument-type tensor_table_row append feature_val tensor_table append tensor_table_row add row headers we actually have something otherwise just empty len tensor_table = tensor_headers = idx layer_fqn + tensor_features tensor_headers tensor_table _generate_channels_table filtered_data OrderedDict str Any channel_features list str num_channels int - tuple list list r Takes filtered data features list generates channels headers table Currently meant generate headers table both channels information Args filtered_data OrderedDict str Any An OrderedDict sorted order model mapping module_fqns - feature_names - values channel_features List str A list channel level features num_channels int Number channels channel data Returns tuple A list headers channel table A list lists containing table information row row The th index row will contain headers columns The rest rows will contain data now we compose table channel information table channel_table list list Any = channel_headers list str = counter keep track number entries channel_table_entry_counter int = len channel_features now we add all channel data module_fqn filtered_data we iterate over all channels channel range num_channels we make new row channel new_channel_row = channel_table_entry_counter module_fqn channel feature channel_features feature filtered_data module_fqn add value applicable module feature_val = filtered_data module_fqn feature channel add applicable feature_val = Not Applicable s tensor we want extract val type feature_val torch Tensor feature_val = feature_val item add value channel specific row pyrefly ignore bad-argument-type new_channel_row append feature_val add table increment row index counter channel_table append new_channel_row channel_table_entry_counter += add row headers we actually have something otherwise just empty len channel_table = channel_headers = idx layer_fqn channel + channel_features channel_headers channel_table generate_filtered_tables feature_filter str = module_fqn_filter str = - dict str tuple list list r Takes optional filter values generates two tables desired information The generated tables presented both list-of-lists format The reason two tables they handle different things first table handles all tensor level information second table handles displays all channel based information The reasoning having all info one table can make ambiguous which collected statistics global which actually per-channel so s better split up into two tables This also makes information much easier digest given plethora statistics collected Tensor table columns idx layer_fqn feature_ feature_ feature_ feature_n ---- --------- --------- --------- --------- --------- Per-Channel table columns idx layer_fqn channel feature_ feature_ feature_ feature_n ---- --------- ------- --------- --------- --------- --------- Args feature_filter str optional Filters features presented only those contain filter substring Default = results all features being printed module_fqn_filter str optional Only includes modules contains string Default = results all modules reports visible table Returns dictionary two keys Dict str Tuple List List A dict containing two keys tensor_level_info channel_level_info Each key maps tuple A list headers each table A list lists containing table information row row The th index row will contain headers columns The rest rows will contain data Example Use xdoctest +SKIP undefined variables mod_report_visualizer generate_filtered_tables feature_filter= per_channel_min module_fqn_filter= block generates table per_channel_min info all modules block model first get filtered data filtered_data OrderedDict str Any = _get_filtered_data feature_filter module_fqn_filter now we split into tensor per-channel data tensor_features set str = set channel_features set str = set keep track number channels we have num_channels int = module_fqn filtered_data feature_name filtered_data module_fqn get data specific feature feature_data = filtered_data module_fqn feature_name check zero dim tensor is_tensor bool = isinstance feature_data torch Tensor is_not_zero_dim bool = is_tensor len feature_data shape = is_not_zero_dim isinstance feature_data list works means per channel channel_features add feature_name num_channels = len feature_data means per-tensor tensor_features add feature_name we make them lists iteration purposes tensor_features_list list str = sorted tensor_features channel_features_list list str = sorted channel_features get tensor info tensor_headers tensor_table = _generate_tensor_table filtered_data tensor_features_list get channel info channel_headers channel_table = _generate_channels_table filtered_data channel_features_list num_channels let s now create dictionary table_dict = TABLE_TENSOR_KEY tensor_headers tensor_table TABLE_CHANNEL_KEY channel_headers channel_table two tables table_dict generate_table_visualization feature_filter str = module_fqn_filter str = r Takes optional filter values prints out formatted tables information The reason two tables printed out instead one large one they handle different things first table handles all tensor level information second table handles displays all channel based information The reasoning having all info one table can make ambiguous which collected statistics global which actually per-channel so s better split up into two tables This also makes information much easier digest given plethora statistics collected Tensor table columns idx layer_fqn feature_ feature_ feature_ feature_n ---- --------- --------- --------- --------- --------- Per-Channel table columns idx layer_fqn channel feature_ feature_ feature_ feature_n ---- --------- ------- --------- --------- --------- --------- Args feature_filter str optional Filters features presented only those contain filter substring Default = results all features being printed module_fqn_filter str optional Only includes modules contains string Default = results all modules reports visible table Example Use xdoctest +SKIP undefined variables mod_report_visualizer generate_table_visualization feature_filter= per_channel_min module_fqn_filter= block prints out neatly formatted table per_channel_min info all modules block model see we got tabulate got_tabulate print Make sure install tabulate try again None get table dict specific tables interest table_dict = generate_filtered_tables feature_filter module_fqn_filter tensor_headers tensor_table = table_dict TABLE_TENSOR_KEY channel_headers channel_table = table_dict TABLE_CHANNEL_KEY get table string print out now we have populated tables each one let s create strings returned table_str = tables will have some headers columns non-feature ex table index module name channel index etc we want look header columns features come after those headers len tensor_headers NUM_NON_FEATURE_TENSOR_HEADERS we have least one tensor level feature added we add tensor table table_str += Tensor Level Information \n table_str += tabulate tensor_table headers=tensor_headers len channel_headers NUM_NON_FEATURE_CHANNEL_HEADERS we have least one channel level feature added we add tensor table table_str += \n\n Channel Level Information \n table_str += tabulate channel_table headers=channel_headers no features all let user know table_str == table_str = No data points generate table print table_str _get_plottable_data feature_filter str module_fqn_filter str - tuple list list list bool r Takes feature filters module filters outputs x y data plotting Args feature_filter str Filters features presented only those contain filter substring module_fqn_filter str Only includes modules contains string Returns tuple three elements The first list containing relevant x-axis data The second list containing corresponding y-axis data If data per channel get table dict specific tables interest table_dict = generate_filtered_tables feature_filter module_fqn_filter tensor_headers tensor_table = table_dict TABLE_TENSOR_KEY channel_headers channel_table = table_dict TABLE_CHANNEL_KEY make sure only feature being plotted get number features each these tensor_info_features_count = len tensor_headers - ModelReportVisualizer NUM_NON_FEATURE_TENSOR_HEADERS channel_info_features_count = len channel_headers - ModelReportVisualizer NUM_NON_FEATURE_CHANNEL_HEADERS see valid tensor channel plot is_valid_per_tensor_plot bool = tensor_info_features_count == is_valid_per_channel_plot bool = channel_info_features_count == offset should either one tensor channel table neither feature_column_offset = ModelReportVisualizer NUM_NON_FEATURE_TENSOR_HEADERS table = tensor_table per_channel plot we have different offset table is_valid_per_channel_plot feature_column_offset = ModelReportVisualizer NUM_NON_FEATURE_CHANNEL_HEADERS table = channel_table x_data list = y_data list list = feature will either tensor feature channel feature is_valid_per_tensor_plot table_row_num row enumerate table get x_value append x_val_to_append = table_row_num index feature will + num non feature columns tensor_feature_index = feature_column_offset row_value = row tensor_feature_index type row_value str x_data append x_val_to_append y_data append row_value is_valid_per_channel_plot gather x_data multiple y_data calculate number channels num_channels int = max row CHANNEL_NUM_INDEX row table + separate data list per channel y_data extend _ range num_channels table_row_num row enumerate table get x_value append x_val_to_append = table_row_num current_channel = row CHANNEL_NUM_INDEX initially chose current channel new_module_index int = table_row_num num_channels x_val_to_append = new_module_index index feature will + num non feature columns tensor_feature_index = feature_column_offset row_value = row tensor_feature_index type row_value str only append new index we appending len x_data == x_data - = x_val_to_append x_data append x_val_to_append append value channel y_data current_channel append row_value more than one feature chosen error_str = Make sure pick only single feature your filter plot graph error_str += We recommend calling get_all_unique_feature_names find unique feature names error_str += Pick one those features plot raise ValueError error_str x y values data per-channel x_data y_data is_valid_per_channel_plot generate_plot_visualization feature_filter str module_fqn_filter str = r Takes feature optional module_filter plots desired data For per channel features averages value across channels plots point per module The reason models hundreds channels can hard differentiate one channel line another so point generating single average point per module give sense general trends encourage further deep dives Note Only features report have tensor value data plottable When tensor information plotted will plot idx x val feature value y_val When channel information plotted will plot first idx each module x val feature value y_val each channel The reason we want able compare values across channels same layer will hard values staggered idx This means each module represented only x value Args feature_filter str Filters features presented only those contain filter substring module_fqn_filter str optional Only includes modules contains string Default = results all modules reports visible table Example Use xdoctest +SKIP undefined variables mod_report_visualizer generate_plot_visualization feature_filter= per_channel_min module_fqn_filter= block outputs line plot per_channel_min information all modules block model each channel gets s own line s plotted across in-order modules x-axis checks we have matplotlib let s user know install don t got_matplotlib print make sure install matplotlib try again None get x y data per channel x_data y_data data_per_channel = _get_plottable_data feature_filter module_fqn_filter plot based whether data per channel ax = plt subplot ax set_ylabel feature_filter ax set_title feature_filter + Plot plt xticks x_data only show ticks actual points data_per_channel ax set_xlabel First idx module set legend well plot single line average channel values num_modules = len y_data all y_data have same length so get num modules num_channels = len y_data we want num channels able calculate average later avg_vals = sum y_data index num_channels index range num_modules plot three things we measured ax plot x_data avg_vals label=f Average Value Across num_channels Channels ax legend loc= upper right ax set_xlabel idx ax plot x_data y_data actually show plot plt show generate_histogram_visualization feature_filter str module_fqn_filter str = num_bins int = r Takes feature optional module_filter plots histogram desired data Note Only features report have tensor value data can viewed histogram If you want plot histogram all channel values specific feature specific model make sure specify both model feature properly filters you should able see distribution channel data Args feature_filter str optional Filters features presented only those contain filter substring Default = results all features being printed module_fqn_filter str optional Only includes modules contains string Default = results all modules reports visible table num_bins int optional The number bins create histogram Default = values will split into equal sized bins Example Use xdoctest +SKIP mod_report_visualizer generategenerate_histogram_visualization_plot_visualization feature_filter= per_channel_min module_fqn_filter= block outputs histogram per_channel_min information all modules block model information gathered across all channels all modules block per_channel_min displayed histogram equally sized bins checks we have matplotlib let s user know install don t got_matplotlib print make sure install matplotlib try again None get x y data per channel _x_data y_data data_per_channel = _get_plottable_data feature_filter module_fqn_filter histogram we just care about plotting y data plot based whether data per channel ax = plt subplot ax set_xlabel feature_filter ax set_ylabel Frequency ax set_title feature_filter + Histogram data_per_channel set legend well combine all data all_data = channel_info y_data all_data extend channel_info _val bins _ = plt hist all_data bins=num_bins stacked=True rwidth= plt xticks bins _val bins _ = plt hist y_data bins=num_bins stacked=False rwidth= plt xticks bins plt show