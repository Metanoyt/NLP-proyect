__future__ annotations typing TYPE_CHECKING typing_extensions assert_never torchgen local torchgen api types ArgName ArrayCType ArrayRefCType BaseCType BaseTypeToCppMapping Binding boolT ConstRefCType CType dimnameListT intArrayRefT iTensorListRefT ListCType longT MutRefCType NamedCType OptionalCType optionalIntArrayRefT optionalSymIntArrayRefT scalarT SpecialArgName symIntArrayRefT SymIntT tensorListT tensorOptionsT tensorT TupleCType VectorCType voidT torchgen model Argument Arguments BaseTy BaseType FunctionSchema ListType NativeFunction OptionalType Return SelfArgument TensorOptionsArguments Type TYPE_CHECKING collections abc Sequence This file describes translation JIT schema public C++ API which what people use when they call functions like add Prominent characteristics C++ API - dtype layout device pin_memory collected into single C++ type TensorOptions native functions API also has tensor options really most relevant C++ API makes calling kwarg factory functions pleasant - defaulting lives here fact dispatcher completely oblivious defaults BTW policy name collisions we try have types collisions functions fair game collide name func FunctionSchema faithful_name_for_out_overloads bool = False symint_overload bool = False - str name = str func name name symint_overload name += _symint func is_out_fn faithful_name_for_out_overloads name += _outf name += _out name Translation value types JIT schema C++ API type Value types look same no matter they argument types types Returns None type question value type valuetype_type t Type binds ArgName mutable bool = True symint bool = False - NamedCType &#124; None isinstance t BaseType t name BaseTy Tensor BaseTy Scalar None str t == SymInt symint NamedCType binds BaseCType SymIntT NamedCType binds BaseCType longT All other BaseType currently map directly BaseCppTypes NamedCType binds BaseCType BaseTypeToCppMapping t name isinstance t OptionalType elem = valuetype_type t elem binds=binds mutable=mutable symint=symint elem None None NamedCType binds OptionalCType elem type isinstance t ListType str t elem == bool assert t size None NamedCType binds ArrayCType BaseCType boolT t size None raise AssertionError f unrecognized type repr t Translation types occurring JIT arguments C++ argument type If remove_non_owning_ref_types set we ll guarantee output CType non-owning reference type For example we ll std vector int instead IntArrayRef See Note translation C++ reference value types argumenttype_type t Type mutable bool binds ArgName remove_non_owning_ref_types bool = False symint bool = False - NamedCType If s value type do value type translation r = valuetype_type t binds=binds mutable=mutable symint=symint r None r isinstance t BaseType t name == BaseTy Tensor mutable local use_const_ref_for_mutable_tensors NamedCType binds MutRefCType BaseCType tensorT NamedCType binds ConstRefCType BaseCType tensorT t name == BaseTy Scalar NamedCType binds ConstRefCType BaseCType scalarT raise AssertionError f base type should have been value type t isinstance t OptionalType str t elem == Tensor mutable local use_const_ref_for_mutable_tensors NamedCType binds MutRefCType BaseCType tensorT TODO fix discrepancy NamedCType binds ConstRefCType OptionalCType BaseCType tensorT str t elem == Scalar NamedCType binds ConstRefCType OptionalCType BaseCType scalarT isinstance t elem ListType str t elem elem == int NamedCType binds BaseCType optionalIntArrayRefT isinstance t elem ListType str t elem elem == SymInt symint NamedCType binds BaseCType optionalSymIntArrayRefT NamedCType binds BaseCType optionalIntArrayRefT elem = argumenttype_type t elem mutable=mutable binds=binds symint=symint NamedCType binds OptionalCType elem type isinstance t ListType TODO remove these special cases ArrayRef fallthrough works fine str t elem == int remove_non_owning_ref_types NamedCType binds VectorCType BaseCType longT NamedCType binds BaseCType intArrayRefT str t elem == SymInt remove_non_owning_ref_types symint NamedCType binds VectorCType BaseCType SymIntT NamedCType binds VectorCType BaseCType longT symint NamedCType binds BaseCType symIntArrayRefT NamedCType binds BaseCType intArrayRefT str t elem == Tensor local use_ilistref_for_tensor_lists NamedCType binds ConstRefCType BaseCType iTensorListRefT NamedCType binds BaseCType tensorListT str t elem == Scalar NamedCType binds ArrayRefCType BaseCType scalarT str t elem == Dimname NamedCType binds BaseCType dimnameListT str t elem == Tensor NamedCType binds ConstRefCType ListCType OptionalCType BaseCType tensorT elem = argumenttype_type t elem mutable=mutable binds=binds symint=symint NamedCType binds ArrayRefCType elem type raise AssertionError f unrecognized type repr t Translate JIT argument into its C++ type argument_type Argument binds ArgName symint bool = False - NamedCType argumenttype_type type mutable=a is_write symint=symint binds=binds Translation non-multi type JIT C++ N B returntype_type returns CType NamedCType This mostly because mismatch between types names e g function type void has names function type std tuple has name returntype_type t Type mutable bool symint bool = False - CType placeholder ignored NB symint ALWAYS respected types So symint argument here IGNORED r = valuetype_type t binds= __placeholder__ mutable=mutable symint=True r None r type isinstance t BaseType t name == BaseTy Tensor mutable local use_const_ref_for_mutable_tensors ConstRefCType BaseCType tensorT MutRefCType BaseCType tensorT Note Tensor Copy Returns Currently we use Argument is_write determine whether Tensor types should copies references If ever changes take look other locations note BaseCType tensorT t name == BaseTy Scalar BaseCType scalarT isinstance t ListType assert mutable Native functions should never mutable tensor list They should void elem = returntype_type t elem mutable=False assert t size None f fixed size list returns supported t VectorCType elem isinstance t OptionalType elem = returntype_type t elem mutable=mutable str t elem == Tensor OptionalCType elem raise AssertionError f unrecognized type t Translation single its C++ type return_type r Return symint bool = False - CType returntype_type r type mutable=r is_write symint=symint Translation full possibly multi JIT its C++ type returns_type rs Sequence Return symint bool = False - CType len rs == BaseCType voidT len rs == return_type rs symint=symint TupleCType return_type r symint=symint r rs return_names f NativeFunction fallback_name str = result - Sequence str returns list str = i r enumerate f func returns If we have inplace function argument implicitly named TODO Consider incorporating into data model f func name name inplace assert i == illegal inplace function multiple returns name = If we out function name name corresponding output function r name will get recorded field_name later f func is_out_fn name = f func arguments out i name If argument explicitly named r name name_conflict = any r name == name f func schema_order_arguments name_conflict f func is_out_fn name = f r name _return name = r name If there no explicit name no fallback name passed we just name output result unless s multi-return which case s result result etc zero-indexed name = fallback_name len f func returns == f fallback_name i returns append name returns JIT_TO_CPP_DEFAULT = False false True true None std nullopt UGH one type directed Mean Reduction Mean contiguous_format c MemoryFormat Contiguous long kLong Convert JIT default into C++ expression representing default default_expr d str t Type symint bool - str d == None str t == Tensor isinstance t BaseType t name BaseTy str Schema allows single quotes C++ needs double len d = d == d - == s = i = while i + len d d i = \\ d i == s += \\ s += d i i += d i + == s += s += d i i + i += f s isinstance t OptionalType d == None std nullopt default_expr d t elem symint=symint isinstance t ListType d startswith d endswith + d - + symint d isdigit str t elem == SymInt f c SymInt d t size None NOTE Sized lists can have scalar defaults raise ValueError f Expected list default found d JIT_TO_CPP_DEFAULT get d d Convert argument into its C++ API form argument Argument &#124; TensorOptionsArguments &#124; SelfArgument cpp_no_default_args set str method bool faithful bool symint bool = False has_tensor_options bool - list Binding sub_argument Argument &#124; TensorOptionsArguments &#124; SelfArgument - list Binding argument cpp_no_default_args=cpp_no_default_args method=method faithful=faithful symint=symint has_tensor_options=has_tensor_options isinstance Argument binds ArgName name == memory_format has_tensor_options binds = SpecialArgName possibly_redundant_memory_format binds = name default str &#124; None = None name cpp_no_default_args default None default = default_expr default type symint=symint Binding nctype=argument_type binds=binds symint=symint name=a name default=default argument=a isinstance TensorOptionsArguments faithful sub_argument dtype + sub_argument layout + sub_argument device + sub_argument pin_memory default = None Enforced NativeFunction __post_init__ assert options cpp_no_default_args all x default == None x all default = dtype default == long default = kLong TODO wrong Binding nctype=NamedCType options BaseCType tensorOptionsT name= options default=default argument=a isinstance SelfArgument method Caller responsible installing implicit context sub_argument argument assert_never arguments arguments Arguments faithful bool symint bool = False method bool cpp_no_default_args set str - list Binding args list Argument &#124; TensorOptionsArguments &#124; SelfArgument = faithful args extend arguments non_out args extend arguments out args extend arguments out args extend arguments non_out r no_default faithful r args r argument faithful=faithful symint=symint method=method has_tensor_options=arguments tensor_options None cpp_no_default_args=cpp_no_default_args